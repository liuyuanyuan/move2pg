// $ANTLR 3.5.2 PLSQL_DMLParser.g 2018-10-06 11:19:31

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package br.com.porcelli.parser.plsql;



import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@SuppressWarnings("all")
public class PLSQLParser_PLSQL_DMLParser extends Parser {
	public static final int EOF=-1;
	public static final int A=4;
	public static final int AMPERSAND=5;
	public static final int APPROXIMATE_NUM_LIT=6;
	public static final int ASSIGN_OP=7;
	public static final int ASTERISK=8;
	public static final int AT_SIGN=9;
	public static final int B=10;
	public static final int BINDVAR=11;
	public static final int BIT_STRING_LIT=12;
	public static final int C=13;
	public static final int CARRET_OPERATOR_PART=14;
	public static final int CHAR_STRING=15;
	public static final int CHAR_STRING_PERL=16;
	public static final int COLON=17;
	public static final int COMMA=18;
	public static final int COMMENT=19;
	public static final int COMMENT_FRAGMENT=20;
	public static final int CONCATENATION_OP=21;
	public static final int D=22;
	public static final int DELIMITED_ID=23;
	public static final int DOUBLE_ASTERISK=24;
	public static final int DOUBLE_PERIOD=25;
	public static final int E=26;
	public static final int EQUALS_OP=27;
	public static final int EXACT_NUM_LIT=28;
	public static final int EXCLAMATION_OPERATOR_PART=29;
	public static final int F=30;
	public static final int G=31;
	public static final int GREATER_THAN_OP=32;
	public static final int GREATER_THAN_OR_EQUALS_OP=33;
	public static final int H=34;
	public static final int HEX_STRING_LIT=35;
	public static final int I=36;
	public static final int INTRODUCER=37;
	public static final int J=38;
	public static final int K=39;
	public static final int L=40;
	public static final int LEFT_BRACKET=41;
	public static final int LEFT_PAREN=42;
	public static final int LESS_THAN_OP=43;
	public static final int LESS_THAN_OR_EQUALS_OP=44;
	public static final int M=45;
	public static final int MINUS_SIGN=46;
	public static final int N=47;
	public static final int NATIONAL_CHAR_STRING_LIT=48;
	public static final int NEWLINE=49;
	public static final int NOT_EQUAL_OP=50;
	public static final int O=51;
	public static final int P=52;
	public static final int PERCENT=53;
	public static final int PERIOD=54;
	public static final int PLSQL_NON_RESERVED_CONNECT_BY_ROOT=55;
	public static final int PLSQL_NON_RESERVED_ELSIF=56;
	public static final int PLSQL_NON_RESERVED_MODEL=57;
	public static final int PLSQL_NON_RESERVED_PIVOT=58;
	public static final int PLSQL_NON_RESERVED_UNPIVOT=59;
	public static final int PLSQL_NON_RESERVED_USING=60;
	public static final int PLSQL_RESERVED_CLUSTERS=61;
	public static final int PLSQL_RESERVED_COLAUTH=62;
	public static final int PLSQL_RESERVED_COMPRESS=63;
	public static final int PLSQL_RESERVED_CRASH=64;
	public static final int PLSQL_RESERVED_EXCLUSIVE=65;
	public static final int PLSQL_RESERVED_IDENTIFIED=66;
	public static final int PLSQL_RESERVED_IF=67;
	public static final int PLSQL_RESERVED_INDEX=68;
	public static final int PLSQL_RESERVED_INDEXES=69;
	public static final int PLSQL_RESERVED_LOCK=70;
	public static final int PLSQL_RESERVED_MINUS=71;
	public static final int PLSQL_RESERVED_MODE=72;
	public static final int PLSQL_RESERVED_NOCOMPRESS=73;
	public static final int PLSQL_RESERVED_NOWAIT=74;
	public static final int PLSQL_RESERVED_RESOURCE=75;
	public static final int PLSQL_RESERVED_SHARE=76;
	public static final int PLSQL_RESERVED_START=77;
	public static final int PLSQL_RESERVED_TABAUTH=78;
	public static final int PLSQL_RESERVED_VIEWS=79;
	public static final int PLUS_SIGN=80;
	public static final int PROMPT=81;
	public static final int Q=82;
	public static final int QS_ANGLE=83;
	public static final int QS_BRACE=84;
	public static final int QS_BRACK=85;
	public static final int QS_OTHER=86;
	public static final int QS_OTHER_CH=87;
	public static final int QS_PAREN=88;
	public static final int QUESTION_MARK=89;
	public static final int QUOTE=90;
	public static final int R=91;
	public static final int REGULAR_ID=92;
	public static final int RIGHT_BRACKET=93;
	public static final int RIGHT_PAREN=94;
	public static final int S=95;
	public static final int SEMICOLON=96;
	public static final int SEPARATOR=97;
	public static final int SIMPLE_LETTER=98;
	public static final int SOLIDUS=99;
	public static final int SPACE=100;
	public static final int SQL92_RESERVED_ALL=101;
	public static final int SQL92_RESERVED_ALTER=102;
	public static final int SQL92_RESERVED_AND=103;
	public static final int SQL92_RESERVED_ANY=104;
	public static final int SQL92_RESERVED_AS=105;
	public static final int SQL92_RESERVED_ASC=106;
	public static final int SQL92_RESERVED_BEGIN=107;
	public static final int SQL92_RESERVED_BETWEEN=108;
	public static final int SQL92_RESERVED_BY=109;
	public static final int SQL92_RESERVED_CASE=110;
	public static final int SQL92_RESERVED_CHECK=111;
	public static final int SQL92_RESERVED_CONNECT=112;
	public static final int SQL92_RESERVED_CREATE=113;
	public static final int SQL92_RESERVED_CURRENT=114;
	public static final int SQL92_RESERVED_CURSOR=115;
	public static final int SQL92_RESERVED_DATE=116;
	public static final int SQL92_RESERVED_DECLARE=117;
	public static final int SQL92_RESERVED_DEFAULT=118;
	public static final int SQL92_RESERVED_DELETE=119;
	public static final int SQL92_RESERVED_DESC=120;
	public static final int SQL92_RESERVED_DISTINCT=121;
	public static final int SQL92_RESERVED_DROP=122;
	public static final int SQL92_RESERVED_ELSE=123;
	public static final int SQL92_RESERVED_END=124;
	public static final int SQL92_RESERVED_EXCEPTION=125;
	public static final int SQL92_RESERVED_EXISTS=126;
	public static final int SQL92_RESERVED_FALSE=127;
	public static final int SQL92_RESERVED_FETCH=128;
	public static final int SQL92_RESERVED_FOR=129;
	public static final int SQL92_RESERVED_FROM=130;
	public static final int SQL92_RESERVED_GOTO=131;
	public static final int SQL92_RESERVED_GRANT=132;
	public static final int SQL92_RESERVED_GROUP=133;
	public static final int SQL92_RESERVED_HAVING=134;
	public static final int SQL92_RESERVED_IN=135;
	public static final int SQL92_RESERVED_INSERT=136;
	public static final int SQL92_RESERVED_INTERSECT=137;
	public static final int SQL92_RESERVED_INTO=138;
	public static final int SQL92_RESERVED_IS=139;
	public static final int SQL92_RESERVED_LIKE=140;
	public static final int SQL92_RESERVED_NOT=141;
	public static final int SQL92_RESERVED_NULL=142;
	public static final int SQL92_RESERVED_OF=143;
	public static final int SQL92_RESERVED_ON=144;
	public static final int SQL92_RESERVED_OPTION=145;
	public static final int SQL92_RESERVED_OR=146;
	public static final int SQL92_RESERVED_ORDER=147;
	public static final int SQL92_RESERVED_OVERLAPS=148;
	public static final int SQL92_RESERVED_PRIOR=149;
	public static final int SQL92_RESERVED_PROCEDURE=150;
	public static final int SQL92_RESERVED_PUBLIC=151;
	public static final int SQL92_RESERVED_REVOKE=152;
	public static final int SQL92_RESERVED_SELECT=153;
	public static final int SQL92_RESERVED_SIZE=154;
	public static final int SQL92_RESERVED_TABLE=155;
	public static final int SQL92_RESERVED_THE=156;
	public static final int SQL92_RESERVED_THEN=157;
	public static final int SQL92_RESERVED_TO=158;
	public static final int SQL92_RESERVED_TRUE=159;
	public static final int SQL92_RESERVED_UNION=160;
	public static final int SQL92_RESERVED_UNIQUE=161;
	public static final int SQL92_RESERVED_UPDATE=162;
	public static final int SQL92_RESERVED_VALUES=163;
	public static final int SQL92_RESERVED_VIEW=164;
	public static final int SQL92_RESERVED_WHEN=165;
	public static final int SQL92_RESERVED_WHERE=166;
	public static final int SQL92_RESERVED_WITH=167;
	public static final int T=168;
	public static final int TILDE_OPERATOR_PART=169;
	public static final int U=170;
	public static final int UNDERSCORE=171;
	public static final int UNSIGNED_INTEGER=172;
	public static final int V=173;
	public static final int VERTICAL_BAR=174;
	public static final int W=175;
	public static final int X=176;
	public static final int Y=177;
	public static final int Z=178;
	public static final int ZV=179;
	public static final int ADD_VK=180;
	public static final int AFTER_EACH_ROW=181;
	public static final int AFTER_STATEMENT=182;
	public static final int AFTER_VK=183;
	public static final int AGENT_VK=184;
	public static final int AGGREGATE_VK=185;
	public static final int ALTER_ATTRIBUTE=186;
	public static final int ALTER_COLLECTION=187;
	public static final int ALTER_FUNCTION=188;
	public static final int ALTER_METHOD=189;
	public static final int ALTER_METHOD_ELEMENT=190;
	public static final int ALTER_PACKAGE=191;
	public static final int ALTER_PROCEDURE=192;
	public static final int ALTER_SEQUENCE=193;
	public static final int ALTER_TRIGGER=194;
	public static final int ALTER_TYPE=195;
	public static final int ANALYZE_VK=196;
	public static final int ANY_ELEMENT=197;
	public static final int ANY_MODE=198;
	public static final int ARGUMENT=200;
	public static final int ARGUMENTS=201;
	public static final int ASSIGN=202;
	public static final int ASSOCIATE_VK=203;
	public static final int ATTRIBUTE=205;
	public static final int ATTRIBUTES=206;
	public static final int ATTRIBUTE_NAME=207;
	public static final int AT_VK=209;
	public static final int AUDIT_VK=210;
	public static final int AUTHID_VK=211;
	public static final int AUTOMATIC_VK=212;
	public static final int AUTONOMOUS_TRANSACTION_VK=213;
	public static final int AUTO_VK=214;
	public static final int BATCH_VK=215;
	public static final int BEFORE_EACH_ROW=216;
	public static final int BEFORE_STATEMENT=217;
	public static final int BEFORE_VK=218;
	public static final int BFILE_VK=219;
	public static final int BINARY_DOUBLE_VK=220;
	public static final int BINARY_FLOAT_VK=221;
	public static final int BINARY_INTEGER_VK=222;
	public static final int BIT_VK=224;
	public static final int BLOB_VK=225;
	public static final int BLOCK=226;
	public static final int BLOCK_VK=227;
	public static final int BODY=228;
	public static final int BODY_MODE=229;
	public static final int BODY_VK=230;
	public static final int BOOLEAN_VK=231;
	public static final int BOTH_VK=232;
	public static final int BREADTH_VK=233;
	public static final int BULK_VK=234;
	public static final int BYTE_VK=235;
	public static final int CACHE_VK=236;
	public static final int CALL_MODE=237;
	public static final int CALL_VK=238;
	public static final int CANONICAL_VK=239;
	public static final int CASCADE_VK=241;
	public static final int CASCATED_ELEMENT=242;
	public static final int CAST_VK=243;
	public static final int CHARACTER_VK=244;
	public static final int CHAR_CS_VK=245;
	public static final int CHAR_SET_NAME=246;
	public static final int CHAR_VK=249;
	public static final int CHR_VK=250;
	public static final int CLOB_VK=251;
	public static final int CLOSE_VK=252;
	public static final int CLUSTER_VK=253;
	public static final int COLLECTION_MODE=254;
	public static final int COLLECTION_NAME=255;
	public static final int COLLECT_VK=256;
	public static final int COLUMNS=258;
	public static final int COLUMN_ALIAS=259;
	public static final int COLUMN_NAME=260;
	public static final int COMMENT_VK=262;
	public static final int COMMITTED_VK=263;
	public static final int COMMIT_VK=264;
	public static final int COMPATIBILITY_VK=265;
	public static final int COMPILATION_UNIT=266;
	public static final int COMPILER_PARAMETER=267;
	public static final int COMPILE_VK=268;
	public static final int COMPOUND_DML=269;
	public static final int COMPOUND_VK=270;
	public static final int CONDITIONAL_INSERT=272;
	public static final int CONSTANT_NEGATED=273;
	public static final int CONSTANT_VK=274;
	public static final int CONSTRAINT_NAME=275;
	public static final int CONSTRAINT_STATE=276;
	public static final int CONSTRAINT_VK=277;
	public static final int CONSTRUCTOR_SPEC=278;
	public static final int CONSTRUCTOR_VK=279;
	public static final int CONTENT_VK=280;
	public static final int CONTEXT_VK=281;
	public static final int CONTINUE_VK=282;
	public static final int CONVERT_VK=283;
	public static final int CORRUPT_XID_ALL_VK=284;
	public static final int CORRUPT_XID_VK=285;
	public static final int COST_CLASS_NAME=286;
	public static final int COST_VK=287;
	public static final int COUNT_VK=288;
	public static final int CREATE_FUNCTION=289;
	public static final int CREATE_PACKAGE_BODY=290;
	public static final int CREATE_PACKAGE_SPEC=291;
	public static final int CREATE_PROCEDURE=292;
	public static final int CREATE_SEQUENCE=293;
	public static final int CREATE_TRIGGER=294;
	public static final int CREATE_TYPE_BODY=295;
	public static final int CREATE_TYPE_SPEC=296;
	public static final int CREATE_VIEW=297;
	public static final int CROSS_VK=298;
	public static final int CUBE_VK=299;
	public static final int CURRENT_USER_VK=300;
	public static final int CURRENT_VK=301;
	public static final int CURSOR_BASED_FOR=302;
	public static final int CURSOR_DECLARE=303;
	public static final int CURSOR_NAME=304;
	public static final int CUSTOMDATUM_VK=305;
	public static final int CUSTOM_TYPE=306;
	public static final int CYCLE_VK=307;
	public static final int C_VK=308;
	public static final int DATABASE_VK=309;
	public static final int DATETIME_OP=310;
	public static final int DAY_VK=311;
	public static final int DBTIMEZONE_VK=312;
	public static final int DB_ROLE_CHANGE_VK=313;
	public static final int DDL_VK=314;
	public static final int DEBUG_VK=315;
	public static final int DECIMAL_VK=316;
	public static final int DECOMPOSE_VK=317;
	public static final int DECREMENT_VK=318;
	public static final int DEC_VK=319;
	public static final int DEFAULTS_VK=320;
	public static final int DEFAULT_VALUE=321;
	public static final int DEFERRABLE_VK=322;
	public static final int DEFERRED_VK=323;
	public static final int DEFINER_VK=324;
	public static final int DENSE_RANK_VK=326;
	public static final int DEPENDENT_HANDLING=327;
	public static final int DEPTH_VK=328;
	public static final int DETERMINISTIC_VK=329;
	public static final int DIMENSION_VK=330;
	public static final int DIRECT_MODE=331;
	public static final int DISABLE_VK=332;
	public static final int DISASSOCIATE_VK=333;
	public static final int DIV_VK=334;
	public static final int DML_EVENT=335;
	public static final int DML_EVENT_ELEMENT=336;
	public static final int DOCUMENT_VK=337;
	public static final int DOT_ASTERISK=338;
	public static final int DOUBLE_VK=339;
	public static final int DROP_FUNCTION=340;
	public static final int DROP_PACKAGE=341;
	public static final int DROP_PROCEDURE=342;
	public static final int DROP_SEQUENCE=343;
	public static final int DROP_TRIGGER=344;
	public static final int DROP_TYPE=345;
	public static final int DSINTERVAL_UNCONSTRAINED_VK=346;
	public static final int DYNAMIC_RETURN=347;
	public static final int ELEMENT=348;
	public static final int ELEMENTS_MODE=349;
	public static final int ELEMENT_SPEC=350;
	public static final int ENABLE_VK=351;
	public static final int ENCODING_VK=352;
	public static final int ENTITYESCAPING_VK=353;
	public static final int EVALNAME_VK=355;
	public static final int EXCEPTIONS_VK=357;
	public static final int EXCEPTION_DECLARE=358;
	public static final int EXCEPTION_INIT_VK=359;
	public static final int EXCEPTION_NAME=360;
	public static final int EXCLUDE_VK=362;
	public static final int EXECUTE_VK=363;
	public static final int EXIT_VK=364;
	public static final int EXPLAIN_STATEMENT=365;
	public static final int EXPR=366;
	public static final int EXPR_LIST=367;
	public static final int EXTERNAL_MODE=368;
	public static final int EXTERNAL_VK=369;
	public static final int EXTRACT_VK=370;
	public static final int FACTORING=371;
	public static final int FAILURE_VK=372;
	public static final int FIELDS=373;
	public static final int FIELD_SPEC=374;
	public static final int FINAL_VK=375;
	public static final int FIRST_VALUE_VK=376;
	public static final int FIRST_VK=377;
	public static final int FLOAT_VK=378;
	public static final int FOLLOWING_VK=379;
	public static final int FOLLOWS_VK=380;
	public static final int FORALL_VK=381;
	public static final int FORCE_VK=382;
	public static final int FOREIGN_KEY=383;
	public static final int FOREIGN_VK=384;
	public static final int FOR_EACH_ROW=385;
	public static final int FOR_LOOP=386;
	public static final int FOR_MULTI_COLUMN=387;
	public static final int FOR_SINGLE_COLUMN=388;
	public static final int FULL_VK=389;
	public static final int FUNCTION_ENABLING_OVER=390;
	public static final int FUNCTION_ENABLING_USING=391;
	public static final int FUNCTION_ENABLING_WITHIN_OR_OVER=392;
	public static final int FUNCTION_NAME=393;
	public static final int FUNCTION_SPEC=394;
	public static final int GROUPING_VK=397;
	public static final int GROUPIN_SET=398;
	public static final int GROUP_BY_ELEMENT=399;
	public static final int HASH_VK=400;
	public static final int HIDE_VK=401;
	public static final int HIERARCHICAL=402;
	public static final int HOSTED_VARIABLE=403;
	public static final int HOSTED_VARIABLE_NAME=404;
	public static final int HOSTED_VARIABLE_ROUTINE_CALL=405;
	public static final int HOUR_VK=406;
	public static final int ID=407;
	public static final int IGNORE_VK=408;
	public static final int IMMEDIATE_VK=409;
	public static final int IMPLEMENTATION_TYPE_NAME=410;
	public static final int INCLUDE_VK=411;
	public static final int INCLUDING_VK=412;
	public static final int INCREMENT_VK=413;
	public static final int INDENT_VK=414;
	public static final int INDEXED_BY=415;
	public static final int INDEXED_FOR=416;
	public static final int INDEX_NAME=417;
	public static final int INDICES_BOUND=418;
	public static final int INITIALLY_VK=419;
	public static final int INLINE_CONSTRAINT_CLAUSE=420;
	public static final int INLINE_VK=421;
	public static final int INNER_VK=422;
	public static final int INOUT_VK=423;
	public static final int INSTANTIABLE_VK=424;
	public static final int INSTEAD_VK=425;
	public static final int INTEGER_VK=426;
	public static final int INTERVAL_DATATYPE=427;
	public static final int INT_VK=429;
	public static final int INVALIDATE_VK=430;
	public static final int ISOLATION_VK=431;
	public static final int IS_A_SET=432;
	public static final int IS_EMPTY=433;
	public static final int IS_INFINITE=434;
	public static final int IS_NAN=435;
	public static final int IS_NOT_A_SET=436;
	public static final int IS_NOT_EMPTY=437;
	public static final int IS_NOT_INFINITE=438;
	public static final int IS_NOT_NAN=439;
	public static final int IS_NOT_NULL=440;
	public static final int IS_NOT_OF_TYPE=441;
	public static final int IS_NOT_PRESENT=442;
	public static final int IS_NULL=443;
	public static final int IS_OF_TYPE=444;
	public static final int IS_PRESENT=445;
	public static final int ITERATE_VK=446;
	public static final int JAVA_VK=447;
	public static final int JOIN_DEF=448;
	public static final int KEEP_VK=449;
	public static final int KEY_VK=450;
	public static final int LABEL_DECLARE=451;
	public static final int LABEL_NAME=452;
	public static final int LANGUAGE_VK=453;
	public static final int LAST_VALUE_VK=454;
	public static final int LAST_VK=455;
	public static final int LEADING_VK=456;
	public static final int LEFT_VK=459;
	public static final int LIBRARY_VK=462;
	public static final int LIKE2_VK=463;
	public static final int LIKE4_VK=464;
	public static final int LIKEC_VK=465;
	public static final int LIMIT_VK=466;
	public static final int LINK_NAME=467;
	public static final int LOCAL_VK=468;
	public static final int LOCK_TABLE_ELEMENT=469;
	public static final int LOGIC_EXPR=470;
	public static final int LOGOFF_VK=471;
	public static final int LOGON_VK=472;
	public static final int LOG_VK=473;
	public static final int LONG_RAW=474;
	public static final int LONG_VK=475;
	public static final int LOOP_VK=476;
	public static final int MAIN_MODEL=477;
	public static final int MAIN_MODEL_NAME=478;
	public static final int MAP_VK=479;
	public static final int MAXVALUE_VK=480;
	public static final int MEASURES_VK=481;
	public static final int MEMBER_VK=482;
	public static final int MERGE_INSERT=483;
	public static final int MERGE_UPDATE=484;
	public static final int MERGE_VK=485;
	public static final int MINUTE_VK=487;
	public static final int MINVALUE_VK=488;
	public static final int MLSLABEL_VK=489;
	public static final int MODEL_COLUMN=490;
	public static final int MODEL_COLUMNS=491;
	public static final int MODEL_EXPRESSION=492;
	public static final int MODEL_RULE=493;
	public static final int MODEL_RULES=494;
	public static final int MODIFIER=495;
	public static final int MODIFY_VK=496;
	public static final int MOD_VK=497;
	public static final int MONTH_VK=498;
	public static final int MULTI_TABLE_MODE=499;
	public static final int NAME_VK=500;
	public static final int NATIVE_DATATYPE=502;
	public static final int NATURALN_VK=503;
	public static final int NATURAL_VK=504;
	public static final int NAV_VK=505;
	public static final int NCHAR_CS_VK=506;
	public static final int NCHAR_VK=507;
	public static final int NCLOB_VK=508;
	public static final int NESTED_TABLE_TYPE_DEF=509;
	public static final int NESTED_VK=510;
	public static final int NEW_VK=511;
	public static final int NOAUDIT_VK=512;
	public static final int NOCACHE_VK=513;
	public static final int NOCOPY_VK=514;
	public static final int NOCYCLE_VK=515;
	public static final int NOENTITYESCAPING_VK=516;
	public static final int NOFORCE=517;
	public static final int NOMAXVALUE_VK=518;
	public static final int NOMINVALUE_VK=519;
	public static final int NONE_VK=520;
	public static final int NON_DML=521;
	public static final int NOORDER_VK=522;
	public static final int NORELY_VK=523;
	public static final int NOSCHEMACHECK_VK=524;
	public static final int NOT_BETWEEN=525;
	public static final int NOT_DEFERRABLE=526;
	public static final int NOT_IN=528;
	public static final int NOT_LIKE=529;
	public static final int NOT_NULL=530;
	public static final int NOVALIDATE_VK=531;
	public static final int NO_VK=532;
	public static final int NULLS_VK=533;
	public static final int NUMBER_VK=534;
	public static final int NUMERIC_VK=535;
	public static final int NVARCHAR2_VK=536;
	public static final int OBJECT_AS=537;
	public static final int OBJECT_MEMBERS=538;
	public static final int OBJECT_TYPE_DEF=539;
	public static final int OBJECT_VK=540;
	public static final int OFF_VK=541;
	public static final int OLD_VK=542;
	public static final int ONLY_VK=543;
	public static final int ON_DELETE=544;
	public static final int OPEN_FOR=545;
	public static final int OPEN_VK=546;
	public static final int ORADATA_VK=547;
	public static final int ORDER_BY_ELEMENT=548;
	public static final int ORDER_BY_ELEMENTS=549;
	public static final int ORDINALITY_VK=550;
	public static final int OSERROR_VK=551;
	public static final int OUTER_JOIN_SIGN=552;
	public static final int OUT_OF_LINE_CONSTRAINT=553;
	public static final int OUT_VK=554;
	public static final int OVERRIDING_VK=555;
	public static final int OVER_VK=556;
	public static final int PACKAGE_NAME=557;
	public static final int PACKAGE_VK=558;
	public static final int PARALLEL_ENABLE_VK=559;
	public static final int PARAMETER=560;
	public static final int PARAMETERS=561;
	public static final int PARAMETERS_VK=562;
	public static final int PARAMETER_NAME=563;
	public static final int PARENT_VK=564;
	public static final int PARTITION_VK=565;
	public static final int PASSING_VK=566;
	public static final int PERCENT_FOUND_VK=568;
	public static final int PERCENT_ISOPEN_VK=569;
	public static final int PERCENT_NOTFOUND_VK=570;
	public static final int PERCENT_ROWCOUNT_VK=571;
	public static final int PERCENT_ROWTYPE_VK=572;
	public static final int PERCENT_TYPE_VK=573;
	public static final int PIPELINED_VK=575;
	public static final int PIPE_ROW=576;
	public static final int PIPE_VK=577;
	public static final int PIVOT_ALIAS=578;
	public static final int PIVOT_ELEMENT=579;
	public static final int PIVOT_IN_ELEMENT=580;
	public static final int PIVOT_VK=581;
	public static final int PLS_INTEGER_VK=596;
	public static final int POSITIVEN_VK=598;
	public static final int POSITIVE_VK=599;
	public static final int PRAGMA_DECLARE=600;
	public static final int PRAGMA_VK=601;
	public static final int PRECEDING_VK=602;
	public static final int PRECISION=603;
	public static final int PRECISION_VK=604;
	public static final int PREDICTION_FUNCTION=605;
	public static final int PRIMARY_KEY=606;
	public static final int PRIMARY_VK=607;
	public static final int PROCEDURE_NAME=608;
	public static final int PROCEDURE_SPEC=609;
	public static final int QUERY_NAME=611;
	public static final int QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS=612;
	public static final int RAISE_VK=613;
	public static final int RANGE_VK=614;
	public static final int RAW_VK=615;
	public static final int READ_VK=616;
	public static final int REAL_VK=617;
	public static final int RECORD_NAME=618;
	public static final int RECORD_TYPE_DECLARE_FIELDS=619;
	public static final int RECORD_TYPE_DECLARE_REFCURSOR=620;
	public static final int RECORD_VAR_DECLARE=621;
	public static final int RECURSIVE_VK=622;
	public static final int REFERENCES_CLAUSE=623;
	public static final int REFERENCES_VK=624;
	public static final int REFERENCE_MODEL_NAME=625;
	public static final int REFERENCE_VK=626;
	public static final int REFERENCING_VK=627;
	public static final int REF_VK=628;
	public static final int REJECT_VK=630;
	public static final int RELIES_ON_VK=631;
	public static final int RELY_VK=632;
	public static final int RENAME_VK=633;
	public static final int REPLACE_VK=634;
	public static final int RESPECT_VK=635;
	public static final int RESTRICT_REFERENCES_VK=636;
	public static final int RESULT_CACHE_VK=637;
	public static final int RETURN_VK=638;
	public static final int REUSE_VK=639;
	public static final int REVERSE_VK=640;
	public static final int RIGHT_VK=643;
	public static final int ROLLBACK_SEGMENT_NAME=644;
	public static final int ROLLBACK_VK=645;
	public static final int ROLLUP_VK=646;
	public static final int ROUTINE_CALL=647;
	public static final int ROUTINE_NAME=648;
	public static final int ROWID_VK=649;
	public static final int ROWS_VK=650;
	public static final int ROW_VK=651;
	public static final int RULES_VK=652;
	public static final int SAMPLE_VK=653;
	public static final int SAVEPOINT_NAME=654;
	public static final int SAVEPOINT_VK=655;
	public static final int SCHEMACHECK_VK=656;
	public static final int SCHEMA_NAME=657;
	public static final int SCHEMA_VK=658;
	public static final int SCN_VK=659;
	public static final int SEARCHED_CASE=660;
	public static final int SEARCH_VK=661;
	public static final int SECOND_VK=662;
	public static final int SEED_VK=663;
	public static final int SELECTED_TABLEVIEW=664;
	public static final int SELECT_BASED_FOR=665;
	public static final int SELECT_ITEM=666;
	public static final int SELECT_LIST=667;
	public static final int SELECT_MODE=668;
	public static final int SELECT_STATEMENT=669;
	public static final int SELF_VK=670;
	public static final int SEQUENCE_NAME=672;
	public static final int SEQUENCE_VK=673;
	public static final int SEQUENTIAL_VK=674;
	public static final int SERIALIZABLE_VK=675;
	public static final int SERIALLY_REUSABLE_VK=676;
	public static final int SERVERERROR_VK=677;
	public static final int SESSIONTIMEZONE_VK=678;
	public static final int SET_CONSTRAINT=679;
	public static final int SET_NULL=680;
	public static final int SET_SERVEROUTPUT=681;
	public static final int SET_TRANSACTION=682;
	public static final int SET_VK=683;
	public static final int SHOW_VK=684;
	public static final int SHUTDOWN_VK=685;
	public static final int SIBLINGS_VK=686;
	public static final int SIGNTYPE_VK=687;
	public static final int SIMPLE_BOUND=688;
	public static final int SIMPLE_CASE=689;
	public static final int SIMPLE_DML=690;
	public static final int SIMPLE_INTEGER_VK=691;
	public static final int SINGLE_TABLE_MODE=692;
	public static final int SINGLE_VK=693;
	public static final int SKIP_VK=694;
	public static final int SMALLINT_VK=695;
	public static final int SOME_VK=697;
	public static final int SPECIFICATION_VK=698;
	public static final int SQLDATA_VK=764;
	public static final int SQLERROR_VK=765;
	public static final int SQL_SCRIPT=766;
	public static final int STANDALONE_VK=767;
	public static final int STANDARD_FUNCTION=768;
	public static final int STARTUP_VK=769;
	public static final int STATEMENTS=770;
	public static final int STATIC_RETURNING=771;
	public static final int STATIC_VK=772;
	public static final int STATISTICS_VK=773;
	public static final int STREAMING_CLAUSE=774;
	public static final int STRING_VK=775;
	public static final int SUBMULTISET_VK=776;
	public static final int SUBPARTITION_VK=777;
	public static final int SUBQUERY=778;
	public static final int SUBTYPE_DECLARE=779;
	public static final int SUCCESS_VK=780;
	public static final int SUSPEND_VK=781;
	public static final int TABLEVIEW_NAME=782;
	public static final int TABLE_ALIAS=783;
	public static final int TABLE_ELEMENT=784;
	public static final int TABLE_EXPRESSION=785;
	public static final int TABLE_REF=786;
	public static final int TABLE_REF_ELEMENT=787;
	public static final int TABLE_TYPE_DECLARE=788;
	public static final int TABLE_VAR_DECLARE=789;
	public static final int TABLE_VAR_NAME=790;
	public static final int THREE_DOTS=791;
	public static final int TIMESTAMP_LTZ_UNCONSTRAINED_VK=792;
	public static final int TIMESTAMP_TZ_UNCONSTRAINED_VK=793;
	public static final int TIMESTAMP_UNCONSTRAINED_VK=794;
	public static final int TIMESTAMP_VK=795;
	public static final int TIMEZONE_ABBR_VK=796;
	public static final int TIMEZONE_HOUR_VK=797;
	public static final int TIMEZONE_MINUTE_VK=798;
	public static final int TIMEZONE_REGION_VK=799;
	public static final int TIME_VK=800;
	public static final int TRAILING_VK=801;
	public static final int TRANSLATE_VK=802;
	public static final int TREAT_VK=803;
	public static final int TRIGGER_NAME=804;
	public static final int TRIM_VK=805;
	public static final int TRUNCATE_VK=806;
	public static final int TYPE_BODY_ELEMENTS=807;
	public static final int TYPE_NAME=808;
	public static final int TYPE_VK=809;
	public static final int UNARY_MINUS=810;
	public static final int UNARY_PLUS=811;
	public static final int UNBOUNDED_VK=812;
	public static final int UNDER_VK=813;
	public static final int UNLIMITED_VK=814;
	public static final int UNPIVOT_IN_ELEMENT=815;
	public static final int UNPIVOT_VK=816;
	public static final int UNTIL_VK=818;
	public static final int UPDATED_VK=819;
	public static final int UPSERT_VK=820;
	public static final int UROWID_VK=821;
	public static final int USING_INDEX=822;
	public static final int USING_MODE=823;
	public static final int VALIDATE_VK=824;
	public static final int VALUES_BOUND=825;
	public static final int VALUE_VK=826;
	public static final int VARCHAR2_VK=827;
	public static final int VARCHAR_VK=828;
	public static final int VARIABLE_DECLARE=829;
	public static final int VARIABLE_NAME=830;
	public static final int VARR_ARRAY_DEF=831;
	public static final int VECTOR_EXPR=832;
	public static final int VERSIONS_VK=833;
	public static final int VERSION_VK=834;
	public static final int VIEW_NAME=836;
	public static final int VIEW_TYPE_CONSTRAINTS=837;
	public static final int VIEW_TYPE_CONSTRAINT_ITEM_INLINE=838;
	public static final int WAIT_VK=839;
	public static final int WARNING_VK=840;
	public static final int WELLFORMED_VK=841;
	public static final int WHENEVER_VK=842;
	public static final int WHILE_LOOP=843;
	public static final int WITHIN_VK=844;
	public static final int WORK_VK=845;
	public static final int WRITE_VK=846;
	public static final int XMLAGG_VK=847;
	public static final int XMLATTRIBUTES_VK=848;
	public static final int XMLCAST_VK=849;
	public static final int XMLCOLATTVAL_VK=850;
	public static final int XMLELEMENT_VK=851;
	public static final int XMLEXISTS_VK=852;
	public static final int XMLFOREST_VK=853;
	public static final int XMLNAMESPACES_VK=854;
	public static final int XMLPARSE_VK=855;
	public static final int XMLPI_VK=856;
	public static final int XMLQUERY_VK=857;
	public static final int XMLROOT_VK=858;
	public static final int XMLSERIALIZE_VK=859;
	public static final int XMLTABLE_VK=860;
	public static final int XML_ALIAS=861;
	public static final int XML_COLUMN=862;
	public static final int XML_COLUMN_NAME=863;
	public static final int XML_ELEMENT=864;
	public static final int XML_VK=865;
	public static final int YEAR_VK=866;
	public static final int YES_VK=867;
	public static final int YMINTERVAL_UNCONSTRAINED_VK=868;

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators
	public PLSQLParser gPLSQLParser;
	public PLSQLParser gParent;


	public PLSQLParser_PLSQL_DMLParser(TokenStream input, PLSQLParser gPLSQLParser) {
		this(input, new RecognizerSharedState(), gPLSQLParser);
	}
	public PLSQLParser_PLSQL_DMLParser(TokenStream input, RecognizerSharedState state, PLSQLParser gPLSQLParser) {
		super(input, state);
		this.gPLSQLParser = gPLSQLParser;
		gParent = gPLSQLParser;
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return PLSQLParser.tokenNames; }
	@Override public String getGrammarFileName() { return "PLSQL_DMLParser.g"; }


	    private boolean isTableAlias() {
	        String lt1 = input.LT(1).getText().toLowerCase();
	        String lt2 = "";
	        if (input.LT(2).getText() != null){
	            lt2 = input.LT(2).getText().toLowerCase();
	        }

	//        if (lt1.equals("as")){
	//            return true;
	//        }

	        if ((lt1.equals("partition") && lt2.equals("by")) || lt1.equals("cross")
	                || lt1.equals("natural") || lt1.equals("inner")
	                || lt1.equals("join")
	                || ((lt1.equals("full") || lt1.equals("left") || lt1.equals("right")) && (lt2.equals("outer") || lt2.equals("join")))) {
	            return false;
	        }
	        return true;
	    }

	    private boolean isStandardPredictionFunction(String originalFunctionName) {
	        String functionName = originalFunctionName.toLowerCase();
	        if (functionName.equals("prediction")
	                || functionName.equals("prediction_bounds")
	                || functionName.equals("prediction_cost")
	                || functionName.equals("prediction_details")
	                || functionName.equals("prediction_probability")
	                || functionName.equals("prediction_set")) {
	            return true;
	        }
	        return false;
	    }

	    private boolean enablesWithinOrOverClause(String originalFunctionName) {
	        String functionName = originalFunctionName.toLowerCase();
	        if (functionName.equals("cume_dist")
	                || functionName.equals("dense_rank")
	                || functionName.equals("listagg")
	                || functionName.equals("percent_rank")
	                || functionName.equals("percentile_cont")
	                || functionName.equals("percentile_disc")
	                || functionName.equals("rank")) {
	            return true;
	        }
	        return false;
	    }

	    private boolean enablesUsingClause(String originalFunctionName) {
	        String functionName = originalFunctionName.toLowerCase();
	        if (functionName.startsWith("cluster_")
	                || functionName.startsWith("feature_")) {
	            return true;
	        }
	        return false;
	    }

	    private boolean enablesOverClause(String originalFunctionName) {
	        String functionName = originalFunctionName.toLowerCase();
	        if (functionName.equals("avg") || functionName.equals("corr")
	                || functionName.equals("lag") || functionName.equals("lead")
	                || functionName.equals("max") || functionName.equals("median")
	                || functionName.equals("min") || functionName.equals("ntile")
	                || functionName.equals("ratio_to_report")
	                || functionName.equals("row_number")
	                || functionName.equals("sum")
	                || functionName.equals("variance")
	                || functionName.startsWith("regr_")
	                || functionName.startsWith("stddev")
	                || functionName.startsWith("var_")
	                || functionName.startsWith("covar_")) {
	            return true;
	        }
	        return false;
	    }


	public static class explain_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "explain_statement"
	// PLSQL_DMLParser.g:201:1: explain_statement : explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.explain_statement_return explain_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.explain_statement_return retval = new PLSQLParser_PLSQL_DMLParser.explain_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP5=null;
		ParserRuleReturnScope explain_key1 =null;
		ParserRuleReturnScope plan_key2 =null;
		ParserRuleReturnScope set_key3 =null;
		ParserRuleReturnScope statement_id_key4 =null;
		ParserRuleReturnScope quoted_string6 =null;
		ParserRuleReturnScope into_key7 =null;
		ParserRuleReturnScope tableview_name8 =null;
		ParserRuleReturnScope for_key9 =null;
		ParserRuleReturnScope select_statement10 =null;
		ParserRuleReturnScope update_statement11 =null;
		ParserRuleReturnScope delete_statement12 =null;
		ParserRuleReturnScope insert_statement13 =null;
		ParserRuleReturnScope merge_statement14 =null;

		Object EQUALS_OP5_tree=null;
		RewriteRuleTokenStream stream_EQUALS_OP=new RewriteRuleTokenStream(adaptor,"token EQUALS_OP");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");
		RewriteRuleSubtreeStream stream_into_key=new RewriteRuleSubtreeStream(adaptor,"rule into_key");
		RewriteRuleSubtreeStream stream_delete_statement=new RewriteRuleSubtreeStream(adaptor,"rule delete_statement");
		RewriteRuleSubtreeStream stream_select_statement=new RewriteRuleSubtreeStream(adaptor,"rule select_statement");
		RewriteRuleSubtreeStream stream_insert_statement=new RewriteRuleSubtreeStream(adaptor,"rule insert_statement");
		RewriteRuleSubtreeStream stream_explain_key=new RewriteRuleSubtreeStream(adaptor,"rule explain_key");
		RewriteRuleSubtreeStream stream_plan_key=new RewriteRuleSubtreeStream(adaptor,"rule plan_key");
		RewriteRuleSubtreeStream stream_statement_id_key=new RewriteRuleSubtreeStream(adaptor,"rule statement_id_key");
		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_set_key=new RewriteRuleSubtreeStream(adaptor,"rule set_key");
		RewriteRuleSubtreeStream stream_quoted_string=new RewriteRuleSubtreeStream(adaptor,"rule quoted_string");
		RewriteRuleSubtreeStream stream_merge_statement=new RewriteRuleSubtreeStream(adaptor,"rule merge_statement");
		RewriteRuleSubtreeStream stream_update_statement=new RewriteRuleSubtreeStream(adaptor,"rule update_statement");

		try {
			// PLSQL_DMLParser.g:202:5: ( explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? ) )
			// PLSQL_DMLParser.g:202:10: explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
			{
			pushFollow(FOLLOW_explain_key_in_explain_statement712);
			explain_key1=gPLSQLParser.explain_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_explain_key.add(explain_key1.getTree());
			pushFollow(FOLLOW_plan_key_in_explain_statement714);
			plan_key2=gPLSQLParser.plan_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_plan_key.add(plan_key2.getTree());
			// PLSQL_DMLParser.g:203:10: ( set_key statement_id_key EQUALS_OP quoted_string )?
			int alt3=2;
			int LA3_0 = input.LA(1);
			if ( (LA3_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {
				alt3=1;
			}
			switch (alt3) {
				case 1 :
					// PLSQL_DMLParser.g:203:11: set_key statement_id_key EQUALS_OP quoted_string
					{
					pushFollow(FOLLOW_set_key_in_explain_statement726);
					set_key3=gPLSQLParser.set_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_set_key.add(set_key3.getTree());
					pushFollow(FOLLOW_statement_id_key_in_explain_statement728);
					statement_id_key4=gPLSQLParser.statement_id_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_statement_id_key.add(statement_id_key4.getTree());
					EQUALS_OP5=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_explain_statement730); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP5);

					pushFollow(FOLLOW_quoted_string_in_explain_statement732);
					quoted_string6=gPLSQLParser.quoted_string();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_quoted_string.add(quoted_string6.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:204:10: ( into_key tableview_name )?
			int alt4=2;
			int LA4_0 = input.LA(1);
			if ( (LA4_0==SQL92_RESERVED_INTO) ) {
				alt4=1;
			}
			switch (alt4) {
				case 1 :
					// PLSQL_DMLParser.g:204:11: into_key tableview_name
					{
					pushFollow(FOLLOW_into_key_in_explain_statement746);
					into_key7=gPLSQLParser.into_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_into_key.add(into_key7.getTree());
					pushFollow(FOLLOW_tableview_name_in_explain_statement748);
					tableview_name8=gPLSQLParser.tableview_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name8.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_for_key_in_explain_statement761);
			for_key9=gPLSQLParser.for_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_for_key.add(for_key9.getTree());
			// PLSQL_DMLParser.g:206:10: ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
			int alt5=5;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==LEFT_PAREN||LA5_0==SQL92_RESERVED_SELECT||LA5_0==SQL92_RESERVED_WITH) ) {
				alt5=1;
			}
			else if ( (LA5_0==SQL92_RESERVED_UPDATE) ) {
				alt5=2;
			}
			else if ( (LA5_0==SQL92_RESERVED_DELETE) ) {
				alt5=3;
			}
			else if ( (LA5_0==SQL92_RESERVED_INSERT) ) {
				alt5=4;
			}
			else if ( (LA5_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("merge")))) {
				alt5=5;
			}

			switch (alt5) {
				case 1 :
					// PLSQL_DMLParser.g:206:12: select_statement
					{
					pushFollow(FOLLOW_select_statement_in_explain_statement774);
					select_statement10=select_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_select_statement.add(select_statement10.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:207:12: update_statement
					{
					pushFollow(FOLLOW_update_statement_in_explain_statement787);
					update_statement11=update_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_update_statement.add(update_statement11.getTree());
					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:208:12: delete_statement
					{
					pushFollow(FOLLOW_delete_statement_in_explain_statement800);
					delete_statement12=delete_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_delete_statement.add(delete_statement12.getTree());
					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:209:12: insert_statement
					{
					pushFollow(FOLLOW_insert_statement_in_explain_statement813);
					insert_statement13=insert_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_insert_statement.add(insert_statement13.getTree());
					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:210:12: merge_statement
					{
					pushFollow(FOLLOW_merge_statement_in_explain_statement826);
					merge_statement14=merge_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_merge_statement.add(merge_statement14.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: update_statement, delete_statement, insert_statement, select_statement, merge_statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 212:10: -> ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? )
			{
				// PLSQL_DMLParser.g:212:13: ^( EXPLAIN_STATEMENT ( select_statement )? ( update_statement )? ( delete_statement )? ( insert_statement )? ( merge_statement )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPLAIN_STATEMENT, "EXPLAIN_STATEMENT"), root_1);
				// PLSQL_DMLParser.g:212:33: ( select_statement )?
				if ( stream_select_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_select_statement.nextTree());
				}
				stream_select_statement.reset();

				// PLSQL_DMLParser.g:212:51: ( update_statement )?
				if ( stream_update_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_update_statement.nextTree());
				}
				stream_update_statement.reset();

				// PLSQL_DMLParser.g:212:69: ( delete_statement )?
				if ( stream_delete_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_delete_statement.nextTree());
				}
				stream_delete_statement.reset();

				// PLSQL_DMLParser.g:212:87: ( insert_statement )?
				if ( stream_insert_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_insert_statement.nextTree());
				}
				stream_insert_statement.reset();

				// PLSQL_DMLParser.g:212:105: ( merge_statement )?
				if ( stream_merge_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_merge_statement.nextTree());
				}
				stream_merge_statement.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "explain_statement"


	public static class select_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "select_statement"
	// PLSQL_DMLParser.g:215:1: select_statement : ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? -> ^( SELECT_STATEMENT ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.select_statement_return select_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.select_statement_return retval = new PLSQLParser_PLSQL_DMLParser.select_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope subquery_factoring_clause15 =null;
		ParserRuleReturnScope subquery16 =null;
		ParserRuleReturnScope order_by_clause17 =null;
		ParserRuleReturnScope for_update_clause18 =null;

		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_order_by_clause=new RewriteRuleSubtreeStream(adaptor,"rule order_by_clause");
		RewriteRuleSubtreeStream stream_for_update_clause=new RewriteRuleSubtreeStream(adaptor,"rule for_update_clause");
		RewriteRuleSubtreeStream stream_subquery_factoring_clause=new RewriteRuleSubtreeStream(adaptor,"rule subquery_factoring_clause");

		try {
			// PLSQL_DMLParser.g:216:5: ( ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? -> ^( SELECT_STATEMENT ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? ) )
			// PLSQL_DMLParser.g:216:9: ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )?
			{
			// PLSQL_DMLParser.g:216:9: ( subquery_factoring_clause )?
			int alt6=2;
			int LA6_0 = input.LA(1);
			if ( (LA6_0==SQL92_RESERVED_WITH) ) {
				alt6=1;
			}
			switch (alt6) {
				case 1 :
					// PLSQL_DMLParser.g:216:9: subquery_factoring_clause
					{
					pushFollow(FOLLOW_subquery_factoring_clause_in_select_statement886);
					subquery_factoring_clause15=subquery_factoring_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery_factoring_clause.add(subquery_factoring_clause15.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_subquery_in_select_statement897);
			subquery16=subquery();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subquery.add(subquery16.getTree());
			// PLSQL_DMLParser.g:218:9: ( order_by_clause )?
			int alt7=2;
			int LA7_0 = input.LA(1);
			if ( (LA7_0==SQL92_RESERVED_ORDER) ) {
				alt7=1;
			}
			switch (alt7) {
				case 1 :
					// PLSQL_DMLParser.g:218:9: order_by_clause
					{
					pushFollow(FOLLOW_order_by_clause_in_select_statement907);
					order_by_clause17=order_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_order_by_clause.add(order_by_clause17.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:219:9: ( for_update_clause )?
			int alt8=2;
			int LA8_0 = input.LA(1);
			if ( (LA8_0==SQL92_RESERVED_FOR) ) {
				alt8=1;
			}
			switch (alt8) {
				case 1 :
					// PLSQL_DMLParser.g:219:9: for_update_clause
					{
					pushFollow(FOLLOW_for_update_clause_in_select_statement918);
					for_update_clause18=for_update_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_for_update_clause.add(for_update_clause18.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: subquery, order_by_clause, subquery_factoring_clause, for_update_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 220:9: -> ^( SELECT_STATEMENT ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? )
			{
				// PLSQL_DMLParser.g:220:12: ^( SELECT_STATEMENT ( subquery_factoring_clause )? subquery ( order_by_clause )? ( for_update_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_STATEMENT, "SELECT_STATEMENT"), root_1);
				// PLSQL_DMLParser.g:220:31: ( subquery_factoring_clause )?
				if ( stream_subquery_factoring_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_subquery_factoring_clause.nextTree());
				}
				stream_subquery_factoring_clause.reset();

				adaptor.addChild(root_1, stream_subquery.nextTree());
				// PLSQL_DMLParser.g:220:67: ( order_by_clause )?
				if ( stream_order_by_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_order_by_clause.nextTree());
				}
				stream_order_by_clause.reset();

				// PLSQL_DMLParser.g:220:84: ( for_update_clause )?
				if ( stream_for_update_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_for_update_clause.nextTree());
				}
				stream_for_update_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "select_statement"


	public static class subquery_factoring_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subquery_factoring_clause"
	// PLSQL_DMLParser.g:224:1: subquery_factoring_clause : with_key ^ ( recursive_key )? factoring_element ( COMMA ! factoring_element )* ;
	public final PLSQLParser_PLSQL_DMLParser.subquery_factoring_clause_return subquery_factoring_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.subquery_factoring_clause_return retval = new PLSQLParser_PLSQL_DMLParser.subquery_factoring_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA22=null;
		ParserRuleReturnScope with_key19 =null;
		ParserRuleReturnScope recursive_key20 =null;
		ParserRuleReturnScope factoring_element21 =null;
		ParserRuleReturnScope factoring_element23 =null;

		Object COMMA22_tree=null;

		try {
			// PLSQL_DMLParser.g:225:5: ( with_key ^ ( recursive_key )? factoring_element ( COMMA ! factoring_element )* )
			// PLSQL_DMLParser.g:225:10: with_key ^ ( recursive_key )? factoring_element ( COMMA ! factoring_element )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_with_key_in_subquery_factoring_clause967);
			with_key19=gPLSQLParser.with_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(with_key19.getTree(), root_0);
			// PLSQL_DMLParser.g:225:20: ( recursive_key )?
			int alt9=2;
			int LA9_0 = input.LA(1);
			if ( (LA9_0==REGULAR_ID) ) {
				int LA9_1 = input.LA(2);
				if ( (LA9_1==DELIMITED_ID||LA9_1==INTRODUCER||LA9_1==REGULAR_ID) ) {
					alt9=1;
				}
			}
			switch (alt9) {
				case 1 :
					// PLSQL_DMLParser.g:225:20: recursive_key
					{
					pushFollow(FOLLOW_recursive_key_in_subquery_factoring_clause970);
					recursive_key20=gPLSQLParser.recursive_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, recursive_key20.getTree());

					}
					break;

			}

			pushFollow(FOLLOW_factoring_element_in_subquery_factoring_clause973);
			factoring_element21=factoring_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, factoring_element21.getTree());

			// PLSQL_DMLParser.g:225:53: ( COMMA ! factoring_element )*
			loop10:
			while (true) {
				int alt10=2;
				int LA10_0 = input.LA(1);
				if ( (LA10_0==COMMA) ) {
					alt10=1;
				}

				switch (alt10) {
				case 1 :
					// PLSQL_DMLParser.g:225:54: COMMA ! factoring_element
					{
					COMMA22=(Token)match(input,COMMA,FOLLOW_COMMA_in_subquery_factoring_clause976); if (state.failed) return retval;
					pushFollow(FOLLOW_factoring_element_in_subquery_factoring_clause979);
					factoring_element23=factoring_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, factoring_element23.getTree());

					}
					break;

				default :
					break loop10;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subquery_factoring_clause"


	public static class factoring_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "factoring_element"
	// PLSQL_DMLParser.g:228:1: factoring_element : query_name ( LEFT_PAREN columns+= column_name ( COMMA columns+= column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? -> ^( FACTORING query_name ( $columns)* subquery ( order_by_clause )? ( search_clause )? ( cycle_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.factoring_element_return factoring_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.factoring_element_return retval = new PLSQLParser_PLSQL_DMLParser.factoring_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN25=null;
		Token COMMA26=null;
		Token RIGHT_PAREN27=null;
		Token LEFT_PAREN29=null;
		Token RIGHT_PAREN32=null;
		List<Object> list_columns=null;
		ParserRuleReturnScope query_name24 =null;
		ParserRuleReturnScope as_key28 =null;
		ParserRuleReturnScope subquery30 =null;
		ParserRuleReturnScope order_by_clause31 =null;
		ParserRuleReturnScope search_clause33 =null;
		ParserRuleReturnScope cycle_clause34 =null;
		RuleReturnScope columns = null;
		Object LEFT_PAREN25_tree=null;
		Object COMMA26_tree=null;
		Object RIGHT_PAREN27_tree=null;
		Object LEFT_PAREN29_tree=null;
		Object RIGHT_PAREN32_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_order_by_clause=new RewriteRuleSubtreeStream(adaptor,"rule order_by_clause");
		RewriteRuleSubtreeStream stream_query_name=new RewriteRuleSubtreeStream(adaptor,"rule query_name");
		RewriteRuleSubtreeStream stream_as_key=new RewriteRuleSubtreeStream(adaptor,"rule as_key");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_search_clause=new RewriteRuleSubtreeStream(adaptor,"rule search_clause");
		RewriteRuleSubtreeStream stream_cycle_clause=new RewriteRuleSubtreeStream(adaptor,"rule cycle_clause");

		try {
			// PLSQL_DMLParser.g:229:5: ( query_name ( LEFT_PAREN columns+= column_name ( COMMA columns+= column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? -> ^( FACTORING query_name ( $columns)* subquery ( order_by_clause )? ( search_clause )? ( cycle_clause )? ) )
			// PLSQL_DMLParser.g:229:10: query_name ( LEFT_PAREN columns+= column_name ( COMMA columns+= column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )?
			{
			pushFollow(FOLLOW_query_name_in_factoring_element1001);
			query_name24=gPLSQLParser.query_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_query_name.add(query_name24.getTree());
			// PLSQL_DMLParser.g:230:10: ( LEFT_PAREN columns+= column_name ( COMMA columns+= column_name )* RIGHT_PAREN )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==LEFT_PAREN) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// PLSQL_DMLParser.g:230:11: LEFT_PAREN columns+= column_name ( COMMA columns+= column_name )* RIGHT_PAREN
					{
					LEFT_PAREN25=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_factoring_element1013); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN25);

					pushFollow(FOLLOW_column_name_in_factoring_element1017);
					columns=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(columns.getTree());
					if (list_columns==null) list_columns=new ArrayList<Object>();
					list_columns.add(columns.getTree());
					// PLSQL_DMLParser.g:230:43: ( COMMA columns+= column_name )*
					loop11:
					while (true) {
						int alt11=2;
						int LA11_0 = input.LA(1);
						if ( (LA11_0==COMMA) ) {
							alt11=1;
						}

						switch (alt11) {
						case 1 :
							// PLSQL_DMLParser.g:230:44: COMMA columns+= column_name
							{
							COMMA26=(Token)match(input,COMMA,FOLLOW_COMMA_in_factoring_element1020); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA26);

							pushFollow(FOLLOW_column_name_in_factoring_element1024);
							columns=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(columns.getTree());
							if (list_columns==null) list_columns=new ArrayList<Object>();
							list_columns.add(columns.getTree());
							}
							break;

						default :
							break loop11;
						}
					}

					RIGHT_PAREN27=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_factoring_element1028); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN27);

					}
					break;

			}

			pushFollow(FOLLOW_as_key_in_factoring_element1041);
			as_key28=gPLSQLParser.as_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_as_key.add(as_key28.getTree());
			LEFT_PAREN29=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_factoring_element1043); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN29);

			pushFollow(FOLLOW_subquery_in_factoring_element1045);
			subquery30=subquery();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subquery.add(subquery30.getTree());
			// PLSQL_DMLParser.g:231:37: ( order_by_clause )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==SQL92_RESERVED_ORDER) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// PLSQL_DMLParser.g:231:37: order_by_clause
					{
					pushFollow(FOLLOW_order_by_clause_in_factoring_element1047);
					order_by_clause31=order_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_order_by_clause.add(order_by_clause31.getTree());
					}
					break;

			}

			RIGHT_PAREN32=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_factoring_element1050); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN32);

			// PLSQL_DMLParser.g:232:10: ( search_clause )?
			int alt14=2;
			int LA14_0 = input.LA(1);
			if ( (LA14_0==REGULAR_ID) ) {
				int LA14_1 = input.LA(2);
				if ( (LA14_1==REGULAR_ID) ) {
					int LA14_3 = input.LA(3);
					if ( (LA14_3==REGULAR_ID) ) {
						int LA14_4 = input.LA(4);
						if ( (LA14_4==SQL92_RESERVED_BY) ) {
							alt14=1;
						}
					}
				}
			}
			switch (alt14) {
				case 1 :
					// PLSQL_DMLParser.g:232:10: search_clause
					{
					pushFollow(FOLLOW_search_clause_in_factoring_element1061);
					search_clause33=search_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_search_clause.add(search_clause33.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:233:10: ( cycle_clause )?
			int alt15=2;
			int LA15_0 = input.LA(1);
			if ( (LA15_0==REGULAR_ID) ) {
				alt15=1;
			}
			switch (alt15) {
				case 1 :
					// PLSQL_DMLParser.g:233:10: cycle_clause
					{
					pushFollow(FOLLOW_cycle_clause_in_factoring_element1073);
					cycle_clause34=cycle_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cycle_clause.add(cycle_clause34.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: columns, query_name, cycle_clause, subquery, search_clause, order_by_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: columns
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_columns=new RewriteRuleSubtreeStream(adaptor,"token columns",list_columns);
			root_0 = (Object)adaptor.nil();
			// 234:9: -> ^( FACTORING query_name ( $columns)* subquery ( order_by_clause )? ( search_clause )? ( cycle_clause )? )
			{
				// PLSQL_DMLParser.g:234:12: ^( FACTORING query_name ( $columns)* subquery ( order_by_clause )? ( search_clause )? ( cycle_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FACTORING, "FACTORING"), root_1);
				adaptor.addChild(root_1, stream_query_name.nextTree());
				// PLSQL_DMLParser.g:234:36: ( $columns)*
				while ( stream_columns.hasNext() ) {
					adaptor.addChild(root_1, stream_columns.nextTree());
				}
				stream_columns.reset();

				adaptor.addChild(root_1, stream_subquery.nextTree());
				// PLSQL_DMLParser.g:234:54: ( order_by_clause )?
				if ( stream_order_by_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_order_by_clause.nextTree());
				}
				stream_order_by_clause.reset();

				// PLSQL_DMLParser.g:234:71: ( search_clause )?
				if ( stream_search_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_search_clause.nextTree());
				}
				stream_search_clause.reset();

				// PLSQL_DMLParser.g:234:86: ( cycle_clause )?
				if ( stream_cycle_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_cycle_clause.nextTree());
				}
				stream_cycle_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "factoring_element"


	public static class search_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "search_clause"
	// PLSQL_DMLParser.g:237:1: search_clause : search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA ! column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name ;
	public final PLSQLParser_PLSQL_DMLParser.search_clause_return search_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.search_clause_return retval = new PLSQLParser_PLSQL_DMLParser.search_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA47=null;
		ParserRuleReturnScope search_key35 =null;
		ParserRuleReturnScope depth_key36 =null;
		ParserRuleReturnScope breadth_key37 =null;
		ParserRuleReturnScope first_key38 =null;
		ParserRuleReturnScope by_key39 =null;
		ParserRuleReturnScope column_name40 =null;
		ParserRuleReturnScope asc_key41 =null;
		ParserRuleReturnScope desc_key42 =null;
		ParserRuleReturnScope nulls_key43 =null;
		ParserRuleReturnScope first_key44 =null;
		ParserRuleReturnScope nulls_key45 =null;
		ParserRuleReturnScope last_key46 =null;
		ParserRuleReturnScope column_name48 =null;
		ParserRuleReturnScope asc_key49 =null;
		ParserRuleReturnScope desc_key50 =null;
		ParserRuleReturnScope nulls_key51 =null;
		ParserRuleReturnScope first_key52 =null;
		ParserRuleReturnScope nulls_key53 =null;
		ParserRuleReturnScope last_key54 =null;
		ParserRuleReturnScope set_key55 =null;
		ParserRuleReturnScope column_name56 =null;

		Object COMMA47_tree=null;

		try {
			// PLSQL_DMLParser.g:238:5: ( search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA ! column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name )
			// PLSQL_DMLParser.g:238:10: search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA ! column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_search_key_in_search_clause1125);
			search_key35=gPLSQLParser.search_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, search_key35.getTree());

			// PLSQL_DMLParser.g:238:21: ( depth_key | breadth_key )
			int alt16=2;
			int LA16_0 = input.LA(1);
			if ( (LA16_0==REGULAR_ID) ) {
				int LA16_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("depth"))) ) {
					alt16=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("breadth"))) ) {
					alt16=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 16, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 16, 0, input);
				throw nvae;
			}

			switch (alt16) {
				case 1 :
					// PLSQL_DMLParser.g:238:23: depth_key
					{
					pushFollow(FOLLOW_depth_key_in_search_clause1129);
					depth_key36=gPLSQLParser.depth_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, depth_key36.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:238:35: breadth_key
					{
					pushFollow(FOLLOW_breadth_key_in_search_clause1133);
					breadth_key37=gPLSQLParser.breadth_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, breadth_key37.getTree());

					}
					break;

			}

			pushFollow(FOLLOW_first_key_in_search_clause1137);
			first_key38=gPLSQLParser.first_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, first_key38.getTree());

			pushFollow(FOLLOW_by_key_in_search_clause1139);
			by_key39=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, by_key39.getTree());

			pushFollow(FOLLOW_column_name_in_search_clause1154);
			column_name40=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name40.getTree());

			// PLSQL_DMLParser.g:239:26: ( asc_key )?
			int alt17=2;
			int LA17_0 = input.LA(1);
			if ( (LA17_0==SQL92_RESERVED_ASC) ) {
				alt17=1;
			}
			switch (alt17) {
				case 1 :
					// PLSQL_DMLParser.g:239:26: asc_key
					{
					pushFollow(FOLLOW_asc_key_in_search_clause1156);
					asc_key41=gPLSQLParser.asc_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, asc_key41.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:239:36: ( desc_key )?
			int alt18=2;
			int LA18_0 = input.LA(1);
			if ( (LA18_0==SQL92_RESERVED_DESC) ) {
				alt18=1;
			}
			switch (alt18) {
				case 1 :
					// PLSQL_DMLParser.g:239:36: desc_key
					{
					pushFollow(FOLLOW_desc_key_in_search_clause1160);
					desc_key42=gPLSQLParser.desc_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, desc_key42.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:239:47: ( nulls_key first_key )?
			int alt19=2;
			int LA19_0 = input.LA(1);
			if ( (LA19_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {
				int LA19_1 = input.LA(2);
				if ( (LA19_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {
					int LA19_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("nulls"))) ) {
						alt19=1;
					}
				}
			}
			switch (alt19) {
				case 1 :
					// PLSQL_DMLParser.g:239:48: nulls_key first_key
					{
					pushFollow(FOLLOW_nulls_key_in_search_clause1165);
					nulls_key43=gPLSQLParser.nulls_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nulls_key43.getTree());

					pushFollow(FOLLOW_first_key_in_search_clause1167);
					first_key44=gPLSQLParser.first_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, first_key44.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:239:70: ( nulls_key last_key )?
			int alt20=2;
			alt20 = dfa20.predict(input);
			switch (alt20) {
				case 1 :
					// PLSQL_DMLParser.g:239:71: nulls_key last_key
					{
					pushFollow(FOLLOW_nulls_key_in_search_clause1172);
					nulls_key45=gPLSQLParser.nulls_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nulls_key45.getTree());

					pushFollow(FOLLOW_last_key_in_search_clause1174);
					last_key46=gPLSQLParser.last_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, last_key46.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:240:14: ( COMMA ! column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )*
			loop25:
			while (true) {
				int alt25=2;
				int LA25_0 = input.LA(1);
				if ( (LA25_0==COMMA) ) {
					alt25=1;
				}

				switch (alt25) {
				case 1 :
					// PLSQL_DMLParser.g:240:15: COMMA ! column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )?
					{
					COMMA47=(Token)match(input,COMMA,FOLLOW_COMMA_in_search_clause1192); if (state.failed) return retval;
					pushFollow(FOLLOW_column_name_in_search_clause1195);
					column_name48=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name48.getTree());

					// PLSQL_DMLParser.g:240:34: ( asc_key )?
					int alt21=2;
					int LA21_0 = input.LA(1);
					if ( (LA21_0==SQL92_RESERVED_ASC) ) {
						alt21=1;
					}
					switch (alt21) {
						case 1 :
							// PLSQL_DMLParser.g:240:34: asc_key
							{
							pushFollow(FOLLOW_asc_key_in_search_clause1197);
							asc_key49=gPLSQLParser.asc_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, asc_key49.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:240:44: ( desc_key )?
					int alt22=2;
					int LA22_0 = input.LA(1);
					if ( (LA22_0==SQL92_RESERVED_DESC) ) {
						alt22=1;
					}
					switch (alt22) {
						case 1 :
							// PLSQL_DMLParser.g:240:44: desc_key
							{
							pushFollow(FOLLOW_desc_key_in_search_clause1201);
							desc_key50=gPLSQLParser.desc_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, desc_key50.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:240:55: ( nulls_key first_key )?
					int alt23=2;
					int LA23_0 = input.LA(1);
					if ( (LA23_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {
						int LA23_1 = input.LA(2);
						if ( (LA23_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {
							int LA23_3 = input.LA(3);
							if ( ((input.LT(1).getText().equalsIgnoreCase("nulls"))) ) {
								alt23=1;
							}
						}
					}
					switch (alt23) {
						case 1 :
							// PLSQL_DMLParser.g:240:56: nulls_key first_key
							{
							pushFollow(FOLLOW_nulls_key_in_search_clause1206);
							nulls_key51=gPLSQLParser.nulls_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, nulls_key51.getTree());

							pushFollow(FOLLOW_first_key_in_search_clause1208);
							first_key52=gPLSQLParser.first_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, first_key52.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:240:78: ( nulls_key last_key )?
					int alt24=2;
					alt24 = dfa24.predict(input);
					switch (alt24) {
						case 1 :
							// PLSQL_DMLParser.g:240:79: nulls_key last_key
							{
							pushFollow(FOLLOW_nulls_key_in_search_clause1213);
							nulls_key53=gPLSQLParser.nulls_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, nulls_key53.getTree());

							pushFollow(FOLLOW_last_key_in_search_clause1215);
							last_key54=gPLSQLParser.last_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, last_key54.getTree());

							}
							break;

					}

					}
					break;

				default :
					break loop25;
				}
			}

			pushFollow(FOLLOW_set_key_in_search_clause1235);
			set_key55=gPLSQLParser.set_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, set_key55.getTree());

			pushFollow(FOLLOW_column_name_in_search_clause1237);
			column_name56=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name56.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "search_clause"


	public static class cycle_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cycle_clause"
	// PLSQL_DMLParser.g:244:1: cycle_clause : cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression ;
	public final PLSQLParser_PLSQL_DMLParser.cycle_clause_return cycle_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.cycle_clause_return retval = new PLSQLParser_PLSQL_DMLParser.cycle_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA59=null;
		ParserRuleReturnScope cycle_key57 =null;
		ParserRuleReturnScope column_name58 =null;
		ParserRuleReturnScope column_name60 =null;
		ParserRuleReturnScope set_key61 =null;
		ParserRuleReturnScope column_name62 =null;
		ParserRuleReturnScope to_key63 =null;
		ParserRuleReturnScope expression64 =null;
		ParserRuleReturnScope default_key65 =null;
		ParserRuleReturnScope expression66 =null;

		Object COMMA59_tree=null;

		try {
			// PLSQL_DMLParser.g:245:5: ( cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression )
			// PLSQL_DMLParser.g:245:10: cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_cycle_key_in_cycle_clause1257);
			cycle_key57=gPLSQLParser.cycle_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, cycle_key57.getTree());

			pushFollow(FOLLOW_column_name_in_cycle_clause1259);
			column_name58=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name58.getTree());

			// PLSQL_DMLParser.g:245:32: ( COMMA column_name )*
			loop26:
			while (true) {
				int alt26=2;
				int LA26_0 = input.LA(1);
				if ( (LA26_0==COMMA) ) {
					alt26=1;
				}

				switch (alt26) {
				case 1 :
					// PLSQL_DMLParser.g:245:34: COMMA column_name
					{
					COMMA59=(Token)match(input,COMMA,FOLLOW_COMMA_in_cycle_clause1263); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					COMMA59_tree = (Object)adaptor.create(COMMA59);
					adaptor.addChild(root_0, COMMA59_tree);
					}

					pushFollow(FOLLOW_column_name_in_cycle_clause1265);
					column_name60=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name60.getTree());

					}
					break;

				default :
					break loop26;
				}
			}

			pushFollow(FOLLOW_set_key_in_cycle_clause1269);
			set_key61=gPLSQLParser.set_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, set_key61.getTree());

			pushFollow(FOLLOW_column_name_in_cycle_clause1271);
			column_name62=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name62.getTree());

			pushFollow(FOLLOW_to_key_in_cycle_clause1273);
			to_key63=gPLSQLParser.to_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, to_key63.getTree());

			pushFollow(FOLLOW_expression_in_cycle_clause1275);
			expression64=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression64.getTree());

			pushFollow(FOLLOW_default_key_in_cycle_clause1277);
			default_key65=gPLSQLParser.default_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, default_key65.getTree());

			pushFollow(FOLLOW_expression_in_cycle_clause1279);
			expression66=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression66.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cycle_clause"


	public static class subquery_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subquery"
	// PLSQL_DMLParser.g:248:1: subquery : subquery_basic_elements ( subquery_operation_part )* -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.subquery_return subquery() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.subquery_return retval = new PLSQLParser_PLSQL_DMLParser.subquery_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope subquery_basic_elements67 =null;
		ParserRuleReturnScope subquery_operation_part68 =null;

		RewriteRuleSubtreeStream stream_subquery_basic_elements=new RewriteRuleSubtreeStream(adaptor,"rule subquery_basic_elements");
		RewriteRuleSubtreeStream stream_subquery_operation_part=new RewriteRuleSubtreeStream(adaptor,"rule subquery_operation_part");

		try {
			// PLSQL_DMLParser.g:249:5: ( subquery_basic_elements ( subquery_operation_part )* -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* ) )
			// PLSQL_DMLParser.g:249:10: subquery_basic_elements ( subquery_operation_part )*
			{
			pushFollow(FOLLOW_subquery_basic_elements_in_subquery1299);
			subquery_basic_elements67=subquery_basic_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_subquery_basic_elements.add(subquery_basic_elements67.getTree());
			// PLSQL_DMLParser.g:249:34: ( subquery_operation_part )*
			loop27:
			while (true) {
				int alt27=2;
				int LA27_0 = input.LA(1);
				if ( (LA27_0==PLSQL_RESERVED_MINUS||LA27_0==SQL92_RESERVED_INTERSECT||LA27_0==SQL92_RESERVED_UNION) ) {
					alt27=1;
				}

				switch (alt27) {
				case 1 :
					// PLSQL_DMLParser.g:249:34: subquery_operation_part
					{
					pushFollow(FOLLOW_subquery_operation_part_in_subquery1301);
					subquery_operation_part68=subquery_operation_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery_operation_part.add(subquery_operation_part68.getTree());
					}
					break;

				default :
					break loop27;
				}
			}

			// AST REWRITE
			// elements: subquery_basic_elements, subquery_operation_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 250:9: -> ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* )
			{
				// PLSQL_DMLParser.g:250:12: ^( SUBQUERY subquery_basic_elements ( subquery_operation_part )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SUBQUERY, "SUBQUERY"), root_1);
				adaptor.addChild(root_1, stream_subquery_basic_elements.nextTree());
				// PLSQL_DMLParser.g:250:47: ( subquery_operation_part )*
				while ( stream_subquery_operation_part.hasNext() ) {
					adaptor.addChild(root_1, stream_subquery_operation_part.nextTree());
				}
				stream_subquery_operation_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subquery"


	public static class subquery_operation_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subquery_operation_part"
	// PLSQL_DMLParser.g:253:1: subquery_operation_part : ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements ;
	public final PLSQLParser_PLSQL_DMLParser.subquery_operation_part_return subquery_operation_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.subquery_operation_part_return retval = new PLSQLParser_PLSQL_DMLParser.subquery_operation_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope union_key69 =null;
		ParserRuleReturnScope all_key70 =null;
		ParserRuleReturnScope intersect_key71 =null;
		ParserRuleReturnScope minus_key72 =null;
		ParserRuleReturnScope subquery_basic_elements73 =null;


		try {
			// PLSQL_DMLParser.g:254:5: ( ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements )
			// PLSQL_DMLParser.g:254:10: ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^) subquery_basic_elements
			{
			root_0 = (Object)adaptor.nil();


			// PLSQL_DMLParser.g:254:10: ( union_key ^ ( all_key )? | intersect_key ^| minus_key ^)
			int alt29=3;
			switch ( input.LA(1) ) {
			case SQL92_RESERVED_UNION:
				{
				alt29=1;
				}
				break;
			case SQL92_RESERVED_INTERSECT:
				{
				alt29=2;
				}
				break;
			case PLSQL_RESERVED_MINUS:
				{
				alt29=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 29, 0, input);
				throw nvae;
			}
			switch (alt29) {
				case 1 :
					// PLSQL_DMLParser.g:254:11: union_key ^ ( all_key )?
					{
					pushFollow(FOLLOW_union_key_in_subquery_operation_part1342);
					union_key69=gPLSQLParser.union_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(union_key69.getTree(), root_0);
					// PLSQL_DMLParser.g:254:22: ( all_key )?
					int alt28=2;
					int LA28_0 = input.LA(1);
					if ( (LA28_0==SQL92_RESERVED_ALL) ) {
						alt28=1;
					}
					switch (alt28) {
						case 1 :
							// PLSQL_DMLParser.g:254:22: all_key
							{
							pushFollow(FOLLOW_all_key_in_subquery_operation_part1345);
							all_key70=gPLSQLParser.all_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, all_key70.getTree());

							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:254:31: intersect_key ^
					{
					pushFollow(FOLLOW_intersect_key_in_subquery_operation_part1348);
					intersect_key71=gPLSQLParser.intersect_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(intersect_key71.getTree(), root_0);
					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:254:46: minus_key ^
					{
					pushFollow(FOLLOW_minus_key_in_subquery_operation_part1351);
					minus_key72=gPLSQLParser.minus_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(minus_key72.getTree(), root_0);
					}
					break;

			}

			pushFollow(FOLLOW_subquery_basic_elements_in_subquery_operation_part1355);
			subquery_basic_elements73=subquery_basic_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery_basic_elements73.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subquery_operation_part"


	public static class subquery_basic_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subquery_basic_elements"
	// PLSQL_DMLParser.g:257:1: subquery_basic_elements : ( query_block | LEFT_PAREN ! subquery RIGHT_PAREN !);
	public final PLSQLParser_PLSQL_DMLParser.subquery_basic_elements_return subquery_basic_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.subquery_basic_elements_return retval = new PLSQLParser_PLSQL_DMLParser.subquery_basic_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN75=null;
		Token RIGHT_PAREN77=null;
		ParserRuleReturnScope query_block74 =null;
		ParserRuleReturnScope subquery76 =null;

		Object LEFT_PAREN75_tree=null;
		Object RIGHT_PAREN77_tree=null;

		try {
			// PLSQL_DMLParser.g:258:5: ( query_block | LEFT_PAREN ! subquery RIGHT_PAREN !)
			int alt30=2;
			int LA30_0 = input.LA(1);
			if ( (LA30_0==SQL92_RESERVED_SELECT) ) {
				alt30=1;
			}
			else if ( (LA30_0==LEFT_PAREN) ) {
				alt30=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 30, 0, input);
				throw nvae;
			}

			switch (alt30) {
				case 1 :
					// PLSQL_DMLParser.g:258:10: query_block
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_query_block_in_subquery_basic_elements1375);
					query_block74=query_block();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, query_block74.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:259:10: LEFT_PAREN ! subquery RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					LEFT_PAREN75=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_subquery_basic_elements1386); if (state.failed) return retval;
					pushFollow(FOLLOW_subquery_in_subquery_basic_elements1389);
					subquery76=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery76.getTree());

					RIGHT_PAREN77=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1391); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subquery_basic_elements"


	public static class query_block_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "query_block"
	// PLSQL_DMLParser.g:262:1: query_block : select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? -> {mode == 1}? ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) -> ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ^( SELECT_LIST ( selected_element )+ ) ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.query_block_return query_block() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.query_block_return retval = new PLSQLParser_PLSQL_DMLParser.query_block_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASTERISK82=null;
		Token COMMA84=null;
		ParserRuleReturnScope select_key78 =null;
		ParserRuleReturnScope distinct_key79 =null;
		ParserRuleReturnScope unique_key80 =null;
		ParserRuleReturnScope all_key81 =null;
		ParserRuleReturnScope selected_element83 =null;
		ParserRuleReturnScope selected_element85 =null;
		ParserRuleReturnScope into_clause86 =null;
		ParserRuleReturnScope from_clause87 =null;
		ParserRuleReturnScope where_clause88 =null;
		ParserRuleReturnScope hierarchical_query_clause89 =null;
		ParserRuleReturnScope group_by_clause90 =null;
		ParserRuleReturnScope model_clause91 =null;

		Object ASTERISK82_tree=null;
		Object COMMA84_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_ASTERISK=new RewriteRuleTokenStream(adaptor,"token ASTERISK");
		RewriteRuleSubtreeStream stream_where_clause=new RewriteRuleSubtreeStream(adaptor,"rule where_clause");
		RewriteRuleSubtreeStream stream_hierarchical_query_clause=new RewriteRuleSubtreeStream(adaptor,"rule hierarchical_query_clause");
		RewriteRuleSubtreeStream stream_distinct_key=new RewriteRuleSubtreeStream(adaptor,"rule distinct_key");
		RewriteRuleSubtreeStream stream_unique_key=new RewriteRuleSubtreeStream(adaptor,"rule unique_key");
		RewriteRuleSubtreeStream stream_all_key=new RewriteRuleSubtreeStream(adaptor,"rule all_key");
		RewriteRuleSubtreeStream stream_from_clause=new RewriteRuleSubtreeStream(adaptor,"rule from_clause");
		RewriteRuleSubtreeStream stream_group_by_clause=new RewriteRuleSubtreeStream(adaptor,"rule group_by_clause");
		RewriteRuleSubtreeStream stream_select_key=new RewriteRuleSubtreeStream(adaptor,"rule select_key");
		RewriteRuleSubtreeStream stream_selected_element=new RewriteRuleSubtreeStream(adaptor,"rule selected_element");
		RewriteRuleSubtreeStream stream_into_clause=new RewriteRuleSubtreeStream(adaptor,"rule into_clause");
		RewriteRuleSubtreeStream stream_model_clause=new RewriteRuleSubtreeStream(adaptor,"rule model_clause");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:264:5: ( select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? -> {mode == 1}? ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) -> ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ^( SELECT_LIST ( selected_element )+ ) ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ) )
			// PLSQL_DMLParser.g:264:10: select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )?
			{
			pushFollow(FOLLOW_select_key_in_query_block1420);
			select_key78=gPLSQLParser.select_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_select_key.add(select_key78.getTree());
			// PLSQL_DMLParser.g:265:9: ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )?
			int alt32=2;
			int LA32_0 = input.LA(1);
			if ( (LA32_0==SQL92_RESERVED_DISTINCT) ) {
				int LA32_1 = input.LA(2);
				if ( (synpred1_PLSQL_DMLParser()) ) {
					alt32=1;
				}
			}
			else if ( (LA32_0==SQL92_RESERVED_UNIQUE) && (synpred1_PLSQL_DMLParser())) {
				alt32=1;
			}
			else if ( (LA32_0==SQL92_RESERVED_ALL) ) {
				int LA32_3 = input.LA(2);
				if ( (synpred1_PLSQL_DMLParser()) ) {
					alt32=1;
				}
			}
			switch (alt32) {
				case 1 :
					// PLSQL_DMLParser.g:265:10: ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key )
					{
					// PLSQL_DMLParser.g:265:46: ( distinct_key | unique_key | all_key )
					int alt31=3;
					switch ( input.LA(1) ) {
					case SQL92_RESERVED_DISTINCT:
						{
						alt31=1;
						}
						break;
					case SQL92_RESERVED_UNIQUE:
						{
						alt31=2;
						}
						break;
					case SQL92_RESERVED_ALL:
						{
						alt31=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 31, 0, input);
						throw nvae;
					}
					switch (alt31) {
						case 1 :
							// PLSQL_DMLParser.g:265:47: distinct_key
							{
							pushFollow(FOLLOW_distinct_key_in_query_block1441);
							distinct_key79=gPLSQLParser.distinct_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_distinct_key.add(distinct_key79.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:265:60: unique_key
							{
							pushFollow(FOLLOW_unique_key_in_query_block1443);
							unique_key80=gPLSQLParser.unique_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_unique_key.add(unique_key80.getTree());
							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:265:71: all_key
							{
							pushFollow(FOLLOW_all_key_in_query_block1445);
							all_key81=gPLSQLParser.all_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_all_key.add(all_key81.getTree());
							}
							break;

					}

					}
					break;

			}

			// PLSQL_DMLParser.g:266:9: ( ASTERISK | selected_element ( COMMA selected_element )* )
			int alt34=2;
			int LA34_0 = input.LA(1);
			if ( (LA34_0==ASTERISK) ) {
				alt34=1;
			}
			else if ( (LA34_0==APPROXIMATE_NUM_LIT||LA34_0==BINDVAR||(LA34_0 >= CHAR_STRING && LA34_0 <= COLON)||LA34_0==DELIMITED_ID||LA34_0==EXACT_NUM_LIT||LA34_0==INTRODUCER||LA34_0==LEFT_PAREN||LA34_0==MINUS_SIGN||LA34_0==NATIONAL_CHAR_STRING_LIT||LA34_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA34_0==PLUS_SIGN||LA34_0==REGULAR_ID||LA34_0==SQL92_RESERVED_ALL||LA34_0==SQL92_RESERVED_ANY||LA34_0==SQL92_RESERVED_CASE||(LA34_0 >= SQL92_RESERVED_CURSOR && LA34_0 <= SQL92_RESERVED_DATE)||(LA34_0 >= SQL92_RESERVED_DEFAULT && LA34_0 <= SQL92_RESERVED_DELETE)||LA34_0==SQL92_RESERVED_DISTINCT||(LA34_0 >= SQL92_RESERVED_EXISTS && LA34_0 <= SQL92_RESERVED_FALSE)||(LA34_0 >= SQL92_RESERVED_NOT && LA34_0 <= SQL92_RESERVED_NULL)||LA34_0==SQL92_RESERVED_PRIOR||LA34_0==SQL92_RESERVED_TRUE||LA34_0==UNSIGNED_INTEGER) ) {
				alt34=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 34, 0, input);
				throw nvae;
			}

			switch (alt34) {
				case 1 :
					// PLSQL_DMLParser.g:266:10: ASTERISK
					{
					ASTERISK82=(Token)match(input,ASTERISK,FOLLOW_ASTERISK_in_query_block1459); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASTERISK.add(ASTERISK82);

					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:266:32: selected_element ( COMMA selected_element )*
					{
					pushFollow(FOLLOW_selected_element_in_query_block1464);
					selected_element83=selected_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_selected_element.add(selected_element83.getTree());
					// PLSQL_DMLParser.g:266:49: ( COMMA selected_element )*
					loop33:
					while (true) {
						int alt33=2;
						int LA33_0 = input.LA(1);
						if ( (LA33_0==COMMA) ) {
							alt33=1;
						}

						switch (alt33) {
						case 1 :
							// PLSQL_DMLParser.g:266:50: COMMA selected_element
							{
							COMMA84=(Token)match(input,COMMA,FOLLOW_COMMA_in_query_block1467); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA84);

							pushFollow(FOLLOW_selected_element_in_query_block1469);
							selected_element85=selected_element();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_selected_element.add(selected_element85.getTree());
							}
							break;

						default :
							break loop33;
						}
					}

					}
					break;

			}

			// PLSQL_DMLParser.g:267:9: ( into_clause )?
			int alt35=2;
			int LA35_0 = input.LA(1);
			if ( (LA35_0==SQL92_RESERVED_INTO) ) {
				alt35=1;
			}
			else if ( (LA35_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("bulk")))) {
				alt35=1;
			}
			switch (alt35) {
				case 1 :
					// PLSQL_DMLParser.g:267:9: into_clause
					{
					pushFollow(FOLLOW_into_clause_in_query_block1482);
					into_clause86=gPLSQLParser.into_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_into_clause.add(into_clause86.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_from_clause_in_query_block1493);
			from_clause87=from_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_from_clause.add(from_clause87.getTree());
			// PLSQL_DMLParser.g:269:9: ( where_clause )?
			int alt36=2;
			int LA36_0 = input.LA(1);
			if ( (LA36_0==SQL92_RESERVED_WHERE) ) {
				alt36=1;
			}
			switch (alt36) {
				case 1 :
					// PLSQL_DMLParser.g:269:9: where_clause
					{
					pushFollow(FOLLOW_where_clause_in_query_block1504);
					where_clause88=gPLSQLParser.where_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_where_clause.add(where_clause88.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:270:9: ( hierarchical_query_clause )?
			int alt37=2;
			int LA37_0 = input.LA(1);
			if ( (LA37_0==SQL92_RESERVED_CONNECT) ) {
				alt37=1;
			}
			else if ( (LA37_0==PLSQL_RESERVED_START) ) {
				alt37=1;
			}
			switch (alt37) {
				case 1 :
					// PLSQL_DMLParser.g:270:9: hierarchical_query_clause
					{
					pushFollow(FOLLOW_hierarchical_query_clause_in_query_block1516);
					hierarchical_query_clause89=hierarchical_query_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_hierarchical_query_clause.add(hierarchical_query_clause89.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:271:9: ( group_by_clause )?
			int alt38=2;
			int LA38_0 = input.LA(1);
			if ( (LA38_0==SQL92_RESERVED_GROUP) ) {
				alt38=1;
			}
			else if ( (LA38_0==SQL92_RESERVED_HAVING) ) {
				alt38=1;
			}
			switch (alt38) {
				case 1 :
					// PLSQL_DMLParser.g:271:9: group_by_clause
					{
					pushFollow(FOLLOW_group_by_clause_in_query_block1528);
					group_by_clause90=group_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_group_by_clause.add(group_by_clause90.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:272:9: ( model_clause )?
			int alt39=2;
			int LA39_0 = input.LA(1);
			if ( (LA39_0==PLSQL_NON_RESERVED_MODEL) ) {
				alt39=1;
			}
			switch (alt39) {
				case 1 :
					// PLSQL_DMLParser.g:272:9: model_clause
					{
					pushFollow(FOLLOW_model_clause_in_query_block1539);
					model_clause91=model_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_clause.add(model_clause91.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: all_key, unique_key, hierarchical_query_clause, group_by_clause, into_clause, selected_element, where_clause, distinct_key, where_clause, ASTERISK, from_clause, from_clause, into_clause, select_key, hierarchical_query_clause, model_clause, distinct_key, all_key, group_by_clause, model_clause, select_key, unique_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 273:9: -> {mode == 1}? ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
			if (mode == 1) {
				// PLSQL_DMLParser.g:273:25: ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ASTERISK ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_select_key.nextNode(), root_1);
				adaptor.addChild(root_1, stream_from_clause.nextTree());
				// PLSQL_DMLParser.g:273:50: ( distinct_key )?
				if ( stream_distinct_key.hasNext() ) {
					adaptor.addChild(root_1, stream_distinct_key.nextTree());
				}
				stream_distinct_key.reset();

				// PLSQL_DMLParser.g:273:64: ( unique_key )?
				if ( stream_unique_key.hasNext() ) {
					adaptor.addChild(root_1, stream_unique_key.nextTree());
				}
				stream_unique_key.reset();

				// PLSQL_DMLParser.g:273:76: ( all_key )?
				if ( stream_all_key.hasNext() ) {
					adaptor.addChild(root_1, stream_all_key.nextTree());
				}
				stream_all_key.reset();

				adaptor.addChild(root_1, stream_ASTERISK.nextNode());
				// PLSQL_DMLParser.g:274:17: ( into_clause )?
				if ( stream_into_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_into_clause.nextTree());
				}
				stream_into_clause.reset();

				// PLSQL_DMLParser.g:274:30: ( where_clause )?
				if ( stream_where_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_where_clause.nextTree());
				}
				stream_where_clause.reset();

				// PLSQL_DMLParser.g:274:44: ( hierarchical_query_clause )?
				if ( stream_hierarchical_query_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_hierarchical_query_clause.nextTree());
				}
				stream_hierarchical_query_clause.reset();

				// PLSQL_DMLParser.g:274:71: ( group_by_clause )?
				if ( stream_group_by_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_group_by_clause.nextTree());
				}
				stream_group_by_clause.reset();

				// PLSQL_DMLParser.g:274:88: ( model_clause )?
				if ( stream_model_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_model_clause.nextTree());
				}
				stream_model_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 275:9: -> ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ^( SELECT_LIST ( selected_element )+ ) ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
			{
				// PLSQL_DMLParser.g:275:12: ^( select_key from_clause ( distinct_key )? ( unique_key )? ( all_key )? ^( SELECT_LIST ( selected_element )+ ) ( into_clause )? ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_select_key.nextNode(), root_1);
				adaptor.addChild(root_1, stream_from_clause.nextTree());
				// PLSQL_DMLParser.g:275:37: ( distinct_key )?
				if ( stream_distinct_key.hasNext() ) {
					adaptor.addChild(root_1, stream_distinct_key.nextTree());
				}
				stream_distinct_key.reset();

				// PLSQL_DMLParser.g:275:51: ( unique_key )?
				if ( stream_unique_key.hasNext() ) {
					adaptor.addChild(root_1, stream_unique_key.nextTree());
				}
				stream_unique_key.reset();

				// PLSQL_DMLParser.g:275:63: ( all_key )?
				if ( stream_all_key.hasNext() ) {
					adaptor.addChild(root_1, stream_all_key.nextTree());
				}
				stream_all_key.reset();

				// PLSQL_DMLParser.g:275:72: ^( SELECT_LIST ( selected_element )+ )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_LIST, "SELECT_LIST"), root_2);
				if ( !(stream_selected_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_selected_element.hasNext() ) {
					adaptor.addChild(root_2, stream_selected_element.nextTree());
				}
				stream_selected_element.reset();

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:276:17: ( into_clause )?
				if ( stream_into_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_into_clause.nextTree());
				}
				stream_into_clause.reset();

				// PLSQL_DMLParser.g:276:30: ( where_clause )?
				if ( stream_where_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_where_clause.nextTree());
				}
				stream_where_clause.reset();

				// PLSQL_DMLParser.g:276:44: ( hierarchical_query_clause )?
				if ( stream_hierarchical_query_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_hierarchical_query_clause.nextTree());
				}
				stream_hierarchical_query_clause.reset();

				// PLSQL_DMLParser.g:276:71: ( group_by_clause )?
				if ( stream_group_by_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_group_by_clause.nextTree());
				}
				stream_group_by_clause.reset();

				// PLSQL_DMLParser.g:276:88: ( model_clause )?
				if ( stream_model_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_model_clause.nextTree());
				}
				stream_model_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "query_block"


	public static class selected_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "selected_element"
	// PLSQL_DMLParser.g:279:1: selected_element : select_list_elements ( column_alias )? -> ^( SELECT_ITEM select_list_elements ( column_alias )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.selected_element_return selected_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.selected_element_return retval = new PLSQLParser_PLSQL_DMLParser.selected_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope select_list_elements92 =null;
		ParserRuleReturnScope column_alias93 =null;

		RewriteRuleSubtreeStream stream_column_alias=new RewriteRuleSubtreeStream(adaptor,"rule column_alias");
		RewriteRuleSubtreeStream stream_select_list_elements=new RewriteRuleSubtreeStream(adaptor,"rule select_list_elements");

		try {
			// PLSQL_DMLParser.g:280:5: ( select_list_elements ( column_alias )? -> ^( SELECT_ITEM select_list_elements ( column_alias )? ) )
			// PLSQL_DMLParser.g:280:10: select_list_elements ( column_alias )?
			{
			pushFollow(FOLLOW_select_list_elements_in_selected_element1683);
			select_list_elements92=select_list_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_select_list_elements.add(select_list_elements92.getTree());
			// PLSQL_DMLParser.g:280:31: ( column_alias )?
			int alt40=2;
			int LA40_0 = input.LA(1);
			if ( ((LA40_0 >= CHAR_STRING && LA40_0 <= CHAR_STRING_PERL)||LA40_0==DELIMITED_ID||LA40_0==INTRODUCER||LA40_0==NATIONAL_CHAR_STRING_LIT||LA40_0==SQL92_RESERVED_AS) ) {
				alt40=1;
			}
			else if ( (LA40_0==REGULAR_ID) ) {
				int LA40_2 = input.LA(2);
				if ( (LA40_2==COMMA||LA40_2==SQL92_RESERVED_FROM||LA40_2==SQL92_RESERVED_INTO) ) {
					alt40=1;
				}
				else if ( (LA40_2==REGULAR_ID) ) {
					int LA40_4 = input.LA(3);
					if ( (LA40_4==REGULAR_ID) ) {
						alt40=1;
					}
				}
			}
			switch (alt40) {
				case 1 :
					// PLSQL_DMLParser.g:280:31: column_alias
					{
					pushFollow(FOLLOW_column_alias_in_selected_element1685);
					column_alias93=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_alias.add(column_alias93.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: select_list_elements, column_alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 281:9: -> ^( SELECT_ITEM select_list_elements ( column_alias )? )
			{
				// PLSQL_DMLParser.g:281:12: ^( SELECT_ITEM select_list_elements ( column_alias )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_ITEM, "SELECT_ITEM"), root_1);
				adaptor.addChild(root_1, stream_select_list_elements.nextTree());
				// PLSQL_DMLParser.g:281:47: ( column_alias )?
				if ( stream_column_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_column_alias.nextTree());
				}
				stream_column_alias.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "selected_element"


	public static class from_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "from_clause"
	// PLSQL_DMLParser.g:284:1: from_clause : from_key ^ table_ref_list ;
	public final PLSQLParser_PLSQL_DMLParser.from_clause_return from_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.from_clause_return retval = new PLSQLParser_PLSQL_DMLParser.from_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope from_key94 =null;
		ParserRuleReturnScope table_ref_list95 =null;


		try {
			// PLSQL_DMLParser.g:285:5: ( from_key ^ table_ref_list )
			// PLSQL_DMLParser.g:285:10: from_key ^ table_ref_list
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_from_key_in_from_clause1725);
			from_key94=gPLSQLParser.from_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(from_key94.getTree(), root_0);
			pushFollow(FOLLOW_table_ref_list_in_from_clause1728);
			table_ref_list95=table_ref_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, table_ref_list95.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "from_clause"


	public static class select_list_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "select_list_elements"
	// PLSQL_DMLParser.g:288:1: select_list_elements : ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) ) | expression -> ^( EXPR expression ) );
	public final PLSQLParser_PLSQL_DMLParser.select_list_elements_return select_list_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.select_list_elements_return retval = new PLSQLParser_PLSQL_DMLParser.select_list_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERIOD97=null;
		Token ASTERISK98=null;
		ParserRuleReturnScope tableview_name96 =null;
		ParserRuleReturnScope expression99 =null;

		Object PERIOD97_tree=null;
		Object ASTERISK98_tree=null;
		RewriteRuleTokenStream stream_PERIOD=new RewriteRuleTokenStream(adaptor,"token PERIOD");
		RewriteRuleTokenStream stream_ASTERISK=new RewriteRuleTokenStream(adaptor,"token ASTERISK");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:289:5: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) ) | expression -> ^( EXPR expression ) )
			int alt41=2;
			switch ( input.LA(1) ) {
			case INTRODUCER:
				{
				int LA41_1 = input.LA(2);
				if ( (synpred2_PLSQL_DMLParser()) ) {
					alt41=1;
				}
				else if ( (true) ) {
					alt41=2;
				}

				}
				break;
			case REGULAR_ID:
				{
				int LA41_2 = input.LA(2);
				if ( (synpred2_PLSQL_DMLParser()) ) {
					alt41=1;
				}
				else if ( (true) ) {
					alt41=2;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA41_3 = input.LA(2);
				if ( (synpred2_PLSQL_DMLParser()) ) {
					alt41=1;
				}
				else if ( (true) ) {
					alt41=2;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case BINDVAR:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case COLON:
			case EXACT_NUM_LIT:
			case LEFT_PAREN:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_CASE:
			case SQL92_RESERVED_CURSOR:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DELETE:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_EXISTS:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NOT:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_PRIOR:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt41=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 41, 0, input);
				throw nvae;
			}
			switch (alt41) {
				case 1 :
					// PLSQL_DMLParser.g:289:10: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
					{
					pushFollow(FOLLOW_tableview_name_in_select_list_elements1757);
					tableview_name96=gPLSQLParser.tableview_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name96.getTree());
					PERIOD97=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_select_list_elements1759); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PERIOD.add(PERIOD97);

					ASTERISK98=(Token)match(input,ASTERISK,FOLLOW_ASTERISK_in_select_list_elements1761); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_ASTERISK.add(ASTERISK98);

					// AST REWRITE
					// elements: tableview_name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 289:76: -> ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) )
					{
						// PLSQL_DMLParser.g:289:79: ^( EXPR ^( DOT_ASTERISK[$ASTERISK] tableview_name ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						// PLSQL_DMLParser.g:289:86: ^( DOT_ASTERISK[$ASTERISK] tableview_name )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(DOT_ASTERISK, ASTERISK98), root_2);
						adaptor.addChild(root_2, stream_tableview_name.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:290:10: expression
					{
					pushFollow(FOLLOW_expression_in_select_list_elements1787);
					expression99=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression99.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 290:21: -> ^( EXPR expression )
					{
						// PLSQL_DMLParser.g:290:24: ^( EXPR expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "select_list_elements"


	public static class table_ref_list_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "table_ref_list"
	// PLSQL_DMLParser.g:293:1: table_ref_list : table_ref ( COMMA ! table_ref )* ;
	public final PLSQLParser_PLSQL_DMLParser.table_ref_list_return table_ref_list() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.table_ref_list_return retval = new PLSQLParser_PLSQL_DMLParser.table_ref_list_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA101=null;
		ParserRuleReturnScope table_ref100 =null;
		ParserRuleReturnScope table_ref102 =null;

		Object COMMA101_tree=null;

		try {
			// PLSQL_DMLParser.g:294:5: ( table_ref ( COMMA ! table_ref )* )
			// PLSQL_DMLParser.g:294:10: table_ref ( COMMA ! table_ref )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_table_ref_in_table_ref_list1815);
			table_ref100=table_ref();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, table_ref100.getTree());

			// PLSQL_DMLParser.g:294:20: ( COMMA ! table_ref )*
			loop42:
			while (true) {
				int alt42=2;
				int LA42_0 = input.LA(1);
				if ( (LA42_0==COMMA) ) {
					alt42=1;
				}

				switch (alt42) {
				case 1 :
					// PLSQL_DMLParser.g:294:21: COMMA ! table_ref
					{
					COMMA101=(Token)match(input,COMMA,FOLLOW_COMMA_in_table_ref_list1818); if (state.failed) return retval;
					pushFollow(FOLLOW_table_ref_in_table_ref_list1821);
					table_ref102=table_ref();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, table_ref102.getTree());

					}
					break;

				default :
					break loop42;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "table_ref_list"


	public static class table_ref_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "table_ref"
	// PLSQL_DMLParser.g:301:1: table_ref : table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? -> ^( TABLE_REF table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.table_ref_return table_ref() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.table_ref_return retval = new PLSQLParser_PLSQL_DMLParser.table_ref_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope table_ref_aux103 =null;
		ParserRuleReturnScope join_clause104 =null;
		ParserRuleReturnScope pivot_clause105 =null;
		ParserRuleReturnScope unpivot_clause106 =null;

		RewriteRuleSubtreeStream stream_table_ref_aux=new RewriteRuleSubtreeStream(adaptor,"rule table_ref_aux");
		RewriteRuleSubtreeStream stream_join_clause=new RewriteRuleSubtreeStream(adaptor,"rule join_clause");
		RewriteRuleSubtreeStream stream_unpivot_clause=new RewriteRuleSubtreeStream(adaptor,"rule unpivot_clause");
		RewriteRuleSubtreeStream stream_pivot_clause=new RewriteRuleSubtreeStream(adaptor,"rule pivot_clause");

		try {
			// PLSQL_DMLParser.g:302:5: ( table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? -> ^( TABLE_REF table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? ) )
			// PLSQL_DMLParser.g:302:10: table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )?
			{
			pushFollow(FOLLOW_table_ref_aux_in_table_ref1847);
			table_ref_aux103=table_ref_aux();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_table_ref_aux.add(table_ref_aux103.getTree());
			// PLSQL_DMLParser.g:302:24: ( join_clause )*
			loop43:
			while (true) {
				int alt43=2;
				int LA43_0 = input.LA(1);
				if ( (LA43_0==REGULAR_ID) ) {
					int LA43_1 = input.LA(2);
					if ( (((input.LT(1).getText().equalsIgnoreCase("cross"))||(input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("natural"))||(input.LT(1).getText().equalsIgnoreCase("inner"))||(input.LT(1).getText().equalsIgnoreCase("full"))||(input.LT(1).getText().equalsIgnoreCase("join")))) ) {
						alt43=1;
					}

				}

				switch (alt43) {
				case 1 :
					// PLSQL_DMLParser.g:302:24: join_clause
					{
					pushFollow(FOLLOW_join_clause_in_table_ref1849);
					join_clause104=join_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_join_clause.add(join_clause104.getTree());
					}
					break;

				default :
					break loop43;
				}
			}

			// PLSQL_DMLParser.g:302:37: ( pivot_clause | unpivot_clause )?
			int alt44=3;
			int LA44_0 = input.LA(1);
			if ( (LA44_0==REGULAR_ID) ) {
				int LA44_1 = input.LA(2);
				if ( (((input.LT(1).getText().equalsIgnoreCase("pivot")))) ) {
					alt44=1;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("unpivot")))) ) {
					alt44=2;
				}
			}
			switch (alt44) {
				case 1 :
					// PLSQL_DMLParser.g:302:38: pivot_clause
					{
					pushFollow(FOLLOW_pivot_clause_in_table_ref1853);
					pivot_clause105=pivot_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_pivot_clause.add(pivot_clause105.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:302:51: unpivot_clause
					{
					pushFollow(FOLLOW_unpivot_clause_in_table_ref1855);
					unpivot_clause106=unpivot_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unpivot_clause.add(unpivot_clause106.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: table_ref_aux, join_clause, pivot_clause, unpivot_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 303:9: -> ^( TABLE_REF table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? )
			{
				// PLSQL_DMLParser.g:303:12: ^( TABLE_REF table_ref_aux ( join_clause )* ( pivot_clause )? ( unpivot_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_REF, "TABLE_REF"), root_1);
				adaptor.addChild(root_1, stream_table_ref_aux.nextTree());
				// PLSQL_DMLParser.g:303:38: ( join_clause )*
				while ( stream_join_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_join_clause.nextTree());
				}
				stream_join_clause.reset();

				// PLSQL_DMLParser.g:303:51: ( pivot_clause )?
				if ( stream_pivot_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_pivot_clause.nextTree());
				}
				stream_pivot_clause.reset();

				// PLSQL_DMLParser.g:303:65: ( unpivot_clause )?
				if ( stream_unpivot_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_unpivot_clause.nextTree());
				}
				stream_unpivot_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "table_ref"


	public static class table_ref_aux_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "table_ref_aux"
	// PLSQL_DMLParser.g:306:1: table_ref_aux : ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( options {k=1; } : pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT ( table_alias )? ( dml_table_expression_clause )? ( table_ref )? ( subquery_operation_part )* ( only_key )? ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.table_ref_aux_return table_ref_aux() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.table_ref_aux_return retval = new PLSQLParser_PLSQL_DMLParser.table_ref_aux_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN110=null;
		Token RIGHT_PAREN113=null;
		Token LEFT_PAREN117=null;
		Token RIGHT_PAREN119=null;
		ParserRuleReturnScope dml_table_expression_clause107 =null;
		ParserRuleReturnScope pivot_clause108 =null;
		ParserRuleReturnScope unpivot_clause109 =null;
		ParserRuleReturnScope table_ref111 =null;
		ParserRuleReturnScope subquery_operation_part112 =null;
		ParserRuleReturnScope pivot_clause114 =null;
		ParserRuleReturnScope unpivot_clause115 =null;
		ParserRuleReturnScope only_key116 =null;
		ParserRuleReturnScope dml_table_expression_clause118 =null;
		ParserRuleReturnScope dml_table_expression_clause120 =null;
		ParserRuleReturnScope pivot_clause121 =null;
		ParserRuleReturnScope unpivot_clause122 =null;
		ParserRuleReturnScope flashback_query_clause123 =null;
		ParserRuleReturnScope table_alias124 =null;

		Object LEFT_PAREN110_tree=null;
		Object RIGHT_PAREN113_tree=null;
		Object LEFT_PAREN117_tree=null;
		Object RIGHT_PAREN119_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_dml_table_expression_clause=new RewriteRuleSubtreeStream(adaptor,"rule dml_table_expression_clause");
		RewriteRuleSubtreeStream stream_flashback_query_clause=new RewriteRuleSubtreeStream(adaptor,"rule flashback_query_clause");
		RewriteRuleSubtreeStream stream_unpivot_clause=new RewriteRuleSubtreeStream(adaptor,"rule unpivot_clause");
		RewriteRuleSubtreeStream stream_subquery_operation_part=new RewriteRuleSubtreeStream(adaptor,"rule subquery_operation_part");
		RewriteRuleSubtreeStream stream_table_ref=new RewriteRuleSubtreeStream(adaptor,"rule table_ref");
		RewriteRuleSubtreeStream stream_only_key=new RewriteRuleSubtreeStream(adaptor,"rule only_key");
		RewriteRuleSubtreeStream stream_table_alias=new RewriteRuleSubtreeStream(adaptor,"rule table_alias");
		RewriteRuleSubtreeStream stream_pivot_clause=new RewriteRuleSubtreeStream(adaptor,"rule pivot_clause");

		try {
			// PLSQL_DMLParser.g:307:5: ( ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( options {k=1; } : pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? -> ^( TABLE_REF_ELEMENT ( table_alias )? ( dml_table_expression_clause )? ( table_ref )? ( subquery_operation_part )* ( only_key )? ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* ) )
			// PLSQL_DMLParser.g:308:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( options {k=1; } : pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )?
			{
			// PLSQL_DMLParser.g:308:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( options {k=1; } : pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )? )
			int alt49=4;
			switch ( input.LA(1) ) {
			case INTRODUCER:
				{
				int LA49_1 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case REGULAR_ID:
				{
				int LA49_2 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( ((synpred5_PLSQL_DMLParser()&&(input.LT(1).getText().equalsIgnoreCase("only")))) ) {
					alt49=3;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA49_3 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case SQL92_RESERVED_DELETE:
				{
				int LA49_4 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA49_5 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA49_6 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case BINDVAR:
				{
				int LA49_7 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case COLON:
				{
				int LA49_8 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case SQL92_RESERVED_TABLE:
				{
				int LA49_9 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case SQL92_RESERVED_THE:
				{
				int LA49_10 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			case LEFT_PAREN:
				{
				int LA49_11 = input.LA(2);
				if ( (synpred3_PLSQL_DMLParser()) ) {
					alt49=1;
				}
				else if ( (synpred4_PLSQL_DMLParser()) ) {
					alt49=2;
				}
				else if ( (true) ) {
					alt49=4;
				}

				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 49, 0, input);
				throw nvae;
			}
			switch (alt49) {
				case 1 :
					// PLSQL_DMLParser.g:308:10: ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )?
					{
					pushFollow(FOLLOW_dml_table_expression_clause_in_table_ref_aux1920);
					dml_table_expression_clause107=dml_table_expression_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dml_table_expression_clause.add(dml_table_expression_clause107.getTree());
					// PLSQL_DMLParser.g:308:76: ( options {k=1; } : pivot_clause | unpivot_clause )?
					int alt45=3;
					alt45 = dfa45.predict(input);
					switch (alt45) {
						case 1 :
							// PLSQL_DMLParser.g:308:93: pivot_clause
							{
							pushFollow(FOLLOW_pivot_clause_in_table_ref_aux1932);
							pivot_clause108=pivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_pivot_clause.add(pivot_clause108.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:308:106: unpivot_clause
							{
							pushFollow(FOLLOW_unpivot_clause_in_table_ref_aux1934);
							unpivot_clause109=unpivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_unpivot_clause.add(unpivot_clause109.getTree());
							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:309:10: ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( options {k=1; } : pivot_clause | unpivot_clause )?
					{
					LEFT_PAREN110=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_table_ref_aux1953); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN110);

					pushFollow(FOLLOW_table_ref_in_table_ref_aux1955);
					table_ref111=table_ref();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_ref.add(table_ref111.getTree());
					// PLSQL_DMLParser.g:309:47: ( subquery_operation_part )*
					loop46:
					while (true) {
						int alt46=2;
						int LA46_0 = input.LA(1);
						if ( (LA46_0==PLSQL_RESERVED_MINUS||LA46_0==SQL92_RESERVED_INTERSECT||LA46_0==SQL92_RESERVED_UNION) ) {
							alt46=1;
						}

						switch (alt46) {
						case 1 :
							// PLSQL_DMLParser.g:309:47: subquery_operation_part
							{
							pushFollow(FOLLOW_subquery_operation_part_in_table_ref_aux1957);
							subquery_operation_part112=subquery_operation_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subquery_operation_part.add(subquery_operation_part112.getTree());
							}
							break;

						default :
							break loop46;
						}
					}

					RIGHT_PAREN113=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_table_ref_aux1960); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN113);

					// PLSQL_DMLParser.g:309:84: ( options {k=1; } : pivot_clause | unpivot_clause )?
					int alt47=3;
					alt47 = dfa47.predict(input);
					switch (alt47) {
						case 1 :
							// PLSQL_DMLParser.g:309:101: pivot_clause
							{
							pushFollow(FOLLOW_pivot_clause_in_table_ref_aux1972);
							pivot_clause114=pivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_pivot_clause.add(pivot_clause114.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:309:114: unpivot_clause
							{
							pushFollow(FOLLOW_unpivot_clause_in_table_ref_aux1974);
							unpivot_clause115=unpivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_unpivot_clause.add(unpivot_clause115.getTree());
							}
							break;

					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:310:10: ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
					{
					pushFollow(FOLLOW_only_key_in_table_ref_aux1995);
					only_key116=gPLSQLParser.only_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_only_key.add(only_key116.getTree());
					LEFT_PAREN117=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_table_ref_aux1997); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN117);

					pushFollow(FOLLOW_dml_table_expression_clause_in_table_ref_aux1999);
					dml_table_expression_clause118=dml_table_expression_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dml_table_expression_clause.add(dml_table_expression_clause118.getTree());
					RIGHT_PAREN119=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_table_ref_aux2001); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN119);

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:311:10: dml_table_expression_clause ( options {k=1; } : pivot_clause | unpivot_clause )?
					{
					pushFollow(FOLLOW_dml_table_expression_clause_in_table_ref_aux2012);
					dml_table_expression_clause120=dml_table_expression_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dml_table_expression_clause.add(dml_table_expression_clause120.getTree());
					// PLSQL_DMLParser.g:311:38: ( options {k=1; } : pivot_clause | unpivot_clause )?
					int alt48=3;
					alt48 = dfa48.predict(input);
					switch (alt48) {
						case 1 :
							// PLSQL_DMLParser.g:311:55: pivot_clause
							{
							pushFollow(FOLLOW_pivot_clause_in_table_ref_aux2024);
							pivot_clause121=pivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_pivot_clause.add(pivot_clause121.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:311:68: unpivot_clause
							{
							pushFollow(FOLLOW_unpivot_clause_in_table_ref_aux2026);
							unpivot_clause122=unpivot_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_unpivot_clause.add(unpivot_clause122.getTree());
							}
							break;

					}

					}
					break;

			}

			// PLSQL_DMLParser.g:313:9: ( flashback_query_clause )*
			loop50:
			while (true) {
				int alt50=2;
				int LA50_0 = input.LA(1);
				if ( (LA50_0==REGULAR_ID) ) {
					int LA50_2 = input.LA(2);
					if ( ((input.LT(1).getText().equalsIgnoreCase("versions"))) ) {
						alt50=1;
					}

				}
				else if ( (LA50_0==SQL92_RESERVED_AS) ) {
					alt50=1;
				}

				switch (alt50) {
				case 1 :
					// PLSQL_DMLParser.g:313:9: flashback_query_clause
					{
					pushFollow(FOLLOW_flashback_query_clause_in_table_ref_aux2044);
					flashback_query_clause123=flashback_query_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_flashback_query_clause.add(flashback_query_clause123.getTree());
					}
					break;

				default :
					break loop50;
				}
			}

			// PLSQL_DMLParser.g:314:9: ({...}? table_alias )?
			int alt51=2;
			switch ( input.LA(1) ) {
				case INTRODUCER:
					{
					int LA51_1 = input.LA(2);
					if ( ((isTableAlias())) ) {
						alt51=1;
					}
					}
					break;
				case REGULAR_ID:
					{
					int LA51_2 = input.LA(2);
					if ( ((isTableAlias())) ) {
						alt51=1;
					}
					}
					break;
				case DELIMITED_ID:
					{
					int LA51_3 = input.LA(2);
					if ( ((isTableAlias())) ) {
						alt51=1;
					}
					}
					break;
				case CHAR_STRING:
				case CHAR_STRING_PERL:
				case NATIONAL_CHAR_STRING_LIT:
					{
					int LA51_4 = input.LA(2);
					if ( ((isTableAlias())) ) {
						alt51=1;
					}
					}
					break;
			}
			switch (alt51) {
				case 1 :
					// PLSQL_DMLParser.g:314:10: {...}? table_alias
					{
					if ( !((isTableAlias())) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "table_ref_aux", "isTableAlias()");
					}
					pushFollow(FOLLOW_table_alias_in_table_ref_aux2058);
					table_alias124=gPLSQLParser.table_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_alias.add(table_alias124.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: pivot_clause, table_alias, only_key, unpivot_clause, subquery_operation_part, flashback_query_clause, table_ref, dml_table_expression_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 315:9: -> ^( TABLE_REF_ELEMENT ( table_alias )? ( dml_table_expression_clause )? ( table_ref )? ( subquery_operation_part )* ( only_key )? ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* )
			{
				// PLSQL_DMLParser.g:315:12: ^( TABLE_REF_ELEMENT ( table_alias )? ( dml_table_expression_clause )? ( table_ref )? ( subquery_operation_part )* ( only_key )? ( pivot_clause )? ( unpivot_clause )? ( flashback_query_clause )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_REF_ELEMENT, "TABLE_REF_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:315:32: ( table_alias )?
				if ( stream_table_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_table_alias.nextTree());
				}
				stream_table_alias.reset();

				// PLSQL_DMLParser.g:315:45: ( dml_table_expression_clause )?
				if ( stream_dml_table_expression_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_dml_table_expression_clause.nextTree());
				}
				stream_dml_table_expression_clause.reset();

				// PLSQL_DMLParser.g:315:74: ( table_ref )?
				if ( stream_table_ref.hasNext() ) {
					adaptor.addChild(root_1, stream_table_ref.nextTree());
				}
				stream_table_ref.reset();

				// PLSQL_DMLParser.g:315:85: ( subquery_operation_part )*
				while ( stream_subquery_operation_part.hasNext() ) {
					adaptor.addChild(root_1, stream_subquery_operation_part.nextTree());
				}
				stream_subquery_operation_part.reset();

				// PLSQL_DMLParser.g:315:110: ( only_key )?
				if ( stream_only_key.hasNext() ) {
					adaptor.addChild(root_1, stream_only_key.nextTree());
				}
				stream_only_key.reset();

				// PLSQL_DMLParser.g:315:120: ( pivot_clause )?
				if ( stream_pivot_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_pivot_clause.nextTree());
				}
				stream_pivot_clause.reset();

				// PLSQL_DMLParser.g:315:134: ( unpivot_clause )?
				if ( stream_unpivot_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_unpivot_clause.nextTree());
				}
				stream_unpivot_clause.reset();

				// PLSQL_DMLParser.g:315:150: ( flashback_query_clause )*
				while ( stream_flashback_query_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_flashback_query_clause.nextTree());
				}
				stream_flashback_query_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "table_ref_aux"


	public static class join_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "join_clause"
	// PLSQL_DMLParser.g:318:1: join_clause : (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part ) -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? ( cross_key )? ( natural_key )? ( inner_key )? ( outer_join_type )? table_ref_aux ( $qpc2)? ( join_on_part )? ( join_using_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.join_clause_return join_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.join_clause_return retval = new PLSQLParser_PLSQL_DMLParser.join_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope qpc1 =null;
		ParserRuleReturnScope qpc2 =null;
		ParserRuleReturnScope cross_key125 =null;
		ParserRuleReturnScope natural_key126 =null;
		ParserRuleReturnScope inner_key127 =null;
		ParserRuleReturnScope outer_join_type128 =null;
		ParserRuleReturnScope join_key129 =null;
		ParserRuleReturnScope table_ref_aux130 =null;
		ParserRuleReturnScope join_on_part131 =null;
		ParserRuleReturnScope join_using_part132 =null;

		RewriteRuleSubtreeStream stream_outer_join_type=new RewriteRuleSubtreeStream(adaptor,"rule outer_join_type");
		RewriteRuleSubtreeStream stream_join_key=new RewriteRuleSubtreeStream(adaptor,"rule join_key");
		RewriteRuleSubtreeStream stream_natural_key=new RewriteRuleSubtreeStream(adaptor,"rule natural_key");
		RewriteRuleSubtreeStream stream_table_ref_aux=new RewriteRuleSubtreeStream(adaptor,"rule table_ref_aux");
		RewriteRuleSubtreeStream stream_join_on_part=new RewriteRuleSubtreeStream(adaptor,"rule join_on_part");
		RewriteRuleSubtreeStream stream_inner_key=new RewriteRuleSubtreeStream(adaptor,"rule inner_key");
		RewriteRuleSubtreeStream stream_query_partition_clause=new RewriteRuleSubtreeStream(adaptor,"rule query_partition_clause");
		RewriteRuleSubtreeStream stream_join_using_part=new RewriteRuleSubtreeStream(adaptor,"rule join_using_part");
		RewriteRuleSubtreeStream stream_cross_key=new RewriteRuleSubtreeStream(adaptor,"rule cross_key");

		try {
			// PLSQL_DMLParser.g:319:5: ( (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part ) -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? ( cross_key )? ( natural_key )? ( inner_key )? ( outer_join_type )? table_ref_aux ( $qpc2)? ( join_on_part )? ( join_using_part )? ) )
			// PLSQL_DMLParser.g:319:10: (qpc1= query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux (qpc2= query_partition_clause )? ( join_on_part | join_using_part )
			{
			// PLSQL_DMLParser.g:319:14: (qpc1= query_partition_clause )?
			int alt52=2;
			int LA52_0 = input.LA(1);
			if ( (LA52_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("cross"))||(input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("natural"))||(input.LT(1).getText().equalsIgnoreCase("inner"))||(input.LT(1).getText().equalsIgnoreCase("full"))||(input.LT(1).getText().equalsIgnoreCase("join"))))) {
				int LA52_1 = input.LA(2);
				if ( (LA52_1==SQL92_RESERVED_BY) && ((input.LT(1).getText().equalsIgnoreCase("partition")))) {
					alt52=1;
				}
			}
			switch (alt52) {
				case 1 :
					// PLSQL_DMLParser.g:319:14: qpc1= query_partition_clause
					{
					pushFollow(FOLLOW_query_partition_clause_in_join_clause2120);
					qpc1=query_partition_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_query_partition_clause.add(qpc1.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:320:9: ( cross_key | natural_key )?
			int alt53=3;
			int LA53_0 = input.LA(1);
			if ( (LA53_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("cross"))||(input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("natural"))||(input.LT(1).getText().equalsIgnoreCase("inner"))||(input.LT(1).getText().equalsIgnoreCase("full"))||(input.LT(1).getText().equalsIgnoreCase("join"))))) {
				int LA53_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("cross"))) ) {
					alt53=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("natural"))) ) {
					alt53=2;
				}
			}
			switch (alt53) {
				case 1 :
					// PLSQL_DMLParser.g:320:10: cross_key
					{
					pushFollow(FOLLOW_cross_key_in_join_clause2132);
					cross_key125=gPLSQLParser.cross_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cross_key.add(cross_key125.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:320:20: natural_key
					{
					pushFollow(FOLLOW_natural_key_in_join_clause2134);
					natural_key126=gPLSQLParser.natural_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_natural_key.add(natural_key126.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:320:34: ( inner_key | outer_join_type )?
			int alt54=3;
			int LA54_0 = input.LA(1);
			if ( (LA54_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("inner"))||(input.LT(1).getText().equalsIgnoreCase("full"))||(input.LT(1).getText().equalsIgnoreCase("join"))))) {
				int LA54_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("inner"))) ) {
					alt54=1;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("full")))) ) {
					alt54=2;
				}
			}
			switch (alt54) {
				case 1 :
					// PLSQL_DMLParser.g:320:35: inner_key
					{
					pushFollow(FOLLOW_inner_key_in_join_clause2139);
					inner_key127=gPLSQLParser.inner_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_inner_key.add(inner_key127.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:320:45: outer_join_type
					{
					pushFollow(FOLLOW_outer_join_type_in_join_clause2141);
					outer_join_type128=outer_join_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outer_join_type.add(outer_join_type128.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_join_key_in_join_clause2145);
			join_key129=gPLSQLParser.join_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_join_key.add(join_key129.getTree());
			pushFollow(FOLLOW_table_ref_aux_in_join_clause2155);
			table_ref_aux130=table_ref_aux();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_table_ref_aux.add(table_ref_aux130.getTree());
			// PLSQL_DMLParser.g:322:13: (qpc2= query_partition_clause )?
			int alt55=2;
			int LA55_0 = input.LA(1);
			if ( (LA55_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("partition")))) {
				alt55=1;
			}
			switch (alt55) {
				case 1 :
					// PLSQL_DMLParser.g:322:13: qpc2= query_partition_clause
					{
					pushFollow(FOLLOW_query_partition_clause_in_join_clause2167);
					qpc2=query_partition_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_query_partition_clause.add(qpc2.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:323:9: ( join_on_part | join_using_part )
			int alt56=2;
			int LA56_0 = input.LA(1);
			if ( (LA56_0==SQL92_RESERVED_ON) ) {
				alt56=1;
			}
			else if ( (LA56_0==PLSQL_NON_RESERVED_USING) ) {
				alt56=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 56, 0, input);
				throw nvae;
			}

			switch (alt56) {
				case 1 :
					// PLSQL_DMLParser.g:323:14: join_on_part
					{
					pushFollow(FOLLOW_join_on_part_in_join_clause2183);
					join_on_part131=join_on_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_join_on_part.add(join_on_part131.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:324:14: join_using_part
					{
					pushFollow(FOLLOW_join_using_part_in_join_clause2198);
					join_using_part132=join_using_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_join_using_part.add(join_using_part132.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: cross_key, join_using_part, table_ref_aux, natural_key, qpc2, qpc1, join_on_part, outer_join_type, inner_key
			// token labels: 
			// rule labels: qpc1, qpc2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_qpc1=new RewriteRuleSubtreeStream(adaptor,"rule qpc1",qpc1!=null?qpc1.getTree():null);
			RewriteRuleSubtreeStream stream_qpc2=new RewriteRuleSubtreeStream(adaptor,"rule qpc2",qpc2!=null?qpc2.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 326:9: -> ^( JOIN_DEF[$join_key.start] ( $qpc1)? ( cross_key )? ( natural_key )? ( inner_key )? ( outer_join_type )? table_ref_aux ( $qpc2)? ( join_on_part )? ( join_using_part )? )
			{
				// PLSQL_DMLParser.g:326:12: ^( JOIN_DEF[$join_key.start] ( $qpc1)? ( cross_key )? ( natural_key )? ( inner_key )? ( outer_join_type )? table_ref_aux ( $qpc2)? ( join_on_part )? ( join_using_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(JOIN_DEF, (join_key129!=null?(join_key129.start):null)), root_1);
				// PLSQL_DMLParser.g:326:41: ( $qpc1)?
				if ( stream_qpc1.hasNext() ) {
					adaptor.addChild(root_1, stream_qpc1.nextTree());
				}
				stream_qpc1.reset();

				// PLSQL_DMLParser.g:326:47: ( cross_key )?
				if ( stream_cross_key.hasNext() ) {
					adaptor.addChild(root_1, stream_cross_key.nextTree());
				}
				stream_cross_key.reset();

				// PLSQL_DMLParser.g:326:58: ( natural_key )?
				if ( stream_natural_key.hasNext() ) {
					adaptor.addChild(root_1, stream_natural_key.nextTree());
				}
				stream_natural_key.reset();

				// PLSQL_DMLParser.g:326:71: ( inner_key )?
				if ( stream_inner_key.hasNext() ) {
					adaptor.addChild(root_1, stream_inner_key.nextTree());
				}
				stream_inner_key.reset();

				// PLSQL_DMLParser.g:326:82: ( outer_join_type )?
				if ( stream_outer_join_type.hasNext() ) {
					adaptor.addChild(root_1, stream_outer_join_type.nextTree());
				}
				stream_outer_join_type.reset();

				adaptor.addChild(root_1, stream_table_ref_aux.nextTree());
				// PLSQL_DMLParser.g:326:114: ( $qpc2)?
				if ( stream_qpc2.hasNext() ) {
					adaptor.addChild(root_1, stream_qpc2.nextTree());
				}
				stream_qpc2.reset();

				// PLSQL_DMLParser.g:326:120: ( join_on_part )?
				if ( stream_join_on_part.hasNext() ) {
					adaptor.addChild(root_1, stream_join_on_part.nextTree());
				}
				stream_join_on_part.reset();

				// PLSQL_DMLParser.g:326:134: ( join_using_part )?
				if ( stream_join_using_part.hasNext() ) {
					adaptor.addChild(root_1, stream_join_using_part.nextTree());
				}
				stream_join_using_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "join_clause"


	public static class join_on_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "join_on_part"
	// PLSQL_DMLParser.g:329:1: join_on_part : on_key condition -> ^( on_key ^( LOGIC_EXPR condition ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.join_on_part_return join_on_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.join_on_part_return retval = new PLSQLParser_PLSQL_DMLParser.join_on_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope on_key133 =null;
		ParserRuleReturnScope condition134 =null;

		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_on_key=new RewriteRuleSubtreeStream(adaptor,"rule on_key");

		try {
			// PLSQL_DMLParser.g:330:5: ( on_key condition -> ^( on_key ^( LOGIC_EXPR condition ) ) )
			// PLSQL_DMLParser.g:330:10: on_key condition
			{
			pushFollow(FOLLOW_on_key_in_join_on_part2271);
			on_key133=gPLSQLParser.on_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_on_key.add(on_key133.getTree());
			pushFollow(FOLLOW_condition_in_join_on_part2273);
			condition134=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition134.getTree());
			// AST REWRITE
			// elements: condition, on_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 331:9: -> ^( on_key ^( LOGIC_EXPR condition ) )
			{
				// PLSQL_DMLParser.g:331:12: ^( on_key ^( LOGIC_EXPR condition ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_on_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:331:21: ^( LOGIC_EXPR condition )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
				adaptor.addChild(root_2, stream_condition.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "join_on_part"


	public static class join_using_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "join_using_part"
	// PLSQL_DMLParser.g:334:1: join_using_part : using_key ^ LEFT_PAREN ! column_name ( COMMA ! column_name )* RIGHT_PAREN !;
	public final PLSQLParser_PLSQL_DMLParser.join_using_part_return join_using_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.join_using_part_return retval = new PLSQLParser_PLSQL_DMLParser.join_using_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN136=null;
		Token COMMA138=null;
		Token RIGHT_PAREN140=null;
		ParserRuleReturnScope using_key135 =null;
		ParserRuleReturnScope column_name137 =null;
		ParserRuleReturnScope column_name139 =null;

		Object LEFT_PAREN136_tree=null;
		Object COMMA138_tree=null;
		Object RIGHT_PAREN140_tree=null;

		try {
			// PLSQL_DMLParser.g:335:5: ( using_key ^ LEFT_PAREN ! column_name ( COMMA ! column_name )* RIGHT_PAREN !)
			// PLSQL_DMLParser.g:335:10: using_key ^ LEFT_PAREN ! column_name ( COMMA ! column_name )* RIGHT_PAREN !
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_using_key_in_join_using_part2314);
			using_key135=gPLSQLParser.using_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(using_key135.getTree(), root_0);
			LEFT_PAREN136=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_join_using_part2317); if (state.failed) return retval;
			pushFollow(FOLLOW_column_name_in_join_using_part2320);
			column_name137=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name137.getTree());

			// PLSQL_DMLParser.g:335:45: ( COMMA ! column_name )*
			loop57:
			while (true) {
				int alt57=2;
				int LA57_0 = input.LA(1);
				if ( (LA57_0==COMMA) ) {
					alt57=1;
				}

				switch (alt57) {
				case 1 :
					// PLSQL_DMLParser.g:335:46: COMMA ! column_name
					{
					COMMA138=(Token)match(input,COMMA,FOLLOW_COMMA_in_join_using_part2323); if (state.failed) return retval;
					pushFollow(FOLLOW_column_name_in_join_using_part2326);
					column_name139=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name139.getTree());

					}
					break;

				default :
					break loop57;
				}
			}

			RIGHT_PAREN140=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_join_using_part2330); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "join_using_part"


	public static class outer_join_type_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outer_join_type"
	// PLSQL_DMLParser.g:338:1: outer_join_type : ( full_key | left_key | right_key ) ( outer_key !)? ;
	public final PLSQLParser_PLSQL_DMLParser.outer_join_type_return outer_join_type() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.outer_join_type_return retval = new PLSQLParser_PLSQL_DMLParser.outer_join_type_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope full_key141 =null;
		ParserRuleReturnScope left_key142 =null;
		ParserRuleReturnScope right_key143 =null;
		ParserRuleReturnScope outer_key144 =null;


		try {
			// PLSQL_DMLParser.g:339:5: ( ( full_key | left_key | right_key ) ( outer_key !)? )
			// PLSQL_DMLParser.g:340:5: ( full_key | left_key | right_key ) ( outer_key !)?
			{
			root_0 = (Object)adaptor.nil();


			// PLSQL_DMLParser.g:340:5: ( full_key | left_key | right_key )
			int alt58=3;
			int LA58_0 = input.LA(1);
			if ( (LA58_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("right"))||(input.LT(1).getText().equalsIgnoreCase("left"))||(input.LT(1).getText().equalsIgnoreCase("full"))))) {
				int LA58_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("full"))) ) {
					alt58=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("left"))) ) {
					alt58=2;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("right"))) ) {
					alt58=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 58, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt58) {
				case 1 :
					// PLSQL_DMLParser.g:340:10: full_key
					{
					pushFollow(FOLLOW_full_key_in_outer_join_type2361);
					full_key141=gPLSQLParser.full_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, full_key141.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:341:10: left_key
					{
					pushFollow(FOLLOW_left_key_in_outer_join_type2372);
					left_key142=gPLSQLParser.left_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, left_key142.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:342:10: right_key
					{
					pushFollow(FOLLOW_right_key_in_outer_join_type2383);
					right_key143=gPLSQLParser.right_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, right_key143.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:344:18: ( outer_key !)?
			int alt59=2;
			int LA59_0 = input.LA(1);
			if ( (LA59_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("outer"))||(input.LT(1).getText().equalsIgnoreCase("join"))))) {
				int LA59_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("outer"))) ) {
					alt59=1;
				}
			}
			switch (alt59) {
				case 1 :
					// PLSQL_DMLParser.g:344:18: outer_key !
					{
					pushFollow(FOLLOW_outer_key_in_outer_join_type2399);
					outer_key144=gPLSQLParser.outer_key();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outer_join_type"


	public static class query_partition_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "query_partition_clause"
	// PLSQL_DMLParser.g:347:1: query_partition_clause : partition_key ^ by_key ! query_partition_clause_spec ;
	public final PLSQLParser_PLSQL_DMLParser.query_partition_clause_return query_partition_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.query_partition_clause_return retval = new PLSQLParser_PLSQL_DMLParser.query_partition_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope partition_key145 =null;
		ParserRuleReturnScope by_key146 =null;
		ParserRuleReturnScope query_partition_clause_spec147 =null;


		try {
			// PLSQL_DMLParser.g:348:5: ( partition_key ^ by_key ! query_partition_clause_spec )
			// PLSQL_DMLParser.g:348:10: partition_key ^ by_key ! query_partition_clause_spec
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_partition_key_in_query_partition_clause2421);
			partition_key145=gPLSQLParser.partition_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(partition_key145.getTree(), root_0);
			pushFollow(FOLLOW_by_key_in_query_partition_clause2424);
			by_key146=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_query_partition_clause_spec_in_query_partition_clause2427);
			query_partition_clause_spec147=query_partition_clause_spec();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, query_partition_clause_spec147.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "query_partition_clause"


	public static class query_partition_clause_spec_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "query_partition_clause_spec"
	// PLSQL_DMLParser.g:351:1: query_partition_clause_spec : ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| ( LEFT_PAREN )=> expression_list | expression_wrapper ( COMMA expression_wrapper )* -> ^( QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS ( expression_wrapper )+ ) );
	public final PLSQLParser_PLSQL_DMLParser.query_partition_clause_spec_return query_partition_clause_spec() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.query_partition_clause_spec_return retval = new PLSQLParser_PLSQL_DMLParser.query_partition_clause_spec_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN148=null;
		Token RIGHT_PAREN150=null;
		Token COMMA153=null;
		ParserRuleReturnScope subquery149 =null;
		ParserRuleReturnScope expression_list151 =null;
		ParserRuleReturnScope expression_wrapper152 =null;
		ParserRuleReturnScope expression_wrapper154 =null;

		Object LEFT_PAREN148_tree=null;
		Object RIGHT_PAREN150_tree=null;
		Object COMMA153_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule expression_wrapper");

		try {
			// PLSQL_DMLParser.g:352:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| ( LEFT_PAREN )=> expression_list | expression_wrapper ( COMMA expression_wrapper )* -> ^( QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS ( expression_wrapper )+ ) )
			int alt61=3;
			int LA61_0 = input.LA(1);
			if ( (LA61_0==LEFT_PAREN) ) {
				int LA61_1 = input.LA(2);
				if ( (synpred6_PLSQL_DMLParser()) ) {
					alt61=1;
				}
				else if ( (synpred7_PLSQL_DMLParser()) ) {
					alt61=2;
				}
				else if ( (true) ) {
					alt61=3;
				}

			}
			else if ( (LA61_0==APPROXIMATE_NUM_LIT||LA61_0==BINDVAR||(LA61_0 >= CHAR_STRING && LA61_0 <= COLON)||LA61_0==DELIMITED_ID||LA61_0==EXACT_NUM_LIT||LA61_0==INTRODUCER||LA61_0==MINUS_SIGN||LA61_0==NATIONAL_CHAR_STRING_LIT||LA61_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA61_0==PLUS_SIGN||LA61_0==REGULAR_ID||LA61_0==SQL92_RESERVED_ALL||LA61_0==SQL92_RESERVED_ANY||LA61_0==SQL92_RESERVED_CASE||(LA61_0 >= SQL92_RESERVED_CURSOR && LA61_0 <= SQL92_RESERVED_DATE)||(LA61_0 >= SQL92_RESERVED_DEFAULT && LA61_0 <= SQL92_RESERVED_DELETE)||LA61_0==SQL92_RESERVED_DISTINCT||(LA61_0 >= SQL92_RESERVED_EXISTS && LA61_0 <= SQL92_RESERVED_FALSE)||(LA61_0 >= SQL92_RESERVED_NOT && LA61_0 <= SQL92_RESERVED_NULL)||LA61_0==SQL92_RESERVED_PRIOR||LA61_0==SQL92_RESERVED_TRUE||LA61_0==UNSIGNED_INTEGER) ) {
				alt61=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 61, 0, input);
				throw nvae;
			}

			switch (alt61) {
				case 1 :
					// PLSQL_DMLParser.g:352:9: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					LEFT_PAREN148=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_query_partition_clause_spec2462); if (state.failed) return retval;
					pushFollow(FOLLOW_subquery_in_query_partition_clause_spec2465);
					subquery149=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery149.getTree());

					RIGHT_PAREN150=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_query_partition_clause_spec2467); if (state.failed) return retval;
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:353:10: ( LEFT_PAREN )=> expression_list
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_expression_list_in_query_partition_clause_spec2484);
					expression_list151=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list151.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:354:10: expression_wrapper ( COMMA expression_wrapper )*
					{
					pushFollow(FOLLOW_expression_wrapper_in_query_partition_clause_spec2495);
					expression_wrapper152=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_wrapper.add(expression_wrapper152.getTree());
					// PLSQL_DMLParser.g:354:29: ( COMMA expression_wrapper )*
					loop60:
					while (true) {
						int alt60=2;
						int LA60_0 = input.LA(1);
						if ( (LA60_0==COMMA) ) {
							alt60=1;
						}

						switch (alt60) {
						case 1 :
							// PLSQL_DMLParser.g:354:30: COMMA expression_wrapper
							{
							COMMA153=(Token)match(input,COMMA,FOLLOW_COMMA_in_query_partition_clause_spec2498); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA153);

							pushFollow(FOLLOW_expression_wrapper_in_query_partition_clause_spec2500);
							expression_wrapper154=expression_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_expression_wrapper.add(expression_wrapper154.getTree());
							}
							break;

						default :
							break loop60;
						}
					}

					// AST REWRITE
					// elements: expression_wrapper
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 354:57: -> ^( QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS ( expression_wrapper )+ )
					{
						// PLSQL_DMLParser.g:354:60: ^( QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS ( expression_wrapper )+ )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS, "QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS"), root_1);
						if ( !(stream_expression_wrapper.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_expression_wrapper.hasNext() ) {
							adaptor.addChild(root_1, stream_expression_wrapper.nextTree());
						}
						stream_expression_wrapper.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "query_partition_clause_spec"


	public static class flashback_query_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "flashback_query_clause"
	// PLSQL_DMLParser.g:357:1: flashback_query_clause : ( versions_key between_key ( scn_key | timestamp_key ) expression -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) ) | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) ) );
	public final PLSQLParser_PLSQL_DMLParser.flashback_query_clause_return flashback_query_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.flashback_query_clause_return retval = new PLSQLParser_PLSQL_DMLParser.flashback_query_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope versions_key155 =null;
		ParserRuleReturnScope between_key156 =null;
		ParserRuleReturnScope scn_key157 =null;
		ParserRuleReturnScope timestamp_key158 =null;
		ParserRuleReturnScope expression159 =null;
		ParserRuleReturnScope as_key160 =null;
		ParserRuleReturnScope of_key161 =null;
		ParserRuleReturnScope scn_key162 =null;
		ParserRuleReturnScope timestamp_key163 =null;
		ParserRuleReturnScope snapshot_key164 =null;
		ParserRuleReturnScope expression165 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_of_key=new RewriteRuleSubtreeStream(adaptor,"rule of_key");
		RewriteRuleSubtreeStream stream_between_key=new RewriteRuleSubtreeStream(adaptor,"rule between_key");
		RewriteRuleSubtreeStream stream_as_key=new RewriteRuleSubtreeStream(adaptor,"rule as_key");
		RewriteRuleSubtreeStream stream_scn_key=new RewriteRuleSubtreeStream(adaptor,"rule scn_key");
		RewriteRuleSubtreeStream stream_timestamp_key=new RewriteRuleSubtreeStream(adaptor,"rule timestamp_key");
		RewriteRuleSubtreeStream stream_snapshot_key=new RewriteRuleSubtreeStream(adaptor,"rule snapshot_key");
		RewriteRuleSubtreeStream stream_versions_key=new RewriteRuleSubtreeStream(adaptor,"rule versions_key");

		try {
			// PLSQL_DMLParser.g:358:5: ( versions_key between_key ( scn_key | timestamp_key ) expression -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) ) | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) ) )
			int alt64=2;
			int LA64_0 = input.LA(1);
			if ( (LA64_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("versions")))) {
				alt64=1;
			}
			else if ( (LA64_0==SQL92_RESERVED_AS) ) {
				alt64=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 64, 0, input);
				throw nvae;
			}

			switch (alt64) {
				case 1 :
					// PLSQL_DMLParser.g:358:10: versions_key between_key ( scn_key | timestamp_key ) expression
					{
					pushFollow(FOLLOW_versions_key_in_flashback_query_clause2531);
					versions_key155=gPLSQLParser.versions_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_versions_key.add(versions_key155.getTree());
					pushFollow(FOLLOW_between_key_in_flashback_query_clause2533);
					between_key156=gPLSQLParser.between_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_between_key.add(between_key156.getTree());
					// PLSQL_DMLParser.g:358:35: ( scn_key | timestamp_key )
					int alt62=2;
					int LA62_0 = input.LA(1);
					if ( (LA62_0==REGULAR_ID) ) {
						int LA62_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("scn"))) ) {
							alt62=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timestamp"))) ) {
							alt62=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 62, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 62, 0, input);
						throw nvae;
					}

					switch (alt62) {
						case 1 :
							// PLSQL_DMLParser.g:358:36: scn_key
							{
							pushFollow(FOLLOW_scn_key_in_flashback_query_clause2536);
							scn_key157=gPLSQLParser.scn_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_scn_key.add(scn_key157.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:358:44: timestamp_key
							{
							pushFollow(FOLLOW_timestamp_key_in_flashback_query_clause2538);
							timestamp_key158=gPLSQLParser.timestamp_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_timestamp_key.add(timestamp_key158.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_expression_in_flashback_query_clause2541);
					expression159=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression159.getTree());
					// AST REWRITE
					// elements: expression, scn_key, timestamp_key, versions_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 358:70: -> ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) )
					{
						// PLSQL_DMLParser.g:358:73: ^( versions_key ( scn_key )? ( timestamp_key )? ^( EXPR expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_versions_key.nextNode(), root_1);
						// PLSQL_DMLParser.g:358:88: ( scn_key )?
						if ( stream_scn_key.hasNext() ) {
							adaptor.addChild(root_1, stream_scn_key.nextTree());
						}
						stream_scn_key.reset();

						// PLSQL_DMLParser.g:358:97: ( timestamp_key )?
						if ( stream_timestamp_key.hasNext() ) {
							adaptor.addChild(root_1, stream_timestamp_key.nextTree());
						}
						stream_timestamp_key.reset();

						// PLSQL_DMLParser.g:358:112: ^( EXPR expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:359:10: as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression
					{
					pushFollow(FOLLOW_as_key_in_flashback_query_clause2571);
					as_key160=gPLSQLParser.as_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_as_key.add(as_key160.getTree());
					pushFollow(FOLLOW_of_key_in_flashback_query_clause2573);
					of_key161=gPLSQLParser.of_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_of_key.add(of_key161.getTree());
					// PLSQL_DMLParser.g:359:24: ( scn_key | timestamp_key | snapshot_key )
					int alt63=3;
					int LA63_0 = input.LA(1);
					if ( (LA63_0==REGULAR_ID) ) {
						int LA63_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("scn"))) ) {
							alt63=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timestamp"))) ) {
							alt63=2;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("snapshot"))) ) {
							alt63=3;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 63, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 63, 0, input);
						throw nvae;
					}

					switch (alt63) {
						case 1 :
							// PLSQL_DMLParser.g:359:25: scn_key
							{
							pushFollow(FOLLOW_scn_key_in_flashback_query_clause2576);
							scn_key162=gPLSQLParser.scn_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_scn_key.add(scn_key162.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:359:33: timestamp_key
							{
							pushFollow(FOLLOW_timestamp_key_in_flashback_query_clause2578);
							timestamp_key163=gPLSQLParser.timestamp_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_timestamp_key.add(timestamp_key163.getTree());
							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:359:47: snapshot_key
							{
							pushFollow(FOLLOW_snapshot_key_in_flashback_query_clause2580);
							snapshot_key164=gPLSQLParser.snapshot_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_snapshot_key.add(snapshot_key164.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_expression_in_flashback_query_clause2583);
					expression165=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression165.getTree());
					// AST REWRITE
					// elements: scn_key, expression, snapshot_key, as_key, timestamp_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 359:72: -> ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) )
					{
						// PLSQL_DMLParser.g:359:75: ^( as_key ( scn_key )? ( timestamp_key )? ( snapshot_key )? ^( EXPR expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_as_key.nextNode(), root_1);
						// PLSQL_DMLParser.g:359:84: ( scn_key )?
						if ( stream_scn_key.hasNext() ) {
							adaptor.addChild(root_1, stream_scn_key.nextTree());
						}
						stream_scn_key.reset();

						// PLSQL_DMLParser.g:359:93: ( timestamp_key )?
						if ( stream_timestamp_key.hasNext() ) {
							adaptor.addChild(root_1, stream_timestamp_key.nextTree());
						}
						stream_timestamp_key.reset();

						// PLSQL_DMLParser.g:359:108: ( snapshot_key )?
						if ( stream_snapshot_key.hasNext() ) {
							adaptor.addChild(root_1, stream_snapshot_key.nextTree());
						}
						stream_snapshot_key.reset();

						// PLSQL_DMLParser.g:359:122: ^( EXPR expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "flashback_query_clause"


	public static class pivot_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_clause"
	// PLSQL_DMLParser.g:362:1: pivot_clause : pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN -> ^( pivot_key ( xml_key )? ( pivot_element )+ pivot_for_clause pivot_in_clause ) ;
	public final PLSQLParser_PLSQL_DMLParser.pivot_clause_return pivot_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_clause_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN168=null;
		Token COMMA170=null;
		Token RIGHT_PAREN174=null;
		ParserRuleReturnScope pivot_key166 =null;
		ParserRuleReturnScope xml_key167 =null;
		ParserRuleReturnScope pivot_element169 =null;
		ParserRuleReturnScope pivot_element171 =null;
		ParserRuleReturnScope pivot_for_clause172 =null;
		ParserRuleReturnScope pivot_in_clause173 =null;

		Object LEFT_PAREN168_tree=null;
		Object COMMA170_tree=null;
		Object RIGHT_PAREN174_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_pivot_key=new RewriteRuleSubtreeStream(adaptor,"rule pivot_key");
		RewriteRuleSubtreeStream stream_pivot_element=new RewriteRuleSubtreeStream(adaptor,"rule pivot_element");
		RewriteRuleSubtreeStream stream_pivot_in_clause=new RewriteRuleSubtreeStream(adaptor,"rule pivot_in_clause");
		RewriteRuleSubtreeStream stream_xml_key=new RewriteRuleSubtreeStream(adaptor,"rule xml_key");
		RewriteRuleSubtreeStream stream_pivot_for_clause=new RewriteRuleSubtreeStream(adaptor,"rule pivot_for_clause");

		try {
			// PLSQL_DMLParser.g:363:5: ( pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN -> ^( pivot_key ( xml_key )? ( pivot_element )+ pivot_for_clause pivot_in_clause ) )
			// PLSQL_DMLParser.g:363:9: pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN
			{
			pushFollow(FOLLOW_pivot_key_in_pivot_clause2623);
			pivot_key166=gPLSQLParser.pivot_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_key.add(pivot_key166.getTree());
			// PLSQL_DMLParser.g:363:19: ( xml_key )?
			int alt65=2;
			int LA65_0 = input.LA(1);
			if ( (LA65_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("xml")))) {
				alt65=1;
			}
			switch (alt65) {
				case 1 :
					// PLSQL_DMLParser.g:363:19: xml_key
					{
					pushFollow(FOLLOW_xml_key_in_pivot_clause2625);
					xml_key167=gPLSQLParser.xml_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_xml_key.add(xml_key167.getTree());
					}
					break;

			}

			LEFT_PAREN168=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_pivot_clause2636); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN168);

			pushFollow(FOLLOW_pivot_element_in_pivot_clause2650);
			pivot_element169=pivot_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_element.add(pivot_element169.getTree());
			// PLSQL_DMLParser.g:365:27: ( COMMA pivot_element )*
			loop66:
			while (true) {
				int alt66=2;
				int LA66_0 = input.LA(1);
				if ( (LA66_0==COMMA) ) {
					alt66=1;
				}

				switch (alt66) {
				case 1 :
					// PLSQL_DMLParser.g:365:28: COMMA pivot_element
					{
					COMMA170=(Token)match(input,COMMA,FOLLOW_COMMA_in_pivot_clause2653); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA170);

					pushFollow(FOLLOW_pivot_element_in_pivot_clause2655);
					pivot_element171=pivot_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_pivot_element.add(pivot_element171.getTree());
					}
					break;

				default :
					break loop66;
				}
			}

			pushFollow(FOLLOW_pivot_for_clause_in_pivot_clause2671);
			pivot_for_clause172=pivot_for_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_for_clause.add(pivot_for_clause172.getTree());
			pushFollow(FOLLOW_pivot_in_clause_in_pivot_clause2685);
			pivot_in_clause173=pivot_in_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_in_clause.add(pivot_in_clause173.getTree());
			RIGHT_PAREN174=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_pivot_clause2697); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN174);

			// AST REWRITE
			// elements: pivot_key, pivot_in_clause, xml_key, pivot_element, pivot_for_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 369:9: -> ^( pivot_key ( xml_key )? ( pivot_element )+ pivot_for_clause pivot_in_clause )
			{
				// PLSQL_DMLParser.g:369:12: ^( pivot_key ( xml_key )? ( pivot_element )+ pivot_for_clause pivot_in_clause )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_pivot_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:369:24: ( xml_key )?
				if ( stream_xml_key.hasNext() ) {
					adaptor.addChild(root_1, stream_xml_key.nextTree());
				}
				stream_xml_key.reset();

				if ( !(stream_pivot_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_pivot_element.hasNext() ) {
					adaptor.addChild(root_1, stream_pivot_element.nextTree());
				}
				stream_pivot_element.reset();

				adaptor.addChild(root_1, stream_pivot_for_clause.nextTree());
				adaptor.addChild(root_1, stream_pivot_in_clause.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_clause"


	public static class pivot_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_element"
	// PLSQL_DMLParser.g:372:1: pivot_element : aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? -> ^( PIVOT_ELEMENT ( column_alias )? ^( EXPR ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) ) ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.pivot_element_return pivot_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_element_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN176=null;
		Token RIGHT_PAREN178=null;
		ParserRuleReturnScope aggregate_function_name175 =null;
		ParserRuleReturnScope expression177 =null;
		ParserRuleReturnScope column_alias179 =null;

		Object LEFT_PAREN176_tree=null;
		Object RIGHT_PAREN178_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_column_alias=new RewriteRuleSubtreeStream(adaptor,"rule column_alias");
		RewriteRuleSubtreeStream stream_aggregate_function_name=new RewriteRuleSubtreeStream(adaptor,"rule aggregate_function_name");

		try {
			// PLSQL_DMLParser.g:373:5: ( aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? -> ^( PIVOT_ELEMENT ( column_alias )? ^( EXPR ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) ) ) ) )
			// PLSQL_DMLParser.g:373:10: aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )?
			{
			pushFollow(FOLLOW_aggregate_function_name_in_pivot_element2741);
			aggregate_function_name175=gPLSQLParser.aggregate_function_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_aggregate_function_name.add(aggregate_function_name175.getTree());
			LEFT_PAREN176=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_pivot_element2743); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN176);

			pushFollow(FOLLOW_expression_in_pivot_element2745);
			expression177=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression177.getTree());
			RIGHT_PAREN178=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_pivot_element2747); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN178);

			// PLSQL_DMLParser.g:373:68: ( column_alias )?
			int alt67=2;
			int LA67_0 = input.LA(1);
			if ( ((LA67_0 >= CHAR_STRING && LA67_0 <= CHAR_STRING_PERL)||LA67_0==DELIMITED_ID||LA67_0==INTRODUCER||LA67_0==NATIONAL_CHAR_STRING_LIT||LA67_0==REGULAR_ID||LA67_0==SQL92_RESERVED_AS) ) {
				alt67=1;
			}
			switch (alt67) {
				case 1 :
					// PLSQL_DMLParser.g:373:68: column_alias
					{
					pushFollow(FOLLOW_column_alias_in_pivot_element2749);
					column_alias179=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_alias.add(column_alias179.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: expression, aggregate_function_name, column_alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 374:9: -> ^( PIVOT_ELEMENT ( column_alias )? ^( EXPR ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) ) ) )
			{
				// PLSQL_DMLParser.g:374:12: ^( PIVOT_ELEMENT ( column_alias )? ^( EXPR ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) ) ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PIVOT_ELEMENT, "PIVOT_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:374:28: ( column_alias )?
				if ( stream_column_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_column_alias.nextTree());
				}
				stream_column_alias.reset();

				// PLSQL_DMLParser.g:374:42: ^( EXPR ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) ) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				// PLSQL_DMLParser.g:374:49: ^( CASCATED_ELEMENT aggregate_function_name ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) ) )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(CASCATED_ELEMENT, "CASCATED_ELEMENT"), root_3);
				adaptor.addChild(root_3, stream_aggregate_function_name.nextTree());
				// PLSQL_DMLParser.g:374:92: ^( ARGUMENTS ^( ARGUMENT ^( EXPR expression ) ) )
				{
				Object root_4 = (Object)adaptor.nil();
				root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENTS, "ARGUMENTS"), root_4);
				// PLSQL_DMLParser.g:374:104: ^( ARGUMENT ^( EXPR expression ) )
				{
				Object root_5 = (Object)adaptor.nil();
				root_5 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT, "ARGUMENT"), root_5);
				// PLSQL_DMLParser.g:374:115: ^( EXPR expression )
				{
				Object root_6 = (Object)adaptor.nil();
				root_6 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_6);
				adaptor.addChild(root_6, stream_expression.nextTree());
				adaptor.addChild(root_5, root_6);
				}

				adaptor.addChild(root_4, root_5);
				}

				adaptor.addChild(root_3, root_4);
				}

				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_element"


	public static class pivot_for_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_for_clause"
	// PLSQL_DMLParser.g:377:1: pivot_for_clause : for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) -> ^( for_key ( column_name )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.pivot_for_clause_return pivot_for_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_for_clause_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_for_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN182=null;
		Token COMMA184=null;
		Token RIGHT_PAREN186=null;
		ParserRuleReturnScope for_key180 =null;
		ParserRuleReturnScope column_name181 =null;
		ParserRuleReturnScope column_name183 =null;
		ParserRuleReturnScope column_name185 =null;

		Object LEFT_PAREN182_tree=null;
		Object COMMA184_tree=null;
		Object RIGHT_PAREN186_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");

		try {
			// PLSQL_DMLParser.g:378:5: ( for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) -> ^( for_key ( column_name )+ ) )
			// PLSQL_DMLParser.g:378:10: for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
			{
			pushFollow(FOLLOW_for_key_in_pivot_for_clause2811);
			for_key180=gPLSQLParser.for_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_for_key.add(for_key180.getTree());
			// PLSQL_DMLParser.g:379:5: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
			int alt69=2;
			int LA69_0 = input.LA(1);
			if ( (LA69_0==DELIMITED_ID||LA69_0==INTRODUCER||LA69_0==REGULAR_ID) ) {
				alt69=1;
			}
			else if ( (LA69_0==LEFT_PAREN) ) {
				alt69=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 69, 0, input);
				throw nvae;
			}

			switch (alt69) {
				case 1 :
					// PLSQL_DMLParser.g:379:10: column_name
					{
					pushFollow(FOLLOW_column_name_in_pivot_for_clause2823);
					column_name181=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name181.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:380:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
					{
					LEFT_PAREN182=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_pivot_for_clause2834); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN182);

					pushFollow(FOLLOW_column_name_in_pivot_for_clause2836);
					column_name183=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name183.getTree());
					// PLSQL_DMLParser.g:380:33: ( COMMA column_name )*
					loop68:
					while (true) {
						int alt68=2;
						int LA68_0 = input.LA(1);
						if ( (LA68_0==COMMA) ) {
							alt68=1;
						}

						switch (alt68) {
						case 1 :
							// PLSQL_DMLParser.g:380:34: COMMA column_name
							{
							COMMA184=(Token)match(input,COMMA,FOLLOW_COMMA_in_pivot_for_clause2839); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA184);

							pushFollow(FOLLOW_column_name_in_pivot_for_clause2841);
							column_name185=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name185.getTree());
							}
							break;

						default :
							break loop68;
						}
					}

					RIGHT_PAREN186=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_pivot_for_clause2845); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN186);

					}
					break;

			}

			// AST REWRITE
			// elements: for_key, column_name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 382:9: -> ^( for_key ( column_name )+ )
			{
				// PLSQL_DMLParser.g:382:12: ^( for_key ( column_name )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_for_key.nextNode(), root_1);
				if ( !(stream_column_name.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_1, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_for_clause"


	public static class pivot_in_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_in_clause"
	// PLSQL_DMLParser.g:385:1: pivot_in_clause : in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN -> {mode == 1}? ^( in_key subquery ) -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) ) -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.pivot_in_clause_return pivot_in_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_in_clause_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_in_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN188=null;
		Token COMMA191=null;
		Token COMMA194=null;
		Token RIGHT_PAREN196=null;
		ParserRuleReturnScope in_key187 =null;
		ParserRuleReturnScope subquery189 =null;
		ParserRuleReturnScope any_key190 =null;
		ParserRuleReturnScope any_key192 =null;
		ParserRuleReturnScope pivot_in_clause_element193 =null;
		ParserRuleReturnScope pivot_in_clause_element195 =null;

		Object LEFT_PAREN188_tree=null;
		Object COMMA191_tree=null;
		Object COMMA194_tree=null;
		Object RIGHT_PAREN196_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_pivot_in_clause_element=new RewriteRuleSubtreeStream(adaptor,"rule pivot_in_clause_element");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_any_key=new RewriteRuleSubtreeStream(adaptor,"rule any_key");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:387:5: ( in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN -> {mode == 1}? ^( in_key subquery ) -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) ) -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) ) )
			// PLSQL_DMLParser.g:387:10: in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN
			{
			pushFollow(FOLLOW_in_key_in_pivot_in_clause2896);
			in_key187=gPLSQLParser.in_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_in_key.add(in_key187.getTree());
			LEFT_PAREN188=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_pivot_in_clause2906); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN188);

			// PLSQL_DMLParser.g:389:13: ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* )
			int alt72=3;
			int LA72_0 = input.LA(1);
			if ( (LA72_0==SQL92_RESERVED_SELECT) && (synpred8_PLSQL_DMLParser())) {
				alt72=1;
			}
			else if ( (LA72_0==LEFT_PAREN) ) {
				int LA72_2 = input.LA(2);
				if ( (synpred8_PLSQL_DMLParser()) ) {
					alt72=1;
				}
				else if ( (true) ) {
					alt72=3;
				}

			}
			else if ( (LA72_0==SQL92_RESERVED_ANY) ) {
				int LA72_3 = input.LA(2);
				if ( (synpred9_PLSQL_DMLParser()) ) {
					alt72=2;
				}
				else if ( (true) ) {
					alt72=3;
				}

			}
			else if ( (LA72_0==APPROXIMATE_NUM_LIT||LA72_0==BINDVAR||(LA72_0 >= CHAR_STRING && LA72_0 <= COLON)||LA72_0==DELIMITED_ID||LA72_0==EXACT_NUM_LIT||LA72_0==INTRODUCER||LA72_0==MINUS_SIGN||LA72_0==NATIONAL_CHAR_STRING_LIT||LA72_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA72_0==PLUS_SIGN||LA72_0==REGULAR_ID||LA72_0==SQL92_RESERVED_ALL||LA72_0==SQL92_RESERVED_CASE||(LA72_0 >= SQL92_RESERVED_CURSOR && LA72_0 <= SQL92_RESERVED_DATE)||(LA72_0 >= SQL92_RESERVED_DEFAULT && LA72_0 <= SQL92_RESERVED_DELETE)||LA72_0==SQL92_RESERVED_DISTINCT||(LA72_0 >= SQL92_RESERVED_EXISTS && LA72_0 <= SQL92_RESERVED_FALSE)||(LA72_0 >= SQL92_RESERVED_NOT && LA72_0 <= SQL92_RESERVED_NULL)||LA72_0==SQL92_RESERVED_PRIOR||LA72_0==SQL92_RESERVED_TRUE||LA72_0==UNSIGNED_INTEGER) ) {
				alt72=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 72, 0, input);
				throw nvae;
			}

			switch (alt72) {
				case 1 :
					// PLSQL_DMLParser.g:389:18: ( select_key )=> subquery
					{
					pushFollow(FOLLOW_subquery_in_pivot_in_clause2930);
					subquery189=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery.add(subquery189.getTree());
					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:390:18: ( any_key )=> any_key ( COMMA any_key )*
					{
					pushFollow(FOLLOW_any_key_in_pivot_in_clause2956);
					any_key190=gPLSQLParser.any_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_any_key.add(any_key190.getTree());
					// PLSQL_DMLParser.g:390:38: ( COMMA any_key )*
					loop70:
					while (true) {
						int alt70=2;
						int LA70_0 = input.LA(1);
						if ( (LA70_0==COMMA) ) {
							alt70=1;
						}

						switch (alt70) {
						case 1 :
							// PLSQL_DMLParser.g:390:39: COMMA any_key
							{
							COMMA191=(Token)match(input,COMMA,FOLLOW_COMMA_in_pivot_in_clause2959); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA191);

							pushFollow(FOLLOW_any_key_in_pivot_in_clause2961);
							any_key192=gPLSQLParser.any_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_any_key.add(any_key192.getTree());
							}
							break;

						default :
							break loop70;
						}
					}

					if ( state.backtracking==0 ) {mode = 2;}
					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:391:18: pivot_in_clause_element ( COMMA pivot_in_clause_element )*
					{
					pushFollow(FOLLOW_pivot_in_clause_element_in_pivot_in_clause2984);
					pivot_in_clause_element193=pivot_in_clause_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_pivot_in_clause_element.add(pivot_in_clause_element193.getTree());
					// PLSQL_DMLParser.g:391:42: ( COMMA pivot_in_clause_element )*
					loop71:
					while (true) {
						int alt71=2;
						int LA71_0 = input.LA(1);
						if ( (LA71_0==COMMA) ) {
							alt71=1;
						}

						switch (alt71) {
						case 1 :
							// PLSQL_DMLParser.g:391:43: COMMA pivot_in_clause_element
							{
							COMMA194=(Token)match(input,COMMA,FOLLOW_COMMA_in_pivot_in_clause2987); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA194);

							pushFollow(FOLLOW_pivot_in_clause_element_in_pivot_in_clause2989);
							pivot_in_clause_element195=pivot_in_clause_element();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_pivot_in_clause_element.add(pivot_in_clause_element195.getTree());
							}
							break;

						default :
							break loop71;
						}
					}

					}
					break;

			}

			RIGHT_PAREN196=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_pivot_in_clause3015); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN196);

			// AST REWRITE
			// elements: in_key, in_key, in_key, pivot_in_clause_element, subquery, any_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 394:9: -> {mode == 1}? ^( in_key subquery )
			if (mode == 1) {
				// PLSQL_DMLParser.g:394:24: ^( in_key subquery )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_1);
				adaptor.addChild(root_1, stream_subquery.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 395:9: -> {mode == 2}? ^( in_key ^( ANY_MODE ( any_key )+ ) )
			if (mode == 2) {
				// PLSQL_DMLParser.g:395:24: ^( in_key ^( ANY_MODE ( any_key )+ ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:395:33: ^( ANY_MODE ( any_key )+ )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ANY_MODE, "ANY_MODE"), root_2);
				if ( !(stream_any_key.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_any_key.hasNext() ) {
					adaptor.addChild(root_2, stream_any_key.nextTree());
				}
				stream_any_key.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 396:9: -> ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) )
			{
				// PLSQL_DMLParser.g:396:12: ^( in_key ^( ELEMENTS_MODE ( pivot_in_clause_element )+ ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:396:21: ^( ELEMENTS_MODE ( pivot_in_clause_element )+ )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ELEMENTS_MODE, "ELEMENTS_MODE"), root_2);
				if ( !(stream_pivot_in_clause_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_pivot_in_clause_element.hasNext() ) {
					adaptor.addChild(root_2, stream_pivot_in_clause_element.nextTree());
				}
				stream_pivot_in_clause_element.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_in_clause"


	public static class pivot_in_clause_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_in_clause_element"
	// PLSQL_DMLParser.g:399:1: pivot_in_clause_element : pivot_in_clause_elements ( column_alias )? -> ^( PIVOT_IN_ELEMENT ( column_alias )? pivot_in_clause_elements ) ;
	public final PLSQLParser_PLSQL_DMLParser.pivot_in_clause_element_return pivot_in_clause_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_in_clause_element_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_in_clause_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope pivot_in_clause_elements197 =null;
		ParserRuleReturnScope column_alias198 =null;

		RewriteRuleSubtreeStream stream_column_alias=new RewriteRuleSubtreeStream(adaptor,"rule column_alias");
		RewriteRuleSubtreeStream stream_pivot_in_clause_elements=new RewriteRuleSubtreeStream(adaptor,"rule pivot_in_clause_elements");

		try {
			// PLSQL_DMLParser.g:400:5: ( pivot_in_clause_elements ( column_alias )? -> ^( PIVOT_IN_ELEMENT ( column_alias )? pivot_in_clause_elements ) )
			// PLSQL_DMLParser.g:400:10: pivot_in_clause_elements ( column_alias )?
			{
			pushFollow(FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3095);
			pivot_in_clause_elements197=pivot_in_clause_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_in_clause_elements.add(pivot_in_clause_elements197.getTree());
			// PLSQL_DMLParser.g:400:35: ( column_alias )?
			int alt73=2;
			int LA73_0 = input.LA(1);
			if ( ((LA73_0 >= CHAR_STRING && LA73_0 <= CHAR_STRING_PERL)||LA73_0==DELIMITED_ID||LA73_0==INTRODUCER||LA73_0==NATIONAL_CHAR_STRING_LIT||LA73_0==REGULAR_ID||LA73_0==SQL92_RESERVED_AS) ) {
				alt73=1;
			}
			switch (alt73) {
				case 1 :
					// PLSQL_DMLParser.g:400:35: column_alias
					{
					pushFollow(FOLLOW_column_alias_in_pivot_in_clause_element3097);
					column_alias198=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_alias.add(column_alias198.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: column_alias, pivot_in_clause_elements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 401:9: -> ^( PIVOT_IN_ELEMENT ( column_alias )? pivot_in_clause_elements )
			{
				// PLSQL_DMLParser.g:401:12: ^( PIVOT_IN_ELEMENT ( column_alias )? pivot_in_clause_elements )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PIVOT_IN_ELEMENT, "PIVOT_IN_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:401:31: ( column_alias )?
				if ( stream_column_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_column_alias.nextTree());
				}
				stream_column_alias.reset();

				adaptor.addChild(root_1, stream_pivot_in_clause_elements.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_in_clause_element"


	public static class pivot_in_clause_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_in_clause_elements"
	// PLSQL_DMLParser.g:404:1: pivot_in_clause_elements : ( expression -> ^( EXPR expression ) | ( LEFT_PAREN )=> expression_list );
	public final PLSQLParser_PLSQL_DMLParser.pivot_in_clause_elements_return pivot_in_clause_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.pivot_in_clause_elements_return retval = new PLSQLParser_PLSQL_DMLParser.pivot_in_clause_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression199 =null;
		ParserRuleReturnScope expression_list200 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:405:5: ( expression -> ^( EXPR expression ) | ( LEFT_PAREN )=> expression_list )
			int alt74=2;
			int LA74_0 = input.LA(1);
			if ( (LA74_0==APPROXIMATE_NUM_LIT||LA74_0==BINDVAR||(LA74_0 >= CHAR_STRING && LA74_0 <= COLON)||LA74_0==DELIMITED_ID||LA74_0==EXACT_NUM_LIT||LA74_0==INTRODUCER||LA74_0==MINUS_SIGN||LA74_0==NATIONAL_CHAR_STRING_LIT||LA74_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA74_0==PLUS_SIGN||LA74_0==REGULAR_ID||LA74_0==SQL92_RESERVED_ALL||LA74_0==SQL92_RESERVED_ANY||LA74_0==SQL92_RESERVED_CASE||(LA74_0 >= SQL92_RESERVED_CURSOR && LA74_0 <= SQL92_RESERVED_DATE)||(LA74_0 >= SQL92_RESERVED_DEFAULT && LA74_0 <= SQL92_RESERVED_DELETE)||LA74_0==SQL92_RESERVED_DISTINCT||(LA74_0 >= SQL92_RESERVED_EXISTS && LA74_0 <= SQL92_RESERVED_FALSE)||(LA74_0 >= SQL92_RESERVED_NOT && LA74_0 <= SQL92_RESERVED_NULL)||LA74_0==SQL92_RESERVED_PRIOR||LA74_0==SQL92_RESERVED_TRUE||LA74_0==UNSIGNED_INTEGER) ) {
				alt74=1;
			}
			else if ( (LA74_0==LEFT_PAREN) ) {
				int LA74_27 = input.LA(2);
				if ( (true) ) {
					alt74=1;
				}
				else if ( (synpred10_PLSQL_DMLParser()) ) {
					alt74=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 74, 27, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 74, 0, input);
				throw nvae;
			}

			switch (alt74) {
				case 1 :
					// PLSQL_DMLParser.g:405:10: expression
					{
					pushFollow(FOLLOW_expression_in_pivot_in_clause_elements3137);
					expression199=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression199.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 405:21: -> ^( EXPR expression )
					{
						// PLSQL_DMLParser.g:405:24: ^( EXPR expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:406:10: ( LEFT_PAREN )=> expression_list
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_expression_list_in_pivot_in_clause_elements3161);
					expression_list200=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list200.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_in_clause_elements"


	public static class unpivot_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unpivot_clause"
	// PLSQL_DMLParser.g:409:1: unpivot_clause : unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause ) ;
	public final PLSQLParser_PLSQL_DMLParser.unpivot_clause_return unpivot_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.unpivot_clause_return retval = new PLSQLParser_PLSQL_DMLParser.unpivot_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN205=null;
		Token LEFT_PAREN207=null;
		Token COMMA209=null;
		Token RIGHT_PAREN211=null;
		Token RIGHT_PAREN214=null;
		ParserRuleReturnScope unpivot_key201 =null;
		ParserRuleReturnScope include_key202 =null;
		ParserRuleReturnScope exclude_key203 =null;
		ParserRuleReturnScope nulls_key204 =null;
		ParserRuleReturnScope column_name206 =null;
		ParserRuleReturnScope column_name208 =null;
		ParserRuleReturnScope column_name210 =null;
		ParserRuleReturnScope pivot_for_clause212 =null;
		ParserRuleReturnScope unpivot_in_clause213 =null;

		Object LEFT_PAREN205_tree=null;
		Object LEFT_PAREN207_tree=null;
		Object COMMA209_tree=null;
		Object RIGHT_PAREN211_tree=null;
		Object RIGHT_PAREN214_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_unpivot_key=new RewriteRuleSubtreeStream(adaptor,"rule unpivot_key");
		RewriteRuleSubtreeStream stream_nulls_key=new RewriteRuleSubtreeStream(adaptor,"rule nulls_key");
		RewriteRuleSubtreeStream stream_include_key=new RewriteRuleSubtreeStream(adaptor,"rule include_key");
		RewriteRuleSubtreeStream stream_unpivot_in_clause=new RewriteRuleSubtreeStream(adaptor,"rule unpivot_in_clause");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_exclude_key=new RewriteRuleSubtreeStream(adaptor,"rule exclude_key");
		RewriteRuleSubtreeStream stream_pivot_for_clause=new RewriteRuleSubtreeStream(adaptor,"rule pivot_for_clause");

		try {
			// PLSQL_DMLParser.g:410:5: ( unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause ) )
			// PLSQL_DMLParser.g:410:10: unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN
			{
			pushFollow(FOLLOW_unpivot_key_in_unpivot_clause3181);
			unpivot_key201=gPLSQLParser.unpivot_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_unpivot_key.add(unpivot_key201.getTree());
			// PLSQL_DMLParser.g:411:9: ( ( include_key | exclude_key ) nulls_key )?
			int alt76=2;
			int LA76_0 = input.LA(1);
			if ( (LA76_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("exclude"))||(input.LT(1).getText().equalsIgnoreCase("include"))))) {
				alt76=1;
			}
			switch (alt76) {
				case 1 :
					// PLSQL_DMLParser.g:411:10: ( include_key | exclude_key ) nulls_key
					{
					// PLSQL_DMLParser.g:411:10: ( include_key | exclude_key )
					int alt75=2;
					int LA75_0 = input.LA(1);
					if ( (LA75_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("exclude"))||(input.LT(1).getText().equalsIgnoreCase("include"))))) {
						int LA75_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("include"))) ) {
							alt75=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("exclude"))) ) {
							alt75=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 75, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt75) {
						case 1 :
							// PLSQL_DMLParser.g:411:11: include_key
							{
							pushFollow(FOLLOW_include_key_in_unpivot_clause3194);
							include_key202=gPLSQLParser.include_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_include_key.add(include_key202.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:411:23: exclude_key
							{
							pushFollow(FOLLOW_exclude_key_in_unpivot_clause3196);
							exclude_key203=gPLSQLParser.exclude_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_exclude_key.add(exclude_key203.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_nulls_key_in_unpivot_clause3199);
					nulls_key204=gPLSQLParser.nulls_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_nulls_key.add(nulls_key204.getTree());
					}
					break;

			}

			LEFT_PAREN205=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_unpivot_clause3211); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN205);

			// PLSQL_DMLParser.g:413:13: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
			int alt78=2;
			int LA78_0 = input.LA(1);
			if ( (LA78_0==DELIMITED_ID||LA78_0==INTRODUCER||LA78_0==REGULAR_ID) ) {
				alt78=1;
			}
			else if ( (LA78_0==LEFT_PAREN) ) {
				alt78=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 78, 0, input);
				throw nvae;
			}

			switch (alt78) {
				case 1 :
					// PLSQL_DMLParser.g:413:18: column_name
					{
					pushFollow(FOLLOW_column_name_in_unpivot_clause3230);
					column_name206=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name206.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:414:18: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
					{
					LEFT_PAREN207=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_unpivot_clause3249); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN207);

					pushFollow(FOLLOW_column_name_in_unpivot_clause3251);
					column_name208=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name208.getTree());
					// PLSQL_DMLParser.g:414:41: ( COMMA column_name )*
					loop77:
					while (true) {
						int alt77=2;
						int LA77_0 = input.LA(1);
						if ( (LA77_0==COMMA) ) {
							alt77=1;
						}

						switch (alt77) {
						case 1 :
							// PLSQL_DMLParser.g:414:42: COMMA column_name
							{
							COMMA209=(Token)match(input,COMMA,FOLLOW_COMMA_in_unpivot_clause3254); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA209);

							pushFollow(FOLLOW_column_name_in_unpivot_clause3256);
							column_name210=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name210.getTree());
							}
							break;

						default :
							break loop77;
						}
					}

					RIGHT_PAREN211=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_unpivot_clause3260); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN211);

					}
					break;

			}

			pushFollow(FOLLOW_pivot_for_clause_in_unpivot_clause3288);
			pivot_for_clause212=pivot_for_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_pivot_for_clause.add(pivot_for_clause212.getTree());
			pushFollow(FOLLOW_unpivot_in_clause_in_unpivot_clause3302);
			unpivot_in_clause213=unpivot_in_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_unpivot_in_clause.add(unpivot_in_clause213.getTree());
			RIGHT_PAREN214=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_unpivot_clause3312); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN214);

			// AST REWRITE
			// elements: unpivot_in_clause, unpivot_key, nulls_key, column_name, include_key, exclude_key, pivot_for_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 419:9: -> ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause )
			{
				// PLSQL_DMLParser.g:419:12: ^( unpivot_key ( include_key )? ( exclude_key )? ( nulls_key )? ( column_name )+ pivot_for_clause unpivot_in_clause )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_unpivot_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:419:26: ( include_key )?
				if ( stream_include_key.hasNext() ) {
					adaptor.addChild(root_1, stream_include_key.nextTree());
				}
				stream_include_key.reset();

				// PLSQL_DMLParser.g:419:39: ( exclude_key )?
				if ( stream_exclude_key.hasNext() ) {
					adaptor.addChild(root_1, stream_exclude_key.nextTree());
				}
				stream_exclude_key.reset();

				// PLSQL_DMLParser.g:419:52: ( nulls_key )?
				if ( stream_nulls_key.hasNext() ) {
					adaptor.addChild(root_1, stream_nulls_key.nextTree());
				}
				stream_nulls_key.reset();

				if ( !(stream_column_name.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_1, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				adaptor.addChild(root_1, stream_pivot_for_clause.nextTree());
				adaptor.addChild(root_1, stream_unpivot_in_clause.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unpivot_clause"


	public static class unpivot_in_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unpivot_in_clause"
	// PLSQL_DMLParser.g:422:1: unpivot_in_clause : in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.unpivot_in_clause_return unpivot_in_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.unpivot_in_clause_return retval = new PLSQLParser_PLSQL_DMLParser.unpivot_in_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN216=null;
		Token COMMA218=null;
		Token RIGHT_PAREN220=null;
		ParserRuleReturnScope in_key215 =null;
		ParserRuleReturnScope unpivot_in_elements217 =null;
		ParserRuleReturnScope unpivot_in_elements219 =null;

		Object LEFT_PAREN216_tree=null;
		Object COMMA218_tree=null;
		Object RIGHT_PAREN220_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_unpivot_in_elements=new RewriteRuleSubtreeStream(adaptor,"rule unpivot_in_elements");

		try {
			// PLSQL_DMLParser.g:423:5: ( in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ ) )
			// PLSQL_DMLParser.g:423:10: in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN
			{
			pushFollow(FOLLOW_in_key_in_unpivot_in_clause3362);
			in_key215=gPLSQLParser.in_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_in_key.add(in_key215.getTree());
			LEFT_PAREN216=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_unpivot_in_clause3372); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN216);

			pushFollow(FOLLOW_unpivot_in_elements_in_unpivot_in_clause3386);
			unpivot_in_elements217=unpivot_in_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_unpivot_in_elements.add(unpivot_in_elements217.getTree());
			// PLSQL_DMLParser.g:425:33: ( COMMA unpivot_in_elements )*
			loop79:
			while (true) {
				int alt79=2;
				int LA79_0 = input.LA(1);
				if ( (LA79_0==COMMA) ) {
					alt79=1;
				}

				switch (alt79) {
				case 1 :
					// PLSQL_DMLParser.g:425:34: COMMA unpivot_in_elements
					{
					COMMA218=(Token)match(input,COMMA,FOLLOW_COMMA_in_unpivot_in_clause3389); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA218);

					pushFollow(FOLLOW_unpivot_in_elements_in_unpivot_in_clause3391);
					unpivot_in_elements219=unpivot_in_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unpivot_in_elements.add(unpivot_in_elements219.getTree());
					}
					break;

				default :
					break loop79;
				}
			}

			RIGHT_PAREN220=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3403); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN220);

			// AST REWRITE
			// elements: in_key, unpivot_in_elements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 427:9: -> ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ )
			{
				// PLSQL_DMLParser.g:427:12: ^( in_key ( ^( UNPIVOT_IN_ELEMENT unpivot_in_elements ) )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_1);
				if ( !(stream_unpivot_in_elements.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_unpivot_in_elements.hasNext() ) {
					// PLSQL_DMLParser.g:427:21: ^( UNPIVOT_IN_ELEMENT unpivot_in_elements )
					{
					Object root_2 = (Object)adaptor.nil();
					root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNPIVOT_IN_ELEMENT, "UNPIVOT_IN_ELEMENT"), root_2);
					adaptor.addChild(root_2, stream_unpivot_in_elements.nextTree());
					adaptor.addChild(root_1, root_2);
					}

				}
				stream_unpivot_in_elements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unpivot_in_clause"


	public static class unpivot_in_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unpivot_in_elements"
	// PLSQL_DMLParser.g:430:1: unpivot_in_elements : ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( ( as_key )? ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? -> ( column_name )+ ^( PIVOT_ALIAS ( constant )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.unpivot_in_elements_return unpivot_in_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.unpivot_in_elements_return retval = new PLSQLParser_PLSQL_DMLParser.unpivot_in_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN222=null;
		Token COMMA224=null;
		Token RIGHT_PAREN226=null;
		Token LEFT_PAREN229=null;
		Token COMMA231=null;
		Token RIGHT_PAREN233=null;
		ParserRuleReturnScope column_name221 =null;
		ParserRuleReturnScope column_name223 =null;
		ParserRuleReturnScope column_name225 =null;
		ParserRuleReturnScope as_key227 =null;
		ParserRuleReturnScope constant228 =null;
		ParserRuleReturnScope constant230 =null;
		ParserRuleReturnScope constant232 =null;

		Object LEFT_PAREN222_tree=null;
		Object COMMA224_tree=null;
		Object RIGHT_PAREN226_tree=null;
		Object LEFT_PAREN229_tree=null;
		Object COMMA231_tree=null;
		Object RIGHT_PAREN233_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		RewriteRuleSubtreeStream stream_as_key=new RewriteRuleSubtreeStream(adaptor,"rule as_key");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");

		try {
			// PLSQL_DMLParser.g:431:5: ( ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( ( as_key )? ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? -> ( column_name )+ ^( PIVOT_ALIAS ( constant )+ ) )
			// PLSQL_DMLParser.g:431:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( ( as_key )? ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
			{
			// PLSQL_DMLParser.g:431:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
			int alt81=2;
			int LA81_0 = input.LA(1);
			if ( (LA81_0==DELIMITED_ID||LA81_0==INTRODUCER||LA81_0==REGULAR_ID) ) {
				alt81=1;
			}
			else if ( (LA81_0==LEFT_PAREN) ) {
				alt81=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 81, 0, input);
				throw nvae;
			}

			switch (alt81) {
				case 1 :
					// PLSQL_DMLParser.g:431:14: column_name
					{
					pushFollow(FOLLOW_column_name_in_unpivot_in_elements3448);
					column_name221=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name221.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:432:14: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
					{
					LEFT_PAREN222=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_unpivot_in_elements3463); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN222);

					pushFollow(FOLLOW_column_name_in_unpivot_in_elements3465);
					column_name223=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name223.getTree());
					// PLSQL_DMLParser.g:432:37: ( COMMA column_name )*
					loop80:
					while (true) {
						int alt80=2;
						int LA80_0 = input.LA(1);
						if ( (LA80_0==COMMA) ) {
							alt80=1;
						}

						switch (alt80) {
						case 1 :
							// PLSQL_DMLParser.g:432:38: COMMA column_name
							{
							COMMA224=(Token)match(input,COMMA,FOLLOW_COMMA_in_unpivot_in_elements3468); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA224);

							pushFollow(FOLLOW_column_name_in_unpivot_in_elements3470);
							column_name225=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name225.getTree());
							}
							break;

						default :
							break loop80;
						}
					}

					RIGHT_PAREN226=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3474); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN226);

					}
					break;

			}

			// PLSQL_DMLParser.g:434:9: ( ( as_key )? ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
			int alt85=2;
			int LA85_0 = input.LA(1);
			if ( (LA85_0==APPROXIMATE_NUM_LIT||(LA85_0 >= CHAR_STRING && LA85_0 <= CHAR_STRING_PERL)||LA85_0==EXACT_NUM_LIT||LA85_0==LEFT_PAREN||LA85_0==MINUS_SIGN||LA85_0==NATIONAL_CHAR_STRING_LIT||LA85_0==REGULAR_ID||LA85_0==SQL92_RESERVED_AS||LA85_0==SQL92_RESERVED_DATE||LA85_0==SQL92_RESERVED_DEFAULT||LA85_0==SQL92_RESERVED_FALSE||LA85_0==SQL92_RESERVED_NULL||LA85_0==SQL92_RESERVED_TRUE||LA85_0==UNSIGNED_INTEGER) ) {
				alt85=1;
			}
			switch (alt85) {
				case 1 :
					// PLSQL_DMLParser.g:434:14: ( as_key )? ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
					{
					// PLSQL_DMLParser.g:434:14: ( as_key )?
					int alt82=2;
					int LA82_0 = input.LA(1);
					if ( (LA82_0==SQL92_RESERVED_AS) ) {
						alt82=1;
					}
					switch (alt82) {
						case 1 :
							// PLSQL_DMLParser.g:434:14: as_key
							{
							pushFollow(FOLLOW_as_key_in_unpivot_in_elements3499);
							as_key227=gPLSQLParser.as_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_as_key.add(as_key227.getTree());
							}
							break;

					}

					// PLSQL_DMLParser.g:435:9: ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
					int alt84=2;
					int LA84_0 = input.LA(1);
					if ( (LA84_0==APPROXIMATE_NUM_LIT||(LA84_0 >= CHAR_STRING && LA84_0 <= CHAR_STRING_PERL)||LA84_0==EXACT_NUM_LIT||LA84_0==MINUS_SIGN||LA84_0==NATIONAL_CHAR_STRING_LIT||LA84_0==REGULAR_ID||LA84_0==SQL92_RESERVED_DATE||LA84_0==SQL92_RESERVED_DEFAULT||LA84_0==SQL92_RESERVED_FALSE||LA84_0==SQL92_RESERVED_NULL||LA84_0==SQL92_RESERVED_TRUE||LA84_0==UNSIGNED_INTEGER) ) {
						alt84=1;
					}
					else if ( (LA84_0==LEFT_PAREN) && (synpred11_PLSQL_DMLParser())) {
						alt84=2;
					}

					switch (alt84) {
						case 1 :
							// PLSQL_DMLParser.g:435:14: constant
							{
							pushFollow(FOLLOW_constant_in_unpivot_in_elements3515);
							constant228=gPLSQLParser.constant();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_constant.add(constant228.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:436:14: ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN
							{
							LEFT_PAREN229=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_unpivot_in_elements3535); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN229);

							pushFollow(FOLLOW_constant_in_unpivot_in_elements3537);
							constant230=gPLSQLParser.constant();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_constant.add(constant230.getTree());
							// PLSQL_DMLParser.g:436:49: ( COMMA constant )*
							loop83:
							while (true) {
								int alt83=2;
								int LA83_0 = input.LA(1);
								if ( (LA83_0==COMMA) ) {
									alt83=1;
								}

								switch (alt83) {
								case 1 :
									// PLSQL_DMLParser.g:436:50: COMMA constant
									{
									COMMA231=(Token)match(input,COMMA,FOLLOW_COMMA_in_unpivot_in_elements3540); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_COMMA.add(COMMA231);

									pushFollow(FOLLOW_constant_in_unpivot_in_elements3542);
									constant232=gPLSQLParser.constant();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_constant.add(constant232.getTree());
									}
									break;

								default :
									break loop83;
								}
							}

							RIGHT_PAREN233=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3546); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN233);

							}
							break;

					}

					}
					break;

			}

			// AST REWRITE
			// elements: column_name, constant
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 439:9: -> ( column_name )+ ^( PIVOT_ALIAS ( constant )+ )
			{
				if ( !(stream_column_name.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_0, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				// PLSQL_DMLParser.g:439:25: ^( PIVOT_ALIAS ( constant )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PIVOT_ALIAS, "PIVOT_ALIAS"), root_1);
				if ( !(stream_constant.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_constant.hasNext() ) {
					adaptor.addChild(root_1, stream_constant.nextTree());
				}
				stream_constant.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unpivot_in_elements"


	public static class hierarchical_query_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "hierarchical_query_clause"
	// PLSQL_DMLParser.g:442:1: hierarchical_query_clause : ( connect_key by_key ( nocycle_key )? condition ( start_part )? -> ^( HIERARCHICAL ( start_part )? ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) | start_part connect_key by_key ( nocycle_key )? condition -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) );
	public final PLSQLParser_PLSQL_DMLParser.hierarchical_query_clause_return hierarchical_query_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.hierarchical_query_clause_return retval = new PLSQLParser_PLSQL_DMLParser.hierarchical_query_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope connect_key234 =null;
		ParserRuleReturnScope by_key235 =null;
		ParserRuleReturnScope nocycle_key236 =null;
		ParserRuleReturnScope condition237 =null;
		ParserRuleReturnScope start_part238 =null;
		ParserRuleReturnScope start_part239 =null;
		ParserRuleReturnScope connect_key240 =null;
		ParserRuleReturnScope by_key241 =null;
		ParserRuleReturnScope nocycle_key242 =null;
		ParserRuleReturnScope condition243 =null;

		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_by_key=new RewriteRuleSubtreeStream(adaptor,"rule by_key");
		RewriteRuleSubtreeStream stream_nocycle_key=new RewriteRuleSubtreeStream(adaptor,"rule nocycle_key");
		RewriteRuleSubtreeStream stream_start_part=new RewriteRuleSubtreeStream(adaptor,"rule start_part");
		RewriteRuleSubtreeStream stream_connect_key=new RewriteRuleSubtreeStream(adaptor,"rule connect_key");

		try {
			// PLSQL_DMLParser.g:443:5: ( connect_key by_key ( nocycle_key )? condition ( start_part )? -> ^( HIERARCHICAL ( start_part )? ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) | start_part connect_key by_key ( nocycle_key )? condition -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) ) )
			int alt89=2;
			int LA89_0 = input.LA(1);
			if ( (LA89_0==SQL92_RESERVED_CONNECT) ) {
				alt89=1;
			}
			else if ( (LA89_0==PLSQL_RESERVED_START) ) {
				alt89=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 89, 0, input);
				throw nvae;
			}

			switch (alt89) {
				case 1 :
					// PLSQL_DMLParser.g:443:10: connect_key by_key ( nocycle_key )? condition ( start_part )?
					{
					pushFollow(FOLLOW_connect_key_in_hierarchical_query_clause3607);
					connect_key234=gPLSQLParser.connect_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_connect_key.add(connect_key234.getTree());
					pushFollow(FOLLOW_by_key_in_hierarchical_query_clause3609);
					by_key235=gPLSQLParser.by_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_by_key.add(by_key235.getTree());
					// PLSQL_DMLParser.g:443:29: ( nocycle_key )?
					int alt86=2;
					int LA86_0 = input.LA(1);
					if ( (LA86_0==REGULAR_ID) ) {
						int LA86_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("nocycle"))) ) {
							alt86=1;
						}
					}
					switch (alt86) {
						case 1 :
							// PLSQL_DMLParser.g:443:29: nocycle_key
							{
							pushFollow(FOLLOW_nocycle_key_in_hierarchical_query_clause3611);
							nocycle_key236=gPLSQLParser.nocycle_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_nocycle_key.add(nocycle_key236.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_condition_in_hierarchical_query_clause3614);
					condition237=condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_condition.add(condition237.getTree());
					// PLSQL_DMLParser.g:443:52: ( start_part )?
					int alt87=2;
					int LA87_0 = input.LA(1);
					if ( (LA87_0==PLSQL_RESERVED_START) ) {
						alt87=1;
					}
					switch (alt87) {
						case 1 :
							// PLSQL_DMLParser.g:443:52: start_part
							{
							pushFollow(FOLLOW_start_part_in_hierarchical_query_clause3616);
							start_part238=start_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_start_part.add(start_part238.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: connect_key, start_part, condition, nocycle_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 444:9: -> ^( HIERARCHICAL ( start_part )? ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
					{
						// PLSQL_DMLParser.g:444:12: ^( HIERARCHICAL ( start_part )? ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(HIERARCHICAL, "HIERARCHICAL"), root_1);
						// PLSQL_DMLParser.g:444:27: ( start_part )?
						if ( stream_start_part.hasNext() ) {
							adaptor.addChild(root_1, stream_start_part.nextTree());
						}
						stream_start_part.reset();

						// PLSQL_DMLParser.g:444:39: ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot(stream_connect_key.nextNode(), root_2);
						// PLSQL_DMLParser.g:444:53: ( nocycle_key )?
						if ( stream_nocycle_key.hasNext() ) {
							adaptor.addChild(root_2, stream_nocycle_key.nextTree());
						}
						stream_nocycle_key.reset();

						// PLSQL_DMLParser.g:444:66: ^( LOGIC_EXPR condition )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
						adaptor.addChild(root_3, stream_condition.nextTree());
						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:445:10: start_part connect_key by_key ( nocycle_key )? condition
					{
					pushFollow(FOLLOW_start_part_in_hierarchical_query_clause3658);
					start_part239=start_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_start_part.add(start_part239.getTree());
					pushFollow(FOLLOW_connect_key_in_hierarchical_query_clause3660);
					connect_key240=gPLSQLParser.connect_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_connect_key.add(connect_key240.getTree());
					pushFollow(FOLLOW_by_key_in_hierarchical_query_clause3662);
					by_key241=gPLSQLParser.by_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_by_key.add(by_key241.getTree());
					// PLSQL_DMLParser.g:445:40: ( nocycle_key )?
					int alt88=2;
					int LA88_0 = input.LA(1);
					if ( (LA88_0==REGULAR_ID) ) {
						int LA88_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("nocycle"))) ) {
							alt88=1;
						}
					}
					switch (alt88) {
						case 1 :
							// PLSQL_DMLParser.g:445:40: nocycle_key
							{
							pushFollow(FOLLOW_nocycle_key_in_hierarchical_query_clause3664);
							nocycle_key242=gPLSQLParser.nocycle_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_nocycle_key.add(nocycle_key242.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_condition_in_hierarchical_query_clause3667);
					condition243=condition();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_condition.add(condition243.getTree());
					// AST REWRITE
					// elements: start_part, connect_key, nocycle_key, condition
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 446:9: -> ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
					{
						// PLSQL_DMLParser.g:446:12: ^( HIERARCHICAL start_part ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(HIERARCHICAL, "HIERARCHICAL"), root_1);
						adaptor.addChild(root_1, stream_start_part.nextTree());
						// PLSQL_DMLParser.g:446:38: ^( connect_key ( nocycle_key )? ^( LOGIC_EXPR condition ) )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot(stream_connect_key.nextNode(), root_2);
						// PLSQL_DMLParser.g:446:52: ( nocycle_key )?
						if ( stream_nocycle_key.hasNext() ) {
							adaptor.addChild(root_2, stream_nocycle_key.nextTree());
						}
						stream_nocycle_key.reset();

						// PLSQL_DMLParser.g:446:65: ^( LOGIC_EXPR condition )
						{
						Object root_3 = (Object)adaptor.nil();
						root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
						adaptor.addChild(root_3, stream_condition.nextTree());
						adaptor.addChild(root_2, root_3);
						}

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "hierarchical_query_clause"


	public static class start_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "start_part"
	// PLSQL_DMLParser.g:449:1: start_part : start_key with_key condition -> ^( start_key ^( LOGIC_EXPR condition ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.start_part_return start_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.start_part_return retval = new PLSQLParser_PLSQL_DMLParser.start_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope start_key244 =null;
		ParserRuleReturnScope with_key245 =null;
		ParserRuleReturnScope condition246 =null;

		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_with_key=new RewriteRuleSubtreeStream(adaptor,"rule with_key");
		RewriteRuleSubtreeStream stream_start_key=new RewriteRuleSubtreeStream(adaptor,"rule start_key");

		try {
			// PLSQL_DMLParser.g:450:5: ( start_key with_key condition -> ^( start_key ^( LOGIC_EXPR condition ) ) )
			// PLSQL_DMLParser.g:450:10: start_key with_key condition
			{
			pushFollow(FOLLOW_start_key_in_start_part3716);
			start_key244=gPLSQLParser.start_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_start_key.add(start_key244.getTree());
			pushFollow(FOLLOW_with_key_in_start_part3718);
			with_key245=gPLSQLParser.with_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_with_key.add(with_key245.getTree());
			pushFollow(FOLLOW_condition_in_start_part3720);
			condition246=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition246.getTree());
			// AST REWRITE
			// elements: start_key, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 451:9: -> ^( start_key ^( LOGIC_EXPR condition ) )
			{
				// PLSQL_DMLParser.g:451:12: ^( start_key ^( LOGIC_EXPR condition ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_start_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:451:24: ^( LOGIC_EXPR condition )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
				adaptor.addChild(root_2, stream_condition.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "start_part"


	public static class group_by_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "group_by_clause"
	// PLSQL_DMLParser.g:454:1: group_by_clause : ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? -> ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ( having_clause )? ) | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? -> ^( group_key having_clause ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ) );
	public final PLSQLParser_PLSQL_DMLParser.group_by_clause_return group_by_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.group_by_clause_return retval = new PLSQLParser_PLSQL_DMLParser.group_by_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA250=null;
		Token COMMA257=null;
		ParserRuleReturnScope group_key247 =null;
		ParserRuleReturnScope by_key248 =null;
		ParserRuleReturnScope group_by_elements249 =null;
		ParserRuleReturnScope group_by_elements251 =null;
		ParserRuleReturnScope having_clause252 =null;
		ParserRuleReturnScope having_clause253 =null;
		ParserRuleReturnScope group_key254 =null;
		ParserRuleReturnScope by_key255 =null;
		ParserRuleReturnScope group_by_elements256 =null;
		ParserRuleReturnScope group_by_elements258 =null;

		Object COMMA250_tree=null;
		Object COMMA257_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_by_key=new RewriteRuleSubtreeStream(adaptor,"rule by_key");
		RewriteRuleSubtreeStream stream_group_by_elements=new RewriteRuleSubtreeStream(adaptor,"rule group_by_elements");
		RewriteRuleSubtreeStream stream_having_clause=new RewriteRuleSubtreeStream(adaptor,"rule having_clause");
		RewriteRuleSubtreeStream stream_group_key=new RewriteRuleSubtreeStream(adaptor,"rule group_key");

		try {
			// PLSQL_DMLParser.g:455:5: ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? -> ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ( having_clause )? ) | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? -> ^( group_key having_clause ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ) )
			int alt94=2;
			int LA94_0 = input.LA(1);
			if ( (LA94_0==SQL92_RESERVED_GROUP) && (synpred12_PLSQL_DMLParser())) {
				alt94=1;
			}
			else if ( (LA94_0==SQL92_RESERVED_HAVING) && (synpred14_PLSQL_DMLParser())) {
				alt94=2;
			}

			switch (alt94) {
				case 1 :
					// PLSQL_DMLParser.g:455:10: ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )?
					{
					pushFollow(FOLLOW_group_key_in_group_by_clause3766);
					group_key247=gPLSQLParser.group_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_group_key.add(group_key247.getTree());
					pushFollow(FOLLOW_by_key_in_group_by_clause3768);
					by_key248=gPLSQLParser.by_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_by_key.add(by_key248.getTree());
					pushFollow(FOLLOW_group_by_elements_in_group_by_clause3770);
					group_by_elements249=group_by_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_group_by_elements.add(group_by_elements249.getTree());
					// PLSQL_DMLParser.g:455:60: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
					loop90:
					while (true) {
						int alt90=2;
						int LA90_0 = input.LA(1);
						if ( (LA90_0==COMMA) ) {
							int LA90_2 = input.LA(2);
							if ( (synpred13_PLSQL_DMLParser()) ) {
								alt90=1;
							}

						}

						switch (alt90) {
						case 1 :
							// PLSQL_DMLParser.g:455:61: ( COMMA group_by_elements )=> COMMA group_by_elements
							{
							COMMA250=(Token)match(input,COMMA,FOLLOW_COMMA_in_group_by_clause3780); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA250);

							pushFollow(FOLLOW_group_by_elements_in_group_by_clause3782);
							group_by_elements251=group_by_elements();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_group_by_elements.add(group_by_elements251.getTree());
							}
							break;

						default :
							break loop90;
						}
					}

					// PLSQL_DMLParser.g:455:115: ( having_clause )?
					int alt91=2;
					int LA91_0 = input.LA(1);
					if ( (LA91_0==SQL92_RESERVED_HAVING) ) {
						alt91=1;
					}
					switch (alt91) {
						case 1 :
							// PLSQL_DMLParser.g:455:115: having_clause
							{
							pushFollow(FOLLOW_having_clause_in_group_by_clause3786);
							having_clause252=having_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_having_clause.add(having_clause252.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: group_key, having_clause, group_by_elements
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 456:10: -> ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ( having_clause )? )
					{
						// PLSQL_DMLParser.g:456:13: ^( group_key ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ ( having_clause )? )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_group_key.nextNode(), root_1);
						if ( !(stream_group_by_elements.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_group_by_elements.hasNext() ) {
							// PLSQL_DMLParser.g:456:25: ^( GROUP_BY_ELEMENT group_by_elements )
							{
							Object root_2 = (Object)adaptor.nil();
							root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(GROUP_BY_ELEMENT, "GROUP_BY_ELEMENT"), root_2);
							adaptor.addChild(root_2, stream_group_by_elements.nextTree());
							adaptor.addChild(root_1, root_2);
							}

						}
						stream_group_by_elements.reset();

						// PLSQL_DMLParser.g:456:64: ( having_clause )?
						if ( stream_having_clause.hasNext() ) {
							adaptor.addChild(root_1, stream_having_clause.nextTree());
						}
						stream_having_clause.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:457:10: ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
					{
					pushFollow(FOLLOW_having_clause_in_group_by_clause3829);
					having_clause253=having_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_having_clause.add(having_clause253.getTree());
					// PLSQL_DMLParser.g:457:40: ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
					int alt93=2;
					int LA93_0 = input.LA(1);
					if ( (LA93_0==SQL92_RESERVED_GROUP) ) {
						alt93=1;
					}
					switch (alt93) {
						case 1 :
							// PLSQL_DMLParser.g:457:41: group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
							{
							pushFollow(FOLLOW_group_key_in_group_by_clause3832);
							group_key254=gPLSQLParser.group_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_group_key.add(group_key254.getTree());
							pushFollow(FOLLOW_by_key_in_group_by_clause3834);
							by_key255=gPLSQLParser.by_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_by_key.add(by_key255.getTree());
							pushFollow(FOLLOW_group_by_elements_in_group_by_clause3836);
							group_by_elements256=group_by_elements();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_group_by_elements.add(group_by_elements256.getTree());
							// PLSQL_DMLParser.g:457:76: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
							loop92:
							while (true) {
								int alt92=2;
								int LA92_0 = input.LA(1);
								if ( (LA92_0==COMMA) ) {
									int LA92_2 = input.LA(2);
									if ( (synpred15_PLSQL_DMLParser()) ) {
										alt92=1;
									}

								}

								switch (alt92) {
								case 1 :
									// PLSQL_DMLParser.g:457:77: ( COMMA group_by_elements )=> COMMA group_by_elements
									{
									COMMA257=(Token)match(input,COMMA,FOLLOW_COMMA_in_group_by_clause3846); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_COMMA.add(COMMA257);

									pushFollow(FOLLOW_group_by_elements_in_group_by_clause3848);
									group_by_elements258=group_by_elements();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_group_by_elements.add(group_by_elements258.getTree());
									}
									break;

								default :
									break loop92;
								}
							}

							}
							break;

					}

					// AST REWRITE
					// elements: group_key, having_clause, group_by_elements
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 458:10: -> ^( group_key having_clause ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ )
					{
						// PLSQL_DMLParser.g:458:13: ^( group_key having_clause ( ^( GROUP_BY_ELEMENT group_by_elements ) )+ )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_group_key.nextNode(), root_1);
						adaptor.addChild(root_1, stream_having_clause.nextTree());
						if ( !(stream_group_by_elements.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_group_by_elements.hasNext() ) {
							// PLSQL_DMLParser.g:458:39: ^( GROUP_BY_ELEMENT group_by_elements )
							{
							Object root_2 = (Object)adaptor.nil();
							root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(GROUP_BY_ELEMENT, "GROUP_BY_ELEMENT"), root_2);
							adaptor.addChild(root_2, stream_group_by_elements.nextTree());
							adaptor.addChild(root_1, root_2);
							}

						}
						stream_group_by_elements.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "group_by_clause"


	public static class group_by_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "group_by_elements"
	// PLSQL_DMLParser.g:461:1: group_by_elements : ( grouping_sets_clause | rollup_cube_clause | expression -> ^( EXPR expression ) );
	public final PLSQLParser_PLSQL_DMLParser.group_by_elements_return group_by_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.group_by_elements_return retval = new PLSQLParser_PLSQL_DMLParser.group_by_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope grouping_sets_clause259 =null;
		ParserRuleReturnScope rollup_cube_clause260 =null;
		ParserRuleReturnScope expression261 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:462:5: ( grouping_sets_clause | rollup_cube_clause | expression -> ^( EXPR expression ) )
			int alt95=3;
			int LA95_0 = input.LA(1);
			if ( (LA95_0==REGULAR_ID) ) {
				int LA95_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("grouping"))) ) {
					alt95=1;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("cube"))||(input.LT(1).getText().equalsIgnoreCase("rollup")))) ) {
					alt95=2;
				}
				else if ( (true) ) {
					alt95=3;
				}

			}
			else if ( (LA95_0==APPROXIMATE_NUM_LIT||LA95_0==BINDVAR||(LA95_0 >= CHAR_STRING && LA95_0 <= COLON)||LA95_0==DELIMITED_ID||LA95_0==EXACT_NUM_LIT||LA95_0==INTRODUCER||LA95_0==LEFT_PAREN||LA95_0==MINUS_SIGN||LA95_0==NATIONAL_CHAR_STRING_LIT||LA95_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA95_0==PLUS_SIGN||LA95_0==SQL92_RESERVED_ALL||LA95_0==SQL92_RESERVED_ANY||LA95_0==SQL92_RESERVED_CASE||(LA95_0 >= SQL92_RESERVED_CURSOR && LA95_0 <= SQL92_RESERVED_DATE)||(LA95_0 >= SQL92_RESERVED_DEFAULT && LA95_0 <= SQL92_RESERVED_DELETE)||LA95_0==SQL92_RESERVED_DISTINCT||(LA95_0 >= SQL92_RESERVED_EXISTS && LA95_0 <= SQL92_RESERVED_FALSE)||(LA95_0 >= SQL92_RESERVED_NOT && LA95_0 <= SQL92_RESERVED_NULL)||LA95_0==SQL92_RESERVED_PRIOR||LA95_0==SQL92_RESERVED_TRUE||LA95_0==UNSIGNED_INTEGER) ) {
				alt95=3;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 95, 0, input);
				throw nvae;
			}

			switch (alt95) {
				case 1 :
					// PLSQL_DMLParser.g:462:10: grouping_sets_clause
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_grouping_sets_clause_in_group_by_elements3896);
					grouping_sets_clause259=grouping_sets_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, grouping_sets_clause259.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:463:10: rollup_cube_clause
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_rollup_cube_clause_in_group_by_elements3907);
					rollup_cube_clause260=rollup_cube_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rollup_cube_clause260.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:464:10: expression
					{
					pushFollow(FOLLOW_expression_in_group_by_elements3919);
					expression261=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression261.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 464:21: -> ^( EXPR expression )
					{
						// PLSQL_DMLParser.g:464:24: ^( EXPR expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "group_by_elements"


	public static class rollup_cube_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rollup_cube_clause"
	// PLSQL_DMLParser.g:467:1: rollup_cube_clause : ( rollup_key ^| cube_key ^) LEFT_PAREN ! grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN !;
	public final PLSQLParser_PLSQL_DMLParser.rollup_cube_clause_return rollup_cube_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.rollup_cube_clause_return retval = new PLSQLParser_PLSQL_DMLParser.rollup_cube_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN264=null;
		Token COMMA266=null;
		Token RIGHT_PAREN268=null;
		ParserRuleReturnScope rollup_key262 =null;
		ParserRuleReturnScope cube_key263 =null;
		ParserRuleReturnScope grouping_sets_elements265 =null;
		ParserRuleReturnScope grouping_sets_elements267 =null;

		Object LEFT_PAREN264_tree=null;
		Object COMMA266_tree=null;
		Object RIGHT_PAREN268_tree=null;

		try {
			// PLSQL_DMLParser.g:468:5: ( ( rollup_key ^| cube_key ^) LEFT_PAREN ! grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN !)
			// PLSQL_DMLParser.g:468:10: ( rollup_key ^| cube_key ^) LEFT_PAREN ! grouping_sets_elements ( COMMA ! grouping_sets_elements )* RIGHT_PAREN !
			{
			root_0 = (Object)adaptor.nil();


			// PLSQL_DMLParser.g:468:10: ( rollup_key ^| cube_key ^)
			int alt96=2;
			int LA96_0 = input.LA(1);
			if ( (LA96_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("cube"))||(input.LT(1).getText().equalsIgnoreCase("rollup"))))) {
				int LA96_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("rollup"))) ) {
					alt96=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("cube"))) ) {
					alt96=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 96, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt96) {
				case 1 :
					// PLSQL_DMLParser.g:468:11: rollup_key ^
					{
					pushFollow(FOLLOW_rollup_key_in_rollup_cube_clause3948);
					rollup_key262=gPLSQLParser.rollup_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(rollup_key262.getTree(), root_0);
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:468:23: cube_key ^
					{
					pushFollow(FOLLOW_cube_key_in_rollup_cube_clause3951);
					cube_key263=gPLSQLParser.cube_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(cube_key263.getTree(), root_0);
					}
					break;

			}

			LEFT_PAREN264=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_rollup_cube_clause3955); if (state.failed) return retval;
			pushFollow(FOLLOW_grouping_sets_elements_in_rollup_cube_clause3958);
			grouping_sets_elements265=grouping_sets_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, grouping_sets_elements265.getTree());

			// PLSQL_DMLParser.g:468:69: ( COMMA ! grouping_sets_elements )*
			loop97:
			while (true) {
				int alt97=2;
				int LA97_0 = input.LA(1);
				if ( (LA97_0==COMMA) ) {
					alt97=1;
				}

				switch (alt97) {
				case 1 :
					// PLSQL_DMLParser.g:468:70: COMMA ! grouping_sets_elements
					{
					COMMA266=(Token)match(input,COMMA,FOLLOW_COMMA_in_rollup_cube_clause3961); if (state.failed) return retval;
					pushFollow(FOLLOW_grouping_sets_elements_in_rollup_cube_clause3964);
					grouping_sets_elements267=grouping_sets_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, grouping_sets_elements267.getTree());

					}
					break;

				default :
					break loop97;
				}
			}

			RIGHT_PAREN268=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_rollup_cube_clause3968); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rollup_cube_clause"


	public static class grouping_sets_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "grouping_sets_clause"
	// PLSQL_DMLParser.g:471:1: grouping_sets_clause : grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.grouping_sets_clause_return grouping_sets_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.grouping_sets_clause_return retval = new PLSQLParser_PLSQL_DMLParser.grouping_sets_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN271=null;
		Token COMMA273=null;
		Token RIGHT_PAREN275=null;
		ParserRuleReturnScope grouping_key269 =null;
		ParserRuleReturnScope sets_key270 =null;
		ParserRuleReturnScope grouping_sets_elements272 =null;
		ParserRuleReturnScope grouping_sets_elements274 =null;

		Object LEFT_PAREN271_tree=null;
		Object COMMA273_tree=null;
		Object RIGHT_PAREN275_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_sets_key=new RewriteRuleSubtreeStream(adaptor,"rule sets_key");
		RewriteRuleSubtreeStream stream_grouping_sets_elements=new RewriteRuleSubtreeStream(adaptor,"rule grouping_sets_elements");
		RewriteRuleSubtreeStream stream_grouping_key=new RewriteRuleSubtreeStream(adaptor,"rule grouping_key");

		try {
			// PLSQL_DMLParser.g:472:5: ( grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ ) )
			// PLSQL_DMLParser.g:472:10: grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
			{
			pushFollow(FOLLOW_grouping_key_in_grouping_sets_clause3990);
			grouping_key269=gPLSQLParser.grouping_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_grouping_key.add(grouping_key269.getTree());
			pushFollow(FOLLOW_sets_key_in_grouping_sets_clause3992);
			sets_key270=gPLSQLParser.sets_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_sets_key.add(sets_key270.getTree());
			LEFT_PAREN271=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_grouping_sets_clause4003); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN271);

			pushFollow(FOLLOW_grouping_sets_elements_in_grouping_sets_clause4005);
			grouping_sets_elements272=grouping_sets_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_grouping_sets_elements.add(grouping_sets_elements272.getTree());
			// PLSQL_DMLParser.g:473:43: ( COMMA grouping_sets_elements )*
			loop98:
			while (true) {
				int alt98=2;
				int LA98_0 = input.LA(1);
				if ( (LA98_0==COMMA) ) {
					alt98=1;
				}

				switch (alt98) {
				case 1 :
					// PLSQL_DMLParser.g:473:44: COMMA grouping_sets_elements
					{
					COMMA273=(Token)match(input,COMMA,FOLLOW_COMMA_in_grouping_sets_clause4008); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA273);

					pushFollow(FOLLOW_grouping_sets_elements_in_grouping_sets_clause4010);
					grouping_sets_elements274=grouping_sets_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_grouping_sets_elements.add(grouping_sets_elements274.getTree());
					}
					break;

				default :
					break loop98;
				}
			}

			RIGHT_PAREN275=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4014); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN275);

			// AST REWRITE
			// elements: grouping_sets_elements, grouping_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 474:9: -> ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ )
			{
				// PLSQL_DMLParser.g:474:12: ^( grouping_key ( ^( GROUPIN_SET grouping_sets_elements ) )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_grouping_key.nextNode(), root_1);
				if ( !(stream_grouping_sets_elements.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_grouping_sets_elements.hasNext() ) {
					// PLSQL_DMLParser.g:474:27: ^( GROUPIN_SET grouping_sets_elements )
					{
					Object root_2 = (Object)adaptor.nil();
					root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(GROUPIN_SET, "GROUPIN_SET"), root_2);
					adaptor.addChild(root_2, stream_grouping_sets_elements.nextTree());
					adaptor.addChild(root_1, root_2);
					}

				}
				stream_grouping_sets_elements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "grouping_sets_clause"


	public static class grouping_sets_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "grouping_sets_elements"
	// PLSQL_DMLParser.g:477:1: grouping_sets_elements : ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression -> ^( EXPR expression ) );
	public final PLSQLParser_PLSQL_DMLParser.grouping_sets_elements_return grouping_sets_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.grouping_sets_elements_return retval = new PLSQLParser_PLSQL_DMLParser.grouping_sets_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope rollup_cube_clause276 =null;
		ParserRuleReturnScope expression_list277 =null;
		ParserRuleReturnScope expression278 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:478:5: ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression -> ^( EXPR expression ) )
			int alt99=3;
			switch ( input.LA(1) ) {
			case REGULAR_ID:
				{
				int LA99_1 = input.LA(2);
				if ( ((((input.LT(1).getText().equalsIgnoreCase("cube"))||(input.LT(1).getText().equalsIgnoreCase("rollup")))&&synpred16_PLSQL_DMLParser())) ) {
					alt99=1;
				}
				else if ( (true) ) {
					alt99=3;
				}

				}
				break;
			case LEFT_PAREN:
				{
				int LA99_2 = input.LA(2);
				if ( (synpred17_PLSQL_DMLParser()) ) {
					alt99=2;
				}
				else if ( (true) ) {
					alt99=3;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case BINDVAR:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case COLON:
			case DELIMITED_ID:
			case EXACT_NUM_LIT:
			case INTRODUCER:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_CASE:
			case SQL92_RESERVED_CURSOR:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DELETE:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_EXISTS:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NOT:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_PRIOR:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt99=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 99, 0, input);
				throw nvae;
			}
			switch (alt99) {
				case 1 :
					// PLSQL_DMLParser.g:478:10: ( rollup_key | cube_key )=> rollup_cube_clause
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_rollup_cube_clause_in_grouping_sets_elements4062);
					rollup_cube_clause276=rollup_cube_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rollup_cube_clause276.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:479:10: ( LEFT_PAREN )=> expression_list
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_expression_list_in_grouping_sets_elements4078);
					expression_list277=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list277.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:480:10: expression
					{
					pushFollow(FOLLOW_expression_in_grouping_sets_elements4089);
					expression278=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression278.getTree());
					// AST REWRITE
					// elements: expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 480:21: -> ^( EXPR expression )
					{
						// PLSQL_DMLParser.g:480:24: ^( EXPR expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "grouping_sets_elements"


	public static class having_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "having_clause"
	// PLSQL_DMLParser.g:483:1: having_clause : having_key condition -> ^( having_key ^( LOGIC_EXPR condition ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.having_clause_return having_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.having_clause_return retval = new PLSQLParser_PLSQL_DMLParser.having_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope having_key279 =null;
		ParserRuleReturnScope condition280 =null;

		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_having_key=new RewriteRuleSubtreeStream(adaptor,"rule having_key");

		try {
			// PLSQL_DMLParser.g:484:5: ( having_key condition -> ^( having_key ^( LOGIC_EXPR condition ) ) )
			// PLSQL_DMLParser.g:484:10: having_key condition
			{
			pushFollow(FOLLOW_having_key_in_having_clause4117);
			having_key279=gPLSQLParser.having_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_having_key.add(having_key279.getTree());
			pushFollow(FOLLOW_condition_in_having_clause4119);
			condition280=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition280.getTree());
			// AST REWRITE
			// elements: having_key, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 485:9: -> ^( having_key ^( LOGIC_EXPR condition ) )
			{
				// PLSQL_DMLParser.g:485:12: ^( having_key ^( LOGIC_EXPR condition ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_having_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:485:25: ^( LOGIC_EXPR condition )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
				adaptor.addChild(root_2, stream_condition.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "having_clause"


	public static class model_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_clause"
	// PLSQL_DMLParser.g:488:1: model_clause : model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model -> ^( model_key main_model ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_clause_return model_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_clause_return retval = new PLSQLParser_PLSQL_DMLParser.model_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope model_key281 =null;
		ParserRuleReturnScope cell_reference_options282 =null;
		ParserRuleReturnScope return_rows_clause283 =null;
		ParserRuleReturnScope reference_model284 =null;
		ParserRuleReturnScope main_model285 =null;

		RewriteRuleSubtreeStream stream_model_key=new RewriteRuleSubtreeStream(adaptor,"rule model_key");
		RewriteRuleSubtreeStream stream_cell_reference_options=new RewriteRuleSubtreeStream(adaptor,"rule cell_reference_options");
		RewriteRuleSubtreeStream stream_reference_model=new RewriteRuleSubtreeStream(adaptor,"rule reference_model");
		RewriteRuleSubtreeStream stream_return_rows_clause=new RewriteRuleSubtreeStream(adaptor,"rule return_rows_clause");
		RewriteRuleSubtreeStream stream_main_model=new RewriteRuleSubtreeStream(adaptor,"rule main_model");

		try {
			// PLSQL_DMLParser.g:489:5: ( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model -> ^( model_key main_model ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* ) )
			// PLSQL_DMLParser.g:489:10: model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model
			{
			pushFollow(FOLLOW_model_key_in_model_clause4159);
			model_key281=gPLSQLParser.model_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_key.add(model_key281.getTree());
			// PLSQL_DMLParser.g:489:20: ( cell_reference_options )*
			loop100:
			while (true) {
				int alt100=2;
				int LA100_0 = input.LA(1);
				if ( (LA100_0==REGULAR_ID) ) {
					int LA100_1 = input.LA(2);
					if ( (LA100_1==REGULAR_ID) ) {
						int LA100_3 = input.LA(3);
						if ( (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("ignore")))) ) {
							alt100=1;
						}

					}

				}
				else if ( (LA100_0==SQL92_RESERVED_UNIQUE) ) {
					alt100=1;
				}

				switch (alt100) {
				case 1 :
					// PLSQL_DMLParser.g:489:20: cell_reference_options
					{
					pushFollow(FOLLOW_cell_reference_options_in_model_clause4161);
					cell_reference_options282=cell_reference_options();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cell_reference_options.add(cell_reference_options282.getTree());
					}
					break;

				default :
					break loop100;
				}
			}

			// PLSQL_DMLParser.g:489:44: ( return_rows_clause )?
			int alt101=2;
			int LA101_0 = input.LA(1);
			if ( (LA101_0==REGULAR_ID) ) {
				int LA101_1 = input.LA(2);
				if ( (LA101_1==REGULAR_ID) ) {
					int LA101_2 = input.LA(3);
					if ( (LA101_2==REGULAR_ID) ) {
						int LA101_6 = input.LA(4);
						if ( (LA101_6==REGULAR_ID) ) {
							alt101=1;
						}
					}
				}
				else if ( (LA101_1==SQL92_RESERVED_ALL) ) {
					alt101=1;
				}
			}
			switch (alt101) {
				case 1 :
					// PLSQL_DMLParser.g:489:44: return_rows_clause
					{
					pushFollow(FOLLOW_return_rows_clause_in_model_clause4164);
					return_rows_clause283=return_rows_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_return_rows_clause.add(return_rows_clause283.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:489:64: ( reference_model )*
			loop102:
			while (true) {
				int alt102=2;
				alt102 = dfa102.predict(input);
				switch (alt102) {
				case 1 :
					// PLSQL_DMLParser.g:489:64: reference_model
					{
					pushFollow(FOLLOW_reference_model_in_model_clause4167);
					reference_model284=reference_model();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_reference_model.add(reference_model284.getTree());
					}
					break;

				default :
					break loop102;
				}
			}

			pushFollow(FOLLOW_main_model_in_model_clause4170);
			main_model285=main_model();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_main_model.add(main_model285.getTree());
			// AST REWRITE
			// elements: model_key, reference_model, return_rows_clause, cell_reference_options, main_model
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 490:9: -> ^( model_key main_model ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* )
			{
				// PLSQL_DMLParser.g:490:12: ^( model_key main_model ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_model_key.nextNode(), root_1);
				adaptor.addChild(root_1, stream_main_model.nextTree());
				// PLSQL_DMLParser.g:490:35: ( cell_reference_options )*
				while ( stream_cell_reference_options.hasNext() ) {
					adaptor.addChild(root_1, stream_cell_reference_options.nextTree());
				}
				stream_cell_reference_options.reset();

				// PLSQL_DMLParser.g:490:59: ( return_rows_clause )?
				if ( stream_return_rows_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_return_rows_clause.nextTree());
				}
				stream_return_rows_clause.reset();

				// PLSQL_DMLParser.g:490:79: ( reference_model )*
				while ( stream_reference_model.hasNext() ) {
					adaptor.addChild(root_1, stream_reference_model.nextTree());
				}
				stream_reference_model.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_clause"


	public static class cell_reference_options_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cell_reference_options"
	// PLSQL_DMLParser.g:493:1: cell_reference_options : ( ( ignore_key ^| keep_key ^) nav_key | unique_key ^ ( dimension_key | single_key reference_key !) );
	public final PLSQLParser_PLSQL_DMLParser.cell_reference_options_return cell_reference_options() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.cell_reference_options_return retval = new PLSQLParser_PLSQL_DMLParser.cell_reference_options_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope ignore_key286 =null;
		ParserRuleReturnScope keep_key287 =null;
		ParserRuleReturnScope nav_key288 =null;
		ParserRuleReturnScope unique_key289 =null;
		ParserRuleReturnScope dimension_key290 =null;
		ParserRuleReturnScope single_key291 =null;
		ParserRuleReturnScope reference_key292 =null;


		try {
			// PLSQL_DMLParser.g:494:5: ( ( ignore_key ^| keep_key ^) nav_key | unique_key ^ ( dimension_key | single_key reference_key !) )
			int alt105=2;
			int LA105_0 = input.LA(1);
			if ( (LA105_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
				alt105=1;
			}
			else if ( (LA105_0==SQL92_RESERVED_UNIQUE) ) {
				alt105=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 105, 0, input);
				throw nvae;
			}

			switch (alt105) {
				case 1 :
					// PLSQL_DMLParser.g:494:10: ( ignore_key ^| keep_key ^) nav_key
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:494:10: ( ignore_key ^| keep_key ^)
					int alt103=2;
					int LA103_0 = input.LA(1);
					if ( (LA103_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
						int LA103_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("ignore"))) ) {
							alt103=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("keep"))) ) {
							alt103=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 103, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt103) {
						case 1 :
							// PLSQL_DMLParser.g:494:11: ignore_key ^
							{
							pushFollow(FOLLOW_ignore_key_in_cell_reference_options4216);
							ignore_key286=gPLSQLParser.ignore_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(ignore_key286.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:494:23: keep_key ^
							{
							pushFollow(FOLLOW_keep_key_in_cell_reference_options4219);
							keep_key287=gPLSQLParser.keep_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(keep_key287.getTree(), root_0);
							}
							break;

					}

					pushFollow(FOLLOW_nav_key_in_cell_reference_options4223);
					nav_key288=gPLSQLParser.nav_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nav_key288.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:495:10: unique_key ^ ( dimension_key | single_key reference_key !)
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_unique_key_in_cell_reference_options4234);
					unique_key289=gPLSQLParser.unique_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(unique_key289.getTree(), root_0);
					// PLSQL_DMLParser.g:495:22: ( dimension_key | single_key reference_key !)
					int alt104=2;
					int LA104_0 = input.LA(1);
					if ( (LA104_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("single"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))))) {
						int LA104_1 = input.LA(2);
						if ( (LA104_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("single"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))))) {
							int LA104_2 = input.LA(3);
							if ( ((input.LT(1).getText().equalsIgnoreCase("dimension"))) ) {
								alt104=1;
							}
							else if ( ((input.LT(1).getText().equalsIgnoreCase("single"))) ) {
								alt104=2;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 104, 2, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}
						else if ( (LA104_1==LEFT_PAREN||LA104_1==SQL92_RESERVED_UNIQUE) && ((input.LT(1).getText().equalsIgnoreCase("dimension")))) {
							alt104=1;
						}

					}

					switch (alt104) {
						case 1 :
							// PLSQL_DMLParser.g:495:23: dimension_key
							{
							pushFollow(FOLLOW_dimension_key_in_cell_reference_options4238);
							dimension_key290=gPLSQLParser.dimension_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, dimension_key290.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:495:37: single_key reference_key !
							{
							pushFollow(FOLLOW_single_key_in_cell_reference_options4240);
							single_key291=gPLSQLParser.single_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, single_key291.getTree());

							pushFollow(FOLLOW_reference_key_in_cell_reference_options4242);
							reference_key292=gPLSQLParser.reference_key();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cell_reference_options"


	public static class return_rows_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "return_rows_clause"
	// PLSQL_DMLParser.g:498:1: return_rows_clause : return_key ^ ( updated_key | all_key ) rows_key !;
	public final PLSQLParser_PLSQL_DMLParser.return_rows_clause_return return_rows_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.return_rows_clause_return retval = new PLSQLParser_PLSQL_DMLParser.return_rows_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope return_key293 =null;
		ParserRuleReturnScope updated_key294 =null;
		ParserRuleReturnScope all_key295 =null;
		ParserRuleReturnScope rows_key296 =null;


		try {
			// PLSQL_DMLParser.g:499:5: ( return_key ^ ( updated_key | all_key ) rows_key !)
			// PLSQL_DMLParser.g:499:10: return_key ^ ( updated_key | all_key ) rows_key !
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_return_key_in_return_rows_clause4265);
			return_key293=gPLSQLParser.return_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(return_key293.getTree(), root_0);
			// PLSQL_DMLParser.g:499:22: ( updated_key | all_key )
			int alt106=2;
			int LA106_0 = input.LA(1);
			if ( (LA106_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("updated")))) {
				alt106=1;
			}
			else if ( (LA106_0==SQL92_RESERVED_ALL) ) {
				alt106=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 106, 0, input);
				throw nvae;
			}

			switch (alt106) {
				case 1 :
					// PLSQL_DMLParser.g:499:23: updated_key
					{
					pushFollow(FOLLOW_updated_key_in_return_rows_clause4269);
					updated_key294=gPLSQLParser.updated_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, updated_key294.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:499:35: all_key
					{
					pushFollow(FOLLOW_all_key_in_return_rows_clause4271);
					all_key295=gPLSQLParser.all_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, all_key295.getTree());

					}
					break;

			}

			pushFollow(FOLLOW_rows_key_in_return_rows_clause4274);
			rows_key296=gPLSQLParser.rows_key();
			state._fsp--;
			if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "return_rows_clause"


	public static class reference_model_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "reference_model"
	// PLSQL_DMLParser.g:502:1: reference_model : reference_key ^ reference_model_name on_key ! LEFT_PAREN ! subquery RIGHT_PAREN ! model_column_clauses ( cell_reference_options )* ;
	public final PLSQLParser_PLSQL_DMLParser.reference_model_return reference_model() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.reference_model_return retval = new PLSQLParser_PLSQL_DMLParser.reference_model_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN300=null;
		Token RIGHT_PAREN302=null;
		ParserRuleReturnScope reference_key297 =null;
		ParserRuleReturnScope reference_model_name298 =null;
		ParserRuleReturnScope on_key299 =null;
		ParserRuleReturnScope subquery301 =null;
		ParserRuleReturnScope model_column_clauses303 =null;
		ParserRuleReturnScope cell_reference_options304 =null;

		Object LEFT_PAREN300_tree=null;
		Object RIGHT_PAREN302_tree=null;

		try {
			// PLSQL_DMLParser.g:503:5: ( reference_key ^ reference_model_name on_key ! LEFT_PAREN ! subquery RIGHT_PAREN ! model_column_clauses ( cell_reference_options )* )
			// PLSQL_DMLParser.g:503:10: reference_key ^ reference_model_name on_key ! LEFT_PAREN ! subquery RIGHT_PAREN ! model_column_clauses ( cell_reference_options )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_reference_key_in_reference_model4295);
			reference_key297=gPLSQLParser.reference_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(reference_key297.getTree(), root_0);
			pushFollow(FOLLOW_reference_model_name_in_reference_model4298);
			reference_model_name298=gPLSQLParser.reference_model_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, reference_model_name298.getTree());

			pushFollow(FOLLOW_on_key_in_reference_model4300);
			on_key299=gPLSQLParser.on_key();
			state._fsp--;
			if (state.failed) return retval;
			LEFT_PAREN300=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_reference_model4316); if (state.failed) return retval;
			pushFollow(FOLLOW_subquery_in_reference_model4319);
			subquery301=subquery();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery301.getTree());

			RIGHT_PAREN302=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_reference_model4321); if (state.failed) return retval;
			pushFollow(FOLLOW_model_column_clauses_in_reference_model4324);
			model_column_clauses303=model_column_clauses();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, model_column_clauses303.getTree());

			// PLSQL_DMLParser.g:505:13: ( cell_reference_options )*
			loop107:
			while (true) {
				int alt107=2;
				int LA107_0 = input.LA(1);
				if ( (LA107_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))||(input.LT(1).getText().equalsIgnoreCase("reference"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
					int LA107_1 = input.LA(2);
					if ( (LA107_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
						int LA107_4 = input.LA(3);
						if ( (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("ignore")))) ) {
							alt107=1;
						}

					}

				}
				else if ( (LA107_0==SQL92_RESERVED_UNIQUE) ) {
					alt107=1;
				}

				switch (alt107) {
				case 1 :
					// PLSQL_DMLParser.g:505:13: cell_reference_options
					{
					pushFollow(FOLLOW_cell_reference_options_in_reference_model4339);
					cell_reference_options304=cell_reference_options();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, cell_reference_options304.getTree());

					}
					break;

				default :
					break loop107;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "reference_model"


	public static class main_model_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "main_model"
	// PLSQL_DMLParser.g:508:1: main_model : ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses model_rules_clause ( cell_reference_options )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.main_model_return main_model() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.main_model_return retval = new PLSQLParser_PLSQL_DMLParser.main_model_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope main_key305 =null;
		ParserRuleReturnScope main_model_name306 =null;
		ParserRuleReturnScope model_column_clauses307 =null;
		ParserRuleReturnScope cell_reference_options308 =null;
		ParserRuleReturnScope model_rules_clause309 =null;

		RewriteRuleSubtreeStream stream_cell_reference_options=new RewriteRuleSubtreeStream(adaptor,"rule cell_reference_options");
		RewriteRuleSubtreeStream stream_model_rules_clause=new RewriteRuleSubtreeStream(adaptor,"rule model_rules_clause");
		RewriteRuleSubtreeStream stream_main_model_name=new RewriteRuleSubtreeStream(adaptor,"rule main_model_name");
		RewriteRuleSubtreeStream stream_model_column_clauses=new RewriteRuleSubtreeStream(adaptor,"rule model_column_clauses");
		RewriteRuleSubtreeStream stream_main_key=new RewriteRuleSubtreeStream(adaptor,"rule main_key");

		try {
			// PLSQL_DMLParser.g:509:5: ( ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses model_rules_clause ( cell_reference_options )* ) )
			// PLSQL_DMLParser.g:509:10: ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause
			{
			// PLSQL_DMLParser.g:509:10: ( main_key main_model_name )?
			int alt108=2;
			int LA108_0 = input.LA(1);
			if ( (LA108_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))))) {
				int LA108_1 = input.LA(2);
				if ( (LA108_1==DELIMITED_ID||LA108_1==INTRODUCER||LA108_1==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("main")))) {
					alt108=1;
				}
			}
			switch (alt108) {
				case 1 :
					// PLSQL_DMLParser.g:509:11: main_key main_model_name
					{
					pushFollow(FOLLOW_main_key_in_main_model4361);
					main_key305=gPLSQLParser.main_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_main_key.add(main_key305.getTree());
					pushFollow(FOLLOW_main_model_name_in_main_model4363);
					main_model_name306=gPLSQLParser.main_model_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_main_model_name.add(main_model_name306.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_model_column_clauses_in_main_model4367);
			model_column_clauses307=model_column_clauses();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_column_clauses.add(model_column_clauses307.getTree());
			// PLSQL_DMLParser.g:509:59: ( cell_reference_options )*
			loop109:
			while (true) {
				int alt109=2;
				int LA109_0 = input.LA(1);
				if ( (LA109_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("rules"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
					int LA109_1 = input.LA(2);
					if ( (LA109_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("rules"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
						int LA109_5 = input.LA(3);
						if ( (((input.LT(1).getText().equalsIgnoreCase("keep"))||(input.LT(1).getText().equalsIgnoreCase("ignore")))) ) {
							alt109=1;
						}

					}

				}
				else if ( (LA109_0==SQL92_RESERVED_UNIQUE) ) {
					alt109=1;
				}

				switch (alt109) {
				case 1 :
					// PLSQL_DMLParser.g:509:59: cell_reference_options
					{
					pushFollow(FOLLOW_cell_reference_options_in_main_model4369);
					cell_reference_options308=cell_reference_options();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_cell_reference_options.add(cell_reference_options308.getTree());
					}
					break;

				default :
					break loop109;
				}
			}

			pushFollow(FOLLOW_model_rules_clause_in_main_model4372);
			model_rules_clause309=model_rules_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_rules_clause.add(model_rules_clause309.getTree());
			// AST REWRITE
			// elements: cell_reference_options, main_model_name, model_column_clauses, model_rules_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 510:9: -> ^( MAIN_MODEL ( main_model_name )? model_column_clauses model_rules_clause ( cell_reference_options )* )
			{
				// PLSQL_DMLParser.g:510:12: ^( MAIN_MODEL ( main_model_name )? model_column_clauses model_rules_clause ( cell_reference_options )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MAIN_MODEL, "MAIN_MODEL"), root_1);
				// PLSQL_DMLParser.g:510:25: ( main_model_name )?
				if ( stream_main_model_name.hasNext() ) {
					adaptor.addChild(root_1, stream_main_model_name.nextTree());
				}
				stream_main_model_name.reset();

				adaptor.addChild(root_1, stream_model_column_clauses.nextTree());
				adaptor.addChild(root_1, stream_model_rules_clause.nextTree());
				// PLSQL_DMLParser.g:510:82: ( cell_reference_options )*
				while ( stream_cell_reference_options.hasNext() ) {
					adaptor.addChild(root_1, stream_cell_reference_options.nextTree());
				}
				stream_cell_reference_options.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "main_model"


	public static class model_column_clauses_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_column_clauses"
	// PLSQL_DMLParser.g:513:1: model_column_clauses : ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list -> ^( MODEL_COLUMN ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ( model_column_partition_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_column_clauses_return model_column_clauses() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_column_clauses_return retval = new PLSQLParser_PLSQL_DMLParser.model_column_clauses_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope model_column_partition_part310 =null;
		ParserRuleReturnScope dimension_key311 =null;
		ParserRuleReturnScope by_key312 =null;
		ParserRuleReturnScope model_column_list313 =null;
		ParserRuleReturnScope measures_key314 =null;
		ParserRuleReturnScope model_column_list315 =null;

		RewriteRuleSubtreeStream stream_dimension_key=new RewriteRuleSubtreeStream(adaptor,"rule dimension_key");
		RewriteRuleSubtreeStream stream_model_column_list=new RewriteRuleSubtreeStream(adaptor,"rule model_column_list");
		RewriteRuleSubtreeStream stream_by_key=new RewriteRuleSubtreeStream(adaptor,"rule by_key");
		RewriteRuleSubtreeStream stream_model_column_partition_part=new RewriteRuleSubtreeStream(adaptor,"rule model_column_partition_part");
		RewriteRuleSubtreeStream stream_measures_key=new RewriteRuleSubtreeStream(adaptor,"rule measures_key");

		try {
			// PLSQL_DMLParser.g:514:5: ( ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list -> ^( MODEL_COLUMN ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ( model_column_partition_part )? ) )
			// PLSQL_DMLParser.g:514:10: ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list
			{
			// PLSQL_DMLParser.g:514:10: ( model_column_partition_part )?
			int alt110=2;
			int LA110_0 = input.LA(1);
			if ( (LA110_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))))) {
				int LA110_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("partition"))) ) {
					alt110=1;
				}
			}
			switch (alt110) {
				case 1 :
					// PLSQL_DMLParser.g:514:10: model_column_partition_part
					{
					pushFollow(FOLLOW_model_column_partition_part_in_model_column_clauses4416);
					model_column_partition_part310=model_column_partition_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_column_partition_part.add(model_column_partition_part310.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_dimension_key_in_model_column_clauses4427);
			dimension_key311=gPLSQLParser.dimension_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_dimension_key.add(dimension_key311.getTree());
			pushFollow(FOLLOW_by_key_in_model_column_clauses4429);
			by_key312=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_by_key.add(by_key312.getTree());
			pushFollow(FOLLOW_model_column_list_in_model_column_clauses4431);
			model_column_list313=model_column_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_column_list.add(model_column_list313.getTree());
			pushFollow(FOLLOW_measures_key_in_model_column_clauses4433);
			measures_key314=gPLSQLParser.measures_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_measures_key.add(measures_key314.getTree());
			pushFollow(FOLLOW_model_column_list_in_model_column_clauses4435);
			model_column_list315=model_column_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_column_list.add(model_column_list315.getTree());
			// AST REWRITE
			// elements: model_column_list, dimension_key, model_column_list, model_column_partition_part, measures_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 516:9: -> ^( MODEL_COLUMN ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ( model_column_partition_part )? )
			{
				// PLSQL_DMLParser.g:516:12: ^( MODEL_COLUMN ^( dimension_key model_column_list ) ^( measures_key model_column_list ) ( model_column_partition_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_COLUMN, "MODEL_COLUMN"), root_1);
				// PLSQL_DMLParser.g:516:27: ^( dimension_key model_column_list )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_dimension_key.nextNode(), root_2);
				adaptor.addChild(root_2, stream_model_column_list.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:516:62: ^( measures_key model_column_list )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_measures_key.nextNode(), root_2);
				adaptor.addChild(root_2, stream_model_column_list.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:516:96: ( model_column_partition_part )?
				if ( stream_model_column_partition_part.hasNext() ) {
					adaptor.addChild(root_1, stream_model_column_partition_part.nextTree());
				}
				stream_model_column_partition_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_column_clauses"


	public static class model_column_partition_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_column_partition_part"
	// PLSQL_DMLParser.g:519:1: model_column_partition_part : partition_key ^ by_key ! model_column_list ;
	public final PLSQLParser_PLSQL_DMLParser.model_column_partition_part_return model_column_partition_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_column_partition_part_return retval = new PLSQLParser_PLSQL_DMLParser.model_column_partition_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope partition_key316 =null;
		ParserRuleReturnScope by_key317 =null;
		ParserRuleReturnScope model_column_list318 =null;


		try {
			// PLSQL_DMLParser.g:520:5: ( partition_key ^ by_key ! model_column_list )
			// PLSQL_DMLParser.g:520:10: partition_key ^ by_key ! model_column_list
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_partition_key_in_model_column_partition_part4484);
			partition_key316=gPLSQLParser.partition_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(partition_key316.getTree(), root_0);
			pushFollow(FOLLOW_by_key_in_model_column_partition_part4487);
			by_key317=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_model_column_list_in_model_column_partition_part4490);
			model_column_list318=model_column_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, model_column_list318.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_column_partition_part"


	public static class model_column_list_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_column_list"
	// PLSQL_DMLParser.g:523:1: model_column_list : LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN -> ^( MODEL_COLUMNS ( model_column )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_column_list_return model_column_list() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_column_list_return retval = new PLSQLParser_PLSQL_DMLParser.model_column_list_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN319=null;
		Token COMMA321=null;
		Token RIGHT_PAREN323=null;
		ParserRuleReturnScope model_column320 =null;
		ParserRuleReturnScope model_column322 =null;

		Object LEFT_PAREN319_tree=null;
		Object COMMA321_tree=null;
		Object RIGHT_PAREN323_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_model_column=new RewriteRuleSubtreeStream(adaptor,"rule model_column");

		try {
			// PLSQL_DMLParser.g:524:5: ( LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN -> ^( MODEL_COLUMNS ( model_column )+ ) )
			// PLSQL_DMLParser.g:524:10: LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN
			{
			LEFT_PAREN319=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_model_column_list4510); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN319);

			pushFollow(FOLLOW_model_column_in_model_column_list4512);
			model_column320=model_column();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_column.add(model_column320.getTree());
			// PLSQL_DMLParser.g:524:34: ( COMMA model_column )*
			loop111:
			while (true) {
				int alt111=2;
				int LA111_0 = input.LA(1);
				if ( (LA111_0==COMMA) ) {
					alt111=1;
				}

				switch (alt111) {
				case 1 :
					// PLSQL_DMLParser.g:524:35: COMMA model_column
					{
					COMMA321=(Token)match(input,COMMA,FOLLOW_COMMA_in_model_column_list4515); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA321);

					pushFollow(FOLLOW_model_column_in_model_column_list4517);
					model_column322=model_column();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_column.add(model_column322.getTree());
					}
					break;

				default :
					break loop111;
				}
			}

			RIGHT_PAREN323=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_model_column_list4522); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN323);

			// AST REWRITE
			// elements: model_column
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 525:9: -> ^( MODEL_COLUMNS ( model_column )+ )
			{
				// PLSQL_DMLParser.g:525:12: ^( MODEL_COLUMNS ( model_column )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_COLUMNS, "MODEL_COLUMNS"), root_1);
				if ( !(stream_model_column.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_model_column.hasNext() ) {
					adaptor.addChild(root_1, stream_model_column.nextTree());
				}
				stream_model_column.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_column_list"


	public static class model_column_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_column"
	// PLSQL_DMLParser.g:528:1: model_column : expression ( table_alias )? -> ^( MODEL_COLUMN ( table_alias )? ^( EXPR expression ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_column_return model_column() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_column_return retval = new PLSQLParser_PLSQL_DMLParser.model_column_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression324 =null;
		ParserRuleReturnScope table_alias325 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_table_alias=new RewriteRuleSubtreeStream(adaptor,"rule table_alias");

		try {
			// PLSQL_DMLParser.g:529:5: ( expression ( table_alias )? -> ^( MODEL_COLUMN ( table_alias )? ^( EXPR expression ) ) )
			// PLSQL_DMLParser.g:529:10: expression ( table_alias )?
			{
			pushFollow(FOLLOW_expression_in_model_column4559);
			expression324=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression324.getTree());
			// PLSQL_DMLParser.g:529:21: ( table_alias )?
			int alt112=2;
			int LA112_0 = input.LA(1);
			if ( ((LA112_0 >= CHAR_STRING && LA112_0 <= CHAR_STRING_PERL)||LA112_0==DELIMITED_ID||LA112_0==INTRODUCER||LA112_0==NATIONAL_CHAR_STRING_LIT||LA112_0==REGULAR_ID) ) {
				alt112=1;
			}
			switch (alt112) {
				case 1 :
					// PLSQL_DMLParser.g:529:21: table_alias
					{
					pushFollow(FOLLOW_table_alias_in_model_column4561);
					table_alias325=gPLSQLParser.table_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_alias.add(table_alias325.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: expression, table_alias
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 530:9: -> ^( MODEL_COLUMN ( table_alias )? ^( EXPR expression ) )
			{
				// PLSQL_DMLParser.g:530:12: ^( MODEL_COLUMN ( table_alias )? ^( EXPR expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_COLUMN, "MODEL_COLUMN"), root_1);
				// PLSQL_DMLParser.g:530:27: ( table_alias )?
				if ( stream_table_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_table_alias.nextTree());
				}
				stream_table_alias.reset();

				// PLSQL_DMLParser.g:530:40: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_column"


	public static class model_rules_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_rules_clause"
	// PLSQL_DMLParser.g:533:1: model_rules_clause : ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN -> ^( MODEL_RULES ( model_rules_element )+ ( model_rules_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_rules_clause_return model_rules_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_rules_clause_return retval = new PLSQLParser_PLSQL_DMLParser.model_rules_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN327=null;
		Token COMMA329=null;
		Token RIGHT_PAREN331=null;
		ParserRuleReturnScope model_rules_part326 =null;
		ParserRuleReturnScope model_rules_element328 =null;
		ParserRuleReturnScope model_rules_element330 =null;

		Object LEFT_PAREN327_tree=null;
		Object COMMA329_tree=null;
		Object RIGHT_PAREN331_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_model_rules_part=new RewriteRuleSubtreeStream(adaptor,"rule model_rules_part");
		RewriteRuleSubtreeStream stream_model_rules_element=new RewriteRuleSubtreeStream(adaptor,"rule model_rules_element");

		try {
			// PLSQL_DMLParser.g:534:5: ( ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN -> ^( MODEL_RULES ( model_rules_element )+ ( model_rules_part )? ) )
			// PLSQL_DMLParser.g:534:10: ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN
			{
			// PLSQL_DMLParser.g:534:10: ( model_rules_part )?
			int alt113=2;
			int LA113_0 = input.LA(1);
			if ( (LA113_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("rules")))) {
				alt113=1;
			}
			switch (alt113) {
				case 1 :
					// PLSQL_DMLParser.g:534:10: model_rules_part
					{
					pushFollow(FOLLOW_model_rules_part_in_model_rules_clause4605);
					model_rules_part326=model_rules_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_rules_part.add(model_rules_part326.getTree());
					}
					break;

			}

			LEFT_PAREN327=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_model_rules_clause4608); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN327);

			pushFollow(FOLLOW_model_rules_element_in_model_rules_clause4610);
			model_rules_element328=model_rules_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_rules_element.add(model_rules_element328.getTree());
			// PLSQL_DMLParser.g:534:59: ( COMMA model_rules_element )*
			loop114:
			while (true) {
				int alt114=2;
				int LA114_0 = input.LA(1);
				if ( (LA114_0==COMMA) ) {
					alt114=1;
				}

				switch (alt114) {
				case 1 :
					// PLSQL_DMLParser.g:534:60: COMMA model_rules_element
					{
					COMMA329=(Token)match(input,COMMA,FOLLOW_COMMA_in_model_rules_clause4613); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA329);

					pushFollow(FOLLOW_model_rules_element_in_model_rules_clause4615);
					model_rules_element330=model_rules_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_rules_element.add(model_rules_element330.getTree());
					}
					break;

				default :
					break loop114;
				}
			}

			RIGHT_PAREN331=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_model_rules_clause4619); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN331);

			// AST REWRITE
			// elements: model_rules_part, model_rules_element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 535:9: -> ^( MODEL_RULES ( model_rules_element )+ ( model_rules_part )? )
			{
				// PLSQL_DMLParser.g:535:12: ^( MODEL_RULES ( model_rules_element )+ ( model_rules_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_RULES, "MODEL_RULES"), root_1);
				if ( !(stream_model_rules_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_model_rules_element.hasNext() ) {
					adaptor.addChild(root_1, stream_model_rules_element.nextTree());
				}
				stream_model_rules_element.reset();

				// PLSQL_DMLParser.g:535:47: ( model_rules_part )?
				if ( stream_model_rules_part.hasNext() ) {
					adaptor.addChild(root_1, stream_model_rules_part.nextTree());
				}
				stream_model_rules_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_rules_clause"


	public static class model_rules_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_rules_part"
	// PLSQL_DMLParser.g:538:1: model_rules_part : rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_rules_part_return model_rules_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_rules_part_return retval = new PLSQLParser_PLSQL_DMLParser.model_rules_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope rules_key332 =null;
		ParserRuleReturnScope update_key333 =null;
		ParserRuleReturnScope upsert_key334 =null;
		ParserRuleReturnScope all_key335 =null;
		ParserRuleReturnScope automatic_key336 =null;
		ParserRuleReturnScope sequential_key337 =null;
		ParserRuleReturnScope order_key338 =null;
		ParserRuleReturnScope model_iterate_clause339 =null;

		RewriteRuleSubtreeStream stream_sequential_key=new RewriteRuleSubtreeStream(adaptor,"rule sequential_key");
		RewriteRuleSubtreeStream stream_order_key=new RewriteRuleSubtreeStream(adaptor,"rule order_key");
		RewriteRuleSubtreeStream stream_all_key=new RewriteRuleSubtreeStream(adaptor,"rule all_key");
		RewriteRuleSubtreeStream stream_update_key=new RewriteRuleSubtreeStream(adaptor,"rule update_key");
		RewriteRuleSubtreeStream stream_automatic_key=new RewriteRuleSubtreeStream(adaptor,"rule automatic_key");
		RewriteRuleSubtreeStream stream_rules_key=new RewriteRuleSubtreeStream(adaptor,"rule rules_key");
		RewriteRuleSubtreeStream stream_upsert_key=new RewriteRuleSubtreeStream(adaptor,"rule upsert_key");
		RewriteRuleSubtreeStream stream_model_iterate_clause=new RewriteRuleSubtreeStream(adaptor,"rule model_iterate_clause");

		try {
			// PLSQL_DMLParser.g:539:5: ( rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? ) )
			// PLSQL_DMLParser.g:539:10: rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )?
			{
			pushFollow(FOLLOW_rules_key_in_model_rules_part4659);
			rules_key332=gPLSQLParser.rules_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_rules_key.add(rules_key332.getTree());
			// PLSQL_DMLParser.g:539:20: ( update_key | upsert_key ( all_key )? )?
			int alt116=3;
			int LA116_0 = input.LA(1);
			if ( (LA116_0==SQL92_RESERVED_UPDATE) ) {
				alt116=1;
			}
			else if ( (LA116_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("sequential"))||(input.LT(1).getText().equalsIgnoreCase("iterate"))||(input.LT(1).getText().equalsIgnoreCase("upsert"))||(input.LT(1).getText().equalsIgnoreCase("automatic"))))) {
				int LA116_2 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("upsert"))) ) {
					alt116=2;
				}
			}
			switch (alt116) {
				case 1 :
					// PLSQL_DMLParser.g:539:21: update_key
					{
					pushFollow(FOLLOW_update_key_in_model_rules_part4662);
					update_key333=gPLSQLParser.update_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_update_key.add(update_key333.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:539:32: upsert_key ( all_key )?
					{
					pushFollow(FOLLOW_upsert_key_in_model_rules_part4664);
					upsert_key334=gPLSQLParser.upsert_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_upsert_key.add(upsert_key334.getTree());
					// PLSQL_DMLParser.g:539:43: ( all_key )?
					int alt115=2;
					int LA115_0 = input.LA(1);
					if ( (LA115_0==SQL92_RESERVED_ALL) ) {
						alt115=1;
					}
					switch (alt115) {
						case 1 :
							// PLSQL_DMLParser.g:539:43: all_key
							{
							pushFollow(FOLLOW_all_key_in_model_rules_part4666);
							all_key335=gPLSQLParser.all_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_all_key.add(all_key335.getTree());
							}
							break;

					}

					}
					break;

			}

			// PLSQL_DMLParser.g:539:54: ( ( automatic_key | sequential_key ) order_key )?
			int alt118=2;
			int LA118_0 = input.LA(1);
			if ( (LA118_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("sequential"))||(input.LT(1).getText().equalsIgnoreCase("iterate"))||(input.LT(1).getText().equalsIgnoreCase("automatic"))))) {
				int LA118_1 = input.LA(2);
				if ( (LA118_1==SQL92_RESERVED_ORDER) && (((input.LT(1).getText().equalsIgnoreCase("sequential"))||(input.LT(1).getText().equalsIgnoreCase("automatic"))))) {
					alt118=1;
				}
			}
			switch (alt118) {
				case 1 :
					// PLSQL_DMLParser.g:539:55: ( automatic_key | sequential_key ) order_key
					{
					// PLSQL_DMLParser.g:539:55: ( automatic_key | sequential_key )
					int alt117=2;
					int LA117_0 = input.LA(1);
					if ( (LA117_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("sequential"))||(input.LT(1).getText().equalsIgnoreCase("automatic"))))) {
						int LA117_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("automatic"))) ) {
							alt117=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("sequential"))) ) {
							alt117=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 117, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt117) {
						case 1 :
							// PLSQL_DMLParser.g:539:56: automatic_key
							{
							pushFollow(FOLLOW_automatic_key_in_model_rules_part4673);
							automatic_key336=gPLSQLParser.automatic_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_automatic_key.add(automatic_key336.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:539:70: sequential_key
							{
							pushFollow(FOLLOW_sequential_key_in_model_rules_part4675);
							sequential_key337=gPLSQLParser.sequential_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_sequential_key.add(sequential_key337.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_order_key_in_model_rules_part4678);
					order_key338=gPLSQLParser.order_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_order_key.add(order_key338.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:539:98: ( model_iterate_clause )?
			int alt119=2;
			int LA119_0 = input.LA(1);
			if ( (LA119_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("iterate")))) {
				alt119=1;
			}
			switch (alt119) {
				case 1 :
					// PLSQL_DMLParser.g:539:98: model_iterate_clause
					{
					pushFollow(FOLLOW_model_iterate_clause_in_model_rules_part4682);
					model_iterate_clause339=model_iterate_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_iterate_clause.add(model_iterate_clause339.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: all_key, sequential_key, automatic_key, update_key, model_iterate_clause, rules_key, upsert_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 540:9: -> ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? )
			{
				// PLSQL_DMLParser.g:540:12: ^( rules_key ( update_key )? ( upsert_key )? ( all_key )? ( automatic_key )? ( sequential_key )? ( model_iterate_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_rules_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:540:24: ( update_key )?
				if ( stream_update_key.hasNext() ) {
					adaptor.addChild(root_1, stream_update_key.nextTree());
				}
				stream_update_key.reset();

				// PLSQL_DMLParser.g:540:36: ( upsert_key )?
				if ( stream_upsert_key.hasNext() ) {
					adaptor.addChild(root_1, stream_upsert_key.nextTree());
				}
				stream_upsert_key.reset();

				// PLSQL_DMLParser.g:540:48: ( all_key )?
				if ( stream_all_key.hasNext() ) {
					adaptor.addChild(root_1, stream_all_key.nextTree());
				}
				stream_all_key.reset();

				// PLSQL_DMLParser.g:540:57: ( automatic_key )?
				if ( stream_automatic_key.hasNext() ) {
					adaptor.addChild(root_1, stream_automatic_key.nextTree());
				}
				stream_automatic_key.reset();

				// PLSQL_DMLParser.g:540:72: ( sequential_key )?
				if ( stream_sequential_key.hasNext() ) {
					adaptor.addChild(root_1, stream_sequential_key.nextTree());
				}
				stream_sequential_key.reset();

				// PLSQL_DMLParser.g:540:88: ( model_iterate_clause )?
				if ( stream_model_iterate_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_model_iterate_clause.nextTree());
				}
				stream_model_iterate_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_rules_part"


	public static class model_rules_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_rules_element"
	// PLSQL_DMLParser.g:543:1: model_rules_element : ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_rules_element_return model_rules_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_rules_element_return retval = new PLSQLParser_PLSQL_DMLParser.model_rules_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP345=null;
		ParserRuleReturnScope update_key340 =null;
		ParserRuleReturnScope upsert_key341 =null;
		ParserRuleReturnScope all_key342 =null;
		ParserRuleReturnScope cell_assignment343 =null;
		ParserRuleReturnScope order_by_clause344 =null;
		ParserRuleReturnScope expression346 =null;

		Object EQUALS_OP345_tree=null;
		RewriteRuleTokenStream stream_EQUALS_OP=new RewriteRuleTokenStream(adaptor,"token EQUALS_OP");
		RewriteRuleSubtreeStream stream_order_by_clause=new RewriteRuleSubtreeStream(adaptor,"rule order_by_clause");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_all_key=new RewriteRuleSubtreeStream(adaptor,"rule all_key");
		RewriteRuleSubtreeStream stream_cell_assignment=new RewriteRuleSubtreeStream(adaptor,"rule cell_assignment");
		RewriteRuleSubtreeStream stream_update_key=new RewriteRuleSubtreeStream(adaptor,"rule update_key");
		RewriteRuleSubtreeStream stream_upsert_key=new RewriteRuleSubtreeStream(adaptor,"rule upsert_key");

		try {
			// PLSQL_DMLParser.g:544:5: ( ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? ) )
			// PLSQL_DMLParser.g:544:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression
			{
			// PLSQL_DMLParser.g:544:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )?
			int alt121=3;
			int LA121_0 = input.LA(1);
			if ( (LA121_0==SQL92_RESERVED_UPDATE) ) {
				alt121=1;
			}
			else if ( (LA121_0==REGULAR_ID) ) {
				int LA121_2 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("upsert"))) ) {
					alt121=2;
				}
			}
			switch (alt121) {
				case 1 :
					// PLSQL_DMLParser.g:544:11: update_key
					{
					pushFollow(FOLLOW_update_key_in_model_rules_element4736);
					update_key340=gPLSQLParser.update_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_update_key.add(update_key340.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:544:22: upsert_key ( ( all_key )=> all_key )?
					{
					pushFollow(FOLLOW_upsert_key_in_model_rules_element4738);
					upsert_key341=gPLSQLParser.upsert_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_upsert_key.add(upsert_key341.getTree());
					// PLSQL_DMLParser.g:544:33: ( ( all_key )=> all_key )?
					int alt120=2;
					int LA120_0 = input.LA(1);
					if ( (LA120_0==SQL92_RESERVED_ALL) ) {
						int LA120_1 = input.LA(2);
						if ( (synpred18_PLSQL_DMLParser()) ) {
							alt120=1;
						}
					}
					switch (alt120) {
						case 1 :
							// PLSQL_DMLParser.g:544:34: ( all_key )=> all_key
							{
							pushFollow(FOLLOW_all_key_in_model_rules_element4746);
							all_key342=gPLSQLParser.all_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_all_key.add(all_key342.getTree());
							}
							break;

					}

					}
					break;

			}

			pushFollow(FOLLOW_cell_assignment_in_model_rules_element4760);
			cell_assignment343=cell_assignment();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_cell_assignment.add(cell_assignment343.getTree());
			// PLSQL_DMLParser.g:546:17: ( order_by_clause )?
			int alt122=2;
			int LA122_0 = input.LA(1);
			if ( (LA122_0==SQL92_RESERVED_ORDER) ) {
				alt122=1;
			}
			switch (alt122) {
				case 1 :
					// PLSQL_DMLParser.g:546:17: order_by_clause
					{
					pushFollow(FOLLOW_order_by_clause_in_model_rules_element4778);
					order_by_clause344=order_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_order_by_clause.add(order_by_clause344.getTree());
					}
					break;

			}

			EQUALS_OP345=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_model_rules_element4793); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP345);

			pushFollow(FOLLOW_expression_in_model_rules_element4795);
			expression346=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression346.getTree());
			// AST REWRITE
			// elements: cell_assignment, order_by_clause, upsert_key, update_key, expression, all_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 548:9: -> ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? )
			{
				// PLSQL_DMLParser.g:548:12: ^( MODEL_RULE ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) ) ( update_key )? ( upsert_key )? ( all_key )? ( order_by_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_RULE, "MODEL_RULE"), root_1);
				// PLSQL_DMLParser.g:548:25: ^( ASSIGN[$EQUALS_OP] cell_assignment ^( EXPR expression ) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASSIGN, EQUALS_OP345), root_2);
				adaptor.addChild(root_2, stream_cell_assignment.nextTree());
				// PLSQL_DMLParser.g:548:62: ^( EXPR expression )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_3);
				adaptor.addChild(root_3, stream_expression.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:548:82: ( update_key )?
				if ( stream_update_key.hasNext() ) {
					adaptor.addChild(root_1, stream_update_key.nextTree());
				}
				stream_update_key.reset();

				// PLSQL_DMLParser.g:548:94: ( upsert_key )?
				if ( stream_upsert_key.hasNext() ) {
					adaptor.addChild(root_1, stream_upsert_key.nextTree());
				}
				stream_upsert_key.reset();

				// PLSQL_DMLParser.g:548:106: ( all_key )?
				if ( stream_all_key.hasNext() ) {
					adaptor.addChild(root_1, stream_all_key.nextTree());
				}
				stream_all_key.reset();

				// PLSQL_DMLParser.g:548:115: ( order_by_clause )?
				if ( stream_order_by_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_order_by_clause.nextTree());
				}
				stream_order_by_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_rules_element"


	public static class cell_assignment_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cell_assignment"
	// PLSQL_DMLParser.g:551:1: cell_assignment : model_expression ;
	public final PLSQLParser_PLSQL_DMLParser.cell_assignment_return cell_assignment() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.cell_assignment_return retval = new PLSQLParser_PLSQL_DMLParser.cell_assignment_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope model_expression347 =null;


		try {
			// PLSQL_DMLParser.g:552:5: ( model_expression )
			// PLSQL_DMLParser.g:552:10: model_expression
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_model_expression_in_cell_assignment4854);
			model_expression347=model_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, model_expression347.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cell_assignment"


	public static class model_iterate_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_iterate_clause"
	// PLSQL_DMLParser.g:555:1: model_iterate_clause : iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? -> ^( iterate_key ^( EXPR expression ) ( until_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.model_iterate_clause_return model_iterate_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_iterate_clause_return retval = new PLSQLParser_PLSQL_DMLParser.model_iterate_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN349=null;
		Token RIGHT_PAREN351=null;
		ParserRuleReturnScope iterate_key348 =null;
		ParserRuleReturnScope expression350 =null;
		ParserRuleReturnScope until_part352 =null;

		Object LEFT_PAREN349_tree=null;
		Object RIGHT_PAREN351_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_until_part=new RewriteRuleSubtreeStream(adaptor,"rule until_part");
		RewriteRuleSubtreeStream stream_iterate_key=new RewriteRuleSubtreeStream(adaptor,"rule iterate_key");

		try {
			// PLSQL_DMLParser.g:556:5: ( iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? -> ^( iterate_key ^( EXPR expression ) ( until_part )? ) )
			// PLSQL_DMLParser.g:556:10: iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )?
			{
			pushFollow(FOLLOW_iterate_key_in_model_iterate_clause4874);
			iterate_key348=gPLSQLParser.iterate_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_iterate_key.add(iterate_key348.getTree());
			LEFT_PAREN349=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_model_iterate_clause4876); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN349);

			pushFollow(FOLLOW_expression_in_model_iterate_clause4878);
			expression350=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression350.getTree());
			RIGHT_PAREN351=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_model_iterate_clause4880); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN351);

			// PLSQL_DMLParser.g:556:56: ( until_part )?
			int alt123=2;
			int LA123_0 = input.LA(1);
			if ( (LA123_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("until")))) {
				alt123=1;
			}
			switch (alt123) {
				case 1 :
					// PLSQL_DMLParser.g:556:56: until_part
					{
					pushFollow(FOLLOW_until_part_in_model_iterate_clause4882);
					until_part352=until_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_until_part.add(until_part352.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: expression, iterate_key, until_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 557:9: -> ^( iterate_key ^( EXPR expression ) ( until_part )? )
			{
				// PLSQL_DMLParser.g:557:11: ^( iterate_key ^( EXPR expression ) ( until_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_iterate_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:557:25: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:557:44: ( until_part )?
				if ( stream_until_part.hasNext() ) {
					adaptor.addChild(root_1, stream_until_part.nextTree());
				}
				stream_until_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_iterate_clause"


	public static class until_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "until_part"
	// PLSQL_DMLParser.g:560:1: until_part : until_key LEFT_PAREN condition RIGHT_PAREN -> ^( until_key ^( LOGIC_EXPR condition ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.until_part_return until_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.until_part_return retval = new PLSQLParser_PLSQL_DMLParser.until_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN354=null;
		Token RIGHT_PAREN356=null;
		ParserRuleReturnScope until_key353 =null;
		ParserRuleReturnScope condition355 =null;

		Object LEFT_PAREN354_tree=null;
		Object RIGHT_PAREN356_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_until_key=new RewriteRuleSubtreeStream(adaptor,"rule until_key");

		try {
			// PLSQL_DMLParser.g:561:5: ( until_key LEFT_PAREN condition RIGHT_PAREN -> ^( until_key ^( LOGIC_EXPR condition ) ) )
			// PLSQL_DMLParser.g:561:10: until_key LEFT_PAREN condition RIGHT_PAREN
			{
			pushFollow(FOLLOW_until_key_in_until_part4925);
			until_key353=gPLSQLParser.until_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_until_key.add(until_key353.getTree());
			LEFT_PAREN354=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_until_part4927); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN354);

			pushFollow(FOLLOW_condition_in_until_part4929);
			condition355=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition355.getTree());
			RIGHT_PAREN356=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_until_part4931); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN356);

			// AST REWRITE
			// elements: until_key, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 562:9: -> ^( until_key ^( LOGIC_EXPR condition ) )
			{
				// PLSQL_DMLParser.g:562:12: ^( until_key ^( LOGIC_EXPR condition ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_until_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:562:24: ^( LOGIC_EXPR condition )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
				adaptor.addChild(root_2, stream_condition.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "until_part"


	public static class order_by_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "order_by_clause"
	// PLSQL_DMLParser.g:565:1: order_by_clause : order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.order_by_clause_return order_by_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.order_by_clause_return retval = new PLSQLParser_PLSQL_DMLParser.order_by_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA361=null;
		ParserRuleReturnScope order_key357 =null;
		ParserRuleReturnScope siblings_key358 =null;
		ParserRuleReturnScope by_key359 =null;
		ParserRuleReturnScope order_by_elements360 =null;
		ParserRuleReturnScope order_by_elements362 =null;

		Object COMMA361_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_order_key=new RewriteRuleSubtreeStream(adaptor,"rule order_key");
		RewriteRuleSubtreeStream stream_siblings_key=new RewriteRuleSubtreeStream(adaptor,"rule siblings_key");
		RewriteRuleSubtreeStream stream_by_key=new RewriteRuleSubtreeStream(adaptor,"rule by_key");
		RewriteRuleSubtreeStream stream_order_by_elements=new RewriteRuleSubtreeStream(adaptor,"rule order_by_elements");

		try {
			// PLSQL_DMLParser.g:566:5: ( order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) ) )
			// PLSQL_DMLParser.g:566:10: order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )*
			{
			pushFollow(FOLLOW_order_key_in_order_by_clause4971);
			order_key357=gPLSQLParser.order_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_order_key.add(order_key357.getTree());
			// PLSQL_DMLParser.g:566:20: ( siblings_key )?
			int alt124=2;
			int LA124_0 = input.LA(1);
			if ( (LA124_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("siblings")))) {
				alt124=1;
			}
			switch (alt124) {
				case 1 :
					// PLSQL_DMLParser.g:566:20: siblings_key
					{
					pushFollow(FOLLOW_siblings_key_in_order_by_clause4973);
					siblings_key358=gPLSQLParser.siblings_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_siblings_key.add(siblings_key358.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_by_key_in_order_by_clause4976);
			by_key359=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_by_key.add(by_key359.getTree());
			pushFollow(FOLLOW_order_by_elements_in_order_by_clause4978);
			order_by_elements360=order_by_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_order_by_elements.add(order_by_elements360.getTree());
			// PLSQL_DMLParser.g:566:59: ( COMMA order_by_elements )*
			loop125:
			while (true) {
				int alt125=2;
				int LA125_0 = input.LA(1);
				if ( (LA125_0==COMMA) ) {
					alt125=1;
				}

				switch (alt125) {
				case 1 :
					// PLSQL_DMLParser.g:566:60: COMMA order_by_elements
					{
					COMMA361=(Token)match(input,COMMA,FOLLOW_COMMA_in_order_by_clause4981); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA361);

					pushFollow(FOLLOW_order_by_elements_in_order_by_clause4983);
					order_by_elements362=order_by_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_order_by_elements.add(order_by_elements362.getTree());
					}
					break;

				default :
					break loop125;
				}
			}

			// AST REWRITE
			// elements: order_by_elements, siblings_key, order_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 567:9: -> ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) )
			{
				// PLSQL_DMLParser.g:567:12: ^( order_key ( siblings_key )? ^( ORDER_BY_ELEMENTS ( order_by_elements )+ ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_order_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:567:24: ( siblings_key )?
				if ( stream_siblings_key.hasNext() ) {
					adaptor.addChild(root_1, stream_siblings_key.nextTree());
				}
				stream_siblings_key.reset();

				// PLSQL_DMLParser.g:567:38: ^( ORDER_BY_ELEMENTS ( order_by_elements )+ )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ORDER_BY_ELEMENTS, "ORDER_BY_ELEMENTS"), root_2);
				if ( !(stream_order_by_elements.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_order_by_elements.hasNext() ) {
					adaptor.addChild(root_2, stream_order_by_elements.nextTree());
				}
				stream_order_by_elements.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "order_by_clause"


	public static class order_by_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "order_by_elements"
	// PLSQL_DMLParser.g:570:1: order_by_elements : expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.order_by_elements_return order_by_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.order_by_elements_return retval = new PLSQLParser_PLSQL_DMLParser.order_by_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression363 =null;
		ParserRuleReturnScope asc_key364 =null;
		ParserRuleReturnScope desc_key365 =null;
		ParserRuleReturnScope nulls_key366 =null;
		ParserRuleReturnScope first_key367 =null;
		ParserRuleReturnScope last_key368 =null;

		RewriteRuleSubtreeStream stream_nulls_key=new RewriteRuleSubtreeStream(adaptor,"rule nulls_key");
		RewriteRuleSubtreeStream stream_first_key=new RewriteRuleSubtreeStream(adaptor,"rule first_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_asc_key=new RewriteRuleSubtreeStream(adaptor,"rule asc_key");
		RewriteRuleSubtreeStream stream_desc_key=new RewriteRuleSubtreeStream(adaptor,"rule desc_key");
		RewriteRuleSubtreeStream stream_last_key=new RewriteRuleSubtreeStream(adaptor,"rule last_key");

		try {
			// PLSQL_DMLParser.g:571:5: ( expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? ) )
			// PLSQL_DMLParser.g:571:10: expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )?
			{
			pushFollow(FOLLOW_expression_in_order_by_elements5029);
			expression363=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression363.getTree());
			// PLSQL_DMLParser.g:571:21: ( asc_key | desc_key )?
			int alt126=3;
			int LA126_0 = input.LA(1);
			if ( (LA126_0==SQL92_RESERVED_ASC) ) {
				alt126=1;
			}
			else if ( (LA126_0==SQL92_RESERVED_DESC) ) {
				alt126=2;
			}
			switch (alt126) {
				case 1 :
					// PLSQL_DMLParser.g:571:22: asc_key
					{
					pushFollow(FOLLOW_asc_key_in_order_by_elements5032);
					asc_key364=gPLSQLParser.asc_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_asc_key.add(asc_key364.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:571:30: desc_key
					{
					pushFollow(FOLLOW_desc_key_in_order_by_elements5034);
					desc_key365=gPLSQLParser.desc_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_desc_key.add(desc_key365.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:571:41: ( nulls_key ( first_key | last_key ) )?
			int alt128=2;
			int LA128_0 = input.LA(1);
			if ( (LA128_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("rows"))||(input.LT(1).getText().equalsIgnoreCase("range"))||(input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA128_1 = input.LA(2);
				if ( (LA128_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("rows"))||(input.LT(1).getText().equalsIgnoreCase("range"))||(input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA128_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("nulls"))) ) {
						alt128=1;
					}
				}
			}
			switch (alt128) {
				case 1 :
					// PLSQL_DMLParser.g:571:42: nulls_key ( first_key | last_key )
					{
					pushFollow(FOLLOW_nulls_key_in_order_by_elements5039);
					nulls_key366=gPLSQLParser.nulls_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_nulls_key.add(nulls_key366.getTree());
					// PLSQL_DMLParser.g:571:52: ( first_key | last_key )
					int alt127=2;
					int LA127_0 = input.LA(1);
					if ( (LA127_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("first"))||(input.LT(1).getText().equalsIgnoreCase("last"))))) {
						int LA127_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("first"))) ) {
							alt127=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("last"))) ) {
							alt127=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 127, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt127) {
						case 1 :
							// PLSQL_DMLParser.g:571:53: first_key
							{
							pushFollow(FOLLOW_first_key_in_order_by_elements5042);
							first_key367=gPLSQLParser.first_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_first_key.add(first_key367.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:571:63: last_key
							{
							pushFollow(FOLLOW_last_key_in_order_by_elements5044);
							last_key368=gPLSQLParser.last_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_last_key.add(last_key368.getTree());
							}
							break;

					}

					}
					break;

			}

			// AST REWRITE
			// elements: nulls_key, expression, last_key, desc_key, asc_key, first_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 572:9: -> ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? )
			{
				// PLSQL_DMLParser.g:572:12: ^( ORDER_BY_ELEMENT ^( EXPR expression ) ( asc_key )? ( desc_key )? ( nulls_key )? ( first_key )? ( last_key )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ORDER_BY_ELEMENT, "ORDER_BY_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:572:31: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:572:50: ( asc_key )?
				if ( stream_asc_key.hasNext() ) {
					adaptor.addChild(root_1, stream_asc_key.nextTree());
				}
				stream_asc_key.reset();

				// PLSQL_DMLParser.g:572:59: ( desc_key )?
				if ( stream_desc_key.hasNext() ) {
					adaptor.addChild(root_1, stream_desc_key.nextTree());
				}
				stream_desc_key.reset();

				// PLSQL_DMLParser.g:572:69: ( nulls_key )?
				if ( stream_nulls_key.hasNext() ) {
					adaptor.addChild(root_1, stream_nulls_key.nextTree());
				}
				stream_nulls_key.reset();

				// PLSQL_DMLParser.g:572:80: ( first_key )?
				if ( stream_first_key.hasNext() ) {
					adaptor.addChild(root_1, stream_first_key.nextTree());
				}
				stream_first_key.reset();

				// PLSQL_DMLParser.g:572:91: ( last_key )?
				if ( stream_last_key.hasNext() ) {
					adaptor.addChild(root_1, stream_last_key.nextTree());
				}
				stream_last_key.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "order_by_elements"


	public static class for_update_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_update_clause"
	// PLSQL_DMLParser.g:575:1: for_update_clause : for_key update_key ( for_update_of_part )? ( for_update_options )? -> ^( for_key ( for_update_of_part )? ( for_update_options )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.for_update_clause_return for_update_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.for_update_clause_return retval = new PLSQLParser_PLSQL_DMLParser.for_update_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope for_key369 =null;
		ParserRuleReturnScope update_key370 =null;
		ParserRuleReturnScope for_update_of_part371 =null;
		ParserRuleReturnScope for_update_options372 =null;

		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_for_update_of_part=new RewriteRuleSubtreeStream(adaptor,"rule for_update_of_part");
		RewriteRuleSubtreeStream stream_update_key=new RewriteRuleSubtreeStream(adaptor,"rule update_key");
		RewriteRuleSubtreeStream stream_for_update_options=new RewriteRuleSubtreeStream(adaptor,"rule for_update_options");

		try {
			// PLSQL_DMLParser.g:576:5: ( for_key update_key ( for_update_of_part )? ( for_update_options )? -> ^( for_key ( for_update_of_part )? ( for_update_options )? ) )
			// PLSQL_DMLParser.g:576:10: for_key update_key ( for_update_of_part )? ( for_update_options )?
			{
			pushFollow(FOLLOW_for_key_in_for_update_clause5102);
			for_key369=gPLSQLParser.for_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_for_key.add(for_key369.getTree());
			pushFollow(FOLLOW_update_key_in_for_update_clause5104);
			update_key370=gPLSQLParser.update_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_update_key.add(update_key370.getTree());
			// PLSQL_DMLParser.g:576:29: ( for_update_of_part )?
			int alt129=2;
			int LA129_0 = input.LA(1);
			if ( (LA129_0==SQL92_RESERVED_OF) ) {
				alt129=1;
			}
			switch (alt129) {
				case 1 :
					// PLSQL_DMLParser.g:576:29: for_update_of_part
					{
					pushFollow(FOLLOW_for_update_of_part_in_for_update_clause5106);
					for_update_of_part371=for_update_of_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_for_update_of_part.add(for_update_of_part371.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:576:49: ( for_update_options )?
			int alt130=2;
			int LA130_0 = input.LA(1);
			if ( (LA130_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("skip"))||(input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("wait"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA130_1 = input.LA(2);
				if ( (LA130_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("skip"))||(input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("wait"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA130_4 = input.LA(3);
					if ( (((input.LT(1).getText().equalsIgnoreCase("skip"))||(input.LT(1).getText().equalsIgnoreCase("wait")))) ) {
						alt130=1;
					}
				}
				else if ( (LA130_1==APPROXIMATE_NUM_LIT||LA130_1==BINDVAR||(LA130_1 >= CHAR_STRING && LA130_1 <= COLON)||LA130_1==DELIMITED_ID||LA130_1==EXACT_NUM_LIT||LA130_1==INTRODUCER||LA130_1==LEFT_PAREN||LA130_1==MINUS_SIGN||LA130_1==NATIONAL_CHAR_STRING_LIT||LA130_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA130_1==PLUS_SIGN||LA130_1==SQL92_RESERVED_ALL||LA130_1==SQL92_RESERVED_ANY||LA130_1==SQL92_RESERVED_CASE||(LA130_1 >= SQL92_RESERVED_CURSOR && LA130_1 <= SQL92_RESERVED_DATE)||(LA130_1 >= SQL92_RESERVED_DEFAULT && LA130_1 <= SQL92_RESERVED_DELETE)||LA130_1==SQL92_RESERVED_DISTINCT||(LA130_1 >= SQL92_RESERVED_EXISTS && LA130_1 <= SQL92_RESERVED_FALSE)||(LA130_1 >= SQL92_RESERVED_NOT && LA130_1 <= SQL92_RESERVED_NULL)||LA130_1==SQL92_RESERVED_PRIOR||LA130_1==SQL92_RESERVED_TRUE||LA130_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("wait")))) {
					alt130=1;
				}
			}
			else if ( (LA130_0==PLSQL_RESERVED_NOWAIT) ) {
				alt130=1;
			}
			switch (alt130) {
				case 1 :
					// PLSQL_DMLParser.g:576:49: for_update_options
					{
					pushFollow(FOLLOW_for_update_options_in_for_update_clause5109);
					for_update_options372=for_update_options();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_for_update_options.add(for_update_options372.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: for_key, for_update_of_part, for_update_options
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 577:9: -> ^( for_key ( for_update_of_part )? ( for_update_options )? )
			{
				// PLSQL_DMLParser.g:577:12: ^( for_key ( for_update_of_part )? ( for_update_options )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_for_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:577:22: ( for_update_of_part )?
				if ( stream_for_update_of_part.hasNext() ) {
					adaptor.addChild(root_1, stream_for_update_of_part.nextTree());
				}
				stream_for_update_of_part.reset();

				// PLSQL_DMLParser.g:577:42: ( for_update_options )?
				if ( stream_for_update_options.hasNext() ) {
					adaptor.addChild(root_1, stream_for_update_options.nextTree());
				}
				stream_for_update_options.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_update_clause"


	public static class for_update_of_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_update_of_part"
	// PLSQL_DMLParser.g:580:1: for_update_of_part : of_key ^ column_name ( COMMA ! column_name )* ;
	public final PLSQLParser_PLSQL_DMLParser.for_update_of_part_return for_update_of_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.for_update_of_part_return retval = new PLSQLParser_PLSQL_DMLParser.for_update_of_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA375=null;
		ParserRuleReturnScope of_key373 =null;
		ParserRuleReturnScope column_name374 =null;
		ParserRuleReturnScope column_name376 =null;

		Object COMMA375_tree=null;

		try {
			// PLSQL_DMLParser.g:581:5: ( of_key ^ column_name ( COMMA ! column_name )* )
			// PLSQL_DMLParser.g:581:10: of_key ^ column_name ( COMMA ! column_name )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_of_key_in_for_update_of_part5150);
			of_key373=gPLSQLParser.of_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(of_key373.getTree(), root_0);
			pushFollow(FOLLOW_column_name_in_for_update_of_part5153);
			column_name374=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name374.getTree());

			// PLSQL_DMLParser.g:581:30: ( COMMA ! column_name )*
			loop131:
			while (true) {
				int alt131=2;
				int LA131_0 = input.LA(1);
				if ( (LA131_0==COMMA) ) {
					alt131=1;
				}

				switch (alt131) {
				case 1 :
					// PLSQL_DMLParser.g:581:31: COMMA ! column_name
					{
					COMMA375=(Token)match(input,COMMA,FOLLOW_COMMA_in_for_update_of_part5156); if (state.failed) return retval;
					pushFollow(FOLLOW_column_name_in_for_update_of_part5159);
					column_name376=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_name376.getTree());

					}
					break;

				default :
					break loop131;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_update_of_part"


	public static class for_update_options_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_update_options"
	// PLSQL_DMLParser.g:584:1: for_update_options : ( skip_key locked_key !| nowait_key | wait_key expression -> ^( wait_key ^( EXPR expression ) ) );
	public final PLSQLParser_PLSQL_DMLParser.for_update_options_return for_update_options() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.for_update_options_return retval = new PLSQLParser_PLSQL_DMLParser.for_update_options_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope skip_key377 =null;
		ParserRuleReturnScope locked_key378 =null;
		ParserRuleReturnScope nowait_key379 =null;
		ParserRuleReturnScope wait_key380 =null;
		ParserRuleReturnScope expression381 =null;

		RewriteRuleSubtreeStream stream_wait_key=new RewriteRuleSubtreeStream(adaptor,"rule wait_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:585:5: ( skip_key locked_key !| nowait_key | wait_key expression -> ^( wait_key ^( EXPR expression ) ) )
			int alt132=3;
			int LA132_0 = input.LA(1);
			if ( (LA132_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("skip"))||(input.LT(1).getText().equalsIgnoreCase("wait"))))) {
				int LA132_1 = input.LA(2);
				if ( (LA132_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("skip"))||(input.LT(1).getText().equalsIgnoreCase("wait"))))) {
					int LA132_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("skip"))) ) {
						alt132=1;
					}
					else if ( ((input.LT(1).getText().equalsIgnoreCase("wait"))) ) {
						alt132=3;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						int nvaeMark = input.mark();
						try {
							for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
								input.consume();
							}
							NoViableAltException nvae =
								new NoViableAltException("", 132, 3, input);
							throw nvae;
						} finally {
							input.rewind(nvaeMark);
						}
					}

				}
				else if ( (LA132_1==APPROXIMATE_NUM_LIT||LA132_1==BINDVAR||(LA132_1 >= CHAR_STRING && LA132_1 <= COLON)||LA132_1==DELIMITED_ID||LA132_1==EXACT_NUM_LIT||LA132_1==INTRODUCER||LA132_1==LEFT_PAREN||LA132_1==MINUS_SIGN||LA132_1==NATIONAL_CHAR_STRING_LIT||LA132_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA132_1==PLUS_SIGN||LA132_1==SQL92_RESERVED_ALL||LA132_1==SQL92_RESERVED_ANY||LA132_1==SQL92_RESERVED_CASE||(LA132_1 >= SQL92_RESERVED_CURSOR && LA132_1 <= SQL92_RESERVED_DATE)||(LA132_1 >= SQL92_RESERVED_DEFAULT && LA132_1 <= SQL92_RESERVED_DELETE)||LA132_1==SQL92_RESERVED_DISTINCT||(LA132_1 >= SQL92_RESERVED_EXISTS && LA132_1 <= SQL92_RESERVED_FALSE)||(LA132_1 >= SQL92_RESERVED_NOT && LA132_1 <= SQL92_RESERVED_NULL)||LA132_1==SQL92_RESERVED_PRIOR||LA132_1==SQL92_RESERVED_TRUE||LA132_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("wait")))) {
					alt132=3;
				}

			}
			else if ( (LA132_0==PLSQL_RESERVED_NOWAIT) ) {
				alt132=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 132, 0, input);
				throw nvae;
			}

			switch (alt132) {
				case 1 :
					// PLSQL_DMLParser.g:585:10: skip_key locked_key !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_skip_key_in_for_update_options5181);
					skip_key377=gPLSQLParser.skip_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, skip_key377.getTree());

					pushFollow(FOLLOW_locked_key_in_for_update_options5183);
					locked_key378=gPLSQLParser.locked_key();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:586:10: nowait_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_nowait_key_in_for_update_options5195);
					nowait_key379=gPLSQLParser.nowait_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nowait_key379.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:587:10: wait_key expression
					{
					pushFollow(FOLLOW_wait_key_in_for_update_options5206);
					wait_key380=gPLSQLParser.wait_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wait_key.add(wait_key380.getTree());
					pushFollow(FOLLOW_expression_in_for_update_options5208);
					expression381=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression381.getTree());
					// AST REWRITE
					// elements: wait_key, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 587:30: -> ^( wait_key ^( EXPR expression ) )
					{
						// PLSQL_DMLParser.g:587:33: ^( wait_key ^( EXPR expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_wait_key.nextNode(), root_1);
						// PLSQL_DMLParser.g:587:44: ^( EXPR expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_update_options"


	public static class update_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "update_statement"
	// PLSQL_DMLParser.g:592:1: update_statement : update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
	public final PLSQLParser_PLSQL_DMLParser.update_statement_return update_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.update_statement_return retval = new PLSQLParser_PLSQL_DMLParser.update_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope update_key382 =null;
		ParserRuleReturnScope general_table_ref383 =null;
		ParserRuleReturnScope update_set_clause384 =null;
		ParserRuleReturnScope where_clause385 =null;
		ParserRuleReturnScope static_returning_clause386 =null;
		ParserRuleReturnScope error_logging_clause387 =null;


		try {
			// PLSQL_DMLParser.g:593:5: ( update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
			// PLSQL_DMLParser.g:593:10: update_key ^ general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_update_key_in_update_statement5242);
			update_key382=gPLSQLParser.update_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(update_key382.getTree(), root_0);
			pushFollow(FOLLOW_general_table_ref_in_update_statement5245);
			general_table_ref383=general_table_ref();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, general_table_ref383.getTree());

			pushFollow(FOLLOW_update_set_clause_in_update_statement5255);
			update_set_clause384=update_set_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, update_set_clause384.getTree());

			// PLSQL_DMLParser.g:595:9: ( where_clause )?
			int alt133=2;
			int LA133_0 = input.LA(1);
			if ( (LA133_0==SQL92_RESERVED_WHERE) ) {
				alt133=1;
			}
			switch (alt133) {
				case 1 :
					// PLSQL_DMLParser.g:595:9: where_clause
					{
					pushFollow(FOLLOW_where_clause_in_update_statement5265);
					where_clause385=gPLSQLParser.where_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, where_clause385.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:595:23: ( static_returning_clause )?
			int alt134=2;
			int LA134_0 = input.LA(1);
			if ( (LA134_0==REGULAR_ID) ) {
				int LA134_1 = input.LA(2);
				if ( (((input.LT(1).getText().equalsIgnoreCase("return"))||(input.LT(1).getText().equalsIgnoreCase("returning")))) ) {
					alt134=1;
				}
			}
			switch (alt134) {
				case 1 :
					// PLSQL_DMLParser.g:595:23: static_returning_clause
					{
					pushFollow(FOLLOW_static_returning_clause_in_update_statement5268);
					static_returning_clause386=static_returning_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, static_returning_clause386.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:595:48: ( error_logging_clause )?
			int alt135=2;
			int LA135_0 = input.LA(1);
			if ( (LA135_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA135_1 = input.LA(2);
				if ( (LA135_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA135_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("log"))) ) {
						alt135=1;
					}
				}
			}
			switch (alt135) {
				case 1 :
					// PLSQL_DMLParser.g:595:48: error_logging_clause
					{
					pushFollow(FOLLOW_error_logging_clause_in_update_statement5271);
					error_logging_clause387=error_logging_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, error_logging_clause387.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "update_statement"


	public static class update_set_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "update_set_clause"
	// PLSQL_DMLParser.g:599:1: update_set_clause : set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ ) -> ^( set_key ^( value_key id ^( EXPR expression ) ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.update_set_clause_return update_set_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.update_set_clause_return retval = new PLSQLParser_PLSQL_DMLParser.update_set_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA390=null;
		Token LEFT_PAREN393=null;
		Token RIGHT_PAREN395=null;
		Token EQUALS_OP396=null;
		ParserRuleReturnScope set_key388 =null;
		ParserRuleReturnScope column_based_update_set_clause389 =null;
		ParserRuleReturnScope column_based_update_set_clause391 =null;
		ParserRuleReturnScope value_key392 =null;
		ParserRuleReturnScope id394 =null;
		ParserRuleReturnScope expression397 =null;

		Object COMMA390_tree=null;
		Object LEFT_PAREN393_tree=null;
		Object RIGHT_PAREN395_tree=null;
		Object EQUALS_OP396_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EQUALS_OP=new RewriteRuleTokenStream(adaptor,"token EQUALS_OP");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_value_key=new RewriteRuleSubtreeStream(adaptor,"rule value_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_column_based_update_set_clause=new RewriteRuleSubtreeStream(adaptor,"rule column_based_update_set_clause");
		RewriteRuleSubtreeStream stream_set_key=new RewriteRuleSubtreeStream(adaptor,"rule set_key");
		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:601:5: ( set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ ) -> ^( set_key ^( value_key id ^( EXPR expression ) ) ) )
			// PLSQL_DMLParser.g:601:10: set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
			{
			pushFollow(FOLLOW_set_key_in_update_set_clause5301);
			set_key388=gPLSQLParser.set_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_set_key.add(set_key388.getTree());
			// PLSQL_DMLParser.g:602:5: ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
			int alt137=2;
			int LA137_0 = input.LA(1);
			if ( (LA137_0==DELIMITED_ID||LA137_0==INTRODUCER||LA137_0==LEFT_PAREN) ) {
				alt137=1;
			}
			else if ( (LA137_0==REGULAR_ID) ) {
				int LA137_2 = input.LA(2);
				if ( (LA137_2==EQUALS_OP||LA137_2==PERIOD) ) {
					alt137=1;
				}
				else if ( (LA137_2==LEFT_PAREN) ) {
					alt137=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 137, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 137, 0, input);
				throw nvae;
			}

			switch (alt137) {
				case 1 :
					// PLSQL_DMLParser.g:602:10: column_based_update_set_clause ( COMMA column_based_update_set_clause )*
					{
					pushFollow(FOLLOW_column_based_update_set_clause_in_update_set_clause5312);
					column_based_update_set_clause389=column_based_update_set_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_based_update_set_clause.add(column_based_update_set_clause389.getTree());
					// PLSQL_DMLParser.g:602:41: ( COMMA column_based_update_set_clause )*
					loop136:
					while (true) {
						int alt136=2;
						int LA136_0 = input.LA(1);
						if ( (LA136_0==COMMA) ) {
							alt136=1;
						}

						switch (alt136) {
						case 1 :
							// PLSQL_DMLParser.g:602:42: COMMA column_based_update_set_clause
							{
							COMMA390=(Token)match(input,COMMA,FOLLOW_COMMA_in_update_set_clause5315); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA390);

							pushFollow(FOLLOW_column_based_update_set_clause_in_update_set_clause5317);
							column_based_update_set_clause391=column_based_update_set_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_based_update_set_clause.add(column_based_update_set_clause391.getTree());
							}
							break;

						default :
							break loop136;
						}
					}

					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:603:10: value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression
					{
					pushFollow(FOLLOW_value_key_in_update_set_clause5332);
					value_key392=gPLSQLParser.value_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_value_key.add(value_key392.getTree());
					LEFT_PAREN393=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_update_set_clause5334); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN393);

					pushFollow(FOLLOW_id_in_update_set_clause5336);
					id394=gPLSQLParser.id();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_id.add(id394.getTree());
					RIGHT_PAREN395=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_update_set_clause5338); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN395);

					EQUALS_OP396=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_update_set_clause5340); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP396);

					pushFollow(FOLLOW_expression_in_update_set_clause5342);
					expression397=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression397.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: value_key, column_based_update_set_clause, id, expression, set_key, set_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 605:9: -> {mode == 1}? ^( set_key ( column_based_update_set_clause )+ )
			if (mode == 1) {
				// PLSQL_DMLParser.g:605:24: ^( set_key ( column_based_update_set_clause )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_set_key.nextNode(), root_1);
				if ( !(stream_column_based_update_set_clause.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column_based_update_set_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_column_based_update_set_clause.nextTree());
				}
				stream_column_based_update_set_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 606:9: -> ^( set_key ^( value_key id ^( EXPR expression ) ) )
			{
				// PLSQL_DMLParser.g:606:12: ^( set_key ^( value_key id ^( EXPR expression ) ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_set_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:606:22: ^( value_key id ^( EXPR expression ) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_value_key.nextNode(), root_2);
				adaptor.addChild(root_2, stream_id.nextTree());
				// PLSQL_DMLParser.g:606:37: ^( EXPR expression )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_3);
				adaptor.addChild(root_3, stream_expression.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "update_set_clause"


	public static class column_based_update_set_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "column_based_update_set_clause"
	// PLSQL_DMLParser.g:609:1: column_based_update_set_clause : ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery ) );
	public final PLSQLParser_PLSQL_DMLParser.column_based_update_set_clause_return column_based_update_set_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.column_based_update_set_clause_return retval = new PLSQLParser_PLSQL_DMLParser.column_based_update_set_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP399=null;
		Token LEFT_PAREN401=null;
		Token COMMA403=null;
		Token RIGHT_PAREN405=null;
		Token EQUALS_OP406=null;
		ParserRuleReturnScope column_name398 =null;
		ParserRuleReturnScope expression400 =null;
		ParserRuleReturnScope column_name402 =null;
		ParserRuleReturnScope column_name404 =null;
		ParserRuleReturnScope subquery407 =null;

		Object EQUALS_OP399_tree=null;
		Object LEFT_PAREN401_tree=null;
		Object COMMA403_tree=null;
		Object RIGHT_PAREN405_tree=null;
		Object EQUALS_OP406_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_EQUALS_OP=new RewriteRuleTokenStream(adaptor,"token EQUALS_OP");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");

		try {
			// PLSQL_DMLParser.g:610:5: ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery ) )
			int alt139=2;
			int LA139_0 = input.LA(1);
			if ( (LA139_0==DELIMITED_ID||LA139_0==INTRODUCER||LA139_0==REGULAR_ID) ) {
				alt139=1;
			}
			else if ( (LA139_0==LEFT_PAREN) ) {
				alt139=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 139, 0, input);
				throw nvae;
			}

			switch (alt139) {
				case 1 :
					// PLSQL_DMLParser.g:610:10: column_name EQUALS_OP expression
					{
					pushFollow(FOLLOW_column_name_in_column_based_update_set_clause5412);
					column_name398=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name398.getTree());
					EQUALS_OP399=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_column_based_update_set_clause5414); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP399);

					pushFollow(FOLLOW_expression_in_column_based_update_set_clause5416);
					expression400=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression400.getTree());
					// AST REWRITE
					// elements: expression, column_name
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 610:43: -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
					{
						// PLSQL_DMLParser.g:610:46: ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASSIGN, EQUALS_OP399), root_1);
						adaptor.addChild(root_1, stream_column_name.nextTree());
						// PLSQL_DMLParser.g:610:79: ^( EXPR expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:611:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery
					{
					LEFT_PAREN401=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_column_based_update_set_clause5442); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN401);

					pushFollow(FOLLOW_column_name_in_column_based_update_set_clause5444);
					column_name402=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name402.getTree());
					// PLSQL_DMLParser.g:611:33: ( COMMA column_name )*
					loop138:
					while (true) {
						int alt138=2;
						int LA138_0 = input.LA(1);
						if ( (LA138_0==COMMA) ) {
							alt138=1;
						}

						switch (alt138) {
						case 1 :
							// PLSQL_DMLParser.g:611:34: COMMA column_name
							{
							COMMA403=(Token)match(input,COMMA,FOLLOW_COMMA_in_column_based_update_set_clause5447); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA403);

							pushFollow(FOLLOW_column_name_in_column_based_update_set_clause5449);
							column_name404=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name404.getTree());
							}
							break;

						default :
							break loop138;
						}
					}

					RIGHT_PAREN405=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause5453); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN405);

					EQUALS_OP406=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_column_based_update_set_clause5455); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP406);

					pushFollow(FOLLOW_subquery_in_column_based_update_set_clause5457);
					subquery407=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery.add(subquery407.getTree());
					// AST REWRITE
					// elements: column_name, subquery
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 611:85: -> ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery )
					{
						// PLSQL_DMLParser.g:611:88: ^( ASSIGN[$EQUALS_OP] ( column_name )+ subquery )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASSIGN, EQUALS_OP406), root_1);
						if ( !(stream_column_name.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_column_name.hasNext() ) {
							adaptor.addChild(root_1, stream_column_name.nextTree());
						}
						stream_column_name.reset();

						adaptor.addChild(root_1, stream_subquery.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "column_based_update_set_clause"


	public static class delete_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "delete_statement"
	// PLSQL_DMLParser.g:616:1: delete_statement : delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
	public final PLSQLParser_PLSQL_DMLParser.delete_statement_return delete_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.delete_statement_return retval = new PLSQLParser_PLSQL_DMLParser.delete_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope delete_key408 =null;
		ParserRuleReturnScope from_key409 =null;
		ParserRuleReturnScope general_table_ref410 =null;
		ParserRuleReturnScope where_clause411 =null;
		ParserRuleReturnScope static_returning_clause412 =null;
		ParserRuleReturnScope error_logging_clause413 =null;


		try {
			// PLSQL_DMLParser.g:617:5: ( delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
			// PLSQL_DMLParser.g:617:10: delete_key ^ ( from_key !)? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_delete_key_in_delete_statement5491);
			delete_key408=gPLSQLParser.delete_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(delete_key408.getTree(), root_0);
			// PLSQL_DMLParser.g:617:30: ( from_key !)?
			int alt140=2;
			int LA140_0 = input.LA(1);
			if ( (LA140_0==SQL92_RESERVED_FROM) ) {
				alt140=1;
			}
			switch (alt140) {
				case 1 :
					// PLSQL_DMLParser.g:617:30: from_key !
					{
					pushFollow(FOLLOW_from_key_in_delete_statement5494);
					from_key409=gPLSQLParser.from_key();
					state._fsp--;
					if (state.failed) return retval;
					}
					break;

			}

			pushFollow(FOLLOW_general_table_ref_in_delete_statement5506);
			general_table_ref410=general_table_ref();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, general_table_ref410.getTree());

			// PLSQL_DMLParser.g:619:9: ( where_clause )?
			int alt141=2;
			int LA141_0 = input.LA(1);
			if ( (LA141_0==SQL92_RESERVED_WHERE) ) {
				alt141=1;
			}
			switch (alt141) {
				case 1 :
					// PLSQL_DMLParser.g:619:9: where_clause
					{
					pushFollow(FOLLOW_where_clause_in_delete_statement5516);
					where_clause411=gPLSQLParser.where_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, where_clause411.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:619:23: ( static_returning_clause )?
			int alt142=2;
			int LA142_0 = input.LA(1);
			if ( (LA142_0==REGULAR_ID) ) {
				int LA142_1 = input.LA(2);
				if ( (((input.LT(1).getText().equalsIgnoreCase("return"))||(input.LT(1).getText().equalsIgnoreCase("returning")))) ) {
					alt142=1;
				}
			}
			switch (alt142) {
				case 1 :
					// PLSQL_DMLParser.g:619:23: static_returning_clause
					{
					pushFollow(FOLLOW_static_returning_clause_in_delete_statement5519);
					static_returning_clause412=static_returning_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, static_returning_clause412.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:619:48: ( error_logging_clause )?
			int alt143=2;
			int LA143_0 = input.LA(1);
			if ( (LA143_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA143_1 = input.LA(2);
				if ( (LA143_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA143_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("log"))) ) {
						alt143=1;
					}
				}
			}
			switch (alt143) {
				case 1 :
					// PLSQL_DMLParser.g:619:48: error_logging_clause
					{
					pushFollow(FOLLOW_error_logging_clause_in_delete_statement5522);
					error_logging_clause413=error_logging_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, error_logging_clause413.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "delete_statement"


	public static class insert_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "insert_statement"
	// PLSQL_DMLParser.g:622:1: insert_statement : insert_key ^ ( single_table_insert | multi_table_insert ) ;
	public final PLSQLParser_PLSQL_DMLParser.insert_statement_return insert_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.insert_statement_return retval = new PLSQLParser_PLSQL_DMLParser.insert_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope insert_key414 =null;
		ParserRuleReturnScope single_table_insert415 =null;
		ParserRuleReturnScope multi_table_insert416 =null;


		try {
			// PLSQL_DMLParser.g:623:5: ( insert_key ^ ( single_table_insert | multi_table_insert ) )
			// PLSQL_DMLParser.g:623:10: insert_key ^ ( single_table_insert | multi_table_insert )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_insert_key_in_insert_statement5543);
			insert_key414=gPLSQLParser.insert_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(insert_key414.getTree(), root_0);
			// PLSQL_DMLParser.g:624:5: ( single_table_insert | multi_table_insert )
			int alt144=2;
			int LA144_0 = input.LA(1);
			if ( (LA144_0==SQL92_RESERVED_INTO) ) {
				alt144=1;
			}
			else if ( (LA144_0==SQL92_RESERVED_ALL) ) {
				alt144=2;
			}
			else if ( (LA144_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("first")))) {
				alt144=2;
			}
			else if ( (LA144_0==SQL92_RESERVED_WHEN) ) {
				alt144=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 144, 0, input);
				throw nvae;
			}

			switch (alt144) {
				case 1 :
					// PLSQL_DMLParser.g:624:10: single_table_insert
					{
					pushFollow(FOLLOW_single_table_insert_in_insert_statement5555);
					single_table_insert415=single_table_insert();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, single_table_insert415.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:625:10: multi_table_insert
					{
					pushFollow(FOLLOW_multi_table_insert_in_insert_statement5566);
					multi_table_insert416=multi_table_insert();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, multi_table_insert416.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "insert_statement"


	public static class single_table_insert_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "single_table_insert"
	// PLSQL_DMLParser.g:631:1: single_table_insert : insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.single_table_insert_return single_table_insert() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.single_table_insert_return retval = new PLSQLParser_PLSQL_DMLParser.single_table_insert_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope insert_into_clause417 =null;
		ParserRuleReturnScope values_clause418 =null;
		ParserRuleReturnScope static_returning_clause419 =null;
		ParserRuleReturnScope select_statement420 =null;
		ParserRuleReturnScope error_logging_clause421 =null;

		RewriteRuleSubtreeStream stream_error_logging_clause=new RewriteRuleSubtreeStream(adaptor,"rule error_logging_clause");
		RewriteRuleSubtreeStream stream_insert_into_clause=new RewriteRuleSubtreeStream(adaptor,"rule insert_into_clause");
		RewriteRuleSubtreeStream stream_static_returning_clause=new RewriteRuleSubtreeStream(adaptor,"rule static_returning_clause");
		RewriteRuleSubtreeStream stream_select_statement=new RewriteRuleSubtreeStream(adaptor,"rule select_statement");
		RewriteRuleSubtreeStream stream_values_clause=new RewriteRuleSubtreeStream(adaptor,"rule values_clause");

		try {
			// PLSQL_DMLParser.g:632:5: ( insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? ) )
			// PLSQL_DMLParser.g:632:10: insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )?
			{
			pushFollow(FOLLOW_insert_into_clause_in_single_table_insert5594);
			insert_into_clause417=insert_into_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_insert_into_clause.add(insert_into_clause417.getTree());
			// PLSQL_DMLParser.g:633:5: ( values_clause ( static_returning_clause )? | select_statement )
			int alt146=2;
			int LA146_0 = input.LA(1);
			if ( (LA146_0==SQL92_RESERVED_VALUES) ) {
				alt146=1;
			}
			else if ( (LA146_0==LEFT_PAREN||LA146_0==SQL92_RESERVED_SELECT||LA146_0==SQL92_RESERVED_WITH) ) {
				alt146=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 146, 0, input);
				throw nvae;
			}

			switch (alt146) {
				case 1 :
					// PLSQL_DMLParser.g:633:10: values_clause ( static_returning_clause )?
					{
					pushFollow(FOLLOW_values_clause_in_single_table_insert5605);
					values_clause418=values_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_values_clause.add(values_clause418.getTree());
					// PLSQL_DMLParser.g:633:24: ( static_returning_clause )?
					int alt145=2;
					int LA145_0 = input.LA(1);
					if ( (LA145_0==REGULAR_ID) ) {
						int LA145_1 = input.LA(2);
						if ( (((input.LT(1).getText().equalsIgnoreCase("return"))||(input.LT(1).getText().equalsIgnoreCase("returning")))) ) {
							alt145=1;
						}
					}
					switch (alt145) {
						case 1 :
							// PLSQL_DMLParser.g:633:24: static_returning_clause
							{
							pushFollow(FOLLOW_static_returning_clause_in_single_table_insert5607);
							static_returning_clause419=static_returning_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_static_returning_clause.add(static_returning_clause419.getTree());
							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:634:10: select_statement
					{
					pushFollow(FOLLOW_select_statement_in_single_table_insert5619);
					select_statement420=select_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_select_statement.add(select_statement420.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:636:9: ( error_logging_clause )?
			int alt147=2;
			int LA147_0 = input.LA(1);
			if ( (LA147_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA147_1 = input.LA(2);
				if ( (LA147_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA147_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("log"))) ) {
						alt147=1;
					}
				}
			}
			switch (alt147) {
				case 1 :
					// PLSQL_DMLParser.g:636:9: error_logging_clause
					{
					pushFollow(FOLLOW_error_logging_clause_in_single_table_insert5635);
					error_logging_clause421=error_logging_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_error_logging_clause.add(error_logging_clause421.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: static_returning_clause, insert_into_clause, select_statement, error_logging_clause, values_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 637:9: -> ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? )
			{
				// PLSQL_DMLParser.g:637:12: ^( SINGLE_TABLE_MODE insert_into_clause ( values_clause )? ( static_returning_clause )? ( select_statement )? ( error_logging_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SINGLE_TABLE_MODE, "SINGLE_TABLE_MODE"), root_1);
				adaptor.addChild(root_1, stream_insert_into_clause.nextTree());
				// PLSQL_DMLParser.g:637:51: ( values_clause )?
				if ( stream_values_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_values_clause.nextTree());
				}
				stream_values_clause.reset();

				// PLSQL_DMLParser.g:637:66: ( static_returning_clause )?
				if ( stream_static_returning_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_static_returning_clause.nextTree());
				}
				stream_static_returning_clause.reset();

				// PLSQL_DMLParser.g:637:91: ( select_statement )?
				if ( stream_select_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_select_statement.nextTree());
				}
				stream_select_statement.reset();

				// PLSQL_DMLParser.g:637:109: ( error_logging_clause )?
				if ( stream_error_logging_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_error_logging_clause.nextTree());
				}
				stream_error_logging_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "single_table_insert"


	public static class multi_table_insert_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multi_table_insert"
	// PLSQL_DMLParser.g:640:1: multi_table_insert : ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement -> ^( MULTI_TABLE_MODE select_statement ( multi_table_element )* ( conditional_insert_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.multi_table_insert_return multi_table_insert() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multi_table_insert_return retval = new PLSQLParser_PLSQL_DMLParser.multi_table_insert_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope all_key422 =null;
		ParserRuleReturnScope multi_table_element423 =null;
		ParserRuleReturnScope conditional_insert_clause424 =null;
		ParserRuleReturnScope select_statement425 =null;

		RewriteRuleSubtreeStream stream_all_key=new RewriteRuleSubtreeStream(adaptor,"rule all_key");
		RewriteRuleSubtreeStream stream_multi_table_element=new RewriteRuleSubtreeStream(adaptor,"rule multi_table_element");
		RewriteRuleSubtreeStream stream_select_statement=new RewriteRuleSubtreeStream(adaptor,"rule select_statement");
		RewriteRuleSubtreeStream stream_conditional_insert_clause=new RewriteRuleSubtreeStream(adaptor,"rule conditional_insert_clause");

		try {
			// PLSQL_DMLParser.g:641:5: ( ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement -> ^( MULTI_TABLE_MODE select_statement ( multi_table_element )* ( conditional_insert_clause )? ) )
			// PLSQL_DMLParser.g:642:5: ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement
			{
			// PLSQL_DMLParser.g:642:5: ( all_key ( multi_table_element )+ | conditional_insert_clause )
			int alt149=2;
			int LA149_0 = input.LA(1);
			if ( (LA149_0==SQL92_RESERVED_ALL) ) {
				int LA149_1 = input.LA(2);
				if ( (LA149_1==SQL92_RESERVED_INTO) ) {
					alt149=1;
				}
				else if ( (LA149_1==SQL92_RESERVED_WHEN) ) {
					alt149=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 149, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA149_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("first")))) {
				alt149=2;
			}
			else if ( (LA149_0==SQL92_RESERVED_WHEN) ) {
				alt149=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 149, 0, input);
				throw nvae;
			}

			switch (alt149) {
				case 1 :
					// PLSQL_DMLParser.g:642:10: all_key ( multi_table_element )+
					{
					pushFollow(FOLLOW_all_key_in_multi_table_insert5694);
					all_key422=gPLSQLParser.all_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_all_key.add(all_key422.getTree());
					// PLSQL_DMLParser.g:642:18: ( multi_table_element )+
					int cnt148=0;
					loop148:
					while (true) {
						int alt148=2;
						int LA148_0 = input.LA(1);
						if ( (LA148_0==SQL92_RESERVED_INTO) ) {
							alt148=1;
						}

						switch (alt148) {
						case 1 :
							// PLSQL_DMLParser.g:642:18: multi_table_element
							{
							pushFollow(FOLLOW_multi_table_element_in_multi_table_insert5696);
							multi_table_element423=multi_table_element();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_multi_table_element.add(multi_table_element423.getTree());
							}
							break;

						default :
							if ( cnt148 >= 1 ) break loop148;
							if (state.backtracking>0) {state.failed=true; return retval;}
							EarlyExitException eee = new EarlyExitException(148, input);
							throw eee;
						}
						cnt148++;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:643:10: conditional_insert_clause
					{
					pushFollow(FOLLOW_conditional_insert_clause_in_multi_table_insert5708);
					conditional_insert_clause424=conditional_insert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_insert_clause.add(conditional_insert_clause424.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_select_statement_in_multi_table_insert5724);
			select_statement425=select_statement();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_select_statement.add(select_statement425.getTree());
			// AST REWRITE
			// elements: multi_table_element, conditional_insert_clause, select_statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 646:9: -> ^( MULTI_TABLE_MODE select_statement ( multi_table_element )* ( conditional_insert_clause )? )
			{
				// PLSQL_DMLParser.g:646:12: ^( MULTI_TABLE_MODE select_statement ( multi_table_element )* ( conditional_insert_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MULTI_TABLE_MODE, "MULTI_TABLE_MODE"), root_1);
				adaptor.addChild(root_1, stream_select_statement.nextTree());
				// PLSQL_DMLParser.g:646:48: ( multi_table_element )*
				while ( stream_multi_table_element.hasNext() ) {
					adaptor.addChild(root_1, stream_multi_table_element.nextTree());
				}
				stream_multi_table_element.reset();

				// PLSQL_DMLParser.g:646:69: ( conditional_insert_clause )?
				if ( stream_conditional_insert_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_conditional_insert_clause.nextTree());
				}
				stream_conditional_insert_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multi_table_insert"


	public static class multi_table_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multi_table_element"
	// PLSQL_DMLParser.g:649:1: multi_table_element : insert_into_clause ( values_clause )? ( error_logging_clause )? -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.multi_table_element_return multi_table_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multi_table_element_return retval = new PLSQLParser_PLSQL_DMLParser.multi_table_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope insert_into_clause426 =null;
		ParserRuleReturnScope values_clause427 =null;
		ParserRuleReturnScope error_logging_clause428 =null;

		RewriteRuleSubtreeStream stream_error_logging_clause=new RewriteRuleSubtreeStream(adaptor,"rule error_logging_clause");
		RewriteRuleSubtreeStream stream_insert_into_clause=new RewriteRuleSubtreeStream(adaptor,"rule insert_into_clause");
		RewriteRuleSubtreeStream stream_values_clause=new RewriteRuleSubtreeStream(adaptor,"rule values_clause");

		try {
			// PLSQL_DMLParser.g:650:5: ( insert_into_clause ( values_clause )? ( error_logging_clause )? -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? ) )
			// PLSQL_DMLParser.g:650:10: insert_into_clause ( values_clause )? ( error_logging_clause )?
			{
			pushFollow(FOLLOW_insert_into_clause_in_multi_table_element5766);
			insert_into_clause426=insert_into_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_insert_into_clause.add(insert_into_clause426.getTree());
			// PLSQL_DMLParser.g:650:29: ( values_clause )?
			int alt150=2;
			int LA150_0 = input.LA(1);
			if ( (LA150_0==SQL92_RESERVED_VALUES) ) {
				alt150=1;
			}
			switch (alt150) {
				case 1 :
					// PLSQL_DMLParser.g:650:29: values_clause
					{
					pushFollow(FOLLOW_values_clause_in_multi_table_element5768);
					values_clause427=values_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_values_clause.add(values_clause427.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:650:44: ( error_logging_clause )?
			int alt151=2;
			int LA151_0 = input.LA(1);
			if ( (LA151_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("log")))) {
				alt151=1;
			}
			switch (alt151) {
				case 1 :
					// PLSQL_DMLParser.g:650:44: error_logging_clause
					{
					pushFollow(FOLLOW_error_logging_clause_in_multi_table_element5771);
					error_logging_clause428=error_logging_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_error_logging_clause.add(error_logging_clause428.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: insert_into_clause, values_clause, error_logging_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 651:9: -> ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? )
			{
				// PLSQL_DMLParser.g:651:12: ^( TABLE_ELEMENT insert_into_clause ( values_clause )? ( error_logging_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_ELEMENT, "TABLE_ELEMENT"), root_1);
				adaptor.addChild(root_1, stream_insert_into_clause.nextTree());
				// PLSQL_DMLParser.g:651:47: ( values_clause )?
				if ( stream_values_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_values_clause.nextTree());
				}
				stream_values_clause.reset();

				// PLSQL_DMLParser.g:651:62: ( error_logging_clause )?
				if ( stream_error_logging_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_error_logging_clause.nextTree());
				}
				stream_error_logging_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multi_table_element"


	public static class conditional_insert_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "conditional_insert_clause"
	// PLSQL_DMLParser.g:654:1: conditional_insert_clause : ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.conditional_insert_clause_return conditional_insert_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.conditional_insert_clause_return retval = new PLSQLParser_PLSQL_DMLParser.conditional_insert_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope all_key429 =null;
		ParserRuleReturnScope first_key430 =null;
		ParserRuleReturnScope conditional_insert_when_part431 =null;
		ParserRuleReturnScope conditional_insert_else_part432 =null;

		RewriteRuleSubtreeStream stream_first_key=new RewriteRuleSubtreeStream(adaptor,"rule first_key");
		RewriteRuleSubtreeStream stream_all_key=new RewriteRuleSubtreeStream(adaptor,"rule all_key");
		RewriteRuleSubtreeStream stream_conditional_insert_when_part=new RewriteRuleSubtreeStream(adaptor,"rule conditional_insert_when_part");
		RewriteRuleSubtreeStream stream_conditional_insert_else_part=new RewriteRuleSubtreeStream(adaptor,"rule conditional_insert_else_part");

		try {
			// PLSQL_DMLParser.g:655:5: ( ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ) )
			// PLSQL_DMLParser.g:655:10: ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )?
			{
			// PLSQL_DMLParser.g:655:10: ( all_key | first_key )?
			int alt152=3;
			int LA152_0 = input.LA(1);
			if ( (LA152_0==SQL92_RESERVED_ALL) ) {
				alt152=1;
			}
			else if ( (LA152_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("first")))) {
				alt152=2;
			}
			switch (alt152) {
				case 1 :
					// PLSQL_DMLParser.g:655:11: all_key
					{
					pushFollow(FOLLOW_all_key_in_conditional_insert_clause5815);
					all_key429=gPLSQLParser.all_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_all_key.add(all_key429.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:655:19: first_key
					{
					pushFollow(FOLLOW_first_key_in_conditional_insert_clause5817);
					first_key430=gPLSQLParser.first_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_first_key.add(first_key430.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:656:9: ( conditional_insert_when_part )+
			int cnt153=0;
			loop153:
			while (true) {
				int alt153=2;
				int LA153_0 = input.LA(1);
				if ( (LA153_0==SQL92_RESERVED_WHEN) ) {
					alt153=1;
				}

				switch (alt153) {
				case 1 :
					// PLSQL_DMLParser.g:656:9: conditional_insert_when_part
					{
					pushFollow(FOLLOW_conditional_insert_when_part_in_conditional_insert_clause5829);
					conditional_insert_when_part431=conditional_insert_when_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_insert_when_part.add(conditional_insert_when_part431.getTree());
					}
					break;

				default :
					if ( cnt153 >= 1 ) break loop153;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(153, input);
					throw eee;
				}
				cnt153++;
			}

			// PLSQL_DMLParser.g:656:39: ( conditional_insert_else_part )?
			int alt154=2;
			int LA154_0 = input.LA(1);
			if ( (LA154_0==SQL92_RESERVED_ELSE) ) {
				alt154=1;
			}
			switch (alt154) {
				case 1 :
					// PLSQL_DMLParser.g:656:39: conditional_insert_else_part
					{
					pushFollow(FOLLOW_conditional_insert_else_part_in_conditional_insert_clause5832);
					conditional_insert_else_part432=conditional_insert_else_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_conditional_insert_else_part.add(conditional_insert_else_part432.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: conditional_insert_else_part, all_key, conditional_insert_when_part, first_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 657:9: -> ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
			{
				// PLSQL_DMLParser.g:657:12: ^( CONDITIONAL_INSERT ( all_key )? ( first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CONDITIONAL_INSERT, "CONDITIONAL_INSERT"), root_1);
				// PLSQL_DMLParser.g:657:33: ( all_key )?
				if ( stream_all_key.hasNext() ) {
					adaptor.addChild(root_1, stream_all_key.nextTree());
				}
				stream_all_key.reset();

				// PLSQL_DMLParser.g:657:42: ( first_key )?
				if ( stream_first_key.hasNext() ) {
					adaptor.addChild(root_1, stream_first_key.nextTree());
				}
				stream_first_key.reset();

				if ( !(stream_conditional_insert_when_part.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_conditional_insert_when_part.hasNext() ) {
					adaptor.addChild(root_1, stream_conditional_insert_when_part.nextTree());
				}
				stream_conditional_insert_when_part.reset();

				// PLSQL_DMLParser.g:657:83: ( conditional_insert_else_part )?
				if ( stream_conditional_insert_else_part.hasNext() ) {
					adaptor.addChild(root_1, stream_conditional_insert_else_part.nextTree());
				}
				stream_conditional_insert_else_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_insert_clause"


	public static class conditional_insert_when_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "conditional_insert_when_part"
	// PLSQL_DMLParser.g:660:1: conditional_insert_when_part : when_key condition then_key ( multi_table_element )+ -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.conditional_insert_when_part_return conditional_insert_when_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.conditional_insert_when_part_return retval = new PLSQLParser_PLSQL_DMLParser.conditional_insert_when_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope when_key433 =null;
		ParserRuleReturnScope condition434 =null;
		ParserRuleReturnScope then_key435 =null;
		ParserRuleReturnScope multi_table_element436 =null;

		RewriteRuleSubtreeStream stream_when_key=new RewriteRuleSubtreeStream(adaptor,"rule when_key");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_then_key=new RewriteRuleSubtreeStream(adaptor,"rule then_key");
		RewriteRuleSubtreeStream stream_multi_table_element=new RewriteRuleSubtreeStream(adaptor,"rule multi_table_element");

		try {
			// PLSQL_DMLParser.g:661:5: ( when_key condition then_key ( multi_table_element )+ -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ ) )
			// PLSQL_DMLParser.g:661:10: when_key condition then_key ( multi_table_element )+
			{
			pushFollow(FOLLOW_when_key_in_conditional_insert_when_part5880);
			when_key433=gPLSQLParser.when_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_when_key.add(when_key433.getTree());
			pushFollow(FOLLOW_condition_in_conditional_insert_when_part5882);
			condition434=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition434.getTree());
			pushFollow(FOLLOW_then_key_in_conditional_insert_when_part5884);
			then_key435=gPLSQLParser.then_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_then_key.add(then_key435.getTree());
			// PLSQL_DMLParser.g:661:38: ( multi_table_element )+
			int cnt155=0;
			loop155:
			while (true) {
				int alt155=2;
				int LA155_0 = input.LA(1);
				if ( (LA155_0==SQL92_RESERVED_INTO) ) {
					alt155=1;
				}

				switch (alt155) {
				case 1 :
					// PLSQL_DMLParser.g:661:38: multi_table_element
					{
					pushFollow(FOLLOW_multi_table_element_in_conditional_insert_when_part5886);
					multi_table_element436=multi_table_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_multi_table_element.add(multi_table_element436.getTree());
					}
					break;

				default :
					if ( cnt155 >= 1 ) break loop155;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(155, input);
					throw eee;
				}
				cnt155++;
			}

			// AST REWRITE
			// elements: condition, when_key, multi_table_element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 662:9: -> ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ )
			{
				// PLSQL_DMLParser.g:662:12: ^( when_key ^( LOGIC_EXPR condition ) ( multi_table_element )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_when_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:662:23: ^( LOGIC_EXPR condition )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_2);
				adaptor.addChild(root_2, stream_condition.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				if ( !(stream_multi_table_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_multi_table_element.hasNext() ) {
					adaptor.addChild(root_1, stream_multi_table_element.nextTree());
				}
				stream_multi_table_element.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_insert_when_part"


	public static class conditional_insert_else_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "conditional_insert_else_part"
	// PLSQL_DMLParser.g:665:1: conditional_insert_else_part : else_key ^ ( multi_table_element )+ ;
	public final PLSQLParser_PLSQL_DMLParser.conditional_insert_else_part_return conditional_insert_else_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.conditional_insert_else_part_return retval = new PLSQLParser_PLSQL_DMLParser.conditional_insert_else_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope else_key437 =null;
		ParserRuleReturnScope multi_table_element438 =null;


		try {
			// PLSQL_DMLParser.g:666:5: ( else_key ^ ( multi_table_element )+ )
			// PLSQL_DMLParser.g:666:10: else_key ^ ( multi_table_element )+
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_else_key_in_conditional_insert_else_part5930);
			else_key437=gPLSQLParser.else_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(else_key437.getTree(), root_0);
			// PLSQL_DMLParser.g:666:20: ( multi_table_element )+
			int cnt156=0;
			loop156:
			while (true) {
				int alt156=2;
				int LA156_0 = input.LA(1);
				if ( (LA156_0==SQL92_RESERVED_INTO) ) {
					alt156=1;
				}

				switch (alt156) {
				case 1 :
					// PLSQL_DMLParser.g:666:20: multi_table_element
					{
					pushFollow(FOLLOW_multi_table_element_in_conditional_insert_else_part5933);
					multi_table_element438=multi_table_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, multi_table_element438.getTree());

					}
					break;

				default :
					if ( cnt156 >= 1 ) break loop156;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(156, input);
					throw eee;
				}
				cnt156++;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "conditional_insert_else_part"


	public static class insert_into_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "insert_into_clause"
	// PLSQL_DMLParser.g:669:1: insert_into_clause : into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.insert_into_clause_return insert_into_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.insert_into_clause_return retval = new PLSQLParser_PLSQL_DMLParser.insert_into_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN441=null;
		Token COMMA443=null;
		Token RIGHT_PAREN445=null;
		ParserRuleReturnScope into_key439 =null;
		ParserRuleReturnScope general_table_ref440 =null;
		ParserRuleReturnScope column_name442 =null;
		ParserRuleReturnScope column_name444 =null;

		Object LEFT_PAREN441_tree=null;
		Object COMMA443_tree=null;
		Object RIGHT_PAREN445_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_into_key=new RewriteRuleSubtreeStream(adaptor,"rule into_key");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_general_table_ref=new RewriteRuleSubtreeStream(adaptor,"rule general_table_ref");

		try {
			// PLSQL_DMLParser.g:670:5: ( into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) ) )
			// PLSQL_DMLParser.g:670:10: into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
			{
			pushFollow(FOLLOW_into_key_in_insert_into_clause5954);
			into_key439=gPLSQLParser.into_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_into_key.add(into_key439.getTree());
			pushFollow(FOLLOW_general_table_ref_in_insert_into_clause5956);
			general_table_ref440=general_table_ref();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_general_table_ref.add(general_table_ref440.getTree());
			// PLSQL_DMLParser.g:671:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
			int alt158=2;
			int LA158_0 = input.LA(1);
			if ( (LA158_0==LEFT_PAREN) ) {
				int LA158_1 = input.LA(2);
				if ( (LA158_1==DELIMITED_ID||LA158_1==INTRODUCER||LA158_1==REGULAR_ID) ) {
					alt158=1;
				}
			}
			switch (alt158) {
				case 1 :
					// PLSQL_DMLParser.g:671:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
					{
					LEFT_PAREN441=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_insert_into_clause5968); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN441);

					pushFollow(FOLLOW_column_name_in_insert_into_clause5970);
					column_name442=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name442.getTree());
					// PLSQL_DMLParser.g:671:33: ( COMMA column_name )*
					loop157:
					while (true) {
						int alt157=2;
						int LA157_0 = input.LA(1);
						if ( (LA157_0==COMMA) ) {
							alt157=1;
						}

						switch (alt157) {
						case 1 :
							// PLSQL_DMLParser.g:671:34: COMMA column_name
							{
							COMMA443=(Token)match(input,COMMA,FOLLOW_COMMA_in_insert_into_clause5973); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA443);

							pushFollow(FOLLOW_column_name_in_insert_into_clause5975);
							column_name444=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name444.getTree());
							}
							break;

						default :
							break loop157;
						}
					}

					RIGHT_PAREN445=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_insert_into_clause5979); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN445);

					}
					break;

			}

			// AST REWRITE
			// elements: general_table_ref, column_name, into_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 672:9: -> ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) )
			{
				// PLSQL_DMLParser.g:672:12: ^( into_key general_table_ref ^( COLUMNS ( column_name )* ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_into_key.nextNode(), root_1);
				adaptor.addChild(root_1, stream_general_table_ref.nextTree());
				// PLSQL_DMLParser.g:672:41: ^( COLUMNS ( column_name )* )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(COLUMNS, "COLUMNS"), root_2);
				// PLSQL_DMLParser.g:672:51: ( column_name )*
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_2, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "insert_into_clause"


	public static class values_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "values_clause"
	// PLSQL_DMLParser.g:675:1: values_clause : values_key ^ ( expression_list | expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.values_clause_return values_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.values_clause_return retval = new PLSQLParser_PLSQL_DMLParser.values_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope values_key446 =null;
		ParserRuleReturnScope expression_list447 =null;
		ParserRuleReturnScope expression_wrapper448 =null;


		try {
			// PLSQL_DMLParser.g:676:5: ( values_key ^ ( expression_list | expression_wrapper ) )
			// PLSQL_DMLParser.g:676:10: values_key ^ ( expression_list | expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_values_key_in_values_clause6024);
			values_key446=gPLSQLParser.values_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(values_key446.getTree(), root_0);
			// PLSQL_DMLParser.g:676:22: ( expression_list | expression_wrapper )
			int alt159=2;
			int LA159_0 = input.LA(1);
			if ( (LA159_0==LEFT_PAREN) ) {
				alt159=1;
			}
			else if ( (LA159_0==APPROXIMATE_NUM_LIT||LA159_0==BINDVAR||(LA159_0 >= CHAR_STRING && LA159_0 <= COLON)||LA159_0==DELIMITED_ID||LA159_0==EXACT_NUM_LIT||LA159_0==INTRODUCER||LA159_0==MINUS_SIGN||LA159_0==NATIONAL_CHAR_STRING_LIT||LA159_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA159_0==PLUS_SIGN||LA159_0==REGULAR_ID||LA159_0==SQL92_RESERVED_ALL||LA159_0==SQL92_RESERVED_ANY||LA159_0==SQL92_RESERVED_CASE||(LA159_0 >= SQL92_RESERVED_CURSOR && LA159_0 <= SQL92_RESERVED_DATE)||(LA159_0 >= SQL92_RESERVED_DEFAULT && LA159_0 <= SQL92_RESERVED_DELETE)||LA159_0==SQL92_RESERVED_DISTINCT||(LA159_0 >= SQL92_RESERVED_EXISTS && LA159_0 <= SQL92_RESERVED_FALSE)||(LA159_0 >= SQL92_RESERVED_NOT && LA159_0 <= SQL92_RESERVED_NULL)||LA159_0==SQL92_RESERVED_PRIOR||LA159_0==SQL92_RESERVED_TRUE||LA159_0==UNSIGNED_INTEGER) ) {
				alt159=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 159, 0, input);
				throw nvae;
			}

			switch (alt159) {
				case 1 :
					// PLSQL_DMLParser.g:676:23: expression_list
					{
					pushFollow(FOLLOW_expression_list_in_values_clause6028);
					expression_list447=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list447.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:676:41: expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_values_clause6032);
					expression_wrapper448=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper448.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "values_clause"


	public static class merge_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_statement"
	// PLSQL_DMLParser.g:680:1: merge_statement : merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? -> ^( merge_key ( table_alias )? tableview_name ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.merge_statement_return merge_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.merge_statement_return retval = new PLSQLParser_PLSQL_DMLParser.merge_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN456=null;
		Token RIGHT_PAREN458=null;
		ParserRuleReturnScope merge_key449 =null;
		ParserRuleReturnScope into_key450 =null;
		ParserRuleReturnScope tableview_name451 =null;
		ParserRuleReturnScope table_alias452 =null;
		ParserRuleReturnScope using_key453 =null;
		ParserRuleReturnScope selected_tableview454 =null;
		ParserRuleReturnScope on_key455 =null;
		ParserRuleReturnScope condition457 =null;
		ParserRuleReturnScope merge_update_clause459 =null;
		ParserRuleReturnScope merge_insert_clause460 =null;
		ParserRuleReturnScope error_logging_clause461 =null;

		Object LEFT_PAREN456_tree=null;
		Object RIGHT_PAREN458_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_error_logging_clause=new RewriteRuleSubtreeStream(adaptor,"rule error_logging_clause");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_into_key=new RewriteRuleSubtreeStream(adaptor,"rule into_key");
		RewriteRuleSubtreeStream stream_merge_update_clause=new RewriteRuleSubtreeStream(adaptor,"rule merge_update_clause");
		RewriteRuleSubtreeStream stream_merge_key=new RewriteRuleSubtreeStream(adaptor,"rule merge_key");
		RewriteRuleSubtreeStream stream_merge_insert_clause=new RewriteRuleSubtreeStream(adaptor,"rule merge_insert_clause");
		RewriteRuleSubtreeStream stream_on_key=new RewriteRuleSubtreeStream(adaptor,"rule on_key");
		RewriteRuleSubtreeStream stream_using_key=new RewriteRuleSubtreeStream(adaptor,"rule using_key");
		RewriteRuleSubtreeStream stream_table_alias=new RewriteRuleSubtreeStream(adaptor,"rule table_alias");
		RewriteRuleSubtreeStream stream_selected_tableview=new RewriteRuleSubtreeStream(adaptor,"rule selected_tableview");

		try {
			// PLSQL_DMLParser.g:681:5: ( merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? -> ^( merge_key ( table_alias )? tableview_name ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? ) )
			// PLSQL_DMLParser.g:681:10: merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )?
			{
			pushFollow(FOLLOW_merge_key_in_merge_statement6054);
			merge_key449=gPLSQLParser.merge_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_merge_key.add(merge_key449.getTree());
			pushFollow(FOLLOW_into_key_in_merge_statement6056);
			into_key450=gPLSQLParser.into_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_into_key.add(into_key450.getTree());
			pushFollow(FOLLOW_tableview_name_in_merge_statement6058);
			tableview_name451=gPLSQLParser.tableview_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name451.getTree());
			// PLSQL_DMLParser.g:681:44: ( table_alias )?
			int alt160=2;
			int LA160_0 = input.LA(1);
			if ( ((LA160_0 >= CHAR_STRING && LA160_0 <= CHAR_STRING_PERL)||LA160_0==DELIMITED_ID||LA160_0==INTRODUCER||LA160_0==NATIONAL_CHAR_STRING_LIT||LA160_0==REGULAR_ID) ) {
				alt160=1;
			}
			switch (alt160) {
				case 1 :
					// PLSQL_DMLParser.g:681:44: table_alias
					{
					pushFollow(FOLLOW_table_alias_in_merge_statement6060);
					table_alias452=gPLSQLParser.table_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_alias.add(table_alias452.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_using_key_in_merge_statement6071);
			using_key453=gPLSQLParser.using_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_using_key.add(using_key453.getTree());
			pushFollow(FOLLOW_selected_tableview_in_merge_statement6073);
			selected_tableview454=selected_tableview();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_selected_tableview.add(selected_tableview454.getTree());
			pushFollow(FOLLOW_on_key_in_merge_statement6075);
			on_key455=gPLSQLParser.on_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_on_key.add(on_key455.getTree());
			LEFT_PAREN456=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_merge_statement6077); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN456);

			pushFollow(FOLLOW_condition_in_merge_statement6079);
			condition457=condition();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_condition.add(condition457.getTree());
			RIGHT_PAREN458=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_merge_statement6081); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN458);

			// PLSQL_DMLParser.g:683:9: ( merge_update_clause )?
			int alt161=2;
			int LA161_0 = input.LA(1);
			if ( (LA161_0==SQL92_RESERVED_WHEN) ) {
				int LA161_1 = input.LA(2);
				if ( (LA161_1==REGULAR_ID) ) {
					alt161=1;
				}
			}
			switch (alt161) {
				case 1 :
					// PLSQL_DMLParser.g:683:9: merge_update_clause
					{
					pushFollow(FOLLOW_merge_update_clause_in_merge_statement6091);
					merge_update_clause459=merge_update_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_merge_update_clause.add(merge_update_clause459.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:683:30: ( merge_insert_clause )?
			int alt162=2;
			int LA162_0 = input.LA(1);
			if ( (LA162_0==SQL92_RESERVED_WHEN) ) {
				alt162=1;
			}
			switch (alt162) {
				case 1 :
					// PLSQL_DMLParser.g:683:30: merge_insert_clause
					{
					pushFollow(FOLLOW_merge_insert_clause_in_merge_statement6094);
					merge_insert_clause460=merge_insert_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_merge_insert_clause.add(merge_insert_clause460.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:684:9: ( error_logging_clause )?
			int alt163=2;
			int LA163_0 = input.LA(1);
			if ( (LA163_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
				int LA163_1 = input.LA(2);
				if ( (LA163_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("log"))))) {
					int LA163_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("log"))) ) {
						alt163=1;
					}
				}
			}
			switch (alt163) {
				case 1 :
					// PLSQL_DMLParser.g:684:9: error_logging_clause
					{
					pushFollow(FOLLOW_error_logging_clause_in_merge_statement6105);
					error_logging_clause461=error_logging_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_error_logging_clause.add(error_logging_clause461.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: using_key, condition, merge_key, merge_update_clause, error_logging_clause, tableview_name, merge_insert_clause, table_alias, selected_tableview
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 685:9: -> ^( merge_key ( table_alias )? tableview_name ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? )
			{
				// PLSQL_DMLParser.g:685:12: ^( merge_key ( table_alias )? tableview_name ^( using_key selected_tableview ^( LOGIC_EXPR condition ) ) ( merge_update_clause )? ( merge_insert_clause )? ( error_logging_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_merge_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:685:24: ( table_alias )?
				if ( stream_table_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_table_alias.nextTree());
				}
				stream_table_alias.reset();

				adaptor.addChild(root_1, stream_tableview_name.nextTree());
				// PLSQL_DMLParser.g:685:52: ^( using_key selected_tableview ^( LOGIC_EXPR condition ) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_using_key.nextNode(), root_2);
				adaptor.addChild(root_2, stream_selected_tableview.nextTree());
				// PLSQL_DMLParser.g:685:83: ^( LOGIC_EXPR condition )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_3);
				adaptor.addChild(root_3, stream_condition.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:686:18: ( merge_update_clause )?
				if ( stream_merge_update_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_merge_update_clause.nextTree());
				}
				stream_merge_update_clause.reset();

				// PLSQL_DMLParser.g:686:39: ( merge_insert_clause )?
				if ( stream_merge_insert_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_merge_insert_clause.nextTree());
				}
				stream_merge_insert_clause.reset();

				// PLSQL_DMLParser.g:686:60: ( error_logging_clause )?
				if ( stream_error_logging_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_error_logging_clause.nextTree());
				}
				stream_error_logging_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_statement"


	public static class merge_update_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_update_clause"
	// PLSQL_DMLParser.g:691:1: merge_update_clause : when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? -> ^( MERGE_UPDATE ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.merge_update_clause_return merge_update_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.merge_update_clause_return retval = new PLSQLParser_PLSQL_DMLParser.merge_update_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA468=null;
		ParserRuleReturnScope when_key462 =null;
		ParserRuleReturnScope matched_key463 =null;
		ParserRuleReturnScope then_key464 =null;
		ParserRuleReturnScope update_key465 =null;
		ParserRuleReturnScope set_key466 =null;
		ParserRuleReturnScope merge_element467 =null;
		ParserRuleReturnScope merge_element469 =null;
		ParserRuleReturnScope where_clause470 =null;
		ParserRuleReturnScope merge_update_delete_part471 =null;

		Object COMMA468_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_when_key=new RewriteRuleSubtreeStream(adaptor,"rule when_key");
		RewriteRuleSubtreeStream stream_where_clause=new RewriteRuleSubtreeStream(adaptor,"rule where_clause");
		RewriteRuleSubtreeStream stream_merge_element=new RewriteRuleSubtreeStream(adaptor,"rule merge_element");
		RewriteRuleSubtreeStream stream_set_key=new RewriteRuleSubtreeStream(adaptor,"rule set_key");
		RewriteRuleSubtreeStream stream_update_key=new RewriteRuleSubtreeStream(adaptor,"rule update_key");
		RewriteRuleSubtreeStream stream_merge_update_delete_part=new RewriteRuleSubtreeStream(adaptor,"rule merge_update_delete_part");
		RewriteRuleSubtreeStream stream_then_key=new RewriteRuleSubtreeStream(adaptor,"rule then_key");
		RewriteRuleSubtreeStream stream_matched_key=new RewriteRuleSubtreeStream(adaptor,"rule matched_key");

		try {
			// PLSQL_DMLParser.g:692:5: ( when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? -> ^( MERGE_UPDATE ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? ) )
			// PLSQL_DMLParser.g:692:10: when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )?
			{
			pushFollow(FOLLOW_when_key_in_merge_update_clause6185);
			when_key462=gPLSQLParser.when_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_when_key.add(when_key462.getTree());
			pushFollow(FOLLOW_matched_key_in_merge_update_clause6187);
			matched_key463=gPLSQLParser.matched_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_matched_key.add(matched_key463.getTree());
			pushFollow(FOLLOW_then_key_in_merge_update_clause6189);
			then_key464=gPLSQLParser.then_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_then_key.add(then_key464.getTree());
			pushFollow(FOLLOW_update_key_in_merge_update_clause6191);
			update_key465=gPLSQLParser.update_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_update_key.add(update_key465.getTree());
			pushFollow(FOLLOW_set_key_in_merge_update_clause6193);
			set_key466=gPLSQLParser.set_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_set_key.add(set_key466.getTree());
			pushFollow(FOLLOW_merge_element_in_merge_update_clause6204);
			merge_element467=merge_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_merge_element.add(merge_element467.getTree());
			// PLSQL_DMLParser.g:693:23: ( COMMA merge_element )*
			loop164:
			while (true) {
				int alt164=2;
				int LA164_0 = input.LA(1);
				if ( (LA164_0==COMMA) ) {
					alt164=1;
				}

				switch (alt164) {
				case 1 :
					// PLSQL_DMLParser.g:693:24: COMMA merge_element
					{
					COMMA468=(Token)match(input,COMMA,FOLLOW_COMMA_in_merge_update_clause6207); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA468);

					pushFollow(FOLLOW_merge_element_in_merge_update_clause6209);
					merge_element469=merge_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_merge_element.add(merge_element469.getTree());
					}
					break;

				default :
					break loop164;
				}
			}

			// PLSQL_DMLParser.g:694:9: ( where_clause )?
			int alt165=2;
			int LA165_0 = input.LA(1);
			if ( (LA165_0==SQL92_RESERVED_WHERE) ) {
				alt165=1;
			}
			switch (alt165) {
				case 1 :
					// PLSQL_DMLParser.g:694:9: where_clause
					{
					pushFollow(FOLLOW_where_clause_in_merge_update_clause6221);
					where_clause470=gPLSQLParser.where_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_where_clause.add(where_clause470.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:694:23: ( merge_update_delete_part )?
			int alt166=2;
			int LA166_0 = input.LA(1);
			if ( (LA166_0==SQL92_RESERVED_DELETE) ) {
				alt166=1;
			}
			switch (alt166) {
				case 1 :
					// PLSQL_DMLParser.g:694:23: merge_update_delete_part
					{
					pushFollow(FOLLOW_merge_update_delete_part_in_merge_update_clause6224);
					merge_update_delete_part471=merge_update_delete_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_merge_update_delete_part.add(merge_update_delete_part471.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: merge_update_delete_part, where_clause, merge_element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 695:9: -> ^( MERGE_UPDATE ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? )
			{
				// PLSQL_DMLParser.g:695:11: ^( MERGE_UPDATE ( merge_element )+ ( where_clause )? ( merge_update_delete_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MERGE_UPDATE, "MERGE_UPDATE"), root_1);
				if ( !(stream_merge_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_merge_element.hasNext() ) {
					adaptor.addChild(root_1, stream_merge_element.nextTree());
				}
				stream_merge_element.reset();

				// PLSQL_DMLParser.g:695:41: ( where_clause )?
				if ( stream_where_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_where_clause.nextTree());
				}
				stream_where_clause.reset();

				// PLSQL_DMLParser.g:695:55: ( merge_update_delete_part )?
				if ( stream_merge_update_delete_part.hasNext() ) {
					adaptor.addChild(root_1, stream_merge_update_delete_part.nextTree());
				}
				stream_merge_update_delete_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_update_clause"


	public static class merge_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_element"
	// PLSQL_DMLParser.g:698:1: merge_element : column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.merge_element_return merge_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.merge_element_return retval = new PLSQLParser_PLSQL_DMLParser.merge_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP473=null;
		ParserRuleReturnScope column_name472 =null;
		ParserRuleReturnScope expression474 =null;

		Object EQUALS_OP473_tree=null;
		RewriteRuleTokenStream stream_EQUALS_OP=new RewriteRuleTokenStream(adaptor,"token EQUALS_OP");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");

		try {
			// PLSQL_DMLParser.g:699:5: ( column_name EQUALS_OP expression -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) ) )
			// PLSQL_DMLParser.g:699:10: column_name EQUALS_OP expression
			{
			pushFollow(FOLLOW_column_name_in_merge_element6267);
			column_name472=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_column_name.add(column_name472.getTree());
			EQUALS_OP473=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_merge_element6269); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_EQUALS_OP.add(EQUALS_OP473);

			pushFollow(FOLLOW_expression_in_merge_element6271);
			expression474=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression474.getTree());
			// AST REWRITE
			// elements: column_name, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 700:9: -> ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
			{
				// PLSQL_DMLParser.g:700:12: ^( ASSIGN[$EQUALS_OP] column_name ^( EXPR expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ASSIGN, EQUALS_OP473), root_1);
				adaptor.addChild(root_1, stream_column_name.nextTree());
				// PLSQL_DMLParser.g:700:45: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_element"


	public static class merge_update_delete_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_update_delete_part"
	// PLSQL_DMLParser.g:703:1: merge_update_delete_part : delete_key ^ where_clause ;
	public final PLSQLParser_PLSQL_DMLParser.merge_update_delete_part_return merge_update_delete_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.merge_update_delete_part_return retval = new PLSQLParser_PLSQL_DMLParser.merge_update_delete_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope delete_key475 =null;
		ParserRuleReturnScope where_clause476 =null;


		try {
			// PLSQL_DMLParser.g:704:5: ( delete_key ^ where_clause )
			// PLSQL_DMLParser.g:704:10: delete_key ^ where_clause
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_delete_key_in_merge_update_delete_part6314);
			delete_key475=gPLSQLParser.delete_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(delete_key475.getTree(), root_0);
			pushFollow(FOLLOW_where_clause_in_merge_update_delete_part6317);
			where_clause476=gPLSQLParser.where_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, where_clause476.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_update_delete_part"


	public static class merge_insert_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_insert_clause"
	// PLSQL_DMLParser.g:707:1: merge_insert_clause : when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? -> ^( MERGE_INSERT ^( COLUMNS ( column_name )* ) expression_list ( where_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.merge_insert_clause_return merge_insert_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.merge_insert_clause_return retval = new PLSQLParser_PLSQL_DMLParser.merge_insert_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN482=null;
		Token COMMA484=null;
		Token RIGHT_PAREN486=null;
		ParserRuleReturnScope when_key477 =null;
		ParserRuleReturnScope not_key478 =null;
		ParserRuleReturnScope matched_key479 =null;
		ParserRuleReturnScope then_key480 =null;
		ParserRuleReturnScope insert_key481 =null;
		ParserRuleReturnScope column_name483 =null;
		ParserRuleReturnScope column_name485 =null;
		ParserRuleReturnScope values_key487 =null;
		ParserRuleReturnScope expression_list488 =null;
		ParserRuleReturnScope where_clause489 =null;

		Object LEFT_PAREN482_tree=null;
		Object COMMA484_tree=null;
		Object RIGHT_PAREN486_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_when_key=new RewriteRuleSubtreeStream(adaptor,"rule when_key");
		RewriteRuleSubtreeStream stream_insert_key=new RewriteRuleSubtreeStream(adaptor,"rule insert_key");
		RewriteRuleSubtreeStream stream_where_clause=new RewriteRuleSubtreeStream(adaptor,"rule where_clause");
		RewriteRuleSubtreeStream stream_not_key=new RewriteRuleSubtreeStream(adaptor,"rule not_key");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_expression_list=new RewriteRuleSubtreeStream(adaptor,"rule expression_list");
		RewriteRuleSubtreeStream stream_then_key=new RewriteRuleSubtreeStream(adaptor,"rule then_key");
		RewriteRuleSubtreeStream stream_values_key=new RewriteRuleSubtreeStream(adaptor,"rule values_key");
		RewriteRuleSubtreeStream stream_matched_key=new RewriteRuleSubtreeStream(adaptor,"rule matched_key");

		try {
			// PLSQL_DMLParser.g:708:5: ( when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? -> ^( MERGE_INSERT ^( COLUMNS ( column_name )* ) expression_list ( where_clause )? ) )
			// PLSQL_DMLParser.g:708:10: when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )?
			{
			pushFollow(FOLLOW_when_key_in_merge_insert_clause6337);
			when_key477=gPLSQLParser.when_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_when_key.add(when_key477.getTree());
			pushFollow(FOLLOW_not_key_in_merge_insert_clause6339);
			not_key478=gPLSQLParser.not_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_not_key.add(not_key478.getTree());
			pushFollow(FOLLOW_matched_key_in_merge_insert_clause6341);
			matched_key479=gPLSQLParser.matched_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_matched_key.add(matched_key479.getTree());
			pushFollow(FOLLOW_then_key_in_merge_insert_clause6343);
			then_key480=gPLSQLParser.then_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_then_key.add(then_key480.getTree());
			pushFollow(FOLLOW_insert_key_in_merge_insert_clause6345);
			insert_key481=gPLSQLParser.insert_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_insert_key.add(insert_key481.getTree());
			// PLSQL_DMLParser.g:709:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
			int alt168=2;
			int LA168_0 = input.LA(1);
			if ( (LA168_0==LEFT_PAREN) ) {
				alt168=1;
			}
			switch (alt168) {
				case 1 :
					// PLSQL_DMLParser.g:709:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
					{
					LEFT_PAREN482=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_merge_insert_clause6357); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN482);

					pushFollow(FOLLOW_column_name_in_merge_insert_clause6359);
					column_name483=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name483.getTree());
					// PLSQL_DMLParser.g:709:33: ( COMMA column_name )*
					loop167:
					while (true) {
						int alt167=2;
						int LA167_0 = input.LA(1);
						if ( (LA167_0==COMMA) ) {
							alt167=1;
						}

						switch (alt167) {
						case 1 :
							// PLSQL_DMLParser.g:709:34: COMMA column_name
							{
							COMMA484=(Token)match(input,COMMA,FOLLOW_COMMA_in_merge_insert_clause6362); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA484);

							pushFollow(FOLLOW_column_name_in_merge_insert_clause6364);
							column_name485=gPLSQLParser.column_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_column_name.add(column_name485.getTree());
							}
							break;

						default :
							break loop167;
						}
					}

					RIGHT_PAREN486=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_merge_insert_clause6368); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN486);

					}
					break;

			}

			pushFollow(FOLLOW_values_key_in_merge_insert_clause6380);
			values_key487=gPLSQLParser.values_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_values_key.add(values_key487.getTree());
			pushFollow(FOLLOW_expression_list_in_merge_insert_clause6382);
			expression_list488=expression_list();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_list.add(expression_list488.getTree());
			// PLSQL_DMLParser.g:710:36: ( where_clause )?
			int alt169=2;
			int LA169_0 = input.LA(1);
			if ( (LA169_0==SQL92_RESERVED_WHERE) ) {
				alt169=1;
			}
			switch (alt169) {
				case 1 :
					// PLSQL_DMLParser.g:710:36: where_clause
					{
					pushFollow(FOLLOW_where_clause_in_merge_insert_clause6384);
					where_clause489=gPLSQLParser.where_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_where_clause.add(where_clause489.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: column_name, where_clause, expression_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 711:9: -> ^( MERGE_INSERT ^( COLUMNS ( column_name )* ) expression_list ( where_clause )? )
			{
				// PLSQL_DMLParser.g:711:12: ^( MERGE_INSERT ^( COLUMNS ( column_name )* ) expression_list ( where_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MERGE_INSERT, "MERGE_INSERT"), root_1);
				// PLSQL_DMLParser.g:711:27: ^( COLUMNS ( column_name )* )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(COLUMNS, "COLUMNS"), root_2);
				// PLSQL_DMLParser.g:711:37: ( column_name )*
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_2, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_expression_list.nextTree());
				// PLSQL_DMLParser.g:711:67: ( where_clause )?
				if ( stream_where_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_where_clause.nextTree());
				}
				stream_where_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_insert_clause"


	public static class selected_tableview_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "selected_tableview"
	// PLSQL_DMLParser.g:714:1: selected_tableview : ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? -> ^( SELECTED_TABLEVIEW ( table_alias )? ( tableview_name )? ( select_statement )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.selected_tableview_return selected_tableview() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.selected_tableview_return retval = new PLSQLParser_PLSQL_DMLParser.selected_tableview_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN491=null;
		Token RIGHT_PAREN493=null;
		ParserRuleReturnScope tableview_name490 =null;
		ParserRuleReturnScope select_statement492 =null;
		ParserRuleReturnScope table_alias494 =null;

		Object LEFT_PAREN491_tree=null;
		Object RIGHT_PAREN493_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");
		RewriteRuleSubtreeStream stream_select_statement=new RewriteRuleSubtreeStream(adaptor,"rule select_statement");
		RewriteRuleSubtreeStream stream_table_alias=new RewriteRuleSubtreeStream(adaptor,"rule table_alias");

		try {
			// PLSQL_DMLParser.g:715:5: ( ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? -> ^( SELECTED_TABLEVIEW ( table_alias )? ( tableview_name )? ( select_statement )? ) )
			// PLSQL_DMLParser.g:715:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )?
			{
			// PLSQL_DMLParser.g:715:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN )
			int alt170=2;
			int LA170_0 = input.LA(1);
			if ( (LA170_0==DELIMITED_ID||LA170_0==INTRODUCER||LA170_0==REGULAR_ID) ) {
				alt170=1;
			}
			else if ( (LA170_0==LEFT_PAREN) ) {
				alt170=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 170, 0, input);
				throw nvae;
			}

			switch (alt170) {
				case 1 :
					// PLSQL_DMLParser.g:715:12: tableview_name
					{
					pushFollow(FOLLOW_tableview_name_in_selected_tableview6434);
					tableview_name490=gPLSQLParser.tableview_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name490.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:715:29: LEFT_PAREN select_statement RIGHT_PAREN
					{
					LEFT_PAREN491=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_selected_tableview6438); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN491);

					pushFollow(FOLLOW_select_statement_in_selected_tableview6440);
					select_statement492=select_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_select_statement.add(select_statement492.getTree());
					RIGHT_PAREN493=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_selected_tableview6442); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN493);

					}
					break;

			}

			// PLSQL_DMLParser.g:715:70: ( table_alias )?
			int alt171=2;
			int LA171_0 = input.LA(1);
			if ( ((LA171_0 >= CHAR_STRING && LA171_0 <= CHAR_STRING_PERL)||LA171_0==DELIMITED_ID||LA171_0==INTRODUCER||LA171_0==NATIONAL_CHAR_STRING_LIT||LA171_0==REGULAR_ID) ) {
				alt171=1;
			}
			switch (alt171) {
				case 1 :
					// PLSQL_DMLParser.g:715:70: table_alias
					{
					pushFollow(FOLLOW_table_alias_in_selected_tableview6445);
					table_alias494=gPLSQLParser.table_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_alias.add(table_alias494.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: tableview_name, table_alias, select_statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 716:9: -> ^( SELECTED_TABLEVIEW ( table_alias )? ( tableview_name )? ( select_statement )? )
			{
				// PLSQL_DMLParser.g:716:12: ^( SELECTED_TABLEVIEW ( table_alias )? ( tableview_name )? ( select_statement )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECTED_TABLEVIEW, "SELECTED_TABLEVIEW"), root_1);
				// PLSQL_DMLParser.g:716:33: ( table_alias )?
				if ( stream_table_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_table_alias.nextTree());
				}
				stream_table_alias.reset();

				// PLSQL_DMLParser.g:716:46: ( tableview_name )?
				if ( stream_tableview_name.hasNext() ) {
					adaptor.addChild(root_1, stream_tableview_name.nextTree());
				}
				stream_tableview_name.reset();

				// PLSQL_DMLParser.g:716:62: ( select_statement )?
				if ( stream_select_statement.hasNext() ) {
					adaptor.addChild(root_1, stream_select_statement.nextTree());
				}
				stream_select_statement.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "selected_tableview"


	public static class lock_table_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lock_table_statement"
	// PLSQL_DMLParser.g:721:1: lock_table_statement : lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.lock_table_statement_return lock_table_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.lock_table_statement_return retval = new PLSQLParser_PLSQL_DMLParser.lock_table_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA498=null;
		ParserRuleReturnScope lock_key495 =null;
		ParserRuleReturnScope table_key496 =null;
		ParserRuleReturnScope lock_table_element497 =null;
		ParserRuleReturnScope lock_table_element499 =null;
		ParserRuleReturnScope in_key500 =null;
		ParserRuleReturnScope lock_mode501 =null;
		ParserRuleReturnScope mode_key502 =null;
		ParserRuleReturnScope wait_nowait_part503 =null;

		Object COMMA498_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_table_key=new RewriteRuleSubtreeStream(adaptor,"rule table_key");
		RewriteRuleSubtreeStream stream_wait_nowait_part=new RewriteRuleSubtreeStream(adaptor,"rule wait_nowait_part");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_mode_key=new RewriteRuleSubtreeStream(adaptor,"rule mode_key");
		RewriteRuleSubtreeStream stream_lock_key=new RewriteRuleSubtreeStream(adaptor,"rule lock_key");
		RewriteRuleSubtreeStream stream_lock_mode=new RewriteRuleSubtreeStream(adaptor,"rule lock_mode");
		RewriteRuleSubtreeStream stream_lock_table_element=new RewriteRuleSubtreeStream(adaptor,"rule lock_table_element");

		try {
			// PLSQL_DMLParser.g:722:5: ( lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? ) )
			// PLSQL_DMLParser.g:722:10: lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )?
			{
			pushFollow(FOLLOW_lock_key_in_lock_table_statement6491);
			lock_key495=gPLSQLParser.lock_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lock_key.add(lock_key495.getTree());
			pushFollow(FOLLOW_table_key_in_lock_table_statement6493);
			table_key496=gPLSQLParser.table_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_table_key.add(table_key496.getTree());
			pushFollow(FOLLOW_lock_table_element_in_lock_table_statement6504);
			lock_table_element497=lock_table_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lock_table_element.add(lock_table_element497.getTree());
			// PLSQL_DMLParser.g:723:28: ( COMMA lock_table_element )*
			loop172:
			while (true) {
				int alt172=2;
				int LA172_0 = input.LA(1);
				if ( (LA172_0==COMMA) ) {
					alt172=1;
				}

				switch (alt172) {
				case 1 :
					// PLSQL_DMLParser.g:723:29: COMMA lock_table_element
					{
					COMMA498=(Token)match(input,COMMA,FOLLOW_COMMA_in_lock_table_statement6507); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA498);

					pushFollow(FOLLOW_lock_table_element_in_lock_table_statement6509);
					lock_table_element499=lock_table_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_lock_table_element.add(lock_table_element499.getTree());
					}
					break;

				default :
					break loop172;
				}
			}

			pushFollow(FOLLOW_in_key_in_lock_table_statement6522);
			in_key500=gPLSQLParser.in_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_in_key.add(in_key500.getTree());
			pushFollow(FOLLOW_lock_mode_in_lock_table_statement6524);
			lock_mode501=lock_mode();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_lock_mode.add(lock_mode501.getTree());
			pushFollow(FOLLOW_mode_key_in_lock_table_statement6526);
			mode_key502=gPLSQLParser.mode_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_mode_key.add(mode_key502.getTree());
			// PLSQL_DMLParser.g:724:35: ( wait_nowait_part )?
			int alt173=2;
			int LA173_0 = input.LA(1);
			if ( (LA173_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("wait"))))) {
				int LA173_1 = input.LA(2);
				if ( (LA173_1==APPROXIMATE_NUM_LIT||LA173_1==BINDVAR||(LA173_1 >= CHAR_STRING && LA173_1 <= COLON)||LA173_1==DELIMITED_ID||LA173_1==EXACT_NUM_LIT||LA173_1==INTRODUCER||LA173_1==LEFT_PAREN||LA173_1==MINUS_SIGN||LA173_1==NATIONAL_CHAR_STRING_LIT||LA173_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA173_1==PLUS_SIGN||LA173_1==SQL92_RESERVED_ALL||LA173_1==SQL92_RESERVED_ANY||LA173_1==SQL92_RESERVED_CASE||(LA173_1 >= SQL92_RESERVED_CURSOR && LA173_1 <= SQL92_RESERVED_DATE)||(LA173_1 >= SQL92_RESERVED_DEFAULT && LA173_1 <= SQL92_RESERVED_DELETE)||LA173_1==SQL92_RESERVED_DISTINCT||(LA173_1 >= SQL92_RESERVED_EXISTS && LA173_1 <= SQL92_RESERVED_FALSE)||(LA173_1 >= SQL92_RESERVED_NOT && LA173_1 <= SQL92_RESERVED_NULL)||LA173_1==SQL92_RESERVED_PRIOR||LA173_1==SQL92_RESERVED_TRUE||LA173_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("wait")))) {
					alt173=1;
				}
				else if ( (LA173_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("wait"))))) {
					int LA173_5 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("wait"))) ) {
						alt173=1;
					}
				}
			}
			else if ( (LA173_0==PLSQL_RESERVED_NOWAIT) ) {
				alt173=1;
			}
			switch (alt173) {
				case 1 :
					// PLSQL_DMLParser.g:724:35: wait_nowait_part
					{
					pushFollow(FOLLOW_wait_nowait_part_in_lock_table_statement6528);
					wait_nowait_part503=wait_nowait_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wait_nowait_part.add(wait_nowait_part503.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: lock_key, lock_mode, wait_nowait_part, lock_table_element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 725:9: -> ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? )
			{
				// PLSQL_DMLParser.g:725:12: ^( lock_key ( lock_table_element )+ lock_mode ( wait_nowait_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_lock_key.nextNode(), root_1);
				if ( !(stream_lock_table_element.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_lock_table_element.hasNext() ) {
					adaptor.addChild(root_1, stream_lock_table_element.nextTree());
				}
				stream_lock_table_element.reset();

				adaptor.addChild(root_1, stream_lock_mode.nextTree());
				// PLSQL_DMLParser.g:725:53: ( wait_nowait_part )?
				if ( stream_wait_nowait_part.hasNext() ) {
					adaptor.addChild(root_1, stream_wait_nowait_part.nextTree());
				}
				stream_wait_nowait_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lock_table_statement"


	public static class wait_nowait_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wait_nowait_part"
	// PLSQL_DMLParser.g:728:1: wait_nowait_part : ( wait_key expression -> ^( wait_key ^( EXPR expression ) ) | nowait_key );
	public final PLSQLParser_PLSQL_DMLParser.wait_nowait_part_return wait_nowait_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.wait_nowait_part_return retval = new PLSQLParser_PLSQL_DMLParser.wait_nowait_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope wait_key504 =null;
		ParserRuleReturnScope expression505 =null;
		ParserRuleReturnScope nowait_key506 =null;

		RewriteRuleSubtreeStream stream_wait_key=new RewriteRuleSubtreeStream(adaptor,"rule wait_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:729:5: ( wait_key expression -> ^( wait_key ^( EXPR expression ) ) | nowait_key )
			int alt174=2;
			int LA174_0 = input.LA(1);
			if ( (LA174_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("wait")))) {
				alt174=1;
			}
			else if ( (LA174_0==PLSQL_RESERVED_NOWAIT) ) {
				alt174=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 174, 0, input);
				throw nvae;
			}

			switch (alt174) {
				case 1 :
					// PLSQL_DMLParser.g:729:10: wait_key expression
					{
					pushFollow(FOLLOW_wait_key_in_wait_nowait_part6571);
					wait_key504=gPLSQLParser.wait_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_wait_key.add(wait_key504.getTree());
					pushFollow(FOLLOW_expression_in_wait_nowait_part6573);
					expression505=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression505.getTree());
					// AST REWRITE
					// elements: expression, wait_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 729:30: -> ^( wait_key ^( EXPR expression ) )
					{
						// PLSQL_DMLParser.g:729:33: ^( wait_key ^( EXPR expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_wait_key.nextNode(), root_1);
						// PLSQL_DMLParser.g:729:44: ^( EXPR expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:730:10: nowait_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_nowait_key_in_wait_nowait_part6596);
					nowait_key506=gPLSQLParser.nowait_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nowait_key506.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wait_nowait_part"


	public static class lock_table_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lock_table_element"
	// PLSQL_DMLParser.g:735:1: lock_table_element : tableview_name ( partition_extension_clause )? -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.lock_table_element_return lock_table_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.lock_table_element_return retval = new PLSQLParser_PLSQL_DMLParser.lock_table_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope tableview_name507 =null;
		ParserRuleReturnScope partition_extension_clause508 =null;

		RewriteRuleSubtreeStream stream_partition_extension_clause=new RewriteRuleSubtreeStream(adaptor,"rule partition_extension_clause");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");

		try {
			// PLSQL_DMLParser.g:736:5: ( tableview_name ( partition_extension_clause )? -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? ) )
			// PLSQL_DMLParser.g:736:10: tableview_name ( partition_extension_clause )?
			{
			pushFollow(FOLLOW_tableview_name_in_lock_table_element6618);
			tableview_name507=gPLSQLParser.tableview_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name507.getTree());
			// PLSQL_DMLParser.g:736:25: ( partition_extension_clause )?
			int alt175=2;
			int LA175_0 = input.LA(1);
			if ( (LA175_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("subpartition"))||(input.LT(1).getText().equalsIgnoreCase("partition"))))) {
				alt175=1;
			}
			switch (alt175) {
				case 1 :
					// PLSQL_DMLParser.g:736:25: partition_extension_clause
					{
					pushFollow(FOLLOW_partition_extension_clause_in_lock_table_element6620);
					partition_extension_clause508=gPLSQLParser.partition_extension_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_partition_extension_clause.add(partition_extension_clause508.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: partition_extension_clause, tableview_name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 737:9: -> ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? )
			{
				// PLSQL_DMLParser.g:737:12: ^( LOCK_TABLE_ELEMENT tableview_name ( partition_extension_clause )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOCK_TABLE_ELEMENT, "LOCK_TABLE_ELEMENT"), root_1);
				adaptor.addChild(root_1, stream_tableview_name.nextTree());
				// PLSQL_DMLParser.g:737:48: ( partition_extension_clause )?
				if ( stream_partition_extension_clause.hasNext() ) {
					adaptor.addChild(root_1, stream_partition_extension_clause.nextTree());
				}
				stream_partition_extension_clause.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lock_table_element"


	public static class lock_mode_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lock_mode"
	// PLSQL_DMLParser.g:740:1: lock_mode : ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key );
	public final PLSQLParser_PLSQL_DMLParser.lock_mode_return lock_mode() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.lock_mode_return retval = new PLSQLParser_PLSQL_DMLParser.lock_mode_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope row_key509 =null;
		ParserRuleReturnScope share_key510 =null;
		ParserRuleReturnScope row_key511 =null;
		ParserRuleReturnScope exclusive_key512 =null;
		ParserRuleReturnScope share_key513 =null;
		ParserRuleReturnScope update_key514 =null;
		ParserRuleReturnScope share_key515 =null;
		ParserRuleReturnScope row_key516 =null;
		ParserRuleReturnScope exclusive_key517 =null;
		ParserRuleReturnScope exclusive_key518 =null;


		try {
			// PLSQL_DMLParser.g:741:5: ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key )
			int alt177=5;
			switch ( input.LA(1) ) {
			case REGULAR_ID:
				{
				int LA177_1 = input.LA(2);
				if ( (LA177_1==PLSQL_RESERVED_SHARE) ) {
					alt177=1;
				}
				else if ( (LA177_1==PLSQL_RESERVED_EXCLUSIVE) ) {
					alt177=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case PLSQL_RESERVED_SHARE:
				{
				int LA177_2 = input.LA(2);
				if ( (LA177_2==PLSQL_RESERVED_MODE||LA177_2==SQL92_RESERVED_UPDATE) ) {
					alt177=3;
				}
				else if ( (LA177_2==REGULAR_ID) ) {
					alt177=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 177, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case PLSQL_RESERVED_EXCLUSIVE:
				{
				alt177=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 177, 0, input);
				throw nvae;
			}
			switch (alt177) {
				case 1 :
					// PLSQL_DMLParser.g:741:10: row_key share_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_row_key_in_lock_mode6660);
					row_key509=gPLSQLParser.row_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, row_key509.getTree());

					pushFollow(FOLLOW_share_key_in_lock_mode6662);
					share_key510=gPLSQLParser.share_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, share_key510.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:742:10: row_key exclusive_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_row_key_in_lock_mode6673);
					row_key511=gPLSQLParser.row_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, row_key511.getTree());

					pushFollow(FOLLOW_exclusive_key_in_lock_mode6675);
					exclusive_key512=gPLSQLParser.exclusive_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exclusive_key512.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:743:10: share_key ( update_key )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_share_key_in_lock_mode6686);
					share_key513=gPLSQLParser.share_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, share_key513.getTree());

					// PLSQL_DMLParser.g:743:20: ( update_key )?
					int alt176=2;
					int LA176_0 = input.LA(1);
					if ( (LA176_0==SQL92_RESERVED_UPDATE) ) {
						alt176=1;
					}
					switch (alt176) {
						case 1 :
							// PLSQL_DMLParser.g:743:20: update_key
							{
							pushFollow(FOLLOW_update_key_in_lock_mode6688);
							update_key514=gPLSQLParser.update_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, update_key514.getTree());

							}
							break;

					}

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:744:10: share_key row_key exclusive_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_share_key_in_lock_mode6700);
					share_key515=gPLSQLParser.share_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, share_key515.getTree());

					pushFollow(FOLLOW_row_key_in_lock_mode6702);
					row_key516=gPLSQLParser.row_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, row_key516.getTree());

					pushFollow(FOLLOW_exclusive_key_in_lock_mode6704);
					exclusive_key517=gPLSQLParser.exclusive_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exclusive_key517.getTree());

					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:745:10: exclusive_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_exclusive_key_in_lock_mode6715);
					exclusive_key518=gPLSQLParser.exclusive_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exclusive_key518.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lock_mode"


	public static class general_table_ref_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "general_table_ref"
	// PLSQL_DMLParser.g:751:1: general_table_ref : ( dml_table_expression_clause_simple | only_key LEFT_PAREN dml_table_expression_clause_simple RIGHT_PAREN ) ( table_alias )? -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause_simple ( only_key )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.general_table_ref_return general_table_ref() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.general_table_ref_return retval = new PLSQLParser_PLSQL_DMLParser.general_table_ref_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN521=null;
		Token RIGHT_PAREN523=null;
		ParserRuleReturnScope dml_table_expression_clause_simple519 =null;
		ParserRuleReturnScope only_key520 =null;
		ParserRuleReturnScope dml_table_expression_clause_simple522 =null;
		ParserRuleReturnScope table_alias524 =null;

		Object LEFT_PAREN521_tree=null;
		Object RIGHT_PAREN523_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_dml_table_expression_clause_simple=new RewriteRuleSubtreeStream(adaptor,"rule dml_table_expression_clause_simple");
		RewriteRuleSubtreeStream stream_only_key=new RewriteRuleSubtreeStream(adaptor,"rule only_key");
		RewriteRuleSubtreeStream stream_table_alias=new RewriteRuleSubtreeStream(adaptor,"rule table_alias");

		try {
			// PLSQL_DMLParser.g:752:5: ( ( dml_table_expression_clause_simple | only_key LEFT_PAREN dml_table_expression_clause_simple RIGHT_PAREN ) ( table_alias )? -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause_simple ( only_key )? ) )
			// PLSQL_DMLParser.g:752:10: ( dml_table_expression_clause_simple | only_key LEFT_PAREN dml_table_expression_clause_simple RIGHT_PAREN ) ( table_alias )?
			{
			// PLSQL_DMLParser.g:752:10: ( dml_table_expression_clause_simple | only_key LEFT_PAREN dml_table_expression_clause_simple RIGHT_PAREN )
			int alt178=2;
			int LA178_0 = input.LA(1);
			if ( (LA178_0==DELIMITED_ID||LA178_0==INTRODUCER||LA178_0==LEFT_PAREN||(LA178_0 >= SQL92_RESERVED_TABLE && LA178_0 <= SQL92_RESERVED_THE)) ) {
				alt178=1;
			}
			else if ( (LA178_0==REGULAR_ID) ) {
				int LA178_5 = input.LA(2);
				if ( (!(((input.LT(1).getText().equalsIgnoreCase("only"))))) ) {
					alt178=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("only"))) ) {
					alt178=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 178, 5, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 178, 0, input);
				throw nvae;
			}

			switch (alt178) {
				case 1 :
					// PLSQL_DMLParser.g:752:15: dml_table_expression_clause_simple
					{
					pushFollow(FOLLOW_dml_table_expression_clause_simple_in_general_table_ref6743);
					dml_table_expression_clause_simple519=dml_table_expression_clause_simple();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dml_table_expression_clause_simple.add(dml_table_expression_clause_simple519.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:753:14: only_key LEFT_PAREN dml_table_expression_clause_simple RIGHT_PAREN
					{
					pushFollow(FOLLOW_only_key_in_general_table_ref6758);
					only_key520=gPLSQLParser.only_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_only_key.add(only_key520.getTree());
					LEFT_PAREN521=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_general_table_ref6760); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN521);

					pushFollow(FOLLOW_dml_table_expression_clause_simple_in_general_table_ref6762);
					dml_table_expression_clause_simple522=dml_table_expression_clause_simple();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_dml_table_expression_clause_simple.add(dml_table_expression_clause_simple522.getTree());
					RIGHT_PAREN523=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_general_table_ref6764); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN523);

					}
					break;

			}

			// PLSQL_DMLParser.g:754:14: ( table_alias )?
			int alt179=2;
			int LA179_0 = input.LA(1);
			if ( ((LA179_0 >= CHAR_STRING && LA179_0 <= CHAR_STRING_PERL)||LA179_0==DELIMITED_ID||LA179_0==INTRODUCER||LA179_0==NATIONAL_CHAR_STRING_LIT) ) {
				alt179=1;
			}
			else if ( (LA179_0==REGULAR_ID) ) {
				int LA179_2 = input.LA(2);
				if ( (!((((input.LT(1).getText().equalsIgnoreCase("return"))||(input.LT(1).getText().equalsIgnoreCase("save"))||(input.LT(1).getText().equalsIgnoreCase("set"))||(input.LT(1).getText().equalsIgnoreCase("returning"))||(input.LT(1).getText().equalsIgnoreCase("log")))))) ) {
					alt179=1;
				}
			}
			switch (alt179) {
				case 1 :
					// PLSQL_DMLParser.g:754:14: table_alias
					{
					pushFollow(FOLLOW_table_alias_in_general_table_ref6779);
					table_alias524=gPLSQLParser.table_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_alias.add(table_alias524.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: only_key, table_alias, dml_table_expression_clause_simple
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 755:9: -> ^( TABLE_REF ( table_alias )? dml_table_expression_clause_simple ( only_key )? )
			{
				// PLSQL_DMLParser.g:755:12: ^( TABLE_REF ( table_alias )? dml_table_expression_clause_simple ( only_key )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_REF, "TABLE_REF"), root_1);
				// PLSQL_DMLParser.g:755:24: ( table_alias )?
				if ( stream_table_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_table_alias.nextTree());
				}
				stream_table_alias.reset();

				adaptor.addChild(root_1, stream_dml_table_expression_clause_simple.nextTree());
				// PLSQL_DMLParser.g:755:72: ( only_key )?
				if ( stream_only_key.hasNext() ) {
					adaptor.addChild(root_1, stream_only_key.nextTree());
				}
				stream_only_key.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "general_table_ref"


	public static class static_returning_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "static_returning_clause"
	// PLSQL_DMLParser.g:758:1: static_returning_clause : ( returning_key | return_key ) expression ( COMMA expression )* into_clause -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause ) ;
	public final PLSQLParser_PLSQL_DMLParser.static_returning_clause_return static_returning_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.static_returning_clause_return retval = new PLSQLParser_PLSQL_DMLParser.static_returning_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA528=null;
		ParserRuleReturnScope returning_key525 =null;
		ParserRuleReturnScope return_key526 =null;
		ParserRuleReturnScope expression527 =null;
		ParserRuleReturnScope expression529 =null;
		ParserRuleReturnScope into_clause530 =null;

		Object COMMA528_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_returning_key=new RewriteRuleSubtreeStream(adaptor,"rule returning_key");
		RewriteRuleSubtreeStream stream_return_key=new RewriteRuleSubtreeStream(adaptor,"rule return_key");
		RewriteRuleSubtreeStream stream_into_clause=new RewriteRuleSubtreeStream(adaptor,"rule into_clause");

		try {
			// PLSQL_DMLParser.g:759:5: ( ( returning_key | return_key ) expression ( COMMA expression )* into_clause -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause ) )
			// PLSQL_DMLParser.g:759:10: ( returning_key | return_key ) expression ( COMMA expression )* into_clause
			{
			// PLSQL_DMLParser.g:759:10: ( returning_key | return_key )
			int alt180=2;
			int LA180_0 = input.LA(1);
			if ( (LA180_0==REGULAR_ID) ) {
				int LA180_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("returning"))) ) {
					alt180=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("return"))) ) {
					alt180=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 180, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 180, 0, input);
				throw nvae;
			}

			switch (alt180) {
				case 1 :
					// PLSQL_DMLParser.g:759:11: returning_key
					{
					pushFollow(FOLLOW_returning_key_in_static_returning_clause6823);
					returning_key525=gPLSQLParser.returning_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_returning_key.add(returning_key525.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:759:25: return_key
					{
					pushFollow(FOLLOW_return_key_in_static_returning_clause6825);
					return_key526=gPLSQLParser.return_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_return_key.add(return_key526.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_expression_in_static_returning_clause6828);
			expression527=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression527.getTree());
			// PLSQL_DMLParser.g:759:48: ( COMMA expression )*
			loop181:
			while (true) {
				int alt181=2;
				int LA181_0 = input.LA(1);
				if ( (LA181_0==COMMA) ) {
					alt181=1;
				}

				switch (alt181) {
				case 1 :
					// PLSQL_DMLParser.g:759:49: COMMA expression
					{
					COMMA528=(Token)match(input,COMMA,FOLLOW_COMMA_in_static_returning_clause6831); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA528);

					pushFollow(FOLLOW_expression_in_static_returning_clause6833);
					expression529=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression529.getTree());
					}
					break;

				default :
					break loop181;
				}
			}

			pushFollow(FOLLOW_into_clause_in_static_returning_clause6846);
			into_clause530=gPLSQLParser.into_clause();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_into_clause.add(into_clause530.getTree());
			// AST REWRITE
			// elements: expression, into_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 761:9: -> ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause )
			{
				// PLSQL_DMLParser.g:761:12: ^( STATIC_RETURNING ( ^( EXPR expression ) )+ into_clause )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(STATIC_RETURNING, "STATIC_RETURNING"), root_1);
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					// PLSQL_DMLParser.g:761:31: ^( EXPR expression )
					{
					Object root_2 = (Object)adaptor.nil();
					root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
					adaptor.addChild(root_2, stream_expression.nextTree());
					adaptor.addChild(root_1, root_2);
					}

				}
				stream_expression.reset();

				adaptor.addChild(root_1, stream_into_clause.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "static_returning_clause"


	public static class error_logging_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "error_logging_clause"
	// PLSQL_DMLParser.g:764:1: error_logging_clause : log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.error_logging_clause_return error_logging_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.error_logging_clause_return retval = new PLSQLParser_PLSQL_DMLParser.error_logging_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope log_key531 =null;
		ParserRuleReturnScope errors_key532 =null;
		ParserRuleReturnScope error_logging_into_part533 =null;
		ParserRuleReturnScope expression_wrapper534 =null;
		ParserRuleReturnScope error_logging_reject_part535 =null;

		RewriteRuleSubtreeStream stream_error_logging_into_part=new RewriteRuleSubtreeStream(adaptor,"rule error_logging_into_part");
		RewriteRuleSubtreeStream stream_log_key=new RewriteRuleSubtreeStream(adaptor,"rule log_key");
		RewriteRuleSubtreeStream stream_expression_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule expression_wrapper");
		RewriteRuleSubtreeStream stream_error_logging_reject_part=new RewriteRuleSubtreeStream(adaptor,"rule error_logging_reject_part");
		RewriteRuleSubtreeStream stream_errors_key=new RewriteRuleSubtreeStream(adaptor,"rule errors_key");

		try {
			// PLSQL_DMLParser.g:765:5: ( log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? ) )
			// PLSQL_DMLParser.g:765:10: log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )?
			{
			pushFollow(FOLLOW_log_key_in_error_logging_clause6889);
			log_key531=gPLSQLParser.log_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_log_key.add(log_key531.getTree());
			pushFollow(FOLLOW_errors_key_in_error_logging_clause6891);
			errors_key532=gPLSQLParser.errors_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_errors_key.add(errors_key532.getTree());
			// PLSQL_DMLParser.g:766:9: ( error_logging_into_part )?
			int alt182=2;
			alt182 = dfa182.predict(input);
			switch (alt182) {
				case 1 :
					// PLSQL_DMLParser.g:766:9: error_logging_into_part
					{
					pushFollow(FOLLOW_error_logging_into_part_in_error_logging_clause6902);
					error_logging_into_part533=error_logging_into_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_error_logging_into_part.add(error_logging_into_part533.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:767:9: ( ( LEFT_PAREN )=> expression_wrapper )?
			int alt183=2;
			int LA183_0 = input.LA(1);
			if ( (LA183_0==SQL92_RESERVED_CURSOR) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_NOT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==MINUS_SIGN) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==PLUS_SIGN) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_PRIOR) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("reject"))||(input.LT(1).getText().equalsIgnoreCase("save"))))) {
				int LA183_7 = input.LA(2);
				if ( (synpred19_PLSQL_DMLParser()) ) {
					alt183=1;
				}
			}
			else if ( (LA183_0==SQL92_RESERVED_DISTINCT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_ALL) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_CASE) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_EXISTS) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_ANY) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==INTRODUCER) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==DELIMITED_ID) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==BINDVAR) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==COLON) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_DELETE) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==UNSIGNED_INTEGER) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==EXACT_NUM_LIT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==APPROXIMATE_NUM_LIT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_DATE) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( ((LA183_0 >= CHAR_STRING && LA183_0 <= CHAR_STRING_PERL)||LA183_0==NATIONAL_CHAR_STRING_LIT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_NULL) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_TRUE) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_FALSE) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==SQL92_RESERVED_DEFAULT) && (synpred19_PLSQL_DMLParser())) {
				alt183=1;
			}
			else if ( (LA183_0==LEFT_PAREN) ) {
				int LA183_27 = input.LA(2);
				if ( (synpred19_PLSQL_DMLParser()) ) {
					alt183=1;
				}
			}
			switch (alt183) {
				case 1 :
					// PLSQL_DMLParser.g:767:10: ( LEFT_PAREN )=> expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_error_logging_clause6919);
					expression_wrapper534=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_wrapper.add(expression_wrapper534.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:768:9: ( error_logging_reject_part )?
			int alt184=2;
			int LA184_0 = input.LA(1);
			if ( (LA184_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("reject"))||(input.LT(1).getText().equalsIgnoreCase("save"))))) {
				int LA184_1 = input.LA(2);
				if ( (LA184_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("reject"))||(input.LT(1).getText().equalsIgnoreCase("save"))))) {
					int LA184_3 = input.LA(3);
					if ( (LA184_3==APPROXIMATE_NUM_LIT||LA184_3==BINDVAR||(LA184_3 >= CHAR_STRING && LA184_3 <= COLON)||LA184_3==DELIMITED_ID||LA184_3==EXACT_NUM_LIT||LA184_3==INTRODUCER||LA184_3==LEFT_PAREN||LA184_3==MINUS_SIGN||LA184_3==NATIONAL_CHAR_STRING_LIT||LA184_3==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA184_3==PLUS_SIGN||LA184_3==REGULAR_ID||LA184_3==SQL92_RESERVED_ALL||LA184_3==SQL92_RESERVED_ANY||LA184_3==SQL92_RESERVED_CASE||(LA184_3 >= SQL92_RESERVED_CURSOR && LA184_3 <= SQL92_RESERVED_DATE)||(LA184_3 >= SQL92_RESERVED_DEFAULT && LA184_3 <= SQL92_RESERVED_DELETE)||LA184_3==SQL92_RESERVED_DISTINCT||(LA184_3 >= SQL92_RESERVED_EXISTS && LA184_3 <= SQL92_RESERVED_FALSE)||(LA184_3 >= SQL92_RESERVED_NOT && LA184_3 <= SQL92_RESERVED_NULL)||LA184_3==SQL92_RESERVED_PRIOR||LA184_3==SQL92_RESERVED_TRUE||LA184_3==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("reject")))) {
						alt184=1;
					}
				}
			}
			switch (alt184) {
				case 1 :
					// PLSQL_DMLParser.g:768:9: error_logging_reject_part
					{
					pushFollow(FOLLOW_error_logging_reject_part_in_error_logging_clause6931);
					error_logging_reject_part535=error_logging_reject_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_error_logging_reject_part.add(error_logging_reject_part535.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: expression_wrapper, error_logging_reject_part, log_key, error_logging_into_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 769:9: -> ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? )
			{
				// PLSQL_DMLParser.g:769:12: ^( log_key ( error_logging_into_part )? ( expression_wrapper )? ( error_logging_reject_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_log_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:769:22: ( error_logging_into_part )?
				if ( stream_error_logging_into_part.hasNext() ) {
					adaptor.addChild(root_1, stream_error_logging_into_part.nextTree());
				}
				stream_error_logging_into_part.reset();

				// PLSQL_DMLParser.g:769:47: ( expression_wrapper )?
				if ( stream_expression_wrapper.hasNext() ) {
					adaptor.addChild(root_1, stream_expression_wrapper.nextTree());
				}
				stream_expression_wrapper.reset();

				// PLSQL_DMLParser.g:769:67: ( error_logging_reject_part )?
				if ( stream_error_logging_reject_part.hasNext() ) {
					adaptor.addChild(root_1, stream_error_logging_reject_part.nextTree());
				}
				stream_error_logging_reject_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "error_logging_clause"


	public static class error_logging_into_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "error_logging_into_part"
	// PLSQL_DMLParser.g:772:1: error_logging_into_part : into_key ^ tableview_name ;
	public final PLSQLParser_PLSQL_DMLParser.error_logging_into_part_return error_logging_into_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.error_logging_into_part_return retval = new PLSQLParser_PLSQL_DMLParser.error_logging_into_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope into_key536 =null;
		ParserRuleReturnScope tableview_name537 =null;


		try {
			// PLSQL_DMLParser.g:773:5: ( into_key ^ tableview_name )
			// PLSQL_DMLParser.g:773:10: into_key ^ tableview_name
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_into_key_in_error_logging_into_part6975);
			into_key536=gPLSQLParser.into_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(into_key536.getTree(), root_0);
			pushFollow(FOLLOW_tableview_name_in_error_logging_into_part6978);
			tableview_name537=gPLSQLParser.tableview_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, tableview_name537.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "error_logging_into_part"


	public static class error_logging_reject_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "error_logging_reject_part"
	// PLSQL_DMLParser.g:776:1: error_logging_reject_part : reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.error_logging_reject_part_return error_logging_reject_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.error_logging_reject_part_return retval = new PLSQLParser_PLSQL_DMLParser.error_logging_reject_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope reject_key538 =null;
		ParserRuleReturnScope limit_key539 =null;
		ParserRuleReturnScope unlimited_key540 =null;
		ParserRuleReturnScope expression_wrapper541 =null;


		try {
			// PLSQL_DMLParser.g:777:5: ( reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper ) )
			// PLSQL_DMLParser.g:777:10: reject_key ^ limit_key ! ( ( unlimited_key )=> unlimited_key | expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_reject_key_in_error_logging_reject_part6998);
			reject_key538=gPLSQLParser.reject_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(reject_key538.getTree(), root_0);
			pushFollow(FOLLOW_limit_key_in_error_logging_reject_part7001);
			limit_key539=gPLSQLParser.limit_key();
			state._fsp--;
			if (state.failed) return retval;
			// PLSQL_DMLParser.g:777:33: ( ( unlimited_key )=> unlimited_key | expression_wrapper )
			int alt185=2;
			int LA185_0 = input.LA(1);
			if ( (LA185_0==REGULAR_ID) ) {
				int LA185_1 = input.LA(2);
				if ( ((synpred20_PLSQL_DMLParser()&&(input.LT(1).getText().equalsIgnoreCase("unlimited")))) ) {
					alt185=1;
				}
				else if ( (true) ) {
					alt185=2;
				}

			}
			else if ( (LA185_0==APPROXIMATE_NUM_LIT||LA185_0==BINDVAR||(LA185_0 >= CHAR_STRING && LA185_0 <= COLON)||LA185_0==DELIMITED_ID||LA185_0==EXACT_NUM_LIT||LA185_0==INTRODUCER||LA185_0==LEFT_PAREN||LA185_0==MINUS_SIGN||LA185_0==NATIONAL_CHAR_STRING_LIT||LA185_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA185_0==PLUS_SIGN||LA185_0==SQL92_RESERVED_ALL||LA185_0==SQL92_RESERVED_ANY||LA185_0==SQL92_RESERVED_CASE||(LA185_0 >= SQL92_RESERVED_CURSOR && LA185_0 <= SQL92_RESERVED_DATE)||(LA185_0 >= SQL92_RESERVED_DEFAULT && LA185_0 <= SQL92_RESERVED_DELETE)||LA185_0==SQL92_RESERVED_DISTINCT||(LA185_0 >= SQL92_RESERVED_EXISTS && LA185_0 <= SQL92_RESERVED_FALSE)||(LA185_0 >= SQL92_RESERVED_NOT && LA185_0 <= SQL92_RESERVED_NULL)||LA185_0==SQL92_RESERVED_PRIOR||LA185_0==SQL92_RESERVED_TRUE||LA185_0==UNSIGNED_INTEGER) ) {
				alt185=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 185, 0, input);
				throw nvae;
			}

			switch (alt185) {
				case 1 :
					// PLSQL_DMLParser.g:777:34: ( unlimited_key )=> unlimited_key
					{
					pushFollow(FOLLOW_unlimited_key_in_error_logging_reject_part7009);
					unlimited_key540=gPLSQLParser.unlimited_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unlimited_key540.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:777:65: expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_error_logging_reject_part7011);
					expression_wrapper541=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper541.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "error_logging_reject_part"


	public static class dml_table_expression_clause_simple_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dml_table_expression_clause_simple"
	// PLSQL_DMLParser.g:780:1: dml_table_expression_clause_simple : ( table_collection_expression -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) ) | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN -> ^( TABLE_EXPRESSION ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) ) | tableview_name ( sample_clause )? -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) ) );
	public final PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_simple_return dml_table_expression_clause_simple() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_simple_return retval = new PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_simple_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN543=null;
		Token RIGHT_PAREN546=null;
		ParserRuleReturnScope table_collection_expression542 =null;
		ParserRuleReturnScope select_statement544 =null;
		ParserRuleReturnScope subquery_restriction_clause545 =null;
		ParserRuleReturnScope tableview_name547 =null;
		ParserRuleReturnScope sample_clause548 =null;

		Object LEFT_PAREN543_tree=null;
		Object RIGHT_PAREN546_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_tableview_name=new RewriteRuleSubtreeStream(adaptor,"rule tableview_name");
		RewriteRuleSubtreeStream stream_table_collection_expression=new RewriteRuleSubtreeStream(adaptor,"rule table_collection_expression");
		RewriteRuleSubtreeStream stream_sample_clause=new RewriteRuleSubtreeStream(adaptor,"rule sample_clause");
		RewriteRuleSubtreeStream stream_subquery_restriction_clause=new RewriteRuleSubtreeStream(adaptor,"rule subquery_restriction_clause");
		RewriteRuleSubtreeStream stream_select_statement=new RewriteRuleSubtreeStream(adaptor,"rule select_statement");

		try {
			// PLSQL_DMLParser.g:781:5: ( table_collection_expression -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) ) | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN -> ^( TABLE_EXPRESSION ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) ) | tableview_name ( sample_clause )? -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) ) )
			int alt188=3;
			switch ( input.LA(1) ) {
			case SQL92_RESERVED_TABLE:
			case SQL92_RESERVED_THE:
				{
				alt188=1;
				}
				break;
			case LEFT_PAREN:
				{
				alt188=2;
				}
				break;
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				alt188=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 188, 0, input);
				throw nvae;
			}
			switch (alt188) {
				case 1 :
					// PLSQL_DMLParser.g:781:10: table_collection_expression
					{
					pushFollow(FOLLOW_table_collection_expression_in_dml_table_expression_clause_simple7032);
					table_collection_expression542=table_collection_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_collection_expression.add(table_collection_expression542.getTree());
					// AST REWRITE
					// elements: table_collection_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 781:38: -> ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) )
					{
						// PLSQL_DMLParser.g:781:41: ^( TABLE_EXPRESSION ^( COLLECTION_MODE table_collection_expression ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
						// PLSQL_DMLParser.g:781:60: ^( COLLECTION_MODE table_collection_expression )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(COLLECTION_MODE, "COLLECTION_MODE"), root_2);
						adaptor.addChild(root_2, stream_table_collection_expression.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:782:10: LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN
					{
					LEFT_PAREN543=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_dml_table_expression_clause_simple7055); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN543);

					pushFollow(FOLLOW_select_statement_in_dml_table_expression_clause_simple7057);
					select_statement544=select_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_select_statement.add(select_statement544.getTree());
					// PLSQL_DMLParser.g:782:38: ( subquery_restriction_clause )?
					int alt186=2;
					int LA186_0 = input.LA(1);
					if ( (LA186_0==SQL92_RESERVED_WITH) ) {
						alt186=1;
					}
					switch (alt186) {
						case 1 :
							// PLSQL_DMLParser.g:782:38: subquery_restriction_clause
							{
							pushFollow(FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause_simple7059);
							subquery_restriction_clause545=subquery_restriction_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_subquery_restriction_clause.add(subquery_restriction_clause545.getTree());
							}
							break;

					}

					RIGHT_PAREN546=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause_simple7062); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN546);

					// AST REWRITE
					// elements: select_statement, subquery_restriction_clause
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 782:79: -> ^( TABLE_EXPRESSION ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) )
					{
						// PLSQL_DMLParser.g:782:82: ^( TABLE_EXPRESSION ^( SELECT_MODE select_statement ( subquery_restriction_clause )? ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
						// PLSQL_DMLParser.g:782:101: ^( SELECT_MODE select_statement ( subquery_restriction_clause )? )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(SELECT_MODE, "SELECT_MODE"), root_2);
						adaptor.addChild(root_2, stream_select_statement.nextTree());
						// PLSQL_DMLParser.g:782:132: ( subquery_restriction_clause )?
						if ( stream_subquery_restriction_clause.hasNext() ) {
							adaptor.addChild(root_2, stream_subquery_restriction_clause.nextTree());
						}
						stream_subquery_restriction_clause.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:783:10: tableview_name ( sample_clause )?
					{
					pushFollow(FOLLOW_tableview_name_in_dml_table_expression_clause_simple7088);
					tableview_name547=gPLSQLParser.tableview_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_tableview_name.add(tableview_name547.getTree());
					// PLSQL_DMLParser.g:783:25: ( sample_clause )?
					int alt187=2;
					alt187 = dfa187.predict(input);
					switch (alt187) {
						case 1 :
							// PLSQL_DMLParser.g:783:25: sample_clause
							{
							pushFollow(FOLLOW_sample_clause_in_dml_table_expression_clause_simple7090);
							sample_clause548=sample_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_sample_clause.add(sample_clause548.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: tableview_name, sample_clause
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 783:40: -> ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) )
					{
						// PLSQL_DMLParser.g:783:43: ^( TABLE_EXPRESSION ^( DIRECT_MODE tableview_name ( sample_clause )? ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
						// PLSQL_DMLParser.g:783:62: ^( DIRECT_MODE tableview_name ( sample_clause )? )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(DIRECT_MODE, "DIRECT_MODE"), root_2);
						adaptor.addChild(root_2, stream_tableview_name.nextTree());
						// PLSQL_DMLParser.g:783:91: ( sample_clause )?
						if ( stream_sample_clause.hasNext() ) {
							adaptor.addChild(root_2, stream_sample_clause.nextTree());
						}
						stream_sample_clause.reset();

						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dml_table_expression_clause_simple"


	public static class dml_table_expression_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dml_table_expression_clause"
	// PLSQL_DMLParser.g:786:1: dml_table_expression_clause : ( ( routine_id ( PERIOD routine_id )* LEFT_PAREN )=> general_element -> ^( TABLE_EXPRESSION general_element ) | dml_table_expression_clause_simple | ( standard_function )=> standard_function -> ^( TABLE_EXPRESSION standard_function ) );
	public final PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_return dml_table_expression_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_return retval = new PLSQLParser_PLSQL_DMLParser.dml_table_expression_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope general_element549 =null;
		ParserRuleReturnScope dml_table_expression_clause_simple550 =null;
		ParserRuleReturnScope standard_function551 =null;

		RewriteRuleSubtreeStream stream_standard_function=new RewriteRuleSubtreeStream(adaptor,"rule standard_function");
		RewriteRuleSubtreeStream stream_general_element=new RewriteRuleSubtreeStream(adaptor,"rule general_element");

		try {
			// PLSQL_DMLParser.g:787:5: ( ( routine_id ( PERIOD routine_id )* LEFT_PAREN )=> general_element -> ^( TABLE_EXPRESSION general_element ) | dml_table_expression_clause_simple | ( standard_function )=> standard_function -> ^( TABLE_EXPRESSION standard_function ) )
			int alt189=3;
			alt189 = dfa189.predict(input);
			switch (alt189) {
				case 1 :
					// PLSQL_DMLParser.g:787:10: ( routine_id ( PERIOD routine_id )* LEFT_PAREN )=> general_element
					{
					pushFollow(FOLLOW_general_element_in_dml_table_expression_clause7141);
					general_element549=gPLSQLParser.general_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_general_element.add(general_element549.getTree());
					// AST REWRITE
					// elements: general_element
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 787:74: -> ^( TABLE_EXPRESSION general_element )
					{
						// PLSQL_DMLParser.g:787:77: ^( TABLE_EXPRESSION general_element )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
						adaptor.addChild(root_1, stream_general_element.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:788:10: dml_table_expression_clause_simple
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_dml_table_expression_clause_simple_in_dml_table_expression_clause7160);
					dml_table_expression_clause_simple550=dml_table_expression_clause_simple();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, dml_table_expression_clause_simple550.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:789:10: ( standard_function )=> standard_function
					{
					pushFollow(FOLLOW_standard_function_in_dml_table_expression_clause7177);
					standard_function551=standard_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standard_function.add(standard_function551.getTree());
					// AST REWRITE
					// elements: standard_function
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 789:51: -> ^( TABLE_EXPRESSION standard_function )
					{
						// PLSQL_DMLParser.g:789:54: ^( TABLE_EXPRESSION standard_function )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TABLE_EXPRESSION, "TABLE_EXPRESSION"), root_1);
						adaptor.addChild(root_1, stream_standard_function.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dml_table_expression_clause"


	public static class table_collection_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "table_collection_expression"
	// PLSQL_DMLParser.g:792:1: table_collection_expression : ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN expression_wrapper RIGHT_PAREN -> expression_wrapper ) ( outer_join_sign -> ^( outer_join_sign $table_collection_expression) )? ;
	public final PLSQLParser_PLSQL_DMLParser.table_collection_expression_return table_collection_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.table_collection_expression_return retval = new PLSQLParser_PLSQL_DMLParser.table_collection_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN554=null;
		Token RIGHT_PAREN556=null;
		Token LEFT_PAREN557=null;
		Token RIGHT_PAREN559=null;
		ParserRuleReturnScope table_key552 =null;
		ParserRuleReturnScope the_key553 =null;
		ParserRuleReturnScope subquery555 =null;
		ParserRuleReturnScope expression_wrapper558 =null;
		ParserRuleReturnScope outer_join_sign560 =null;

		Object LEFT_PAREN554_tree=null;
		Object RIGHT_PAREN556_tree=null;
		Object LEFT_PAREN557_tree=null;
		Object RIGHT_PAREN559_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_table_key=new RewriteRuleSubtreeStream(adaptor,"rule table_key");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_outer_join_sign=new RewriteRuleSubtreeStream(adaptor,"rule outer_join_sign");
		RewriteRuleSubtreeStream stream_the_key=new RewriteRuleSubtreeStream(adaptor,"rule the_key");
		RewriteRuleSubtreeStream stream_expression_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule expression_wrapper");

		try {
			// PLSQL_DMLParser.g:793:5: ( ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN expression_wrapper RIGHT_PAREN -> expression_wrapper ) ( outer_join_sign -> ^( outer_join_sign $table_collection_expression) )? )
			// PLSQL_DMLParser.g:793:10: ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN expression_wrapper RIGHT_PAREN -> expression_wrapper ) ( outer_join_sign -> ^( outer_join_sign $table_collection_expression) )?
			{
			// PLSQL_DMLParser.g:793:10: ( table_key | the_key )
			int alt190=2;
			int LA190_0 = input.LA(1);
			if ( (LA190_0==SQL92_RESERVED_TABLE) ) {
				alt190=1;
			}
			else if ( (LA190_0==SQL92_RESERVED_THE) ) {
				alt190=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 190, 0, input);
				throw nvae;
			}

			switch (alt190) {
				case 1 :
					// PLSQL_DMLParser.g:793:12: table_key
					{
					pushFollow(FOLLOW_table_key_in_table_collection_expression7207);
					table_key552=gPLSQLParser.table_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_table_key.add(table_key552.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:793:24: the_key
					{
					pushFollow(FOLLOW_the_key_in_table_collection_expression7211);
					the_key553=gPLSQLParser.the_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_the_key.add(the_key553.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:794:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN expression_wrapper RIGHT_PAREN -> expression_wrapper )
			int alt191=2;
			int LA191_0 = input.LA(1);
			if ( (LA191_0==LEFT_PAREN) ) {
				int LA191_1 = input.LA(2);
				if ( (synpred23_PLSQL_DMLParser()) ) {
					alt191=1;
				}
				else if ( (true) ) {
					alt191=2;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 191, 0, input);
				throw nvae;
			}

			switch (alt191) {
				case 1 :
					// PLSQL_DMLParser.g:795:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
					{
					LEFT_PAREN554=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_table_collection_expression7250); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN554);

					pushFollow(FOLLOW_subquery_in_table_collection_expression7252);
					subquery555=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery.add(subquery555.getTree());
					RIGHT_PAREN556=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_table_collection_expression7254); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN556);

					// AST REWRITE
					// elements: subquery
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 795:84: -> subquery
					{
						adaptor.addChild(root_0, stream_subquery.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:796:14: LEFT_PAREN expression_wrapper RIGHT_PAREN
					{
					LEFT_PAREN557=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_table_collection_expression7273); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN557);

					pushFollow(FOLLOW_expression_wrapper_in_table_collection_expression7275);
					expression_wrapper558=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_wrapper.add(expression_wrapper558.getTree());
					RIGHT_PAREN559=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_table_collection_expression7277); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN559);

					// AST REWRITE
					// elements: expression_wrapper
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 796:56: -> expression_wrapper
					{
						adaptor.addChild(root_0, stream_expression_wrapper.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;

			}

			// PLSQL_DMLParser.g:798:10: ( outer_join_sign -> ^( outer_join_sign $table_collection_expression) )?
			int alt192=2;
			int LA192_0 = input.LA(1);
			if ( (LA192_0==LEFT_PAREN) ) {
				int LA192_1 = input.LA(2);
				if ( (LA192_1==PLUS_SIGN) ) {
					alt192=1;
				}
			}
			switch (alt192) {
				case 1 :
					// PLSQL_DMLParser.g:798:11: outer_join_sign
					{
					pushFollow(FOLLOW_outer_join_sign_in_table_collection_expression7304);
					outer_join_sign560=gPLSQLParser.outer_join_sign();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_outer_join_sign.add(outer_join_sign560.getTree());
					// AST REWRITE
					// elements: table_collection_expression, outer_join_sign
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 798:27: -> ^( outer_join_sign $table_collection_expression)
					{
						// PLSQL_DMLParser.g:798:30: ^( outer_join_sign $table_collection_expression)
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_outer_join_sign.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "table_collection_expression"


	public static class subquery_restriction_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subquery_restriction_clause"
	// PLSQL_DMLParser.g:801:1: subquery_restriction_clause : with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.subquery_restriction_clause_return subquery_restriction_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.subquery_restriction_clause_return retval = new PLSQLParser_PLSQL_DMLParser.subquery_restriction_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope with_key561 =null;
		ParserRuleReturnScope read_key562 =null;
		ParserRuleReturnScope only_key563 =null;
		ParserRuleReturnScope check_key564 =null;
		ParserRuleReturnScope option_key565 =null;
		ParserRuleReturnScope constraint_key566 =null;
		ParserRuleReturnScope constraint_name567 =null;

		RewriteRuleSubtreeStream stream_option_key=new RewriteRuleSubtreeStream(adaptor,"rule option_key");
		RewriteRuleSubtreeStream stream_with_key=new RewriteRuleSubtreeStream(adaptor,"rule with_key");
		RewriteRuleSubtreeStream stream_constraint_key=new RewriteRuleSubtreeStream(adaptor,"rule constraint_key");
		RewriteRuleSubtreeStream stream_constraint_name=new RewriteRuleSubtreeStream(adaptor,"rule constraint_name");
		RewriteRuleSubtreeStream stream_read_key=new RewriteRuleSubtreeStream(adaptor,"rule read_key");
		RewriteRuleSubtreeStream stream_only_key=new RewriteRuleSubtreeStream(adaptor,"rule only_key");
		RewriteRuleSubtreeStream stream_check_key=new RewriteRuleSubtreeStream(adaptor,"rule check_key");

		try {
			// PLSQL_DMLParser.g:802:5: ( with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? ) )
			// PLSQL_DMLParser.g:802:10: with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
			{
			pushFollow(FOLLOW_with_key_in_subquery_restriction_clause7335);
			with_key561=gPLSQLParser.with_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_with_key.add(with_key561.getTree());
			// PLSQL_DMLParser.g:803:5: ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
			int alt194=2;
			int LA194_0 = input.LA(1);
			if ( (LA194_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("read")))) {
				alt194=1;
			}
			else if ( (LA194_0==SQL92_RESERVED_CHECK) ) {
				alt194=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 194, 0, input);
				throw nvae;
			}

			switch (alt194) {
				case 1 :
					// PLSQL_DMLParser.g:803:10: read_key only_key
					{
					pushFollow(FOLLOW_read_key_in_subquery_restriction_clause7346);
					read_key562=gPLSQLParser.read_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_read_key.add(read_key562.getTree());
					pushFollow(FOLLOW_only_key_in_subquery_restriction_clause7348);
					only_key563=gPLSQLParser.only_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_only_key.add(only_key563.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:804:10: check_key option_key ( constraint_key constraint_name )?
					{
					pushFollow(FOLLOW_check_key_in_subquery_restriction_clause7359);
					check_key564=gPLSQLParser.check_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_check_key.add(check_key564.getTree());
					pushFollow(FOLLOW_option_key_in_subquery_restriction_clause7361);
					option_key565=gPLSQLParser.option_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_option_key.add(option_key565.getTree());
					// PLSQL_DMLParser.g:804:31: ( constraint_key constraint_name )?
					int alt193=2;
					int LA193_0 = input.LA(1);
					if ( (LA193_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("constraint")))) {
						alt193=1;
					}
					switch (alt193) {
						case 1 :
							// PLSQL_DMLParser.g:804:32: constraint_key constraint_name
							{
							pushFollow(FOLLOW_constraint_key_in_subquery_restriction_clause7364);
							constraint_key566=gPLSQLParser.constraint_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_constraint_key.add(constraint_key566.getTree());
							pushFollow(FOLLOW_constraint_name_in_subquery_restriction_clause7366);
							constraint_name567=gPLSQLParser.constraint_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_constraint_name.add(constraint_name567.getTree());
							}
							break;

					}

					}
					break;

			}

			// AST REWRITE
			// elements: read_key, constraint_name, with_key, check_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 806:9: -> ^( with_key ( read_key )? ( check_key )? ( constraint_name )? )
			{
				// PLSQL_DMLParser.g:806:12: ^( with_key ( read_key )? ( check_key )? ( constraint_name )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_with_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:806:23: ( read_key )?
				if ( stream_read_key.hasNext() ) {
					adaptor.addChild(root_1, stream_read_key.nextTree());
				}
				stream_read_key.reset();

				// PLSQL_DMLParser.g:806:33: ( check_key )?
				if ( stream_check_key.hasNext() ) {
					adaptor.addChild(root_1, stream_check_key.nextTree());
				}
				stream_check_key.reset();

				// PLSQL_DMLParser.g:806:44: ( constraint_name )?
				if ( stream_constraint_name.hasNext() ) {
					adaptor.addChild(root_1, stream_constraint_name.nextTree());
				}
				stream_constraint_name.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subquery_restriction_clause"


	public static class sample_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sample_clause"
	// PLSQL_DMLParser.g:809:1: sample_clause : sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )? -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.sample_clause_return sample_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.sample_clause_return retval = new PLSQLParser_PLSQL_DMLParser.sample_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN570=null;
		Token COMMA571=null;
		Token RIGHT_PAREN572=null;
		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope e2 =null;
		ParserRuleReturnScope sample_key568 =null;
		ParserRuleReturnScope block_key569 =null;
		ParserRuleReturnScope seed_part573 =null;

		Object LEFT_PAREN570_tree=null;
		Object COMMA571_tree=null;
		Object RIGHT_PAREN572_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_sample_key=new RewriteRuleSubtreeStream(adaptor,"rule sample_key");
		RewriteRuleSubtreeStream stream_block_key=new RewriteRuleSubtreeStream(adaptor,"rule block_key");
		RewriteRuleSubtreeStream stream_seed_part=new RewriteRuleSubtreeStream(adaptor,"rule seed_part");

		try {
			// PLSQL_DMLParser.g:810:5: ( sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )? -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? ) )
			// PLSQL_DMLParser.g:810:10: sample_key ( block_key )? LEFT_PAREN e1= expression ( COMMA e2= expression )? RIGHT_PAREN ( seed_part )?
			{
			pushFollow(FOLLOW_sample_key_in_sample_clause7417);
			sample_key568=gPLSQLParser.sample_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_sample_key.add(sample_key568.getTree());
			// PLSQL_DMLParser.g:810:21: ( block_key )?
			int alt195=2;
			int LA195_0 = input.LA(1);
			if ( (LA195_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("block")))) {
				alt195=1;
			}
			switch (alt195) {
				case 1 :
					// PLSQL_DMLParser.g:810:21: block_key
					{
					pushFollow(FOLLOW_block_key_in_sample_clause7419);
					block_key569=gPLSQLParser.block_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_block_key.add(block_key569.getTree());
					}
					break;

			}

			LEFT_PAREN570=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_sample_clause7431); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN570);

			pushFollow(FOLLOW_expression_in_sample_clause7435);
			e1=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(e1.getTree());
			// PLSQL_DMLParser.g:811:34: ( COMMA e2= expression )?
			int alt196=2;
			int LA196_0 = input.LA(1);
			if ( (LA196_0==COMMA) ) {
				alt196=1;
			}
			switch (alt196) {
				case 1 :
					// PLSQL_DMLParser.g:811:35: COMMA e2= expression
					{
					COMMA571=(Token)match(input,COMMA,FOLLOW_COMMA_in_sample_clause7438); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA571);

					pushFollow(FOLLOW_expression_in_sample_clause7442);
					e2=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(e2.getTree());
					}
					break;

			}

			RIGHT_PAREN572=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_sample_clause7446); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN572);

			// PLSQL_DMLParser.g:812:9: ( seed_part )?
			int alt197=2;
			alt197 = dfa197.predict(input);
			switch (alt197) {
				case 1 :
					// PLSQL_DMLParser.g:812:9: seed_part
					{
					pushFollow(FOLLOW_seed_part_in_sample_clause7456);
					seed_part573=seed_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_seed_part.add(seed_part573.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: block_key, sample_key, e1, e2, seed_part
			// token labels: 
			// rule labels: e1, e2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,"rule e2",e2!=null?e2.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 813:9: -> ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? )
			{
				// PLSQL_DMLParser.g:813:12: ^( sample_key ( block_key )? ^( EXPR $e1) ( ^( EXPR $e2) )? ( seed_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_sample_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:813:25: ( block_key )?
				if ( stream_block_key.hasNext() ) {
					adaptor.addChild(root_1, stream_block_key.nextTree());
				}
				stream_block_key.reset();

				// PLSQL_DMLParser.g:813:36: ^( EXPR $e1)
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_e1.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:813:48: ( ^( EXPR $e2) )?
				if ( stream_e2.hasNext() ) {
					// PLSQL_DMLParser.g:813:48: ^( EXPR $e2)
					{
					Object root_2 = (Object)adaptor.nil();
					root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
					adaptor.addChild(root_2, stream_e2.nextTree());
					adaptor.addChild(root_1, root_2);
					}

				}
				stream_e2.reset();

				// PLSQL_DMLParser.g:813:61: ( seed_part )?
				if ( stream_seed_part.hasNext() ) {
					adaptor.addChild(root_1, stream_seed_part.nextTree());
				}
				stream_seed_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sample_clause"


	public static class seed_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "seed_part"
	// PLSQL_DMLParser.g:816:1: seed_part : seed_key LEFT_PAREN expression RIGHT_PAREN -> ^( seed_key ^( EXPR expression ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.seed_part_return seed_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.seed_part_return retval = new PLSQLParser_PLSQL_DMLParser.seed_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN575=null;
		Token RIGHT_PAREN577=null;
		ParserRuleReturnScope seed_key574 =null;
		ParserRuleReturnScope expression576 =null;

		Object LEFT_PAREN575_tree=null;
		Object RIGHT_PAREN577_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_seed_key=new RewriteRuleSubtreeStream(adaptor,"rule seed_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:817:5: ( seed_key LEFT_PAREN expression RIGHT_PAREN -> ^( seed_key ^( EXPR expression ) ) )
			// PLSQL_DMLParser.g:817:10: seed_key LEFT_PAREN expression RIGHT_PAREN
			{
			pushFollow(FOLLOW_seed_key_in_seed_part7512);
			seed_key574=gPLSQLParser.seed_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_seed_key.add(seed_key574.getTree());
			LEFT_PAREN575=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_seed_part7514); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN575);

			pushFollow(FOLLOW_expression_in_seed_part7516);
			expression576=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression576.getTree());
			RIGHT_PAREN577=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_seed_part7518); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN577);

			// AST REWRITE
			// elements: expression, seed_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 818:9: -> ^( seed_key ^( EXPR expression ) )
			{
				// PLSQL_DMLParser.g:818:12: ^( seed_key ^( EXPR expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_seed_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:818:23: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "seed_part"


	public static class cursor_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cursor_expression"
	// PLSQL_DMLParser.g:824:1: cursor_expression : cursor_key LEFT_PAREN subquery RIGHT_PAREN ;
	public final PLSQLParser_PLSQL_DMLParser.cursor_expression_return cursor_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.cursor_expression_return retval = new PLSQLParser_PLSQL_DMLParser.cursor_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN579=null;
		Token RIGHT_PAREN581=null;
		ParserRuleReturnScope cursor_key578 =null;
		ParserRuleReturnScope subquery580 =null;

		Object LEFT_PAREN579_tree=null;
		Object RIGHT_PAREN581_tree=null;

		try {
			// PLSQL_DMLParser.g:825:5: ( cursor_key LEFT_PAREN subquery RIGHT_PAREN )
			// PLSQL_DMLParser.g:825:10: cursor_key LEFT_PAREN subquery RIGHT_PAREN
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_cursor_key_in_cursor_expression7561);
			cursor_key578=gPLSQLParser.cursor_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, cursor_key578.getTree());

			LEFT_PAREN579=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_cursor_expression7563); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			LEFT_PAREN579_tree = (Object)adaptor.create(LEFT_PAREN579);
			adaptor.addChild(root_0, LEFT_PAREN579_tree);
			}

			pushFollow(FOLLOW_subquery_in_cursor_expression7565);
			subquery580=subquery();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery580.getTree());

			RIGHT_PAREN581=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_cursor_expression7567); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			RIGHT_PAREN581_tree = (Object)adaptor.create(RIGHT_PAREN581);
			adaptor.addChild(root_0, RIGHT_PAREN581_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cursor_expression"


	public static class expression_list_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression_list"
	// PLSQL_DMLParser.g:828:1: expression_list : LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN -> ^( EXPR_LIST ( ^( EXPR expression ) )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.expression_list_return expression_list() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.expression_list_return retval = new PLSQLParser_PLSQL_DMLParser.expression_list_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN582=null;
		Token COMMA584=null;
		Token RIGHT_PAREN586=null;
		ParserRuleReturnScope expression583 =null;
		ParserRuleReturnScope expression585 =null;

		Object LEFT_PAREN582_tree=null;
		Object COMMA584_tree=null;
		Object RIGHT_PAREN586_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:829:5: ( LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN -> ^( EXPR_LIST ( ^( EXPR expression ) )* ) )
			// PLSQL_DMLParser.g:829:10: LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN
			{
			LEFT_PAREN582=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_expression_list7587); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN582);

			// PLSQL_DMLParser.g:829:21: ( expression )?
			int alt198=2;
			int LA198_0 = input.LA(1);
			if ( (LA198_0==APPROXIMATE_NUM_LIT||LA198_0==BINDVAR||(LA198_0 >= CHAR_STRING && LA198_0 <= COLON)||LA198_0==DELIMITED_ID||LA198_0==EXACT_NUM_LIT||LA198_0==INTRODUCER||LA198_0==LEFT_PAREN||LA198_0==MINUS_SIGN||LA198_0==NATIONAL_CHAR_STRING_LIT||LA198_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA198_0==PLUS_SIGN||LA198_0==REGULAR_ID||LA198_0==SQL92_RESERVED_ALL||LA198_0==SQL92_RESERVED_ANY||LA198_0==SQL92_RESERVED_CASE||(LA198_0 >= SQL92_RESERVED_CURSOR && LA198_0 <= SQL92_RESERVED_DATE)||(LA198_0 >= SQL92_RESERVED_DEFAULT && LA198_0 <= SQL92_RESERVED_DELETE)||LA198_0==SQL92_RESERVED_DISTINCT||(LA198_0 >= SQL92_RESERVED_EXISTS && LA198_0 <= SQL92_RESERVED_FALSE)||(LA198_0 >= SQL92_RESERVED_NOT && LA198_0 <= SQL92_RESERVED_NULL)||LA198_0==SQL92_RESERVED_PRIOR||LA198_0==SQL92_RESERVED_TRUE||LA198_0==UNSIGNED_INTEGER) ) {
				alt198=1;
			}
			switch (alt198) {
				case 1 :
					// PLSQL_DMLParser.g:829:21: expression
					{
					pushFollow(FOLLOW_expression_in_expression_list7589);
					expression583=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression583.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:829:33: ( COMMA expression )*
			loop199:
			while (true) {
				int alt199=2;
				int LA199_0 = input.LA(1);
				if ( (LA199_0==COMMA) ) {
					alt199=1;
				}

				switch (alt199) {
				case 1 :
					// PLSQL_DMLParser.g:829:34: COMMA expression
					{
					COMMA584=(Token)match(input,COMMA,FOLLOW_COMMA_in_expression_list7593); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA584);

					pushFollow(FOLLOW_expression_in_expression_list7595);
					expression585=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression585.getTree());
					}
					break;

				default :
					break loop199;
				}
			}

			RIGHT_PAREN586=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_expression_list7599); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN586);

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 830:9: -> ^( EXPR_LIST ( ^( EXPR expression ) )* )
			{
				// PLSQL_DMLParser.g:830:12: ^( EXPR_LIST ( ^( EXPR expression ) )* )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR_LIST, "EXPR_LIST"), root_1);
				// PLSQL_DMLParser.g:830:24: ( ^( EXPR expression ) )*
				while ( stream_expression.hasNext() ) {
					// PLSQL_DMLParser.g:830:24: ^( EXPR expression )
					{
					Object root_2 = (Object)adaptor.nil();
					root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
					adaptor.addChild(root_2, stream_expression.nextTree());
					adaptor.addChild(root_1, root_2);
					}

				}
				stream_expression.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_list"


	public static class condition_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "condition"
	// PLSQL_DMLParser.g:833:1: condition : expression ;
	public final PLSQLParser_PLSQL_DMLParser.condition_return condition() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.condition_return retval = new PLSQLParser_PLSQL_DMLParser.condition_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression587 =null;


		try {
			// PLSQL_DMLParser.g:834:5: ( expression )
			// PLSQL_DMLParser.g:834:11: expression
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_expression_in_condition7641);
			expression587=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression587.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition"


	public static class condition_wrapper_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "condition_wrapper"
	// PLSQL_DMLParser.g:837:1: condition_wrapper : expression -> ^( LOGIC_EXPR expression ) ;
	public final PLSQLParser_PLSQL_DMLParser.condition_wrapper_return condition_wrapper() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.condition_wrapper_return retval = new PLSQLParser_PLSQL_DMLParser.condition_wrapper_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression588 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:838:5: ( expression -> ^( LOGIC_EXPR expression ) )
			// PLSQL_DMLParser.g:838:10: expression
			{
			pushFollow(FOLLOW_expression_in_condition_wrapper7661);
			expression588=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression588.getTree());
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 839:9: -> ^( LOGIC_EXPR expression )
			{
				// PLSQL_DMLParser.g:839:12: ^( LOGIC_EXPR expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_EXPR, "LOGIC_EXPR"), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "condition_wrapper"


	public static class expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression"
	// PLSQL_DMLParser.g:842:1: expression : ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key ^ logical_and_expression )* );
	public final PLSQLParser_PLSQL_DMLParser.expression_return expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.expression_return retval = new PLSQLParser_PLSQL_DMLParser.expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope cursor_expression589 =null;
		ParserRuleReturnScope logical_and_expression590 =null;
		ParserRuleReturnScope or_key591 =null;
		ParserRuleReturnScope logical_and_expression592 =null;


		try {
			// PLSQL_DMLParser.g:843:5: ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key ^ logical_and_expression )* )
			int alt201=2;
			int LA201_0 = input.LA(1);
			if ( (LA201_0==SQL92_RESERVED_CURSOR) && (synpred24_PLSQL_DMLParser())) {
				alt201=1;
			}
			else if ( (LA201_0==APPROXIMATE_NUM_LIT||LA201_0==BINDVAR||(LA201_0 >= CHAR_STRING && LA201_0 <= COLON)||LA201_0==DELIMITED_ID||LA201_0==EXACT_NUM_LIT||LA201_0==INTRODUCER||LA201_0==LEFT_PAREN||LA201_0==MINUS_SIGN||LA201_0==NATIONAL_CHAR_STRING_LIT||LA201_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA201_0==PLUS_SIGN||LA201_0==REGULAR_ID||LA201_0==SQL92_RESERVED_ALL||LA201_0==SQL92_RESERVED_ANY||LA201_0==SQL92_RESERVED_CASE||LA201_0==SQL92_RESERVED_DATE||(LA201_0 >= SQL92_RESERVED_DEFAULT && LA201_0 <= SQL92_RESERVED_DELETE)||LA201_0==SQL92_RESERVED_DISTINCT||(LA201_0 >= SQL92_RESERVED_EXISTS && LA201_0 <= SQL92_RESERVED_FALSE)||(LA201_0 >= SQL92_RESERVED_NOT && LA201_0 <= SQL92_RESERVED_NULL)||LA201_0==SQL92_RESERVED_PRIOR||LA201_0==SQL92_RESERVED_TRUE||LA201_0==UNSIGNED_INTEGER) ) {
				alt201=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 201, 0, input);
				throw nvae;
			}

			switch (alt201) {
				case 1 :
					// PLSQL_DMLParser.g:843:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_cursor_expression_in_expression7711);
					cursor_expression589=cursor_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, cursor_expression589.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:844:10: logical_and_expression ( or_key ^ logical_and_expression )*
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_logical_and_expression_in_expression7722);
					logical_and_expression590=logical_and_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, logical_and_expression590.getTree());

					// PLSQL_DMLParser.g:844:33: ( or_key ^ logical_and_expression )*
					loop200:
					while (true) {
						int alt200=2;
						int LA200_0 = input.LA(1);
						if ( (LA200_0==SQL92_RESERVED_OR) ) {
							alt200=1;
						}

						switch (alt200) {
						case 1 :
							// PLSQL_DMLParser.g:844:35: or_key ^ logical_and_expression
							{
							pushFollow(FOLLOW_or_key_in_expression7726);
							or_key591=gPLSQLParser.or_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(or_key591.getTree(), root_0);
							pushFollow(FOLLOW_logical_and_expression_in_expression7729);
							logical_and_expression592=logical_and_expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, logical_and_expression592.getTree());

							}
							break;

						default :
							break loop200;
						}
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression"


	public static class expression_wrapper_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression_wrapper"
	// PLSQL_DMLParser.g:847:1: expression_wrapper : expression -> ^( EXPR expression ) ;
	public final PLSQLParser_PLSQL_DMLParser.expression_wrapper_return expression_wrapper() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.expression_wrapper_return retval = new PLSQLParser_PLSQL_DMLParser.expression_wrapper_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression593 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:848:5: ( expression -> ^( EXPR expression ) )
			// PLSQL_DMLParser.g:848:10: expression
			{
			pushFollow(FOLLOW_expression_in_expression_wrapper7752);
			expression593=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression593.getTree());
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 849:9: -> ^( EXPR expression )
			{
				// PLSQL_DMLParser.g:849:12: ^( EXPR expression )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
				adaptor.addChild(root_1, stream_expression.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_wrapper"


	public static class logical_and_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "logical_and_expression"
	// PLSQL_DMLParser.g:852:1: logical_and_expression : negated_expression ( and_key ^ negated_expression )* ;
	public final PLSQLParser_PLSQL_DMLParser.logical_and_expression_return logical_and_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.logical_and_expression_return retval = new PLSQLParser_PLSQL_DMLParser.logical_and_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope negated_expression594 =null;
		ParserRuleReturnScope and_key595 =null;
		ParserRuleReturnScope negated_expression596 =null;


		try {
			// PLSQL_DMLParser.g:853:5: ( negated_expression ( and_key ^ negated_expression )* )
			// PLSQL_DMLParser.g:853:10: negated_expression ( and_key ^ negated_expression )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_negated_expression_in_logical_and_expression7788);
			negated_expression594=negated_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, negated_expression594.getTree());

			// PLSQL_DMLParser.g:853:29: ( and_key ^ negated_expression )*
			loop202:
			while (true) {
				int alt202=2;
				int LA202_0 = input.LA(1);
				if ( (LA202_0==SQL92_RESERVED_AND) ) {
					alt202=1;
				}

				switch (alt202) {
				case 1 :
					// PLSQL_DMLParser.g:853:31: and_key ^ negated_expression
					{
					pushFollow(FOLLOW_and_key_in_logical_and_expression7792);
					and_key595=gPLSQLParser.and_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(and_key595.getTree(), root_0);
					pushFollow(FOLLOW_negated_expression_in_logical_and_expression7795);
					negated_expression596=negated_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, negated_expression596.getTree());

					}
					break;

				default :
					break loop202;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logical_and_expression"


	public static class negated_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "negated_expression"
	// PLSQL_DMLParser.g:856:1: negated_expression : ( not_key ^ negated_expression | equality_expression );
	public final PLSQLParser_PLSQL_DMLParser.negated_expression_return negated_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.negated_expression_return retval = new PLSQLParser_PLSQL_DMLParser.negated_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope not_key597 =null;
		ParserRuleReturnScope negated_expression598 =null;
		ParserRuleReturnScope equality_expression599 =null;


		try {
			// PLSQL_DMLParser.g:857:5: ( not_key ^ negated_expression | equality_expression )
			int alt203=2;
			int LA203_0 = input.LA(1);
			if ( (LA203_0==SQL92_RESERVED_NOT) ) {
				alt203=1;
			}
			else if ( (LA203_0==APPROXIMATE_NUM_LIT||LA203_0==BINDVAR||(LA203_0 >= CHAR_STRING && LA203_0 <= COLON)||LA203_0==DELIMITED_ID||LA203_0==EXACT_NUM_LIT||LA203_0==INTRODUCER||LA203_0==LEFT_PAREN||LA203_0==MINUS_SIGN||LA203_0==NATIONAL_CHAR_STRING_LIT||LA203_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA203_0==PLUS_SIGN||LA203_0==REGULAR_ID||LA203_0==SQL92_RESERVED_ALL||LA203_0==SQL92_RESERVED_ANY||LA203_0==SQL92_RESERVED_CASE||LA203_0==SQL92_RESERVED_DATE||(LA203_0 >= SQL92_RESERVED_DEFAULT && LA203_0 <= SQL92_RESERVED_DELETE)||LA203_0==SQL92_RESERVED_DISTINCT||(LA203_0 >= SQL92_RESERVED_EXISTS && LA203_0 <= SQL92_RESERVED_FALSE)||LA203_0==SQL92_RESERVED_NULL||LA203_0==SQL92_RESERVED_PRIOR||LA203_0==SQL92_RESERVED_TRUE||LA203_0==UNSIGNED_INTEGER) ) {
				alt203=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 203, 0, input);
				throw nvae;
			}

			switch (alt203) {
				case 1 :
					// PLSQL_DMLParser.g:857:10: not_key ^ negated_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_not_key_in_negated_expression7818);
					not_key597=gPLSQLParser.not_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(not_key597.getTree(), root_0);
					pushFollow(FOLLOW_negated_expression_in_negated_expression7821);
					negated_expression598=negated_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, negated_expression598.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:858:10: equality_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_equality_expression_in_negated_expression7832);
					equality_expression599=equality_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, equality_expression599.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "negated_expression"


	public static class equality_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "equality_expression"
	// PLSQL_DMLParser.g:861:1: equality_expression : ( multiset_expression -> multiset_expression ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )* ;
	public final PLSQLParser_PLSQL_DMLParser.equality_expression_return equality_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.equality_expression_return retval = new PLSQLParser_PLSQL_DMLParser.equality_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN612=null;
		Token COMMA615=null;
		Token RIGHT_PAREN617=null;
		ParserRuleReturnScope multiset_expression600 =null;
		ParserRuleReturnScope is_key601 =null;
		ParserRuleReturnScope not_key602 =null;
		ParserRuleReturnScope null_key603 =null;
		ParserRuleReturnScope nan_key604 =null;
		ParserRuleReturnScope present_key605 =null;
		ParserRuleReturnScope infinite_key606 =null;
		ParserRuleReturnScope a_key607 =null;
		ParserRuleReturnScope set_key608 =null;
		ParserRuleReturnScope empty_key609 =null;
		ParserRuleReturnScope of_key610 =null;
		ParserRuleReturnScope type_key611 =null;
		ParserRuleReturnScope only_key613 =null;
		ParserRuleReturnScope type_spec614 =null;
		ParserRuleReturnScope type_spec616 =null;

		Object LEFT_PAREN612_tree=null;
		Object COMMA615_tree=null;
		Object RIGHT_PAREN617_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_infinite_key=new RewriteRuleSubtreeStream(adaptor,"rule infinite_key");
		RewriteRuleSubtreeStream stream_a_key=new RewriteRuleSubtreeStream(adaptor,"rule a_key");
		RewriteRuleSubtreeStream stream_null_key=new RewriteRuleSubtreeStream(adaptor,"rule null_key");
		RewriteRuleSubtreeStream stream_of_key=new RewriteRuleSubtreeStream(adaptor,"rule of_key");
		RewriteRuleSubtreeStream stream_is_key=new RewriteRuleSubtreeStream(adaptor,"rule is_key");
		RewriteRuleSubtreeStream stream_multiset_expression=new RewriteRuleSubtreeStream(adaptor,"rule multiset_expression");
		RewriteRuleSubtreeStream stream_empty_key=new RewriteRuleSubtreeStream(adaptor,"rule empty_key");
		RewriteRuleSubtreeStream stream_type_key=new RewriteRuleSubtreeStream(adaptor,"rule type_key");
		RewriteRuleSubtreeStream stream_type_spec=new RewriteRuleSubtreeStream(adaptor,"rule type_spec");
		RewriteRuleSubtreeStream stream_not_key=new RewriteRuleSubtreeStream(adaptor,"rule not_key");
		RewriteRuleSubtreeStream stream_nan_key=new RewriteRuleSubtreeStream(adaptor,"rule nan_key");
		RewriteRuleSubtreeStream stream_set_key=new RewriteRuleSubtreeStream(adaptor,"rule set_key");
		RewriteRuleSubtreeStream stream_present_key=new RewriteRuleSubtreeStream(adaptor,"rule present_key");
		RewriteRuleSubtreeStream stream_only_key=new RewriteRuleSubtreeStream(adaptor,"rule only_key");

		    boolean isNegated = false;    
		try {
			// PLSQL_DMLParser.g:863:5: ( ( multiset_expression -> multiset_expression ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )* )
			// PLSQL_DMLParser.g:863:10: ( multiset_expression -> multiset_expression ) ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )*
			{
			// PLSQL_DMLParser.g:863:10: ( multiset_expression -> multiset_expression )
			// PLSQL_DMLParser.g:863:11: multiset_expression
			{
			pushFollow(FOLLOW_multiset_expression_in_equality_expression7861);
			multiset_expression600=multiset_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_multiset_expression.add(multiset_expression600.getTree());
			// AST REWRITE
			// elements: multiset_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 863:31: -> multiset_expression
			{
				adaptor.addChild(root_0, stream_multiset_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// PLSQL_DMLParser.g:864:5: ( is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) ) )*
			loop209:
			while (true) {
				int alt209=2;
				int LA209_0 = input.LA(1);
				if ( (LA209_0==SQL92_RESERVED_IS) ) {
					alt209=1;
				}

				switch (alt209) {
				case 1 :
					// PLSQL_DMLParser.g:864:10: is_key ( not_key )? ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) )
					{
					pushFollow(FOLLOW_is_key_in_equality_expression7877);
					is_key601=gPLSQLParser.is_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_is_key.add(is_key601.getTree());
					// PLSQL_DMLParser.g:864:17: ( not_key )?
					int alt204=2;
					int LA204_0 = input.LA(1);
					if ( (LA204_0==SQL92_RESERVED_NOT) ) {
						alt204=1;
					}
					switch (alt204) {
						case 1 :
							// PLSQL_DMLParser.g:864:18: not_key
							{
							pushFollow(FOLLOW_not_key_in_equality_expression7880);
							not_key602=gPLSQLParser.not_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_not_key.add(not_key602.getTree());
							if ( state.backtracking==0 ) {isNegated = true;}
							}
							break;

					}

					// PLSQL_DMLParser.g:865:9: ( null_key -> {isNegated}? ^( IS_NOT_NULL $equality_expression) -> ^( IS_NULL $equality_expression) | nan_key -> {isNegated}? ^( IS_NOT_NAN $equality_expression) -> ^( IS_NAN $equality_expression) | present_key -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression) -> ^( IS_PRESENT $equality_expression) | infinite_key -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression) -> ^( IS_INFINITE $equality_expression) | a_key set_key -> {isNegated}? ^( IS_NOT_A_SET $equality_expression) -> ^( IS_A_SET $equality_expression) | empty_key -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression) -> ^( IS_EMPTY $equality_expression) | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ ) -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ ) )
					int alt208=7;
					int LA208_0 = input.LA(1);
					if ( (LA208_0==SQL92_RESERVED_NULL) ) {
						alt208=1;
					}
					else if ( (LA208_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("infinite"))||(input.LT(1).getText().equalsIgnoreCase("present"))||(input.LT(1).getText().equalsIgnoreCase("empty"))||(input.LT(1).getText().equalsIgnoreCase("nan"))||(input.LT(1).getText().equalsIgnoreCase("a"))))) {
						int LA208_2 = input.LA(2);
						if ( (LA208_2==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("a")))) {
							alt208=5;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("nan"))) ) {
							alt208=2;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("present"))) ) {
							alt208=3;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("infinite"))) ) {
							alt208=4;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("empty"))) ) {
							alt208=6;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 208, 2, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA208_0==SQL92_RESERVED_OF) ) {
						alt208=7;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 208, 0, input);
						throw nvae;
					}

					switch (alt208) {
						case 1 :
							// PLSQL_DMLParser.g:865:14: null_key
							{
							pushFollow(FOLLOW_null_key_in_equality_expression7899);
							null_key603=gPLSQLParser.null_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_null_key.add(null_key603.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 866:17: -> {isNegated}? ^( IS_NOT_NULL $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:866:33: ^( IS_NOT_NULL $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_NULL, "IS_NOT_NULL"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 867:17: -> ^( IS_NULL $equality_expression)
							{
								// PLSQL_DMLParser.g:867:20: ^( IS_NULL $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NULL, "IS_NULL"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:868:14: nan_key
							{
							pushFollow(FOLLOW_nan_key_in_equality_expression7966);
							nan_key604=gPLSQLParser.nan_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_nan_key.add(nan_key604.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 869:17: -> {isNegated}? ^( IS_NOT_NAN $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:869:33: ^( IS_NOT_NAN $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_NAN, "IS_NOT_NAN"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 870:17: -> ^( IS_NAN $equality_expression)
							{
								// PLSQL_DMLParser.g:870:20: ^( IS_NAN $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NAN, "IS_NAN"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:871:14: present_key
							{
							pushFollow(FOLLOW_present_key_in_equality_expression8033);
							present_key605=gPLSQLParser.present_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_present_key.add(present_key605.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 872:17: -> {isNegated}? ^( IS_NOT_PRESENT $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:872:33: ^( IS_NOT_PRESENT $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_PRESENT, "IS_NOT_PRESENT"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 873:17: -> ^( IS_PRESENT $equality_expression)
							{
								// PLSQL_DMLParser.g:873:20: ^( IS_PRESENT $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_PRESENT, "IS_PRESENT"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 4 :
							// PLSQL_DMLParser.g:874:14: infinite_key
							{
							pushFollow(FOLLOW_infinite_key_in_equality_expression8100);
							infinite_key606=gPLSQLParser.infinite_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_infinite_key.add(infinite_key606.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 875:17: -> {isNegated}? ^( IS_NOT_INFINITE $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:875:33: ^( IS_NOT_INFINITE $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_INFINITE, "IS_NOT_INFINITE"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 876:17: -> ^( IS_INFINITE $equality_expression)
							{
								// PLSQL_DMLParser.g:876:20: ^( IS_INFINITE $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_INFINITE, "IS_INFINITE"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 5 :
							// PLSQL_DMLParser.g:877:14: a_key set_key
							{
							pushFollow(FOLLOW_a_key_in_equality_expression8167);
							a_key607=gPLSQLParser.a_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_a_key.add(a_key607.getTree());
							pushFollow(FOLLOW_set_key_in_equality_expression8169);
							set_key608=gPLSQLParser.set_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_set_key.add(set_key608.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 878:17: -> {isNegated}? ^( IS_NOT_A_SET $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:878:33: ^( IS_NOT_A_SET $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_A_SET, "IS_NOT_A_SET"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 879:17: -> ^( IS_A_SET $equality_expression)
							{
								// PLSQL_DMLParser.g:879:20: ^( IS_A_SET $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_A_SET, "IS_A_SET"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 6 :
							// PLSQL_DMLParser.g:880:14: empty_key
							{
							pushFollow(FOLLOW_empty_key_in_equality_expression8236);
							empty_key609=gPLSQLParser.empty_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_empty_key.add(empty_key609.getTree());
							// AST REWRITE
							// elements: equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 881:17: -> {isNegated}? ^( IS_NOT_EMPTY $equality_expression)
							if (isNegated) {
								// PLSQL_DMLParser.g:881:33: ^( IS_NOT_EMPTY $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_EMPTY, "IS_NOT_EMPTY"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 882:17: -> ^( IS_EMPTY $equality_expression)
							{
								// PLSQL_DMLParser.g:882:20: ^( IS_EMPTY $equality_expression)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_EMPTY, "IS_EMPTY"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 7 :
							// PLSQL_DMLParser.g:883:14: of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN
							{
							pushFollow(FOLLOW_of_key_in_equality_expression8303);
							of_key610=gPLSQLParser.of_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_of_key.add(of_key610.getTree());
							// PLSQL_DMLParser.g:883:21: ( type_key )?
							int alt205=2;
							int LA205_0 = input.LA(1);
							if ( (LA205_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("type")))) {
								alt205=1;
							}
							switch (alt205) {
								case 1 :
									// PLSQL_DMLParser.g:883:21: type_key
									{
									pushFollow(FOLLOW_type_key_in_equality_expression8305);
									type_key611=gPLSQLParser.type_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_type_key.add(type_key611.getTree());
									}
									break;

							}

							LEFT_PAREN612=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_equality_expression8308); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN612);

							// PLSQL_DMLParser.g:883:42: ( only_key )?
							int alt206=2;
							int LA206_0 = input.LA(1);
							if ( (LA206_0==REGULAR_ID) ) {
								int LA206_1 = input.LA(2);
								if ( ((input.LT(1).getText().equalsIgnoreCase("only"))) ) {
									alt206=1;
								}
							}
							switch (alt206) {
								case 1 :
									// PLSQL_DMLParser.g:883:42: only_key
									{
									pushFollow(FOLLOW_only_key_in_equality_expression8310);
									only_key613=gPLSQLParser.only_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_only_key.add(only_key613.getTree());
									}
									break;

							}

							pushFollow(FOLLOW_type_spec_in_equality_expression8313);
							type_spec614=gPLSQLParser.type_spec();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_type_spec.add(type_spec614.getTree());
							// PLSQL_DMLParser.g:883:62: ( COMMA type_spec )*
							loop207:
							while (true) {
								int alt207=2;
								int LA207_0 = input.LA(1);
								if ( (LA207_0==COMMA) ) {
									alt207=1;
								}

								switch (alt207) {
								case 1 :
									// PLSQL_DMLParser.g:883:63: COMMA type_spec
									{
									COMMA615=(Token)match(input,COMMA,FOLLOW_COMMA_in_equality_expression8316); if (state.failed) return retval; 
									if ( state.backtracking==0 ) stream_COMMA.add(COMMA615);

									pushFollow(FOLLOW_type_spec_in_equality_expression8318);
									type_spec616=gPLSQLParser.type_spec();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_type_spec.add(type_spec616.getTree());
									}
									break;

								default :
									break loop207;
								}
							}

							RIGHT_PAREN617=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_equality_expression8322); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN617);

							// AST REWRITE
							// elements: type_spec, type_spec, equality_expression, equality_expression
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 884:17: -> {isNegated}? ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ )
							if (isNegated) {
								// PLSQL_DMLParser.g:884:33: ^( IS_NOT_OF_TYPE $equality_expression ( type_spec )+ )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_NOT_OF_TYPE, "IS_NOT_OF_TYPE"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								if ( !(stream_type_spec.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_type_spec.hasNext() ) {
									adaptor.addChild(root_1, stream_type_spec.nextTree());
								}
								stream_type_spec.reset();

								adaptor.addChild(root_0, root_1);
								}

							}

							else // 885:17: -> ^( IS_OF_TYPE $equality_expression ( type_spec )+ )
							{
								// PLSQL_DMLParser.g:885:20: ^( IS_OF_TYPE $equality_expression ( type_spec )+ )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IS_OF_TYPE, "IS_OF_TYPE"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								if ( !(stream_type_spec.hasNext()) ) {
									throw new RewriteEarlyExitException();
								}
								while ( stream_type_spec.hasNext() ) {
									adaptor.addChild(root_1, stream_type_spec.nextTree());
								}
								stream_type_spec.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;

					}

					}
					break;

				default :
					break loop209;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "equality_expression"


	public static class multiset_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multiset_expression"
	// PLSQL_DMLParser.g:891:1: multiset_expression : ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_expression ^( EXPR concatenation ) ) )? ;
	public final PLSQLParser_PLSQL_DMLParser.multiset_expression_return multiset_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multiset_expression_return retval = new PLSQLParser_PLSQL_DMLParser.multiset_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope relational_expression618 =null;
		ParserRuleReturnScope multiset_type619 =null;
		ParserRuleReturnScope of_key620 =null;
		ParserRuleReturnScope concatenation621 =null;

		RewriteRuleSubtreeStream stream_of_key=new RewriteRuleSubtreeStream(adaptor,"rule of_key");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_relational_expression=new RewriteRuleSubtreeStream(adaptor,"rule relational_expression");
		RewriteRuleSubtreeStream stream_multiset_type=new RewriteRuleSubtreeStream(adaptor,"rule multiset_type");

		try {
			// PLSQL_DMLParser.g:892:5: ( ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_expression ^( EXPR concatenation ) ) )? )
			// PLSQL_DMLParser.g:892:10: ( relational_expression -> relational_expression ) ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_expression ^( EXPR concatenation ) ) )?
			{
			// PLSQL_DMLParser.g:892:10: ( relational_expression -> relational_expression )
			// PLSQL_DMLParser.g:892:11: relational_expression
			{
			pushFollow(FOLLOW_relational_expression_in_multiset_expression8419);
			relational_expression618=relational_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_relational_expression.add(relational_expression618.getTree());
			// AST REWRITE
			// elements: relational_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 892:33: -> relational_expression
			{
				adaptor.addChild(root_0, stream_relational_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// PLSQL_DMLParser.g:893:5: ( multiset_type ( of_key )? concatenation -> ^( multiset_type $multiset_expression ^( EXPR concatenation ) ) )?
			int alt211=2;
			int LA211_0 = input.LA(1);
			if ( (LA211_0==REGULAR_ID) ) {
				int LA211_1 = input.LA(2);
				if ( (((input.LT(1).getText().equalsIgnoreCase("submultiset"))||(input.LT(1).getText().equalsIgnoreCase("member")))) ) {
					alt211=1;
				}
			}
			switch (alt211) {
				case 1 :
					// PLSQL_DMLParser.g:893:10: multiset_type ( of_key )? concatenation
					{
					pushFollow(FOLLOW_multiset_type_in_multiset_expression8435);
					multiset_type619=multiset_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_multiset_type.add(multiset_type619.getTree());
					// PLSQL_DMLParser.g:893:24: ( of_key )?
					int alt210=2;
					int LA210_0 = input.LA(1);
					if ( (LA210_0==SQL92_RESERVED_OF) ) {
						alt210=1;
					}
					switch (alt210) {
						case 1 :
							// PLSQL_DMLParser.g:893:24: of_key
							{
							pushFollow(FOLLOW_of_key_in_multiset_expression8437);
							of_key620=gPLSQLParser.of_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_of_key.add(of_key620.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_concatenation_in_multiset_expression8440);
					concatenation621=concatenation();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_concatenation.add(concatenation621.getTree());
					// AST REWRITE
					// elements: multiset_expression, multiset_type, concatenation
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 894:9: -> ^( multiset_type $multiset_expression ^( EXPR concatenation ) )
					{
						// PLSQL_DMLParser.g:894:12: ^( multiset_type $multiset_expression ^( EXPR concatenation ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_multiset_type.nextNode(), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						// PLSQL_DMLParser.g:894:49: ^( EXPR concatenation )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
						adaptor.addChild(root_2, stream_concatenation.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multiset_expression"


	public static class multiset_type_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multiset_type"
	// PLSQL_DMLParser.g:897:1: multiset_type : ( member_key | submultiset_key );
	public final PLSQLParser_PLSQL_DMLParser.multiset_type_return multiset_type() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multiset_type_return retval = new PLSQLParser_PLSQL_DMLParser.multiset_type_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope member_key622 =null;
		ParserRuleReturnScope submultiset_key623 =null;


		try {
			// PLSQL_DMLParser.g:898:5: ( member_key | submultiset_key )
			int alt212=2;
			int LA212_0 = input.LA(1);
			if ( (LA212_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("submultiset"))||(input.LT(1).getText().equalsIgnoreCase("member"))))) {
				int LA212_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("member"))) ) {
					alt212=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("submultiset"))) ) {
					alt212=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 212, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt212) {
				case 1 :
					// PLSQL_DMLParser.g:898:10: member_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_member_key_in_multiset_type8485);
					member_key622=gPLSQLParser.member_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, member_key622.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:899:10: submultiset_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_submultiset_key_in_multiset_type8496);
					submultiset_key623=gPLSQLParser.submultiset_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, submultiset_key623.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multiset_type"


	public static class relational_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "relational_expression"
	// PLSQL_DMLParser.g:902:1: relational_expression : compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )* ;
	public final PLSQLParser_PLSQL_DMLParser.relational_expression_return relational_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.relational_expression_return retval = new PLSQLParser_PLSQL_DMLParser.relational_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP625=null;
		Token LESS_THAN_OP627=null;
		Token GREATER_THAN_OP628=null;
		ParserRuleReturnScope compound_expression624 =null;
		ParserRuleReturnScope not_equal_op626 =null;
		ParserRuleReturnScope less_than_or_equals_op629 =null;
		ParserRuleReturnScope greater_than_or_equals_op630 =null;
		ParserRuleReturnScope compound_expression631 =null;

		Object EQUALS_OP625_tree=null;
		Object LESS_THAN_OP627_tree=null;
		Object GREATER_THAN_OP628_tree=null;

		try {
			// PLSQL_DMLParser.g:903:5: ( compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )* )
			// PLSQL_DMLParser.g:903:10: compound_expression ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_compound_expression_in_relational_expression8516);
			compound_expression624=compound_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, compound_expression624.getTree());

			// PLSQL_DMLParser.g:904:5: ( ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression )*
			loop214:
			while (true) {
				int alt214=2;
				switch ( input.LA(1) ) {
				case EQUALS_OP:
					{
					alt214=1;
					}
					break;
				case NOT_EQUAL_OP:
					{
					alt214=1;
					}
					break;
				case LESS_THAN_OP:
					{
					alt214=1;
					}
					break;
				case EXCLAMATION_OPERATOR_PART:
					{
					alt214=1;
					}
					break;
				case CARRET_OPERATOR_PART:
					{
					alt214=1;
					}
					break;
				case GREATER_THAN_OP:
					{
					alt214=1;
					}
					break;
				case LESS_THAN_OR_EQUALS_OP:
					{
					alt214=1;
					}
					break;
				case GREATER_THAN_OR_EQUALS_OP:
					{
					alt214=1;
					}
					break;
				}
				switch (alt214) {
				case 1 :
					// PLSQL_DMLParser.g:904:7: ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^) compound_expression
					{
					// PLSQL_DMLParser.g:904:7: ( EQUALS_OP ^| not_equal_op ^| LESS_THAN_OP ^| GREATER_THAN_OP ^| less_than_or_equals_op ^| greater_than_or_equals_op ^)
					int alt213=6;
					switch ( input.LA(1) ) {
					case EQUALS_OP:
						{
						alt213=1;
						}
						break;
					case CARRET_OPERATOR_PART:
					case EXCLAMATION_OPERATOR_PART:
					case NOT_EQUAL_OP:
						{
						alt213=2;
						}
						break;
					case LESS_THAN_OP:
						{
						switch ( input.LA(2) ) {
						case GREATER_THAN_OP:
							{
							alt213=2;
							}
							break;
						case EQUALS_OP:
							{
							alt213=5;
							}
							break;
						case APPROXIMATE_NUM_LIT:
						case BINDVAR:
						case CHAR_STRING:
						case CHAR_STRING_PERL:
						case COLON:
						case DELIMITED_ID:
						case EXACT_NUM_LIT:
						case INTRODUCER:
						case LEFT_PAREN:
						case MINUS_SIGN:
						case NATIONAL_CHAR_STRING_LIT:
						case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
						case PLUS_SIGN:
						case REGULAR_ID:
						case SQL92_RESERVED_ALL:
						case SQL92_RESERVED_ANY:
						case SQL92_RESERVED_CASE:
						case SQL92_RESERVED_DATE:
						case SQL92_RESERVED_DEFAULT:
						case SQL92_RESERVED_DELETE:
						case SQL92_RESERVED_DISTINCT:
						case SQL92_RESERVED_EXISTS:
						case SQL92_RESERVED_FALSE:
						case SQL92_RESERVED_NULL:
						case SQL92_RESERVED_PRIOR:
						case SQL92_RESERVED_TRUE:
						case UNSIGNED_INTEGER:
							{
							alt213=3;
							}
							break;
						default:
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 213, 3, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}
						}
						break;
					case GREATER_THAN_OP:
						{
						int LA213_4 = input.LA(2);
						if ( (LA213_4==EQUALS_OP) ) {
							alt213=6;
						}
						else if ( (LA213_4==APPROXIMATE_NUM_LIT||LA213_4==BINDVAR||(LA213_4 >= CHAR_STRING && LA213_4 <= COLON)||LA213_4==DELIMITED_ID||LA213_4==EXACT_NUM_LIT||LA213_4==INTRODUCER||LA213_4==LEFT_PAREN||LA213_4==MINUS_SIGN||LA213_4==NATIONAL_CHAR_STRING_LIT||LA213_4==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA213_4==PLUS_SIGN||LA213_4==REGULAR_ID||LA213_4==SQL92_RESERVED_ALL||LA213_4==SQL92_RESERVED_ANY||LA213_4==SQL92_RESERVED_CASE||LA213_4==SQL92_RESERVED_DATE||(LA213_4 >= SQL92_RESERVED_DEFAULT && LA213_4 <= SQL92_RESERVED_DELETE)||LA213_4==SQL92_RESERVED_DISTINCT||(LA213_4 >= SQL92_RESERVED_EXISTS && LA213_4 <= SQL92_RESERVED_FALSE)||LA213_4==SQL92_RESERVED_NULL||LA213_4==SQL92_RESERVED_PRIOR||LA213_4==SQL92_RESERVED_TRUE||LA213_4==UNSIGNED_INTEGER) ) {
							alt213=4;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 213, 4, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

						}
						break;
					case LESS_THAN_OR_EQUALS_OP:
						{
						alt213=5;
						}
						break;
					case GREATER_THAN_OR_EQUALS_OP:
						{
						alt213=6;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 213, 0, input);
						throw nvae;
					}
					switch (alt213) {
						case 1 :
							// PLSQL_DMLParser.g:904:9: EQUALS_OP ^
							{
							EQUALS_OP625=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_relational_expression8526); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							EQUALS_OP625_tree = (Object)adaptor.create(EQUALS_OP625);
							root_0 = (Object)adaptor.becomeRoot(EQUALS_OP625_tree, root_0);
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:904:22: not_equal_op ^
							{
							pushFollow(FOLLOW_not_equal_op_in_relational_expression8531);
							not_equal_op626=gPLSQLParser.not_equal_op();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(not_equal_op626.getTree(), root_0);
							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:904:38: LESS_THAN_OP ^
							{
							LESS_THAN_OP627=(Token)match(input,LESS_THAN_OP,FOLLOW_LESS_THAN_OP_in_relational_expression8536); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							LESS_THAN_OP627_tree = (Object)adaptor.create(LESS_THAN_OP627);
							root_0 = (Object)adaptor.becomeRoot(LESS_THAN_OP627_tree, root_0);
							}

							}
							break;
						case 4 :
							// PLSQL_DMLParser.g:904:54: GREATER_THAN_OP ^
							{
							GREATER_THAN_OP628=(Token)match(input,GREATER_THAN_OP,FOLLOW_GREATER_THAN_OP_in_relational_expression8541); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							GREATER_THAN_OP628_tree = (Object)adaptor.create(GREATER_THAN_OP628);
							root_0 = (Object)adaptor.becomeRoot(GREATER_THAN_OP628_tree, root_0);
							}

							}
							break;
						case 5 :
							// PLSQL_DMLParser.g:904:73: less_than_or_equals_op ^
							{
							pushFollow(FOLLOW_less_than_or_equals_op_in_relational_expression8546);
							less_than_or_equals_op629=gPLSQLParser.less_than_or_equals_op();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(less_than_or_equals_op629.getTree(), root_0);
							}
							break;
						case 6 :
							// PLSQL_DMLParser.g:904:99: greater_than_or_equals_op ^
							{
							pushFollow(FOLLOW_greater_than_or_equals_op_in_relational_expression8551);
							greater_than_or_equals_op630=gPLSQLParser.greater_than_or_equals_op();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(greater_than_or_equals_op630.getTree(), root_0);
							}
							break;

					}

					pushFollow(FOLLOW_compound_expression_in_relational_expression8556);
					compound_expression631=compound_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, compound_expression631.getTree());

					}
					break;

				default :
					break loop214;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relational_expression"


	public static class compound_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "compound_expression"
	// PLSQL_DMLParser.g:907:1: compound_expression : (e1= concatenation -> $e1) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) ) )? ;
	public final PLSQLParser_PLSQL_DMLParser.compound_expression_return compound_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.compound_expression_return retval = new PLSQLParser_PLSQL_DMLParser.compound_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope e1 =null;
		ParserRuleReturnScope c2 =null;
		ParserRuleReturnScope not_key632 =null;
		ParserRuleReturnScope in_key633 =null;
		ParserRuleReturnScope in_elements634 =null;
		ParserRuleReturnScope between_key635 =null;
		ParserRuleReturnScope between_elements636 =null;
		ParserRuleReturnScope like_type637 =null;
		ParserRuleReturnScope like_escape_part638 =null;

		RewriteRuleSubtreeStream stream_in_elements=new RewriteRuleSubtreeStream(adaptor,"rule in_elements");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_like_escape_part=new RewriteRuleSubtreeStream(adaptor,"rule like_escape_part");
		RewriteRuleSubtreeStream stream_not_key=new RewriteRuleSubtreeStream(adaptor,"rule not_key");
		RewriteRuleSubtreeStream stream_between_key=new RewriteRuleSubtreeStream(adaptor,"rule between_key");
		RewriteRuleSubtreeStream stream_between_elements=new RewriteRuleSubtreeStream(adaptor,"rule between_elements");
		RewriteRuleSubtreeStream stream_like_type=new RewriteRuleSubtreeStream(adaptor,"rule like_type");

		    boolean isNegated = false;    
		try {
			// PLSQL_DMLParser.g:909:5: ( (e1= concatenation -> $e1) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) ) )? )
			// PLSQL_DMLParser.g:909:10: (e1= concatenation -> $e1) ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) ) )?
			{
			// PLSQL_DMLParser.g:909:10: (e1= concatenation -> $e1)
			// PLSQL_DMLParser.g:909:11: e1= concatenation
			{
			pushFollow(FOLLOW_concatenation_in_compound_expression8589);
			e1=concatenation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_concatenation.add(e1.getTree());
			// AST REWRITE
			// elements: e1
			// token labels: 
			// rule labels: e1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,"rule e1",e1!=null?e1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 909:28: -> $e1
			{
				adaptor.addChild(root_0, stream_e1.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// PLSQL_DMLParser.g:910:5: ( ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) ) )?
			int alt218=2;
			switch ( input.LA(1) ) {
				case SQL92_RESERVED_NOT:
					{
					alt218=1;
					}
					break;
				case SQL92_RESERVED_IN:
					{
					alt218=1;
					}
					break;
				case SQL92_RESERVED_BETWEEN:
					{
					alt218=1;
					}
					break;
				case SQL92_RESERVED_LIKE:
					{
					alt218=1;
					}
					break;
				case REGULAR_ID:
					{
					int LA218_5 = input.LA(2);
					if ( (((input.LT(1).getText().equalsIgnoreCase("like4"))||(input.LT(1).getText().equalsIgnoreCase("like2"))||(input.LT(1).getText().equalsIgnoreCase("likec")))) ) {
						alt218=1;
					}
					}
					break;
			}
			switch (alt218) {
				case 1 :
					// PLSQL_DMLParser.g:910:10: ( not_key )? ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) )
					{
					// PLSQL_DMLParser.g:910:10: ( not_key )?
					int alt215=2;
					int LA215_0 = input.LA(1);
					if ( (LA215_0==SQL92_RESERVED_NOT) ) {
						alt215=1;
					}
					switch (alt215) {
						case 1 :
							// PLSQL_DMLParser.g:910:11: not_key
							{
							pushFollow(FOLLOW_not_key_in_compound_expression8607);
							not_key632=gPLSQLParser.not_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_not_key.add(not_key632.getTree());
							if ( state.backtracking==0 ) {isNegated = true;}
							}
							break;

					}

					// PLSQL_DMLParser.g:911:9: ( in_key in_elements -> {isNegated}? ^( NOT_IN $compound_expression in_elements ) -> ^( in_key $compound_expression in_elements ) | between_key between_elements -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements ) -> ^( between_key $compound_expression between_elements ) | like_type c2= concatenation ( like_escape_part )? -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? ) -> ^( like_type $compound_expression $c2 ( like_escape_part )? ) )
					int alt217=3;
					int LA217_0 = input.LA(1);
					if ( (LA217_0==SQL92_RESERVED_IN) ) {
						alt217=1;
					}
					else if ( (LA217_0==SQL92_RESERVED_BETWEEN) ) {
						alt217=2;
					}
					else if ( (LA217_0==SQL92_RESERVED_LIKE) ) {
						alt217=3;
					}
					else if ( (LA217_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("like4"))||(input.LT(1).getText().equalsIgnoreCase("like2"))||(input.LT(1).getText().equalsIgnoreCase("likec"))))) {
						alt217=3;
					}

					switch (alt217) {
						case 1 :
							// PLSQL_DMLParser.g:911:14: in_key in_elements
							{
							pushFollow(FOLLOW_in_key_in_compound_expression8627);
							in_key633=gPLSQLParser.in_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_in_key.add(in_key633.getTree());
							pushFollow(FOLLOW_in_elements_in_compound_expression8629);
							in_elements634=in_elements();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_in_elements.add(in_elements634.getTree());
							// AST REWRITE
							// elements: compound_expression, compound_expression, in_key, in_elements, in_elements
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 912:17: -> {isNegated}? ^( NOT_IN $compound_expression in_elements )
							if (isNegated) {
								// PLSQL_DMLParser.g:912:33: ^( NOT_IN $compound_expression in_elements )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NOT_IN, "NOT_IN"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_in_elements.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 913:17: -> ^( in_key $compound_expression in_elements )
							{
								// PLSQL_DMLParser.g:913:20: ^( in_key $compound_expression in_elements )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_in_elements.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:914:14: between_key between_elements
							{
							pushFollow(FOLLOW_between_key_in_compound_expression8700);
							between_key635=gPLSQLParser.between_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_between_key.add(between_key635.getTree());
							pushFollow(FOLLOW_between_elements_in_compound_expression8702);
							between_elements636=between_elements();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_between_elements.add(between_elements636.getTree());
							// AST REWRITE
							// elements: compound_expression, compound_expression, between_key, between_elements, between_elements
							// token labels: 
							// rule labels: retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 915:17: -> {isNegated}? ^( NOT_BETWEEN $compound_expression between_elements )
							if (isNegated) {
								// PLSQL_DMLParser.g:915:33: ^( NOT_BETWEEN $compound_expression between_elements )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NOT_BETWEEN, "NOT_BETWEEN"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_between_elements.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}

							else // 916:17: -> ^( between_key $compound_expression between_elements )
							{
								// PLSQL_DMLParser.g:916:20: ^( between_key $compound_expression between_elements )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot(stream_between_key.nextNode(), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_between_elements.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:917:14: like_type c2= concatenation ( like_escape_part )?
							{
							pushFollow(FOLLOW_like_type_in_compound_expression8773);
							like_type637=like_type();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_like_type.add(like_type637.getTree());
							pushFollow(FOLLOW_concatenation_in_compound_expression8777);
							c2=concatenation();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation.add(c2.getTree());
							// PLSQL_DMLParser.g:917:41: ( like_escape_part )?
							int alt216=2;
							int LA216_0 = input.LA(1);
							if ( (LA216_0==REGULAR_ID) ) {
								int LA216_1 = input.LA(2);
								if ( ((input.LT(1).getText().equalsIgnoreCase("escape"))) ) {
									alt216=1;
								}
							}
							switch (alt216) {
								case 1 :
									// PLSQL_DMLParser.g:917:41: like_escape_part
									{
									pushFollow(FOLLOW_like_escape_part_in_compound_expression8779);
									like_escape_part638=like_escape_part();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_like_escape_part.add(like_escape_part638.getTree());
									}
									break;

							}

							// AST REWRITE
							// elements: c2, c2, compound_expression, like_escape_part, compound_expression, like_type, like_escape_part
							// token labels: 
							// rule labels: retval, c2
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
							RewriteRuleSubtreeStream stream_c2=new RewriteRuleSubtreeStream(adaptor,"rule c2",c2!=null?c2.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 918:17: -> {isNegated}? ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? )
							if (isNegated) {
								// PLSQL_DMLParser.g:918:33: ^( NOT_LIKE $compound_expression $c2 ( like_escape_part )? )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(NOT_LIKE, "NOT_LIKE"), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_c2.nextTree());
								// PLSQL_DMLParser.g:918:69: ( like_escape_part )?
								if ( stream_like_escape_part.hasNext() ) {
									adaptor.addChild(root_1, stream_like_escape_part.nextTree());
								}
								stream_like_escape_part.reset();

								adaptor.addChild(root_0, root_1);
								}

							}

							else // 919:17: -> ^( like_type $compound_expression $c2 ( like_escape_part )? )
							{
								// PLSQL_DMLParser.g:919:20: ^( like_type $compound_expression $c2 ( like_escape_part )? )
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot(stream_like_type.nextNode(), root_1);
								adaptor.addChild(root_1, stream_retval.nextTree());
								adaptor.addChild(root_1, stream_c2.nextTree());
								// PLSQL_DMLParser.g:919:57: ( like_escape_part )?
								if ( stream_like_escape_part.hasNext() ) {
									adaptor.addChild(root_1, stream_like_escape_part.nextTree());
								}
								stream_like_escape_part.reset();

								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;

					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "compound_expression"


	public static class like_type_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "like_type"
	// PLSQL_DMLParser.g:924:1: like_type : ( like_key | likec_key | like2_key | like4_key );
	public final PLSQLParser_PLSQL_DMLParser.like_type_return like_type() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.like_type_return retval = new PLSQLParser_PLSQL_DMLParser.like_type_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope like_key639 =null;
		ParserRuleReturnScope likec_key640 =null;
		ParserRuleReturnScope like2_key641 =null;
		ParserRuleReturnScope like4_key642 =null;


		try {
			// PLSQL_DMLParser.g:925:5: ( like_key | likec_key | like2_key | like4_key )
			int alt219=4;
			int LA219_0 = input.LA(1);
			if ( (LA219_0==SQL92_RESERVED_LIKE) ) {
				alt219=1;
			}
			else if ( (LA219_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("like4"))||(input.LT(1).getText().equalsIgnoreCase("like2"))||(input.LT(1).getText().equalsIgnoreCase("likec"))))) {
				int LA219_2 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("likec"))) ) {
					alt219=2;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("like2"))) ) {
					alt219=3;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("like4"))) ) {
					alt219=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 219, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt219) {
				case 1 :
					// PLSQL_DMLParser.g:925:10: like_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_like_key_in_like_type8881);
					like_key639=gPLSQLParser.like_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, like_key639.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:926:10: likec_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_likec_key_in_like_type8892);
					likec_key640=gPLSQLParser.likec_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, likec_key640.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:927:10: like2_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_like2_key_in_like_type8903);
					like2_key641=gPLSQLParser.like2_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, like2_key641.getTree());

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:928:10: like4_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_like4_key_in_like_type8914);
					like4_key642=gPLSQLParser.like4_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, like4_key642.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "like_type"


	public static class like_escape_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "like_escape_part"
	// PLSQL_DMLParser.g:931:1: like_escape_part : escape_key concatenation -> concatenation ;
	public final PLSQLParser_PLSQL_DMLParser.like_escape_part_return like_escape_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.like_escape_part_return retval = new PLSQLParser_PLSQL_DMLParser.like_escape_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope escape_key643 =null;
		ParserRuleReturnScope concatenation644 =null;

		RewriteRuleSubtreeStream stream_escape_key=new RewriteRuleSubtreeStream(adaptor,"rule escape_key");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");

		try {
			// PLSQL_DMLParser.g:932:5: ( escape_key concatenation -> concatenation )
			// PLSQL_DMLParser.g:932:10: escape_key concatenation
			{
			pushFollow(FOLLOW_escape_key_in_like_escape_part8934);
			escape_key643=gPLSQLParser.escape_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_escape_key.add(escape_key643.getTree());
			pushFollow(FOLLOW_concatenation_in_like_escape_part8936);
			concatenation644=concatenation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_concatenation.add(concatenation644.getTree());
			// AST REWRITE
			// elements: concatenation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 932:35: -> concatenation
			{
				adaptor.addChild(root_0, stream_concatenation.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "like_escape_part"


	public static class in_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "in_elements"
	// PLSQL_DMLParser.g:935:1: in_elements : ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN -> ^( EXPR_LIST ( concatenation_wrapper )+ ) | constant -> ^( EXPR constant ) | bind_variable -> ^( EXPR bind_variable ) | general_element -> ^( EXPR general_element ) );
	public final PLSQLParser_PLSQL_DMLParser.in_elements_return in_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.in_elements_return retval = new PLSQLParser_PLSQL_DMLParser.in_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN645=null;
		Token RIGHT_PAREN647=null;
		Token LEFT_PAREN648=null;
		Token COMMA650=null;
		Token RIGHT_PAREN652=null;
		ParserRuleReturnScope subquery646 =null;
		ParserRuleReturnScope concatenation_wrapper649 =null;
		ParserRuleReturnScope concatenation_wrapper651 =null;
		ParserRuleReturnScope constant653 =null;
		ParserRuleReturnScope bind_variable654 =null;
		ParserRuleReturnScope general_element655 =null;

		Object LEFT_PAREN645_tree=null;
		Object RIGHT_PAREN647_tree=null;
		Object LEFT_PAREN648_tree=null;
		Object COMMA650_tree=null;
		Object RIGHT_PAREN652_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		RewriteRuleSubtreeStream stream_bind_variable=new RewriteRuleSubtreeStream(adaptor,"rule bind_variable");
		RewriteRuleSubtreeStream stream_concatenation_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule concatenation_wrapper");
		RewriteRuleSubtreeStream stream_general_element=new RewriteRuleSubtreeStream(adaptor,"rule general_element");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:937:5: ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN -> subquery | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN -> ^( EXPR_LIST ( concatenation_wrapper )+ ) | constant -> ^( EXPR constant ) | bind_variable -> ^( EXPR bind_variable ) | general_element -> ^( EXPR general_element ) )
			int alt221=5;
			switch ( input.LA(1) ) {
			case LEFT_PAREN:
				{
				int LA221_1 = input.LA(2);
				if ( (synpred25_PLSQL_DMLParser()) ) {
					alt221=1;
				}
				else if ( (true) ) {
					alt221=2;
				}

				}
				break;
			case REGULAR_ID:
				{
				int LA221_2 = input.LA(2);
				if ( (((input.LT(1).getText().equalsIgnoreCase("minvalue"))||(input.LT(1).getText().equalsIgnoreCase("dbtimezone"))||(input.LT(1).getText().equalsIgnoreCase("interval"))||(input.LT(1).getText().equalsIgnoreCase("sessiontimezone"))||(input.LT(1).getText().equalsIgnoreCase("timestamp"))||(input.LT(1).getText().equalsIgnoreCase("maxvalue")))) ) {
					alt221=3;
				}
				else if ( (true) ) {
					alt221=5;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt221=3;
				}
				break;
			case BINDVAR:
				{
				alt221=4;
				}
				break;
			case COLON:
				{
				alt221=4;
				}
				break;
			case DELIMITED_ID:
			case INTRODUCER:
			case SQL92_RESERVED_DELETE:
			case SQL92_RESERVED_EXISTS:
			case SQL92_RESERVED_PRIOR:
				{
				alt221=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 221, 0, input);
				throw nvae;
			}
			switch (alt221) {
				case 1 :
					// PLSQL_DMLParser.g:937:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
					{
					LEFT_PAREN645=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_in_elements8982); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN645);

					pushFollow(FOLLOW_subquery_in_in_elements8984);
					subquery646=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery.add(subquery646.getTree());
					RIGHT_PAREN647=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_in_elements8986); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN647);

					// AST REWRITE
					// elements: subquery
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 938:10: -> subquery
					{
						adaptor.addChild(root_0, stream_subquery.nextTree());
					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:939:10: LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN
					{
					LEFT_PAREN648=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_in_elements9010); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN648);

					pushFollow(FOLLOW_concatenation_wrapper_in_in_elements9012);
					concatenation_wrapper649=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_concatenation_wrapper.add(concatenation_wrapper649.getTree());
					// PLSQL_DMLParser.g:939:43: ( COMMA concatenation_wrapper )*
					loop220:
					while (true) {
						int alt220=2;
						int LA220_0 = input.LA(1);
						if ( (LA220_0==COMMA) ) {
							alt220=1;
						}

						switch (alt220) {
						case 1 :
							// PLSQL_DMLParser.g:939:44: COMMA concatenation_wrapper
							{
							COMMA650=(Token)match(input,COMMA,FOLLOW_COMMA_in_in_elements9015); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA650);

							pushFollow(FOLLOW_concatenation_wrapper_in_in_elements9017);
							concatenation_wrapper651=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(concatenation_wrapper651.getTree());
							}
							break;

						default :
							break loop220;
						}
					}

					RIGHT_PAREN652=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_in_elements9021); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN652);

					// AST REWRITE
					// elements: concatenation_wrapper
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 940:10: -> ^( EXPR_LIST ( concatenation_wrapper )+ )
					{
						// PLSQL_DMLParser.g:940:13: ^( EXPR_LIST ( concatenation_wrapper )+ )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR_LIST, "EXPR_LIST"), root_1);
						if ( !(stream_concatenation_wrapper.hasNext()) ) {
							throw new RewriteEarlyExitException();
						}
						while ( stream_concatenation_wrapper.hasNext() ) {
							adaptor.addChild(root_1, stream_concatenation_wrapper.nextTree());
						}
						stream_concatenation_wrapper.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:941:10: constant
					{
					pushFollow(FOLLOW_constant_in_in_elements9050);
					constant653=gPLSQLParser.constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_constant.add(constant653.getTree());
					// AST REWRITE
					// elements: constant
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 942:10: -> ^( EXPR constant )
					{
						// PLSQL_DMLParser.g:942:13: ^( EXPR constant )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_constant.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:943:10: bind_variable
					{
					pushFollow(FOLLOW_bind_variable_in_in_elements9078);
					bind_variable654=gPLSQLParser.bind_variable();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_bind_variable.add(bind_variable654.getTree());
					// AST REWRITE
					// elements: bind_variable
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 944:10: -> ^( EXPR bind_variable )
					{
						// PLSQL_DMLParser.g:944:13: ^( EXPR bind_variable )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_bind_variable.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:945:10: general_element
					{
					pushFollow(FOLLOW_general_element_in_in_elements9106);
					general_element655=gPLSQLParser.general_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_general_element.add(general_element655.getTree());
					// AST REWRITE
					// elements: general_element
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 946:10: -> ^( EXPR general_element )
					{
						// PLSQL_DMLParser.g:946:13: ^( EXPR general_element )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
						adaptor.addChild(root_1, stream_general_element.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_elements"


	public static class between_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "between_elements"
	// PLSQL_DMLParser.g:949:1: between_elements : cn1= concatenation and_key cn2= concatenation -> $cn1 $cn2;
	public final PLSQLParser_PLSQL_DMLParser.between_elements_return between_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.between_elements_return retval = new PLSQLParser_PLSQL_DMLParser.between_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope cn1 =null;
		ParserRuleReturnScope cn2 =null;
		ParserRuleReturnScope and_key656 =null;

		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_and_key=new RewriteRuleSubtreeStream(adaptor,"rule and_key");

		try {
			// PLSQL_DMLParser.g:950:5: (cn1= concatenation and_key cn2= concatenation -> $cn1 $cn2)
			// PLSQL_DMLParser.g:950:10: cn1= concatenation and_key cn2= concatenation
			{
			pushFollow(FOLLOW_concatenation_in_between_elements9145);
			cn1=concatenation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_concatenation.add(cn1.getTree());
			pushFollow(FOLLOW_and_key_in_between_elements9147);
			and_key656=gPLSQLParser.and_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_and_key.add(and_key656.getTree());
			pushFollow(FOLLOW_concatenation_in_between_elements9151);
			cn2=concatenation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_concatenation.add(cn2.getTree());
			// AST REWRITE
			// elements: cn1, cn2
			// token labels: 
			// rule labels: cn2, cn1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_cn2=new RewriteRuleSubtreeStream(adaptor,"rule cn2",cn2!=null?cn2.getTree():null);
			RewriteRuleSubtreeStream stream_cn1=new RewriteRuleSubtreeStream(adaptor,"rule cn1",cn1!=null?cn1.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 951:9: -> $cn1 $cn2
			{
				adaptor.addChild(root_0, stream_cn1.nextTree());
				adaptor.addChild(root_0, stream_cn2.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "between_elements"


	public static class concatenation_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "concatenation"
	// PLSQL_DMLParser.g:954:1: concatenation : additive_expression ( concatenation_op ^ additive_expression )* ;
	public final PLSQLParser_PLSQL_DMLParser.concatenation_return concatenation() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.concatenation_return retval = new PLSQLParser_PLSQL_DMLParser.concatenation_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope additive_expression657 =null;
		ParserRuleReturnScope concatenation_op658 =null;
		ParserRuleReturnScope additive_expression659 =null;


		try {
			// PLSQL_DMLParser.g:955:5: ( additive_expression ( concatenation_op ^ additive_expression )* )
			// PLSQL_DMLParser.g:955:10: additive_expression ( concatenation_op ^ additive_expression )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_additive_expression_in_concatenation9187);
			additive_expression657=additive_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, additive_expression657.getTree());

			// PLSQL_DMLParser.g:955:30: ( concatenation_op ^ additive_expression )*
			loop222:
			while (true) {
				int alt222=2;
				int LA222_0 = input.LA(1);
				if ( (LA222_0==CONCATENATION_OP) ) {
					alt222=1;
				}
				else if ( (LA222_0==VERTICAL_BAR) ) {
					alt222=1;
				}

				switch (alt222) {
				case 1 :
					// PLSQL_DMLParser.g:955:31: concatenation_op ^ additive_expression
					{
					pushFollow(FOLLOW_concatenation_op_in_concatenation9190);
					concatenation_op658=gPLSQLParser.concatenation_op();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(concatenation_op658.getTree(), root_0);
					pushFollow(FOLLOW_additive_expression_in_concatenation9193);
					additive_expression659=additive_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, additive_expression659.getTree());

					}
					break;

				default :
					break loop222;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "concatenation"


	public static class concatenation_wrapper_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "concatenation_wrapper"
	// PLSQL_DMLParser.g:958:1: concatenation_wrapper : concatenation -> ^( EXPR concatenation ) ;
	public final PLSQLParser_PLSQL_DMLParser.concatenation_wrapper_return concatenation_wrapper() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.concatenation_wrapper_return retval = new PLSQLParser_PLSQL_DMLParser.concatenation_wrapper_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope concatenation660 =null;

		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");

		try {
			// PLSQL_DMLParser.g:959:5: ( concatenation -> ^( EXPR concatenation ) )
			// PLSQL_DMLParser.g:959:10: concatenation
			{
			pushFollow(FOLLOW_concatenation_in_concatenation_wrapper9215);
			concatenation660=concatenation();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_concatenation.add(concatenation660.getTree());
			// AST REWRITE
			// elements: concatenation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 960:9: -> ^( EXPR concatenation )
			{
				// PLSQL_DMLParser.g:960:12: ^( EXPR concatenation )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
				adaptor.addChild(root_1, stream_concatenation.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "concatenation_wrapper"


	public static class additive_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "additive_expression"
	// PLSQL_DMLParser.g:963:1: additive_expression : multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )* ;
	public final PLSQLParser_PLSQL_DMLParser.additive_expression_return additive_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.additive_expression_return retval = new PLSQLParser_PLSQL_DMLParser.additive_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLUS_SIGN662=null;
		Token MINUS_SIGN663=null;
		ParserRuleReturnScope multiply_expression661 =null;
		ParserRuleReturnScope multiply_expression664 =null;

		Object PLUS_SIGN662_tree=null;
		Object MINUS_SIGN663_tree=null;

		try {
			// PLSQL_DMLParser.g:964:5: ( multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )* )
			// PLSQL_DMLParser.g:964:10: multiply_expression ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_multiply_expression_in_additive_expression9251);
			multiply_expression661=multiply_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, multiply_expression661.getTree());

			// PLSQL_DMLParser.g:964:30: ( ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression )*
			loop224:
			while (true) {
				int alt224=2;
				int LA224_0 = input.LA(1);
				if ( (LA224_0==PLUS_SIGN) ) {
					alt224=1;
				}
				else if ( (LA224_0==MINUS_SIGN) ) {
					alt224=1;
				}

				switch (alt224) {
				case 1 :
					// PLSQL_DMLParser.g:964:32: ( PLUS_SIGN ^| MINUS_SIGN ^) multiply_expression
					{
					// PLSQL_DMLParser.g:964:32: ( PLUS_SIGN ^| MINUS_SIGN ^)
					int alt223=2;
					int LA223_0 = input.LA(1);
					if ( (LA223_0==PLUS_SIGN) ) {
						alt223=1;
					}
					else if ( (LA223_0==MINUS_SIGN) ) {
						alt223=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 223, 0, input);
						throw nvae;
					}

					switch (alt223) {
						case 1 :
							// PLSQL_DMLParser.g:964:34: PLUS_SIGN ^
							{
							PLUS_SIGN662=(Token)match(input,PLUS_SIGN,FOLLOW_PLUS_SIGN_in_additive_expression9257); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PLUS_SIGN662_tree = (Object)adaptor.create(PLUS_SIGN662);
							root_0 = (Object)adaptor.becomeRoot(PLUS_SIGN662_tree, root_0);
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:964:47: MINUS_SIGN ^
							{
							MINUS_SIGN663=(Token)match(input,MINUS_SIGN,FOLLOW_MINUS_SIGN_in_additive_expression9262); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							MINUS_SIGN663_tree = (Object)adaptor.create(MINUS_SIGN663);
							root_0 = (Object)adaptor.becomeRoot(MINUS_SIGN663_tree, root_0);
							}

							}
							break;

					}

					pushFollow(FOLLOW_multiply_expression_in_additive_expression9267);
					multiply_expression664=multiply_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, multiply_expression664.getTree());

					}
					break;

				default :
					break loop224;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "additive_expression"


	public static class multiply_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multiply_expression"
	// PLSQL_DMLParser.g:967:1: multiply_expression : datetime_expression ( ( ASTERISK ^| SOLIDUS ^| PERCENT ^) datetime_expression | ( mod_key datetime_expression )=> mod_key ^ datetime_expression | ( div_key datetime_expression )=> div_key ^ datetime_expression )* ;
	public final PLSQLParser_PLSQL_DMLParser.multiply_expression_return multiply_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multiply_expression_return retval = new PLSQLParser_PLSQL_DMLParser.multiply_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASTERISK666=null;
		Token SOLIDUS667=null;
		Token PERCENT668=null;
		ParserRuleReturnScope datetime_expression665 =null;
		ParserRuleReturnScope datetime_expression669 =null;
		ParserRuleReturnScope mod_key670 =null;
		ParserRuleReturnScope datetime_expression671 =null;
		ParserRuleReturnScope div_key672 =null;
		ParserRuleReturnScope datetime_expression673 =null;

		Object ASTERISK666_tree=null;
		Object SOLIDUS667_tree=null;
		Object PERCENT668_tree=null;

		try {
			// PLSQL_DMLParser.g:968:5: ( datetime_expression ( ( ASTERISK ^| SOLIDUS ^| PERCENT ^) datetime_expression | ( mod_key datetime_expression )=> mod_key ^ datetime_expression | ( div_key datetime_expression )=> div_key ^ datetime_expression )* )
			// PLSQL_DMLParser.g:968:10: datetime_expression ( ( ASTERISK ^| SOLIDUS ^| PERCENT ^) datetime_expression | ( mod_key datetime_expression )=> mod_key ^ datetime_expression | ( div_key datetime_expression )=> div_key ^ datetime_expression )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_datetime_expression_in_multiply_expression9289);
			datetime_expression665=datetime_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, datetime_expression665.getTree());

			// PLSQL_DMLParser.g:969:10: ( ( ASTERISK ^| SOLIDUS ^| PERCENT ^) datetime_expression | ( mod_key datetime_expression )=> mod_key ^ datetime_expression | ( div_key datetime_expression )=> div_key ^ datetime_expression )*
			loop226:
			while (true) {
				int alt226=4;
				switch ( input.LA(1) ) {
				case REGULAR_ID:
					{
					int LA226_2 = input.LA(2);
					if ( ((synpred26_PLSQL_DMLParser()&&(input.LT(1).getText().equalsIgnoreCase("mod")))) ) {
						alt226=2;
					}
					else if ( ((synpred27_PLSQL_DMLParser()&&(input.LT(1).getText().equalsIgnoreCase("div")))) ) {
						alt226=3;
					}

					}
					break;
				case ASTERISK:
					{
					alt226=1;
					}
					break;
				case SOLIDUS:
					{
					alt226=1;
					}
					break;
				case PERCENT:
					{
					alt226=1;
					}
					break;
				}
				switch (alt226) {
				case 1 :
					// PLSQL_DMLParser.g:970:13: ( ASTERISK ^| SOLIDUS ^| PERCENT ^) datetime_expression
					{
					// PLSQL_DMLParser.g:970:13: ( ASTERISK ^| SOLIDUS ^| PERCENT ^)
					int alt225=3;
					switch ( input.LA(1) ) {
					case ASTERISK:
						{
						alt225=1;
						}
						break;
					case SOLIDUS:
						{
						alt225=2;
						}
						break;
					case PERCENT:
						{
						alt225=3;
						}
						break;
					default:
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 225, 0, input);
						throw nvae;
					}
					switch (alt225) {
						case 1 :
							// PLSQL_DMLParser.g:970:15: ASTERISK ^
							{
							ASTERISK666=(Token)match(input,ASTERISK,FOLLOW_ASTERISK_in_multiply_expression9316); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							ASTERISK666_tree = (Object)adaptor.create(ASTERISK666);
							root_0 = (Object)adaptor.becomeRoot(ASTERISK666_tree, root_0);
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:970:27: SOLIDUS ^
							{
							SOLIDUS667=(Token)match(input,SOLIDUS,FOLLOW_SOLIDUS_in_multiply_expression9321); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							SOLIDUS667_tree = (Object)adaptor.create(SOLIDUS667);
							root_0 = (Object)adaptor.becomeRoot(SOLIDUS667_tree, root_0);
							}

							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:970:38: PERCENT ^
							{
							PERCENT668=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_multiply_expression9326); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERCENT668_tree = (Object)adaptor.create(PERCENT668);
							root_0 = (Object)adaptor.becomeRoot(PERCENT668_tree, root_0);
							}

							}
							break;

					}

					pushFollow(FOLLOW_datetime_expression_in_multiply_expression9331);
					datetime_expression669=datetime_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, datetime_expression669.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:971:15: ( mod_key datetime_expression )=> mod_key ^ datetime_expression
					{
					pushFollow(FOLLOW_mod_key_in_multiply_expression9355);
					mod_key670=gPLSQLParser.mod_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(mod_key670.getTree(), root_0);
					pushFollow(FOLLOW_datetime_expression_in_multiply_expression9358);
					datetime_expression671=datetime_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, datetime_expression671.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:972:15: ( div_key datetime_expression )=> div_key ^ datetime_expression
					{
					pushFollow(FOLLOW_div_key_in_multiply_expression9382);
					div_key672=gPLSQLParser.div_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(div_key672.getTree(), root_0);
					pushFollow(FOLLOW_datetime_expression_in_multiply_expression9385);
					datetime_expression673=datetime_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, datetime_expression673.getTree());

					}
					break;

				default :
					break loop226;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multiply_expression"


	public static class datetime_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "datetime_expression"
	// PLSQL_DMLParser.g:976:1: datetime_expression : ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )? ;
	public final PLSQLParser_PLSQL_DMLParser.datetime_expression_return datetime_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.datetime_expression_return retval = new PLSQLParser_PLSQL_DMLParser.datetime_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope model_expression674 =null;
		ParserRuleReturnScope at_key675 =null;
		ParserRuleReturnScope local_key676 =null;
		ParserRuleReturnScope time_key677 =null;
		ParserRuleReturnScope zone_key678 =null;
		ParserRuleReturnScope concatenation_wrapper679 =null;
		ParserRuleReturnScope interval_expression680 =null;

		RewriteRuleSubtreeStream stream_model_expression=new RewriteRuleSubtreeStream(adaptor,"rule model_expression");
		RewriteRuleSubtreeStream stream_local_key=new RewriteRuleSubtreeStream(adaptor,"rule local_key");
		RewriteRuleSubtreeStream stream_interval_expression=new RewriteRuleSubtreeStream(adaptor,"rule interval_expression");
		RewriteRuleSubtreeStream stream_at_key=new RewriteRuleSubtreeStream(adaptor,"rule at_key");
		RewriteRuleSubtreeStream stream_zone_key=new RewriteRuleSubtreeStream(adaptor,"rule zone_key");
		RewriteRuleSubtreeStream stream_concatenation_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule concatenation_wrapper");
		RewriteRuleSubtreeStream stream_time_key=new RewriteRuleSubtreeStream(adaptor,"rule time_key");

		try {
			// PLSQL_DMLParser.g:977:5: ( ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )? )
			// PLSQL_DMLParser.g:977:10: ( model_expression -> model_expression ) ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )?
			{
			// PLSQL_DMLParser.g:977:10: ( model_expression -> model_expression )
			// PLSQL_DMLParser.g:977:11: model_expression
			{
			pushFollow(FOLLOW_model_expression_in_datetime_expression9418);
			model_expression674=model_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_model_expression.add(model_expression674.getTree());
			// AST REWRITE
			// elements: model_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 977:28: -> model_expression
			{
				adaptor.addChild(root_0, stream_model_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// PLSQL_DMLParser.g:978:5: ( at_key ( local_key | time_key zone_key concatenation_wrapper ) -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) ) | ( interval_expression )=> interval_expression -> ^( DATETIME_OP $datetime_expression interval_expression ) )?
			int alt228=3;
			int LA228_0 = input.LA(1);
			if ( (LA228_0==REGULAR_ID) ) {
				int LA228_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("at"))) ) {
					alt228=1;
				}
				else if ( ((synpred28_PLSQL_DMLParser()&&((input.LT(1).getText().equalsIgnoreCase("year"))||(input.LT(1).getText().equalsIgnoreCase("day"))))) ) {
					alt228=2;
				}
			}
			switch (alt228) {
				case 1 :
					// PLSQL_DMLParser.g:978:10: at_key ( local_key | time_key zone_key concatenation_wrapper )
					{
					pushFollow(FOLLOW_at_key_in_datetime_expression9434);
					at_key675=gPLSQLParser.at_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_at_key.add(at_key675.getTree());
					// PLSQL_DMLParser.g:978:17: ( local_key | time_key zone_key concatenation_wrapper )
					int alt227=2;
					int LA227_0 = input.LA(1);
					if ( (LA227_0==REGULAR_ID) ) {
						int LA227_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("local"))) ) {
							alt227=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("time"))) ) {
							alt227=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 227, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 227, 0, input);
						throw nvae;
					}

					switch (alt227) {
						case 1 :
							// PLSQL_DMLParser.g:978:18: local_key
							{
							pushFollow(FOLLOW_local_key_in_datetime_expression9437);
							local_key676=gPLSQLParser.local_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_local_key.add(local_key676.getTree());
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:978:28: time_key zone_key concatenation_wrapper
							{
							pushFollow(FOLLOW_time_key_in_datetime_expression9439);
							time_key677=gPLSQLParser.time_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_time_key.add(time_key677.getTree());
							pushFollow(FOLLOW_zone_key_in_datetime_expression9441);
							zone_key678=gPLSQLParser.zone_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_zone_key.add(zone_key678.getTree());
							pushFollow(FOLLOW_concatenation_wrapper_in_datetime_expression9443);
							concatenation_wrapper679=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(concatenation_wrapper679.getTree());
							}
							break;

					}

					// AST REWRITE
					// elements: time_key, concatenation_wrapper, datetime_expression, local_key, at_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 979:13: -> ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) )
					{
						// PLSQL_DMLParser.g:979:16: ^( DATETIME_OP $datetime_expression ^( at_key ( local_key )? ( time_key )? concatenation_wrapper ) )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATETIME_OP, "DATETIME_OP"), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						// PLSQL_DMLParser.g:979:51: ^( at_key ( local_key )? ( time_key )? concatenation_wrapper )
						{
						Object root_2 = (Object)adaptor.nil();
						root_2 = (Object)adaptor.becomeRoot(stream_at_key.nextNode(), root_2);
						// PLSQL_DMLParser.g:979:60: ( local_key )?
						if ( stream_local_key.hasNext() ) {
							adaptor.addChild(root_2, stream_local_key.nextTree());
						}
						stream_local_key.reset();

						// PLSQL_DMLParser.g:979:71: ( time_key )?
						if ( stream_time_key.hasNext() ) {
							adaptor.addChild(root_2, stream_time_key.nextTree());
						}
						stream_time_key.reset();

						adaptor.addChild(root_2, stream_concatenation_wrapper.nextTree());
						adaptor.addChild(root_1, root_2);
						}

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:980:10: ( interval_expression )=> interval_expression
					{
					pushFollow(FOLLOW_interval_expression_in_datetime_expression9493);
					interval_expression680=interval_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_interval_expression.add(interval_expression680.getTree());
					// AST REWRITE
					// elements: interval_expression, datetime_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 981:13: -> ^( DATETIME_OP $datetime_expression interval_expression )
					{
						// PLSQL_DMLParser.g:981:16: ^( DATETIME_OP $datetime_expression interval_expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATETIME_OP, "DATETIME_OP"), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_interval_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "datetime_expression"


	public static class interval_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "interval_expression"
	// PLSQL_DMLParser.g:985:1: interval_expression : ( day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )? -> ^( day_key second_key ( $cn1)? ( $cn2)? ) | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key -> ^( year_key month_key concatenation_wrapper ) );
	public final PLSQLParser_PLSQL_DMLParser.interval_expression_return interval_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.interval_expression_return retval = new PLSQLParser_PLSQL_DMLParser.interval_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN682=null;
		Token RIGHT_PAREN683=null;
		Token LEFT_PAREN686=null;
		Token RIGHT_PAREN687=null;
		Token LEFT_PAREN689=null;
		Token RIGHT_PAREN691=null;
		ParserRuleReturnScope cn1 =null;
		ParserRuleReturnScope cn2 =null;
		ParserRuleReturnScope day_key681 =null;
		ParserRuleReturnScope to_key684 =null;
		ParserRuleReturnScope second_key685 =null;
		ParserRuleReturnScope year_key688 =null;
		ParserRuleReturnScope concatenation_wrapper690 =null;
		ParserRuleReturnScope to_key692 =null;
		ParserRuleReturnScope month_key693 =null;

		Object LEFT_PAREN682_tree=null;
		Object RIGHT_PAREN683_tree=null;
		Object LEFT_PAREN686_tree=null;
		Object RIGHT_PAREN687_tree=null;
		Object LEFT_PAREN689_tree=null;
		Object RIGHT_PAREN691_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_to_key=new RewriteRuleSubtreeStream(adaptor,"rule to_key");
		RewriteRuleSubtreeStream stream_year_key=new RewriteRuleSubtreeStream(adaptor,"rule year_key");
		RewriteRuleSubtreeStream stream_day_key=new RewriteRuleSubtreeStream(adaptor,"rule day_key");
		RewriteRuleSubtreeStream stream_month_key=new RewriteRuleSubtreeStream(adaptor,"rule month_key");
		RewriteRuleSubtreeStream stream_second_key=new RewriteRuleSubtreeStream(adaptor,"rule second_key");
		RewriteRuleSubtreeStream stream_concatenation_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule concatenation_wrapper");

		try {
			// PLSQL_DMLParser.g:986:5: ( day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )? -> ^( day_key second_key ( $cn1)? ( $cn2)? ) | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key -> ^( year_key month_key concatenation_wrapper ) )
			int alt232=2;
			int LA232_0 = input.LA(1);
			if ( (LA232_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("year"))||(input.LT(1).getText().equalsIgnoreCase("day"))))) {
				int LA232_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("day"))) ) {
					alt232=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("year"))) ) {
					alt232=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 232, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt232) {
				case 1 :
					// PLSQL_DMLParser.g:986:10: day_key ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )?
					{
					pushFollow(FOLLOW_day_key_in_interval_expression9543);
					day_key681=gPLSQLParser.day_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_day_key.add(day_key681.getTree());
					// PLSQL_DMLParser.g:986:21: ( LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN )?
					int alt229=2;
					int LA229_0 = input.LA(1);
					if ( (LA229_0==LEFT_PAREN) ) {
						alt229=1;
					}
					switch (alt229) {
						case 1 :
							// PLSQL_DMLParser.g:986:22: LEFT_PAREN cn1= concatenation_wrapper RIGHT_PAREN
							{
							LEFT_PAREN682=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_interval_expression9549); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN682);

							pushFollow(FOLLOW_concatenation_wrapper_in_interval_expression9553);
							cn1=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(cn1.getTree());
							RIGHT_PAREN683=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_interval_expression9555); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN683);

							}
							break;

					}

					pushFollow(FOLLOW_to_key_in_interval_expression9559);
					to_key684=gPLSQLParser.to_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_to_key.add(to_key684.getTree());
					pushFollow(FOLLOW_second_key_in_interval_expression9561);
					second_key685=gPLSQLParser.second_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_second_key.add(second_key685.getTree());
					// PLSQL_DMLParser.g:986:91: ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )?
					int alt230=2;
					alt230 = dfa230.predict(input);
					switch (alt230) {
						case 1 :
							// PLSQL_DMLParser.g:986:92: LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN
							{
							LEFT_PAREN686=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_interval_expression9564); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN686);

							pushFollow(FOLLOW_concatenation_wrapper_in_interval_expression9568);
							cn2=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(cn2.getTree());
							RIGHT_PAREN687=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_interval_expression9570); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN687);

							}
							break;

					}

					// AST REWRITE
					// elements: day_key, second_key, cn1, cn2
					// token labels: 
					// rule labels: cn2, cn1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_cn2=new RewriteRuleSubtreeStream(adaptor,"rule cn2",cn2!=null?cn2.getTree():null);
					RewriteRuleSubtreeStream stream_cn1=new RewriteRuleSubtreeStream(adaptor,"rule cn1",cn1!=null?cn1.getTree():null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 987:9: -> ^( day_key second_key ( $cn1)? ( $cn2)? )
					{
						// PLSQL_DMLParser.g:987:12: ^( day_key second_key ( $cn1)? ( $cn2)? )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_day_key.nextNode(), root_1);
						adaptor.addChild(root_1, stream_second_key.nextTree());
						// PLSQL_DMLParser.g:987:34: ( $cn1)?
						if ( stream_cn1.hasNext() ) {
							adaptor.addChild(root_1, stream_cn1.nextTree());
						}
						stream_cn1.reset();

						// PLSQL_DMLParser.g:987:40: ( $cn2)?
						if ( stream_cn2.hasNext() ) {
							adaptor.addChild(root_1, stream_cn2.nextTree());
						}
						stream_cn2.reset();

						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:988:10: year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key
					{
					pushFollow(FOLLOW_year_key_in_interval_expression9607);
					year_key688=gPLSQLParser.year_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_year_key.add(year_key688.getTree());
					// PLSQL_DMLParser.g:988:19: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
					int alt231=2;
					int LA231_0 = input.LA(1);
					if ( (LA231_0==LEFT_PAREN) ) {
						alt231=1;
					}
					switch (alt231) {
						case 1 :
							// PLSQL_DMLParser.g:988:20: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
							{
							LEFT_PAREN689=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_interval_expression9610); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN689);

							pushFollow(FOLLOW_concatenation_wrapper_in_interval_expression9612);
							concatenation_wrapper690=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(concatenation_wrapper690.getTree());
							RIGHT_PAREN691=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_interval_expression9614); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN691);

							}
							break;

					}

					pushFollow(FOLLOW_to_key_in_interval_expression9618);
					to_key692=gPLSQLParser.to_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_to_key.add(to_key692.getTree());
					pushFollow(FOLLOW_month_key_in_interval_expression9620);
					month_key693=gPLSQLParser.month_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_month_key.add(month_key693.getTree());
					// AST REWRITE
					// elements: month_key, concatenation_wrapper, year_key
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 989:9: -> ^( year_key month_key concatenation_wrapper )
					{
						// PLSQL_DMLParser.g:989:12: ^( year_key month_key concatenation_wrapper )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot(stream_year_key.nextNode(), root_1);
						adaptor.addChild(root_1, stream_month_key.nextTree());
						adaptor.addChild(root_1, stream_concatenation_wrapper.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "interval_expression"


	public static class model_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_expression"
	// PLSQL_DMLParser.g:992:1: model_expression : ( unary_expression -> unary_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )? ;
	public final PLSQLParser_PLSQL_DMLParser.model_expression_return model_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_expression_return retval = new PLSQLParser_PLSQL_DMLParser.model_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_BRACKET695=null;
		Token RIGHT_BRACKET697=null;
		ParserRuleReturnScope unary_expression694 =null;
		ParserRuleReturnScope model_expression_element696 =null;

		Object LEFT_BRACKET695_tree=null;
		Object RIGHT_BRACKET697_tree=null;
		RewriteRuleTokenStream stream_RIGHT_BRACKET=new RewriteRuleTokenStream(adaptor,"token RIGHT_BRACKET");
		RewriteRuleTokenStream stream_LEFT_BRACKET=new RewriteRuleTokenStream(adaptor,"token LEFT_BRACKET");
		RewriteRuleSubtreeStream stream_model_expression_element=new RewriteRuleSubtreeStream(adaptor,"rule model_expression_element");
		RewriteRuleSubtreeStream stream_unary_expression=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression");

		try {
			// PLSQL_DMLParser.g:993:5: ( ( unary_expression -> unary_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )? )
			// PLSQL_DMLParser.g:993:10: ( unary_expression -> unary_expression ) ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )?
			{
			// PLSQL_DMLParser.g:993:10: ( unary_expression -> unary_expression )
			// PLSQL_DMLParser.g:993:11: unary_expression
			{
			pushFollow(FOLLOW_unary_expression_in_model_expression9659);
			unary_expression694=unary_expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_unary_expression.add(unary_expression694.getTree());
			// AST REWRITE
			// elements: unary_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 993:28: -> unary_expression
			{
				adaptor.addChild(root_0, stream_unary_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			// PLSQL_DMLParser.g:994:9: ( LEFT_BRACKET model_expression_element RIGHT_BRACKET -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element ) )?
			int alt233=2;
			int LA233_0 = input.LA(1);
			if ( (LA233_0==LEFT_BRACKET) ) {
				alt233=1;
			}
			switch (alt233) {
				case 1 :
					// PLSQL_DMLParser.g:994:10: LEFT_BRACKET model_expression_element RIGHT_BRACKET
					{
					LEFT_BRACKET695=(Token)match(input,LEFT_BRACKET,FOLLOW_LEFT_BRACKET_in_model_expression9675); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_BRACKET.add(LEFT_BRACKET695);

					pushFollow(FOLLOW_model_expression_element_in_model_expression9677);
					model_expression_element696=model_expression_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_model_expression_element.add(model_expression_element696.getTree());
					RIGHT_BRACKET697=(Token)match(input,RIGHT_BRACKET,FOLLOW_RIGHT_BRACKET_in_model_expression9679); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_BRACKET.add(RIGHT_BRACKET697);

					// AST REWRITE
					// elements: model_expression, model_expression_element
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 995:13: -> ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element )
					{
						// PLSQL_DMLParser.g:995:16: ^( MODEL_EXPRESSION[$LEFT_BRACKET] $model_expression model_expression_element )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MODEL_EXPRESSION, LEFT_BRACKET695), root_1);
						adaptor.addChild(root_1, stream_retval.nextTree());
						adaptor.addChild(root_1, stream_model_expression_element.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_expression"


	public static class model_expression_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_expression_element"
	// PLSQL_DMLParser.g:998:1: model_expression_element : ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA ! single_column_for_loop )* | multi_column_for_loop );
	public final PLSQLParser_PLSQL_DMLParser.model_expression_element_return model_expression_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.model_expression_element_return retval = new PLSQLParser_PLSQL_DMLParser.model_expression_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA700=null;
		Token COMMA704=null;
		ParserRuleReturnScope any_key698 =null;
		ParserRuleReturnScope condition_wrapper699 =null;
		ParserRuleReturnScope any_key701 =null;
		ParserRuleReturnScope condition_wrapper702 =null;
		ParserRuleReturnScope single_column_for_loop703 =null;
		ParserRuleReturnScope single_column_for_loop705 =null;
		ParserRuleReturnScope multi_column_for_loop706 =null;

		Object COMMA700_tree=null;
		Object COMMA704_tree=null;

		try {
			// PLSQL_DMLParser.g:999:5: ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA ! single_column_for_loop )* | multi_column_for_loop )
			int alt238=3;
			int LA238_0 = input.LA(1);
			if ( (LA238_0==APPROXIMATE_NUM_LIT||LA238_0==BINDVAR||(LA238_0 >= CHAR_STRING && LA238_0 <= COLON)||LA238_0==DELIMITED_ID||LA238_0==EXACT_NUM_LIT||LA238_0==INTRODUCER||LA238_0==LEFT_PAREN||LA238_0==MINUS_SIGN||LA238_0==NATIONAL_CHAR_STRING_LIT||LA238_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA238_0==PLUS_SIGN||LA238_0==REGULAR_ID||LA238_0==SQL92_RESERVED_ALL||LA238_0==SQL92_RESERVED_ANY||LA238_0==SQL92_RESERVED_CASE||(LA238_0 >= SQL92_RESERVED_CURSOR && LA238_0 <= SQL92_RESERVED_DATE)||(LA238_0 >= SQL92_RESERVED_DEFAULT && LA238_0 <= SQL92_RESERVED_DELETE)||LA238_0==SQL92_RESERVED_DISTINCT||(LA238_0 >= SQL92_RESERVED_EXISTS && LA238_0 <= SQL92_RESERVED_FALSE)||(LA238_0 >= SQL92_RESERVED_NOT && LA238_0 <= SQL92_RESERVED_NULL)||LA238_0==SQL92_RESERVED_PRIOR||LA238_0==SQL92_RESERVED_TRUE||LA238_0==UNSIGNED_INTEGER) ) {
				alt238=1;
			}
			else if ( (LA238_0==SQL92_RESERVED_FOR) ) {
				int LA238_2 = input.LA(2);
				if ( (LA238_2==DELIMITED_ID||LA238_2==INTRODUCER||LA238_2==REGULAR_ID) ) {
					alt238=2;
				}
				else if ( (LA238_2==LEFT_PAREN) ) {
					alt238=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 238, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 238, 0, input);
				throw nvae;
			}

			switch (alt238) {
				case 1 :
					// PLSQL_DMLParser.g:999:10: ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )*
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:999:10: ( ( any_key )=> any_key | condition_wrapper )
					int alt234=2;
					int LA234_0 = input.LA(1);
					if ( (LA234_0==SQL92_RESERVED_ANY) ) {
						int LA234_1 = input.LA(2);
						if ( (LA234_1==COMMA) && (synpred29_PLSQL_DMLParser())) {
							alt234=1;
						}
						else if ( (LA234_1==RIGHT_BRACKET) && (synpred29_PLSQL_DMLParser())) {
							alt234=1;
						}
						else if ( (LA234_1==LEFT_PAREN) ) {
							alt234=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 234, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}
					else if ( (LA234_0==APPROXIMATE_NUM_LIT||LA234_0==BINDVAR||(LA234_0 >= CHAR_STRING && LA234_0 <= COLON)||LA234_0==DELIMITED_ID||LA234_0==EXACT_NUM_LIT||LA234_0==INTRODUCER||LA234_0==LEFT_PAREN||LA234_0==MINUS_SIGN||LA234_0==NATIONAL_CHAR_STRING_LIT||LA234_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA234_0==PLUS_SIGN||LA234_0==REGULAR_ID||LA234_0==SQL92_RESERVED_ALL||LA234_0==SQL92_RESERVED_CASE||(LA234_0 >= SQL92_RESERVED_CURSOR && LA234_0 <= SQL92_RESERVED_DATE)||(LA234_0 >= SQL92_RESERVED_DEFAULT && LA234_0 <= SQL92_RESERVED_DELETE)||LA234_0==SQL92_RESERVED_DISTINCT||(LA234_0 >= SQL92_RESERVED_EXISTS && LA234_0 <= SQL92_RESERVED_FALSE)||(LA234_0 >= SQL92_RESERVED_NOT && LA234_0 <= SQL92_RESERVED_NULL)||LA234_0==SQL92_RESERVED_PRIOR||LA234_0==SQL92_RESERVED_TRUE||LA234_0==UNSIGNED_INTEGER) ) {
						alt234=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 234, 0, input);
						throw nvae;
					}

					switch (alt234) {
						case 1 :
							// PLSQL_DMLParser.g:999:11: ( any_key )=> any_key
							{
							pushFollow(FOLLOW_any_key_in_model_expression_element9731);
							any_key698=gPLSQLParser.any_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, any_key698.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:999:31: condition_wrapper
							{
							pushFollow(FOLLOW_condition_wrapper_in_model_expression_element9733);
							condition_wrapper699=condition_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, condition_wrapper699.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:999:50: ( COMMA ! ( ( any_key )=> any_key | condition_wrapper ) )*
					loop236:
					while (true) {
						int alt236=2;
						int LA236_0 = input.LA(1);
						if ( (LA236_0==COMMA) ) {
							alt236=1;
						}

						switch (alt236) {
						case 1 :
							// PLSQL_DMLParser.g:999:51: COMMA ! ( ( any_key )=> any_key | condition_wrapper )
							{
							COMMA700=(Token)match(input,COMMA,FOLLOW_COMMA_in_model_expression_element9737); if (state.failed) return retval;
							// PLSQL_DMLParser.g:999:58: ( ( any_key )=> any_key | condition_wrapper )
							int alt235=2;
							int LA235_0 = input.LA(1);
							if ( (LA235_0==SQL92_RESERVED_ANY) ) {
								int LA235_1 = input.LA(2);
								if ( (LA235_1==RIGHT_BRACKET) && (synpred30_PLSQL_DMLParser())) {
									alt235=1;
								}
								else if ( (LA235_1==COMMA) && (synpred30_PLSQL_DMLParser())) {
									alt235=1;
								}
								else if ( (LA235_1==LEFT_PAREN) ) {
									alt235=2;
								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										input.consume();
										NoViableAltException nvae =
											new NoViableAltException("", 235, 1, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}
							else if ( (LA235_0==APPROXIMATE_NUM_LIT||LA235_0==BINDVAR||(LA235_0 >= CHAR_STRING && LA235_0 <= COLON)||LA235_0==DELIMITED_ID||LA235_0==EXACT_NUM_LIT||LA235_0==INTRODUCER||LA235_0==LEFT_PAREN||LA235_0==MINUS_SIGN||LA235_0==NATIONAL_CHAR_STRING_LIT||LA235_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA235_0==PLUS_SIGN||LA235_0==REGULAR_ID||LA235_0==SQL92_RESERVED_ALL||LA235_0==SQL92_RESERVED_CASE||(LA235_0 >= SQL92_RESERVED_CURSOR && LA235_0 <= SQL92_RESERVED_DATE)||(LA235_0 >= SQL92_RESERVED_DEFAULT && LA235_0 <= SQL92_RESERVED_DELETE)||LA235_0==SQL92_RESERVED_DISTINCT||(LA235_0 >= SQL92_RESERVED_EXISTS && LA235_0 <= SQL92_RESERVED_FALSE)||(LA235_0 >= SQL92_RESERVED_NOT && LA235_0 <= SQL92_RESERVED_NULL)||LA235_0==SQL92_RESERVED_PRIOR||LA235_0==SQL92_RESERVED_TRUE||LA235_0==UNSIGNED_INTEGER) ) {
								alt235=2;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae =
									new NoViableAltException("", 235, 0, input);
								throw nvae;
							}

							switch (alt235) {
								case 1 :
									// PLSQL_DMLParser.g:999:59: ( any_key )=> any_key
									{
									pushFollow(FOLLOW_any_key_in_model_expression_element9746);
									any_key701=gPLSQLParser.any_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, any_key701.getTree());

									}
									break;
								case 2 :
									// PLSQL_DMLParser.g:999:79: condition_wrapper
									{
									pushFollow(FOLLOW_condition_wrapper_in_model_expression_element9748);
									condition_wrapper702=condition_wrapper();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, condition_wrapper702.getTree());

									}
									break;

							}

							}
							break;

						default :
							break loop236;
						}
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1000:10: single_column_for_loop ( COMMA ! single_column_for_loop )*
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_single_column_for_loop_in_model_expression_element9762);
					single_column_for_loop703=single_column_for_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, single_column_for_loop703.getTree());

					// PLSQL_DMLParser.g:1000:33: ( COMMA ! single_column_for_loop )*
					loop237:
					while (true) {
						int alt237=2;
						int LA237_0 = input.LA(1);
						if ( (LA237_0==COMMA) ) {
							alt237=1;
						}

						switch (alt237) {
						case 1 :
							// PLSQL_DMLParser.g:1000:34: COMMA ! single_column_for_loop
							{
							COMMA704=(Token)match(input,COMMA,FOLLOW_COMMA_in_model_expression_element9765); if (state.failed) return retval;
							pushFollow(FOLLOW_single_column_for_loop_in_model_expression_element9768);
							single_column_for_loop705=single_column_for_loop();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, single_column_for_loop705.getTree());

							}
							break;

						default :
							break loop237;
						}
					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1001:10: multi_column_for_loop
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_multi_column_for_loop_in_model_expression_element9781);
					multi_column_for_loop706=multi_column_for_loop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, multi_column_for_loop706.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_expression_element"


	public static class single_column_for_loop_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "single_column_for_loop"
	// PLSQL_DMLParser.g:1004:1: single_column_for_loop : for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) ) -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.single_column_for_loop_return single_column_for_loop() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.single_column_for_loop_return retval = new PLSQLParser_PLSQL_DMLParser.single_column_for_loop_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope ex1 =null;
		ParserRuleReturnScope ex2 =null;
		ParserRuleReturnScope ex3 =null;
		ParserRuleReturnScope for_key707 =null;
		ParserRuleReturnScope column_name708 =null;
		ParserRuleReturnScope in_key709 =null;
		ParserRuleReturnScope expression_list710 =null;
		ParserRuleReturnScope for_like_part711 =null;
		ParserRuleReturnScope from_key712 =null;
		ParserRuleReturnScope to_key713 =null;
		ParserRuleReturnScope for_increment_decrement_type714 =null;

		RewriteRuleSubtreeStream stream_to_key=new RewriteRuleSubtreeStream(adaptor,"rule to_key");
		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_for_like_part=new RewriteRuleSubtreeStream(adaptor,"rule for_like_part");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_expression_list=new RewriteRuleSubtreeStream(adaptor,"rule expression_list");
		RewriteRuleSubtreeStream stream_from_key=new RewriteRuleSubtreeStream(adaptor,"rule from_key");
		RewriteRuleSubtreeStream stream_for_increment_decrement_type=new RewriteRuleSubtreeStream(adaptor,"rule for_increment_decrement_type");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:1006:5: ( for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) ) -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? ) )
			// PLSQL_DMLParser.g:1006:10: for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
			{
			pushFollow(FOLLOW_for_key_in_single_column_for_loop9809);
			for_key707=gPLSQLParser.for_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_for_key.add(for_key707.getTree());
			pushFollow(FOLLOW_column_name_in_single_column_for_loop9811);
			column_name708=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_column_name.add(column_name708.getTree());
			// PLSQL_DMLParser.g:1007:5: ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
			int alt240=2;
			int LA240_0 = input.LA(1);
			if ( (LA240_0==SQL92_RESERVED_IN) ) {
				alt240=1;
			}
			else if ( (LA240_0==SQL92_RESERVED_FROM||LA240_0==SQL92_RESERVED_LIKE) ) {
				alt240=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 240, 0, input);
				throw nvae;
			}

			switch (alt240) {
				case 1 :
					// PLSQL_DMLParser.g:1007:10: in_key expression_list
					{
					pushFollow(FOLLOW_in_key_in_single_column_for_loop9823);
					in_key709=gPLSQLParser.in_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_in_key.add(in_key709.getTree());
					pushFollow(FOLLOW_expression_list_in_single_column_for_loop9825);
					expression_list710=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_list.add(expression_list710.getTree());
					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1008:10: ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression
					{
					// PLSQL_DMLParser.g:1008:10: ( for_like_part )?
					int alt239=2;
					int LA239_0 = input.LA(1);
					if ( (LA239_0==SQL92_RESERVED_LIKE) ) {
						alt239=1;
					}
					switch (alt239) {
						case 1 :
							// PLSQL_DMLParser.g:1008:10: for_like_part
							{
							pushFollow(FOLLOW_for_like_part_in_single_column_for_loop9838);
							for_like_part711=for_like_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_for_like_part.add(for_like_part711.getTree());
							}
							break;

					}

					pushFollow(FOLLOW_from_key_in_single_column_for_loop9841);
					from_key712=gPLSQLParser.from_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_from_key.add(from_key712.getTree());
					pushFollow(FOLLOW_expression_in_single_column_for_loop9845);
					ex1=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(ex1.getTree());
					pushFollow(FOLLOW_to_key_in_single_column_for_loop9859);
					to_key713=gPLSQLParser.to_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_to_key.add(to_key713.getTree());
					pushFollow(FOLLOW_expression_in_single_column_for_loop9863);
					ex2=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(ex2.getTree());
					pushFollow(FOLLOW_for_increment_decrement_type_in_single_column_for_loop9865);
					for_increment_decrement_type714=for_increment_decrement_type();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_for_increment_decrement_type.add(for_increment_decrement_type714.getTree());
					pushFollow(FOLLOW_expression_in_single_column_for_loop9869);
					ex3=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(ex3.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: ex1, for_increment_decrement_type, expression_list, for_like_part, in_key, to_key, ex3, column_name, from_key, ex2, column_name
			// token labels: 
			// rule labels: ex3, ex2, retval, ex1
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_ex3=new RewriteRuleSubtreeStream(adaptor,"rule ex3",ex3!=null?ex3.getTree():null);
			RewriteRuleSubtreeStream stream_ex2=new RewriteRuleSubtreeStream(adaptor,"rule ex2",ex2!=null?ex2.getTree():null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);
			RewriteRuleSubtreeStream stream_ex1=new RewriteRuleSubtreeStream(adaptor,"rule ex1",ex1!=null?ex1.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1011:9: -> {mode == 1}? ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) )
			if (mode == 1) {
				// PLSQL_DMLParser.g:1011:24: ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( in_key expression_list ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_SINGLE_COLUMN, (for_key707!=null?(for_key707.start):null)), root_1);
				adaptor.addChild(root_1, stream_column_name.nextTree());
				// PLSQL_DMLParser.g:1011:72: ^( in_key expression_list )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_2);
				adaptor.addChild(root_2, stream_expression_list.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1012:9: -> ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? )
			{
				// PLSQL_DMLParser.g:1012:12: ^( FOR_SINGLE_COLUMN[$for_key.start] column_name ^( from_key ^( EXPR $ex1) ) ^( to_key ^( EXPR $ex2) ) ^( for_increment_decrement_type ^( EXPR $ex3) ) ( for_like_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_SINGLE_COLUMN, (for_key707!=null?(for_key707.start):null)), root_1);
				adaptor.addChild(root_1, stream_column_name.nextTree());
				// PLSQL_DMLParser.g:1012:60: ^( from_key ^( EXPR $ex1) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_from_key.nextNode(), root_2);
				// PLSQL_DMLParser.g:1012:71: ^( EXPR $ex1)
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_3);
				adaptor.addChild(root_3, stream_ex1.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:1012:85: ^( to_key ^( EXPR $ex2) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_to_key.nextNode(), root_2);
				// PLSQL_DMLParser.g:1012:94: ^( EXPR $ex2)
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_3);
				adaptor.addChild(root_3, stream_ex2.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:1012:108: ^( for_increment_decrement_type ^( EXPR $ex3) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_for_increment_decrement_type.nextNode(), root_2);
				// PLSQL_DMLParser.g:1012:139: ^( EXPR $ex3)
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_3);
				adaptor.addChild(root_3, stream_ex3.nextTree());
				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:1012:153: ( for_like_part )?
				if ( stream_for_like_part.hasNext() ) {
					adaptor.addChild(root_1, stream_for_like_part.nextTree());
				}
				stream_for_like_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "single_column_for_loop"


	public static class for_like_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_like_part"
	// PLSQL_DMLParser.g:1015:1: for_like_part : like_key expression -> ^( like_key ^( EXPR expression ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.for_like_part_return for_like_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.for_like_part_return retval = new PLSQLParser_PLSQL_DMLParser.for_like_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope like_key715 =null;
		ParserRuleReturnScope expression716 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_like_key=new RewriteRuleSubtreeStream(adaptor,"rule like_key");

		try {
			// PLSQL_DMLParser.g:1016:5: ( like_key expression -> ^( like_key ^( EXPR expression ) ) )
			// PLSQL_DMLParser.g:1016:10: like_key expression
			{
			pushFollow(FOLLOW_like_key_in_for_like_part9978);
			like_key715=gPLSQLParser.like_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_like_key.add(like_key715.getTree());
			pushFollow(FOLLOW_expression_in_for_like_part9980);
			expression716=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression716.getTree());
			// AST REWRITE
			// elements: expression, like_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1017:9: -> ^( like_key ^( EXPR expression ) )
			{
				// PLSQL_DMLParser.g:1017:12: ^( like_key ^( EXPR expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_like_key.nextNode(), root_1);
				// PLSQL_DMLParser.g:1017:23: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_like_part"


	public static class for_increment_decrement_type_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_increment_decrement_type"
	// PLSQL_DMLParser.g:1020:1: for_increment_decrement_type : ( increment_key | decrement_key );
	public final PLSQLParser_PLSQL_DMLParser.for_increment_decrement_type_return for_increment_decrement_type() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.for_increment_decrement_type_return retval = new PLSQLParser_PLSQL_DMLParser.for_increment_decrement_type_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope increment_key717 =null;
		ParserRuleReturnScope decrement_key718 =null;


		try {
			// PLSQL_DMLParser.g:1021:5: ( increment_key | decrement_key )
			int alt241=2;
			int LA241_0 = input.LA(1);
			if ( (LA241_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("increment"))||(input.LT(1).getText().equalsIgnoreCase("decrement"))))) {
				int LA241_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("increment"))) ) {
					alt241=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("decrement"))) ) {
					alt241=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 241, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt241) {
				case 1 :
					// PLSQL_DMLParser.g:1021:10: increment_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_increment_key_in_for_increment_decrement_type10020);
					increment_key717=gPLSQLParser.increment_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, increment_key717.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1022:10: decrement_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_decrement_key_in_for_increment_decrement_type10031);
					decrement_key718=gPLSQLParser.decrement_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, decrement_key718.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_increment_decrement_type"


	public static class multi_column_for_loop_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multi_column_for_loop"
	// PLSQL_DMLParser.g:1025:1: multi_column_for_loop : for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.multi_column_for_loop_return multi_column_for_loop() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.multi_column_for_loop_return retval = new PLSQLParser_PLSQL_DMLParser.multi_column_for_loop_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN720=null;
		Token COMMA722=null;
		Token RIGHT_PAREN724=null;
		Token LEFT_PAREN726=null;
		Token LEFT_PAREN728=null;
		Token COMMA730=null;
		Token RIGHT_PAREN732=null;
		Token RIGHT_PAREN733=null;
		ParserRuleReturnScope for_key719 =null;
		ParserRuleReturnScope column_name721 =null;
		ParserRuleReturnScope column_name723 =null;
		ParserRuleReturnScope in_key725 =null;
		ParserRuleReturnScope subquery727 =null;
		ParserRuleReturnScope expression_list729 =null;
		ParserRuleReturnScope expression_list731 =null;

		Object LEFT_PAREN720_tree=null;
		Object COMMA722_tree=null;
		Object RIGHT_PAREN724_tree=null;
		Object LEFT_PAREN726_tree=null;
		Object LEFT_PAREN728_tree=null;
		Object COMMA730_tree=null;
		Object RIGHT_PAREN732_tree=null;
		Object RIGHT_PAREN733_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_subquery=new RewriteRuleSubtreeStream(adaptor,"rule subquery");
		RewriteRuleSubtreeStream stream_column_name=new RewriteRuleSubtreeStream(adaptor,"rule column_name");
		RewriteRuleSubtreeStream stream_expression_list=new RewriteRuleSubtreeStream(adaptor,"rule expression_list");

		try {
			// PLSQL_DMLParser.g:1026:5: ( for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) ) )
			// PLSQL_DMLParser.g:1026:10: for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN
			{
			pushFollow(FOLLOW_for_key_in_multi_column_for_loop10051);
			for_key719=gPLSQLParser.for_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_for_key.add(for_key719.getTree());
			LEFT_PAREN720=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_multi_column_for_loop10053); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN720);

			pushFollow(FOLLOW_column_name_in_multi_column_for_loop10055);
			column_name721=gPLSQLParser.column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_column_name.add(column_name721.getTree());
			// PLSQL_DMLParser.g:1026:41: ( COMMA column_name )*
			loop242:
			while (true) {
				int alt242=2;
				int LA242_0 = input.LA(1);
				if ( (LA242_0==COMMA) ) {
					alt242=1;
				}

				switch (alt242) {
				case 1 :
					// PLSQL_DMLParser.g:1026:42: COMMA column_name
					{
					COMMA722=(Token)match(input,COMMA,FOLLOW_COMMA_in_multi_column_for_loop10058); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA722);

					pushFollow(FOLLOW_column_name_in_multi_column_for_loop10060);
					column_name723=gPLSQLParser.column_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_name.add(column_name723.getTree());
					}
					break;

				default :
					break loop242;
				}
			}

			RIGHT_PAREN724=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10064); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN724);

			pushFollow(FOLLOW_in_key_in_multi_column_for_loop10066);
			in_key725=gPLSQLParser.in_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_in_key.add(in_key725.getTree());
			LEFT_PAREN726=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_multi_column_for_loop10076); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN726);

			// PLSQL_DMLParser.g:1028:13: ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN )
			int alt244=2;
			int LA244_0 = input.LA(1);
			if ( (LA244_0==SQL92_RESERVED_SELECT) && (synpred31_PLSQL_DMLParser())) {
				alt244=1;
			}
			else if ( (LA244_0==LEFT_PAREN) ) {
				int LA244_2 = input.LA(2);
				if ( (synpred31_PLSQL_DMLParser()) ) {
					alt244=1;
				}
				else if ( (synpred32_PLSQL_DMLParser()) ) {
					alt244=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 244, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 244, 0, input);
				throw nvae;
			}

			switch (alt244) {
				case 1 :
					// PLSQL_DMLParser.g:1028:18: ( select_key )=> subquery
					{
					pushFollow(FOLLOW_subquery_in_multi_column_for_loop10100);
					subquery727=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_subquery.add(subquery727.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1029:18: ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN
					{
					LEFT_PAREN728=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_multi_column_for_loop10124); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN728);

					pushFollow(FOLLOW_expression_list_in_multi_column_for_loop10126);
					expression_list729=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression_list.add(expression_list729.getTree());
					// PLSQL_DMLParser.g:1029:60: ( COMMA expression_list )*
					loop243:
					while (true) {
						int alt243=2;
						int LA243_0 = input.LA(1);
						if ( (LA243_0==COMMA) ) {
							alt243=1;
						}

						switch (alt243) {
						case 1 :
							// PLSQL_DMLParser.g:1029:61: COMMA expression_list
							{
							COMMA730=(Token)match(input,COMMA,FOLLOW_COMMA_in_multi_column_for_loop10129); if (state.failed) return retval; 
							if ( state.backtracking==0 ) stream_COMMA.add(COMMA730);

							pushFollow(FOLLOW_expression_list_in_multi_column_for_loop10131);
							expression_list731=expression_list();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_expression_list.add(expression_list731.getTree());
							}
							break;

						default :
							break loop243;
						}
					}

					RIGHT_PAREN732=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10135); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN732);

					}
					break;

			}

			RIGHT_PAREN733=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10159); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN733);

			// AST REWRITE
			// elements: in_key, expression_list, subquery, column_name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1032:9: -> ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) )
			{
				// PLSQL_DMLParser.g:1032:12: ^( FOR_MULTI_COLUMN[$for_key.start] ( column_name )+ ^( in_key ( subquery )? ( expression_list )* ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_MULTI_COLUMN, (for_key719!=null?(for_key719.start):null)), root_1);
				if ( !(stream_column_name.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_column_name.hasNext() ) {
					adaptor.addChild(root_1, stream_column_name.nextTree());
				}
				stream_column_name.reset();

				// PLSQL_DMLParser.g:1032:60: ^( in_key ( subquery )? ( expression_list )* )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_in_key.nextNode(), root_2);
				// PLSQL_DMLParser.g:1032:69: ( subquery )?
				if ( stream_subquery.hasNext() ) {
					adaptor.addChild(root_2, stream_subquery.nextTree());
				}
				stream_subquery.reset();

				// PLSQL_DMLParser.g:1032:79: ( expression_list )*
				while ( stream_expression_list.hasNext() ) {
					adaptor.addChild(root_2, stream_expression_list.nextTree());
				}
				stream_expression_list.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multi_column_for_loop"


	public static class unary_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unary_expression"
	// PLSQL_DMLParser.g:1035:1: unary_expression options {backtrack=true; } : ( MINUS_SIGN unary_expression -> ^( UNARY_MINUS[$MINUS_SIGN] unary_expression ) | PLUS_SIGN unary_expression -> ^( UNARY_PLUS[$PLUS_SIGN] unary_expression ) | prior_key ^ unary_expression | connect_by_root_key ^ unary_expression |{...}? => new_key ^ unary_expression | distinct_key ^ unary_expression | all_key ^ unary_expression |{...}? case_statement[false] | quantified_expression | cursor_name ( percent_notfound_key ^| percent_found_key ^| percent_isopen_key ^| percent_rowcount_key ^) | atom );
	public final PLSQLParser_PLSQL_DMLParser.unary_expression_return unary_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.unary_expression_return retval = new PLSQLParser_PLSQL_DMLParser.unary_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token MINUS_SIGN734=null;
		Token PLUS_SIGN736=null;
		ParserRuleReturnScope unary_expression735 =null;
		ParserRuleReturnScope unary_expression737 =null;
		ParserRuleReturnScope prior_key738 =null;
		ParserRuleReturnScope unary_expression739 =null;
		ParserRuleReturnScope connect_by_root_key740 =null;
		ParserRuleReturnScope unary_expression741 =null;
		ParserRuleReturnScope new_key742 =null;
		ParserRuleReturnScope unary_expression743 =null;
		ParserRuleReturnScope distinct_key744 =null;
		ParserRuleReturnScope unary_expression745 =null;
		ParserRuleReturnScope all_key746 =null;
		ParserRuleReturnScope unary_expression747 =null;
		ParserRuleReturnScope case_statement748 =null;
		ParserRuleReturnScope quantified_expression749 =null;
		ParserRuleReturnScope cursor_name750 =null;
		ParserRuleReturnScope percent_notfound_key751 =null;
		ParserRuleReturnScope percent_found_key752 =null;
		ParserRuleReturnScope percent_isopen_key753 =null;
		ParserRuleReturnScope percent_rowcount_key754 =null;
		ParserRuleReturnScope atom755 =null;

		Object MINUS_SIGN734_tree=null;
		Object PLUS_SIGN736_tree=null;
		RewriteRuleTokenStream stream_PLUS_SIGN=new RewriteRuleTokenStream(adaptor,"token PLUS_SIGN");
		RewriteRuleTokenStream stream_MINUS_SIGN=new RewriteRuleTokenStream(adaptor,"token MINUS_SIGN");
		RewriteRuleSubtreeStream stream_unary_expression=new RewriteRuleSubtreeStream(adaptor,"rule unary_expression");

		try {
			// PLSQL_DMLParser.g:1040:5: ( MINUS_SIGN unary_expression -> ^( UNARY_MINUS[$MINUS_SIGN] unary_expression ) | PLUS_SIGN unary_expression -> ^( UNARY_PLUS[$PLUS_SIGN] unary_expression ) | prior_key ^ unary_expression | connect_by_root_key ^ unary_expression |{...}? => new_key ^ unary_expression | distinct_key ^ unary_expression | all_key ^ unary_expression |{...}? case_statement[false] | quantified_expression | cursor_name ( percent_notfound_key ^| percent_found_key ^| percent_isopen_key ^| percent_rowcount_key ^) | atom )
			int alt246=11;
			switch ( input.LA(1) ) {
			case MINUS_SIGN:
				{
				int LA246_1 = input.LA(2);
				if ( (synpred33_PLSQL_DMLParser()) ) {
					alt246=1;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case PLUS_SIGN:
				{
				alt246=2;
				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA246_3 = input.LA(2);
				if ( (synpred35_PLSQL_DMLParser()) ) {
					alt246=3;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
				{
				alt246=4;
				}
				break;
			case REGULAR_ID:
				{
				int LA246_5 = input.LA(2);
				if ( ((((input.LT(1).getText().equalsIgnoreCase("new"))&&synpred37_PLSQL_DMLParser())&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))) ) {
					alt246=5;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("some"))&&synpred41_PLSQL_DMLParser())) ) {
					alt246=9;
				}
				else if ( (synpred42_PLSQL_DMLParser()) ) {
					alt246=10;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case SQL92_RESERVED_DISTINCT:
				{
				alt246=6;
				}
				break;
			case SQL92_RESERVED_ALL:
				{
				int LA246_7 = input.LA(2);
				if ( (synpred39_PLSQL_DMLParser()) ) {
					alt246=7;
				}
				else if ( (synpred41_PLSQL_DMLParser()) ) {
					alt246=9;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 246, 7, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case SQL92_RESERVED_CASE:
				{
				alt246=8;
				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA246_9 = input.LA(2);
				if ( (synpred41_PLSQL_DMLParser()) ) {
					alt246=9;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case SQL92_RESERVED_ANY:
				{
				alt246=9;
				}
				break;
			case INTRODUCER:
				{
				int LA246_11 = input.LA(2);
				if ( (synpred42_PLSQL_DMLParser()) ) {
					alt246=10;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA246_12 = input.LA(2);
				if ( (synpred42_PLSQL_DMLParser()) ) {
					alt246=10;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case BINDVAR:
				{
				int LA246_13 = input.LA(2);
				if ( (synpred42_PLSQL_DMLParser()) ) {
					alt246=10;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case COLON:
				{
				int LA246_14 = input.LA(2);
				if ( (synpred42_PLSQL_DMLParser()) ) {
					alt246=10;
				}
				else if ( (true) ) {
					alt246=11;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case LEFT_PAREN:
			case NATIONAL_CHAR_STRING_LIT:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DELETE:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt246=11;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 246, 0, input);
				throw nvae;
			}
			switch (alt246) {
				case 1 :
					// PLSQL_DMLParser.g:1040:10: MINUS_SIGN unary_expression
					{
					MINUS_SIGN734=(Token)match(input,MINUS_SIGN,FOLLOW_MINUS_SIGN_in_unary_expression10216); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_MINUS_SIGN.add(MINUS_SIGN734);

					pushFollow(FOLLOW_unary_expression_in_unary_expression10218);
					unary_expression735=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unary_expression.add(unary_expression735.getTree());
					// AST REWRITE
					// elements: unary_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 1040:38: -> ^( UNARY_MINUS[$MINUS_SIGN] unary_expression )
					{
						// PLSQL_DMLParser.g:1040:41: ^( UNARY_MINUS[$MINUS_SIGN] unary_expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNARY_MINUS, MINUS_SIGN734), root_1);
						adaptor.addChild(root_1, stream_unary_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1041:10: PLUS_SIGN unary_expression
					{
					PLUS_SIGN736=(Token)match(input,PLUS_SIGN,FOLLOW_PLUS_SIGN_in_unary_expression10238); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_PLUS_SIGN.add(PLUS_SIGN736);

					pushFollow(FOLLOW_unary_expression_in_unary_expression10240);
					unary_expression737=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_unary_expression.add(unary_expression737.getTree());
					// AST REWRITE
					// elements: unary_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 1041:37: -> ^( UNARY_PLUS[$PLUS_SIGN] unary_expression )
					{
						// PLSQL_DMLParser.g:1041:40: ^( UNARY_PLUS[$PLUS_SIGN] unary_expression )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNARY_PLUS, PLUS_SIGN736), root_1);
						adaptor.addChild(root_1, stream_unary_expression.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1042:10: prior_key ^ unary_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_prior_key_in_unary_expression10260);
					prior_key738=gPLSQLParser.prior_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(prior_key738.getTree(), root_0);
					pushFollow(FOLLOW_unary_expression_in_unary_expression10263);
					unary_expression739=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression739.getTree());

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:1043:10: connect_by_root_key ^ unary_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_connect_by_root_key_in_unary_expression10274);
					connect_by_root_key740=gPLSQLParser.connect_by_root_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(connect_by_root_key740.getTree(), root_0);
					pushFollow(FOLLOW_unary_expression_in_unary_expression10277);
					unary_expression741=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression741.getTree());

					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:1044:10: {...}? => new_key ^ unary_expression
					{
					root_0 = (Object)adaptor.nil();


					if ( !((input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "unary_expression", "input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")");
					}
					pushFollow(FOLLOW_new_key_in_unary_expression10291);
					new_key742=gPLSQLParser.new_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(new_key742.getTree(), root_0);
					pushFollow(FOLLOW_unary_expression_in_unary_expression10294);
					unary_expression743=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression743.getTree());

					}
					break;
				case 6 :
					// PLSQL_DMLParser.g:1045:10: distinct_key ^ unary_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_distinct_key_in_unary_expression10305);
					distinct_key744=gPLSQLParser.distinct_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(distinct_key744.getTree(), root_0);
					pushFollow(FOLLOW_unary_expression_in_unary_expression10308);
					unary_expression745=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression745.getTree());

					}
					break;
				case 7 :
					// PLSQL_DMLParser.g:1046:10: all_key ^ unary_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_all_key_in_unary_expression10319);
					all_key746=gPLSQLParser.all_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(all_key746.getTree(), root_0);
					pushFollow(FOLLOW_unary_expression_in_unary_expression10322);
					unary_expression747=unary_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, unary_expression747.getTree());

					}
					break;
				case 8 :
					// PLSQL_DMLParser.g:1047:10: {...}? case_statement[false]
					{
					root_0 = (Object)adaptor.nil();


					if ( !(((input.LA(1) == SQL92_RESERVED_CASE || input.LA(2) == SQL92_RESERVED_CASE))) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "unary_expression", "(input.LA(1) == SQL92_RESERVED_CASE || input.LA(2) == SQL92_RESERVED_CASE)");
					}
					pushFollow(FOLLOW_case_statement_in_unary_expression10335);
					case_statement748=case_statement(false);
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, case_statement748.getTree());

					}
					break;
				case 9 :
					// PLSQL_DMLParser.g:1048:10: quantified_expression
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_quantified_expression_in_unary_expression10347);
					quantified_expression749=quantified_expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, quantified_expression749.getTree());

					}
					break;
				case 10 :
					// PLSQL_DMLParser.g:1049:10: cursor_name ( percent_notfound_key ^| percent_found_key ^| percent_isopen_key ^| percent_rowcount_key ^)
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_cursor_name_in_unary_expression10358);
					cursor_name750=gPLSQLParser.cursor_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, cursor_name750.getTree());

					// PLSQL_DMLParser.g:1049:22: ( percent_notfound_key ^| percent_found_key ^| percent_isopen_key ^| percent_rowcount_key ^)
					int alt245=4;
					int LA245_0 = input.LA(1);
					if ( (LA245_0==PERCENT) && (((input.LT(2).getText().equalsIgnoreCase("found"))||(input.LT(2).getText().equalsIgnoreCase("isopen"))||(input.LT(2).getText().equalsIgnoreCase("notfound"))||(input.LT(2).getText().equalsIgnoreCase("rowcount"))))) {
						int LA245_1 = input.LA(2);
						if ( (LA245_1==REGULAR_ID) && (((input.LT(2).getText().equalsIgnoreCase("found"))||(input.LT(2).getText().equalsIgnoreCase("isopen"))||(input.LT(2).getText().equalsIgnoreCase("notfound"))||(input.LT(2).getText().equalsIgnoreCase("rowcount"))))) {
							int LA245_2 = input.LA(3);
							if ( ((input.LT(2).getText().equalsIgnoreCase("notfound"))) ) {
								alt245=1;
							}
							else if ( ((input.LT(2).getText().equalsIgnoreCase("found"))) ) {
								alt245=2;
							}
							else if ( ((input.LT(2).getText().equalsIgnoreCase("isopen"))) ) {
								alt245=3;
							}
							else if ( ((input.LT(2).getText().equalsIgnoreCase("rowcount"))) ) {
								alt245=4;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								int nvaeMark = input.mark();
								try {
									for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
										input.consume();
									}
									NoViableAltException nvae =
										new NoViableAltException("", 245, 2, input);
									throw nvae;
								} finally {
									input.rewind(nvaeMark);
								}
							}

						}

					}

					switch (alt245) {
						case 1 :
							// PLSQL_DMLParser.g:1049:23: percent_notfound_key ^
							{
							pushFollow(FOLLOW_percent_notfound_key_in_unary_expression10361);
							percent_notfound_key751=gPLSQLParser.percent_notfound_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(percent_notfound_key751.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1049:45: percent_found_key ^
							{
							pushFollow(FOLLOW_percent_found_key_in_unary_expression10364);
							percent_found_key752=gPLSQLParser.percent_found_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(percent_found_key752.getTree(), root_0);
							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:1049:64: percent_isopen_key ^
							{
							pushFollow(FOLLOW_percent_isopen_key_in_unary_expression10367);
							percent_isopen_key753=gPLSQLParser.percent_isopen_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(percent_isopen_key753.getTree(), root_0);
							}
							break;
						case 4 :
							// PLSQL_DMLParser.g:1049:84: percent_rowcount_key ^
							{
							pushFollow(FOLLOW_percent_rowcount_key_in_unary_expression10370);
							percent_rowcount_key754=gPLSQLParser.percent_rowcount_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(percent_rowcount_key754.getTree(), root_0);
							}
							break;

					}

					}
					break;
				case 11 :
					// PLSQL_DMLParser.g:1050:10: atom
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_atom_in_unary_expression10383);
					atom755=atom();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, atom755.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unary_expression"


	protected static class case_statement_scope {
		boolean isStatement;
	}
	protected Stack<case_statement_scope> case_statement_stack = new Stack<case_statement_scope>();

	public static class case_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "case_statement"
	// PLSQL_DMLParser.g:1053:1: case_statement[boolean isStatementParameter] : ( ( case_key when_key )=> searched_case_statement | simple_case_statement );
	public final PLSQLParser_PLSQL_DMLParser.case_statement_return case_statement(boolean isStatementParameter) throws RecognitionException {
		case_statement_stack.push(new case_statement_scope());
		PLSQLParser_PLSQL_DMLParser.case_statement_return retval = new PLSQLParser_PLSQL_DMLParser.case_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope searched_case_statement756 =null;
		ParserRuleReturnScope simple_case_statement757 =null;


		case_statement_stack.peek().isStatement = isStatementParameter;
		try {
			// PLSQL_DMLParser.g:1058:5: ( ( case_key when_key )=> searched_case_statement | simple_case_statement )
			int alt247=2;
			int LA247_0 = input.LA(1);
			if ( (LA247_0==SQL92_RESERVED_CASE) ) {
				int LA247_1 = input.LA(2);
				if ( (LA247_1==SQL92_RESERVED_WHEN) && (synpred43_PLSQL_DMLParser())) {
					alt247=1;
				}
				else if ( (LA247_1==APPROXIMATE_NUM_LIT||LA247_1==BINDVAR||(LA247_1 >= CHAR_STRING && LA247_1 <= COLON)||LA247_1==DELIMITED_ID||LA247_1==EXACT_NUM_LIT||LA247_1==INTRODUCER||LA247_1==LEFT_PAREN||LA247_1==MINUS_SIGN||LA247_1==NATIONAL_CHAR_STRING_LIT||LA247_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA247_1==PLUS_SIGN||LA247_1==REGULAR_ID||LA247_1==SQL92_RESERVED_ALL||LA247_1==SQL92_RESERVED_ANY||LA247_1==SQL92_RESERVED_CASE||(LA247_1 >= SQL92_RESERVED_CURSOR && LA247_1 <= SQL92_RESERVED_DATE)||(LA247_1 >= SQL92_RESERVED_DEFAULT && LA247_1 <= SQL92_RESERVED_DELETE)||LA247_1==SQL92_RESERVED_DISTINCT||(LA247_1 >= SQL92_RESERVED_EXISTS && LA247_1 <= SQL92_RESERVED_FALSE)||(LA247_1 >= SQL92_RESERVED_NOT && LA247_1 <= SQL92_RESERVED_NULL)||LA247_1==SQL92_RESERVED_PRIOR||LA247_1==SQL92_RESERVED_TRUE||LA247_1==UNSIGNED_INTEGER) ) {
					alt247=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 247, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 247, 0, input);
				throw nvae;
			}

			switch (alt247) {
				case 1 :
					// PLSQL_DMLParser.g:1058:10: ( case_key when_key )=> searched_case_statement
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_searched_case_statement_in_case_statement10431);
					searched_case_statement756=searched_case_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, searched_case_statement756.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1059:10: simple_case_statement
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_simple_case_statement_in_case_statement10442);
					simple_case_statement757=simple_case_statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_case_statement757.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
			case_statement_stack.pop();
		}
		return retval;
	}
	// $ANTLR end "case_statement"


	public static class simple_case_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simple_case_statement"
	// PLSQL_DMLParser.g:1064:1: simple_case_statement : ck1= case_key expression_wrapper ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? -> ^( SIMPLE_CASE[$ck1.start] expression_wrapper ( simple_case_when_part )+ ( case_else_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.simple_case_statement_return simple_case_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.simple_case_statement_return retval = new PLSQLParser_PLSQL_DMLParser.simple_case_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope ck1 =null;
		ParserRuleReturnScope expression_wrapper758 =null;
		ParserRuleReturnScope simple_case_when_part759 =null;
		ParserRuleReturnScope case_else_part760 =null;
		ParserRuleReturnScope end_key761 =null;
		ParserRuleReturnScope case_key762 =null;
		ParserRuleReturnScope label_name763 =null;

		RewriteRuleSubtreeStream stream_end_key=new RewriteRuleSubtreeStream(adaptor,"rule end_key");
		RewriteRuleSubtreeStream stream_expression_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule expression_wrapper");
		RewriteRuleSubtreeStream stream_simple_case_when_part=new RewriteRuleSubtreeStream(adaptor,"rule simple_case_when_part");
		RewriteRuleSubtreeStream stream_case_key=new RewriteRuleSubtreeStream(adaptor,"rule case_key");
		RewriteRuleSubtreeStream stream_case_else_part=new RewriteRuleSubtreeStream(adaptor,"rule case_else_part");
		RewriteRuleSubtreeStream stream_label_name=new RewriteRuleSubtreeStream(adaptor,"rule label_name");

		try {
			// PLSQL_DMLParser.g:1065:5: (ck1= case_key expression_wrapper ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? -> ^( SIMPLE_CASE[$ck1.start] expression_wrapper ( simple_case_when_part )+ ( case_else_part )? ) )
			// PLSQL_DMLParser.g:1065:10: ck1= case_key expression_wrapper ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
			{
			pushFollow(FOLLOW_case_key_in_simple_case_statement10466);
			ck1=gPLSQLParser.case_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_key.add(ck1.getTree());
			pushFollow(FOLLOW_expression_wrapper_in_simple_case_statement10468);
			expression_wrapper758=expression_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression_wrapper.add(expression_wrapper758.getTree());
			// PLSQL_DMLParser.g:1066:9: ( simple_case_when_part )+
			int cnt248=0;
			loop248:
			while (true) {
				int alt248=2;
				int LA248_0 = input.LA(1);
				if ( (LA248_0==SQL92_RESERVED_WHEN) ) {
					alt248=1;
				}

				switch (alt248) {
				case 1 :
					// PLSQL_DMLParser.g:1066:9: simple_case_when_part
					{
					pushFollow(FOLLOW_simple_case_when_part_in_simple_case_statement10478);
					simple_case_when_part759=simple_case_when_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_simple_case_when_part.add(simple_case_when_part759.getTree());
					}
					break;

				default :
					if ( cnt248 >= 1 ) break loop248;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(248, input);
					throw eee;
				}
				cnt248++;
			}

			// PLSQL_DMLParser.g:1067:9: ( case_else_part )?
			int alt249=2;
			int LA249_0 = input.LA(1);
			if ( (LA249_0==SQL92_RESERVED_ELSE) ) {
				alt249=1;
			}
			switch (alt249) {
				case 1 :
					// PLSQL_DMLParser.g:1067:9: case_else_part
					{
					pushFollow(FOLLOW_case_else_part_in_simple_case_statement10490);
					case_else_part760=case_else_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_else_part.add(case_else_part760.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_end_key_in_simple_case_statement10501);
			end_key761=gPLSQLParser.end_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_end_key.add(end_key761.getTree());
			// PLSQL_DMLParser.g:1068:17: ( case_key )?
			int alt250=2;
			int LA250_0 = input.LA(1);
			if ( (LA250_0==SQL92_RESERVED_CASE) ) {
				alt250=1;
			}
			switch (alt250) {
				case 1 :
					// PLSQL_DMLParser.g:1068:17: case_key
					{
					pushFollow(FOLLOW_case_key_in_simple_case_statement10503);
					case_key762=gPLSQLParser.case_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_key.add(case_key762.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:1068:27: ( label_name )?
			int alt251=2;
			int LA251_0 = input.LA(1);
			if ( (LA251_0==REGULAR_ID) ) {
				alt251=1;
			}
			else if ( (LA251_0==DELIMITED_ID) ) {
				alt251=1;
			}
			switch (alt251) {
				case 1 :
					// PLSQL_DMLParser.g:1068:27: label_name
					{
					pushFollow(FOLLOW_label_name_in_simple_case_statement10506);
					label_name763=gPLSQLParser.label_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_label_name.add(label_name763.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: expression_wrapper, simple_case_when_part, case_else_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1069:9: -> ^( SIMPLE_CASE[$ck1.start] expression_wrapper ( simple_case_when_part )+ ( case_else_part )? )
			{
				// PLSQL_DMLParser.g:1069:12: ^( SIMPLE_CASE[$ck1.start] expression_wrapper ( simple_case_when_part )+ ( case_else_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SIMPLE_CASE, (ck1!=null?(ck1.start):null)), root_1);
				adaptor.addChild(root_1, stream_expression_wrapper.nextTree());
				if ( !(stream_simple_case_when_part.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_simple_case_when_part.hasNext() ) {
					adaptor.addChild(root_1, stream_simple_case_when_part.nextTree());
				}
				stream_simple_case_when_part.reset();

				// PLSQL_DMLParser.g:1069:80: ( case_else_part )?
				if ( stream_case_else_part.hasNext() ) {
					adaptor.addChild(root_1, stream_case_else_part.nextTree());
				}
				stream_case_else_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simple_case_statement"


	public static class simple_case_when_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simple_case_when_part"
	// PLSQL_DMLParser.g:1072:1: simple_case_when_part : when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.simple_case_when_part_return simple_case_when_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.simple_case_when_part_return retval = new PLSQLParser_PLSQL_DMLParser.simple_case_when_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope ew1 =null;
		ParserRuleReturnScope ew2 =null;
		ParserRuleReturnScope when_key764 =null;
		ParserRuleReturnScope then_key765 =null;
		ParserRuleReturnScope seq_of_statements766 =null;


		try {
			// PLSQL_DMLParser.g:1073:5: ( when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper ) )
			// PLSQL_DMLParser.g:1073:10: when_key ^ew1= expression_wrapper then_key ! ({...}? seq_of_statements |ew2= expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_when_key_in_simple_case_when_part10552);
			when_key764=gPLSQLParser.when_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(when_key764.getTree(), root_0);
			pushFollow(FOLLOW_expression_wrapper_in_simple_case_when_part10557);
			ew1=expression_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, ew1.getTree());

			pushFollow(FOLLOW_then_key_in_simple_case_when_part10559);
			then_key765=gPLSQLParser.then_key();
			state._fsp--;
			if (state.failed) return retval;
			// PLSQL_DMLParser.g:1073:53: ({...}? seq_of_statements |ew2= expression_wrapper )
			int alt252=2;
			switch ( input.LA(1) ) {
			case LESS_THAN_OP:
			case PLSQL_RESERVED_IF:
			case PLSQL_RESERVED_LOCK:
			case SQL92_RESERVED_ALTER:
			case SQL92_RESERVED_BEGIN:
			case SQL92_RESERVED_CREATE:
			case SQL92_RESERVED_DECLARE:
			case SQL92_RESERVED_FETCH:
			case SQL92_RESERVED_FOR:
			case SQL92_RESERVED_GOTO:
			case SQL92_RESERVED_GRANT:
			case SQL92_RESERVED_INSERT:
			case SQL92_RESERVED_PROCEDURE:
			case SQL92_RESERVED_SELECT:
			case SQL92_RESERVED_UPDATE:
			case SQL92_RESERVED_WITH:
				{
				alt252=1;
				}
				break;
			case REGULAR_ID:
				{
				int LA252_5 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case INTRODUCER:
				{
				int LA252_8 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA252_9 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case BINDVAR:
				{
				int LA252_10 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case COLON:
				{
				int LA252_11 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_CURSOR:
				{
				int LA252_12 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_DELETE:
				{
				int LA252_14 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA252_15 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA252_16 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_NULL:
				{
				int LA252_20 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case SQL92_RESERVED_CASE:
				{
				int LA252_21 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (((input.LA(1) == SQL92_RESERVED_CASE || input.LA(2) == SQL92_RESERVED_CASE))) ) {
					alt252=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 252, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				int LA252_25 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt252=1;
				}
				else if ( (true) ) {
					alt252=2;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NOT:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt252=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 252, 0, input);
				throw nvae;
			}
			switch (alt252) {
				case 1 :
					// PLSQL_DMLParser.g:1073:54: {...}? seq_of_statements
					{
					if ( !((case_statement_stack.peek().isStatement)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simple_case_when_part", "$case_statement::isStatement");
					}
					pushFollow(FOLLOW_seq_of_statements_in_simple_case_when_part10565);
					seq_of_statements766=gPLSQLParser.seq_of_statements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, seq_of_statements766.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1073:106: ew2= expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_simple_case_when_part10571);
					ew2=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, ew2.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simple_case_when_part"


	public static class searched_case_statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "searched_case_statement"
	// PLSQL_DMLParser.g:1076:1: searched_case_statement : ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? -> ^( SEARCHED_CASE[$ck1.start] ( searched_case_when_part )+ ( case_else_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.searched_case_statement_return searched_case_statement() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.searched_case_statement_return retval = new PLSQLParser_PLSQL_DMLParser.searched_case_statement_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope ck1 =null;
		ParserRuleReturnScope searched_case_when_part767 =null;
		ParserRuleReturnScope case_else_part768 =null;
		ParserRuleReturnScope end_key769 =null;
		ParserRuleReturnScope case_key770 =null;
		ParserRuleReturnScope label_name771 =null;

		RewriteRuleSubtreeStream stream_end_key=new RewriteRuleSubtreeStream(adaptor,"rule end_key");
		RewriteRuleSubtreeStream stream_case_key=new RewriteRuleSubtreeStream(adaptor,"rule case_key");
		RewriteRuleSubtreeStream stream_searched_case_when_part=new RewriteRuleSubtreeStream(adaptor,"rule searched_case_when_part");
		RewriteRuleSubtreeStream stream_case_else_part=new RewriteRuleSubtreeStream(adaptor,"rule case_else_part");
		RewriteRuleSubtreeStream stream_label_name=new RewriteRuleSubtreeStream(adaptor,"rule label_name");

		try {
			// PLSQL_DMLParser.g:1077:5: (ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? -> ^( SEARCHED_CASE[$ck1.start] ( searched_case_when_part )+ ( case_else_part )? ) )
			// PLSQL_DMLParser.g:1077:10: ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
			{
			pushFollow(FOLLOW_case_key_in_searched_case_statement10594);
			ck1=gPLSQLParser.case_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_case_key.add(ck1.getTree());
			// PLSQL_DMLParser.g:1078:9: ( searched_case_when_part )+
			int cnt253=0;
			loop253:
			while (true) {
				int alt253=2;
				int LA253_0 = input.LA(1);
				if ( (LA253_0==SQL92_RESERVED_WHEN) ) {
					alt253=1;
				}

				switch (alt253) {
				case 1 :
					// PLSQL_DMLParser.g:1078:9: searched_case_when_part
					{
					pushFollow(FOLLOW_searched_case_when_part_in_searched_case_statement10604);
					searched_case_when_part767=searched_case_when_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_searched_case_when_part.add(searched_case_when_part767.getTree());
					}
					break;

				default :
					if ( cnt253 >= 1 ) break loop253;
					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee = new EarlyExitException(253, input);
					throw eee;
				}
				cnt253++;
			}

			// PLSQL_DMLParser.g:1079:9: ( case_else_part )?
			int alt254=2;
			int LA254_0 = input.LA(1);
			if ( (LA254_0==SQL92_RESERVED_ELSE) ) {
				alt254=1;
			}
			switch (alt254) {
				case 1 :
					// PLSQL_DMLParser.g:1079:9: case_else_part
					{
					pushFollow(FOLLOW_case_else_part_in_searched_case_statement10615);
					case_else_part768=case_else_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_else_part.add(case_else_part768.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_end_key_in_searched_case_statement10626);
			end_key769=gPLSQLParser.end_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_end_key.add(end_key769.getTree());
			// PLSQL_DMLParser.g:1080:17: ( case_key )?
			int alt255=2;
			int LA255_0 = input.LA(1);
			if ( (LA255_0==SQL92_RESERVED_CASE) ) {
				alt255=1;
			}
			switch (alt255) {
				case 1 :
					// PLSQL_DMLParser.g:1080:17: case_key
					{
					pushFollow(FOLLOW_case_key_in_searched_case_statement10628);
					case_key770=gPLSQLParser.case_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_case_key.add(case_key770.getTree());
					}
					break;

			}

			// PLSQL_DMLParser.g:1080:27: ( label_name )?
			int alt256=2;
			int LA256_0 = input.LA(1);
			if ( (LA256_0==REGULAR_ID) ) {
				alt256=1;
			}
			else if ( (LA256_0==DELIMITED_ID) ) {
				alt256=1;
			}
			switch (alt256) {
				case 1 :
					// PLSQL_DMLParser.g:1080:27: label_name
					{
					pushFollow(FOLLOW_label_name_in_searched_case_statement10631);
					label_name771=gPLSQLParser.label_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_label_name.add(label_name771.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: case_else_part, searched_case_when_part
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1081:9: -> ^( SEARCHED_CASE[$ck1.start] ( searched_case_when_part )+ ( case_else_part )? )
			{
				// PLSQL_DMLParser.g:1081:12: ^( SEARCHED_CASE[$ck1.start] ( searched_case_when_part )+ ( case_else_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SEARCHED_CASE, (ck1!=null?(ck1.start):null)), root_1);
				if ( !(stream_searched_case_when_part.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_searched_case_when_part.hasNext() ) {
					adaptor.addChild(root_1, stream_searched_case_when_part.nextTree());
				}
				stream_searched_case_when_part.reset();

				// PLSQL_DMLParser.g:1081:65: ( case_else_part )?
				if ( stream_case_else_part.hasNext() ) {
					adaptor.addChild(root_1, stream_case_else_part.nextTree());
				}
				stream_case_else_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "searched_case_statement"


	public static class searched_case_when_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "searched_case_when_part"
	// PLSQL_DMLParser.g:1084:1: searched_case_when_part : when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.searched_case_when_part_return searched_case_when_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.searched_case_when_part_return retval = new PLSQLParser_PLSQL_DMLParser.searched_case_when_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope when_key772 =null;
		ParserRuleReturnScope condition_wrapper773 =null;
		ParserRuleReturnScope then_key774 =null;
		ParserRuleReturnScope seq_of_statements775 =null;
		ParserRuleReturnScope expression_wrapper776 =null;


		try {
			// PLSQL_DMLParser.g:1085:5: ( when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper ) )
			// PLSQL_DMLParser.g:1085:10: when_key ^ condition_wrapper then_key ! ({...}? seq_of_statements | expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_when_key_in_searched_case_when_part10674);
			when_key772=gPLSQLParser.when_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(when_key772.getTree(), root_0);
			pushFollow(FOLLOW_condition_wrapper_in_searched_case_when_part10677);
			condition_wrapper773=condition_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, condition_wrapper773.getTree());

			pushFollow(FOLLOW_then_key_in_searched_case_when_part10679);
			then_key774=gPLSQLParser.then_key();
			state._fsp--;
			if (state.failed) return retval;
			// PLSQL_DMLParser.g:1085:48: ({...}? seq_of_statements | expression_wrapper )
			int alt257=2;
			switch ( input.LA(1) ) {
			case LESS_THAN_OP:
			case PLSQL_RESERVED_IF:
			case PLSQL_RESERVED_LOCK:
			case SQL92_RESERVED_ALTER:
			case SQL92_RESERVED_BEGIN:
			case SQL92_RESERVED_CREATE:
			case SQL92_RESERVED_DECLARE:
			case SQL92_RESERVED_FETCH:
			case SQL92_RESERVED_FOR:
			case SQL92_RESERVED_GOTO:
			case SQL92_RESERVED_GRANT:
			case SQL92_RESERVED_INSERT:
			case SQL92_RESERVED_PROCEDURE:
			case SQL92_RESERVED_SELECT:
			case SQL92_RESERVED_UPDATE:
			case SQL92_RESERVED_WITH:
				{
				alt257=1;
				}
				break;
			case REGULAR_ID:
				{
				int LA257_5 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case INTRODUCER:
				{
				int LA257_8 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA257_9 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case BINDVAR:
				{
				int LA257_10 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case COLON:
				{
				int LA257_11 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_CURSOR:
				{
				int LA257_12 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_DELETE:
				{
				int LA257_14 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA257_15 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA257_16 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_NULL:
				{
				int LA257_20 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case SQL92_RESERVED_CASE:
				{
				int LA257_21 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (((input.LA(1) == SQL92_RESERVED_CASE || input.LA(2) == SQL92_RESERVED_CASE))) ) {
					alt257=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 257, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				int LA257_25 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt257=1;
				}
				else if ( (true) ) {
					alt257=2;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NOT:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt257=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 257, 0, input);
				throw nvae;
			}
			switch (alt257) {
				case 1 :
					// PLSQL_DMLParser.g:1085:49: {...}? seq_of_statements
					{
					if ( !((case_statement_stack.peek().isStatement)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "searched_case_when_part", "$case_statement::isStatement");
					}
					pushFollow(FOLLOW_seq_of_statements_in_searched_case_when_part10685);
					seq_of_statements775=gPLSQLParser.seq_of_statements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, seq_of_statements775.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1085:101: expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_searched_case_when_part10689);
					expression_wrapper776=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper776.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "searched_case_when_part"


	public static class case_else_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "case_else_part"
	// PLSQL_DMLParser.g:1088:1: case_else_part : else_key ^ ({...}? seq_of_statements | expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.case_else_part_return case_else_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.case_else_part_return retval = new PLSQLParser_PLSQL_DMLParser.case_else_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope else_key777 =null;
		ParserRuleReturnScope seq_of_statements778 =null;
		ParserRuleReturnScope expression_wrapper779 =null;


		try {
			// PLSQL_DMLParser.g:1089:5: ( else_key ^ ({...}? seq_of_statements | expression_wrapper ) )
			// PLSQL_DMLParser.g:1089:10: else_key ^ ({...}? seq_of_statements | expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_else_key_in_case_else_part10710);
			else_key777=gPLSQLParser.else_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(else_key777.getTree(), root_0);
			// PLSQL_DMLParser.g:1089:20: ({...}? seq_of_statements | expression_wrapper )
			int alt258=2;
			switch ( input.LA(1) ) {
			case LESS_THAN_OP:
			case PLSQL_RESERVED_IF:
			case PLSQL_RESERVED_LOCK:
			case SQL92_RESERVED_ALTER:
			case SQL92_RESERVED_BEGIN:
			case SQL92_RESERVED_CREATE:
			case SQL92_RESERVED_DECLARE:
			case SQL92_RESERVED_FETCH:
			case SQL92_RESERVED_FOR:
			case SQL92_RESERVED_GOTO:
			case SQL92_RESERVED_GRANT:
			case SQL92_RESERVED_INSERT:
			case SQL92_RESERVED_PROCEDURE:
			case SQL92_RESERVED_SELECT:
			case SQL92_RESERVED_UPDATE:
			case SQL92_RESERVED_WITH:
				{
				alt258=1;
				}
				break;
			case REGULAR_ID:
				{
				int LA258_5 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case INTRODUCER:
				{
				int LA258_8 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA258_9 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case BINDVAR:
				{
				int LA258_10 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case COLON:
				{
				int LA258_11 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_CURSOR:
				{
				int LA258_12 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_DELETE:
				{
				int LA258_14 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA258_15 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA258_16 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_NULL:
				{
				int LA258_20 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case SQL92_RESERVED_CASE:
				{
				int LA258_21 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (((input.LA(1) == SQL92_RESERVED_CASE || input.LA(2) == SQL92_RESERVED_CASE))) ) {
					alt258=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 258, 21, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				int LA258_25 = input.LA(2);
				if ( ((case_statement_stack.peek().isStatement)) ) {
					alt258=1;
				}
				else if ( (true) ) {
					alt258=2;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NOT:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt258=2;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 258, 0, input);
				throw nvae;
			}
			switch (alt258) {
				case 1 :
					// PLSQL_DMLParser.g:1089:21: {...}? seq_of_statements
					{
					if ( !((case_statement_stack.peek().isStatement)) ) {
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "case_else_part", "$case_statement::isStatement");
					}
					pushFollow(FOLLOW_seq_of_statements_in_case_else_part10716);
					seq_of_statements778=gPLSQLParser.seq_of_statements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, seq_of_statements778.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1089:73: expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_case_else_part10720);
					expression_wrapper779=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper779.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_else_part"


	public static class atom_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "atom"
	// PLSQL_DMLParser.g:1093:1: atom : ( ( routine_id ( PERIOD routine_id )* outer_join_sign )=> general_element outer_join_sign ^| constant | ( standard_function )=> standard_function -> ^( STANDARD_FUNCTION standard_function ) | general_element | LEFT_PAREN ! ( ( select_key | with_key )=> subquery RIGHT_PAREN ! ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN !) );
	public final PLSQLParser_PLSQL_DMLParser.atom_return atom() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.atom_return retval = new PLSQLParser_PLSQL_DMLParser.atom_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN785=null;
		Token RIGHT_PAREN787=null;
		Token RIGHT_PAREN790=null;
		ParserRuleReturnScope general_element780 =null;
		ParserRuleReturnScope outer_join_sign781 =null;
		ParserRuleReturnScope constant782 =null;
		ParserRuleReturnScope standard_function783 =null;
		ParserRuleReturnScope general_element784 =null;
		ParserRuleReturnScope subquery786 =null;
		ParserRuleReturnScope subquery_operation_part788 =null;
		ParserRuleReturnScope expression_or_vector789 =null;

		Object LEFT_PAREN785_tree=null;
		Object RIGHT_PAREN787_tree=null;
		Object RIGHT_PAREN790_tree=null;
		RewriteRuleSubtreeStream stream_standard_function=new RewriteRuleSubtreeStream(adaptor,"rule standard_function");

		try {
			// PLSQL_DMLParser.g:1098:5: ( ( routine_id ( PERIOD routine_id )* outer_join_sign )=> general_element outer_join_sign ^| constant | ( standard_function )=> standard_function -> ^( STANDARD_FUNCTION standard_function ) | general_element | LEFT_PAREN ! ( ( select_key | with_key )=> subquery RIGHT_PAREN ! ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN !) )
			int alt261=5;
			switch ( input.LA(1) ) {
			case INTRODUCER:
				{
				int LA261_1 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case REGULAR_ID:
				{
				int LA261_2 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("minvalue"))||(input.LT(1).getText().equalsIgnoreCase("dbtimezone"))||(input.LT(1).getText().equalsIgnoreCase("interval"))||(input.LT(1).getText().equalsIgnoreCase("sessiontimezone"))||(input.LT(1).getText().equalsIgnoreCase("timestamp"))||(input.LT(1).getText().equalsIgnoreCase("maxvalue")))) ) {
					alt261=2;
				}
				else if ( ((((enablesWithinOrOverClause(input.LT(1).getText()))||(input.LT(1).getText().equalsIgnoreCase("first_value"))||(input.LT(1).getText().equalsIgnoreCase("xmlparse"))||(input.LT(1).getText().equalsIgnoreCase("xmlquery"))||(input.LT(1).getText().equalsIgnoreCase("xmlpi"))||(input.LT(1).getText().equalsIgnoreCase("xmlelement"))||(enablesUsingClause(input.LT(1).getText()))||(input.LT(1).getText().equalsIgnoreCase("last_value"))||(input.LT(1).getText().equalsIgnoreCase("count"))||(input.LT(1).getText().equalsIgnoreCase("xmlforest"))||(input.LT(1).getText().equalsIgnoreCase("cast"))||(input.LT(1).getText().equalsIgnoreCase("collect"))||(enablesOverClause(input.LT(1).getText()))||(input.LT(1).getText().equalsIgnoreCase("xmltable"))||(input.LT(1).getText().equalsIgnoreCase("chr"))||(isStandardPredictionFunction(input.LT(1).getText()))||(input.LT(1).getText().equalsIgnoreCase("decompose"))||(input.LT(1).getText().equalsIgnoreCase("xmlagg"))||(input.LT(1).getText().equalsIgnoreCase("xmlserialize"))||(input.LT(1).getText().equalsIgnoreCase("translate"))||(input.LT(1).getText().equalsIgnoreCase("treat"))||(input.LT(1).getText().equalsIgnoreCase("trim"))||(input.LT(1).getText().equalsIgnoreCase("xmlcolattval"))||(input.LT(1).getText().equalsIgnoreCase("extract"))||(input.LT(1).getText().equalsIgnoreCase("xmlexists"))||(input.LT(1).getText().equalsIgnoreCase("xmlroot"))||(input.LT(1).getText().equalsIgnoreCase("xmlcast")))&&synpred45_PLSQL_DMLParser())) ) {
					alt261=3;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case DELIMITED_ID:
				{
				int LA261_3 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case SQL92_RESERVED_DELETE:
				{
				int LA261_4 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				int LA261_5 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case SQL92_RESERVED_PRIOR:
				{
				int LA261_6 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case BINDVAR:
				{
				int LA261_7 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case COLON:
				{
				int LA261_8 = input.LA(2);
				if ( (synpred44_PLSQL_DMLParser()) ) {
					alt261=1;
				}
				else if ( (true) ) {
					alt261=4;
				}

				}
				break;
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case EXACT_NUM_LIT:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt261=2;
				}
				break;
			case LEFT_PAREN:
				{
				alt261=5;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 261, 0, input);
				throw nvae;
			}
			switch (alt261) {
				case 1 :
					// PLSQL_DMLParser.g:1098:10: ( routine_id ( PERIOD routine_id )* outer_join_sign )=> general_element outer_join_sign ^
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_general_element_in_atom10759);
					general_element780=gPLSQLParser.general_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element780.getTree());

					pushFollow(FOLLOW_outer_join_sign_in_atom10761);
					outer_join_sign781=gPLSQLParser.outer_join_sign();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(outer_join_sign781.getTree(), root_0);
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1099:10: constant
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_constant_in_atom10773);
					constant782=gPLSQLParser.constant();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, constant782.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1100:10: ( standard_function )=> standard_function
					{
					pushFollow(FOLLOW_standard_function_in_atom10790);
					standard_function783=standard_function();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_standard_function.add(standard_function783.getTree());
					// AST REWRITE
					// elements: standard_function
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if ( state.backtracking==0 ) {
					retval.tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

					root_0 = (Object)adaptor.nil();
					// 1100:51: -> ^( STANDARD_FUNCTION standard_function )
					{
						// PLSQL_DMLParser.g:1100:54: ^( STANDARD_FUNCTION standard_function )
						{
						Object root_1 = (Object)adaptor.nil();
						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(STANDARD_FUNCTION, "STANDARD_FUNCTION"), root_1);
						adaptor.addChild(root_1, stream_standard_function.nextTree());
						adaptor.addChild(root_0, root_1);
						}

					}


					retval.tree = root_0;
					}

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:1101:10: general_element
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_general_element_in_atom10809);
					general_element784=gPLSQLParser.general_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element784.getTree());

					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:1102:10: LEFT_PAREN ! ( ( select_key | with_key )=> subquery RIGHT_PAREN ! ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN !)
					{
					root_0 = (Object)adaptor.nil();


					LEFT_PAREN785=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_atom10820); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1103:10: ( ( select_key | with_key )=> subquery RIGHT_PAREN ! ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN !)
					int alt260=2;
					int LA260_0 = input.LA(1);
					if ( (LA260_0==SQL92_RESERVED_SELECT) && (synpred46_PLSQL_DMLParser())) {
						alt260=1;
					}
					else if ( (LA260_0==LEFT_PAREN) ) {
						int LA260_2 = input.LA(2);
						if ( (synpred46_PLSQL_DMLParser()) ) {
							alt260=1;
						}
						else if ( (true) ) {
							alt260=2;
						}

					}
					else if ( (LA260_0==APPROXIMATE_NUM_LIT||LA260_0==BINDVAR||(LA260_0 >= CHAR_STRING && LA260_0 <= COLON)||LA260_0==DELIMITED_ID||LA260_0==EXACT_NUM_LIT||LA260_0==INTRODUCER||LA260_0==MINUS_SIGN||LA260_0==NATIONAL_CHAR_STRING_LIT||LA260_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA260_0==PLUS_SIGN||LA260_0==REGULAR_ID||LA260_0==SQL92_RESERVED_ALL||LA260_0==SQL92_RESERVED_ANY||LA260_0==SQL92_RESERVED_CASE||(LA260_0 >= SQL92_RESERVED_CURSOR && LA260_0 <= SQL92_RESERVED_DATE)||(LA260_0 >= SQL92_RESERVED_DEFAULT && LA260_0 <= SQL92_RESERVED_DELETE)||LA260_0==SQL92_RESERVED_DISTINCT||(LA260_0 >= SQL92_RESERVED_EXISTS && LA260_0 <= SQL92_RESERVED_FALSE)||(LA260_0 >= SQL92_RESERVED_NOT && LA260_0 <= SQL92_RESERVED_NULL)||LA260_0==SQL92_RESERVED_PRIOR||LA260_0==SQL92_RESERVED_TRUE||LA260_0==UNSIGNED_INTEGER) ) {
						alt260=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 260, 0, input);
						throw nvae;
					}

					switch (alt260) {
						case 1 :
							// PLSQL_DMLParser.g:1104:15: ( select_key | with_key )=> subquery RIGHT_PAREN ! ( subquery_operation_part )*
							{
							pushFollow(FOLLOW_subquery_in_atom10858);
							subquery786=subquery();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery786.getTree());

							RIGHT_PAREN787=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_atom10860); if (state.failed) return retval;
							// PLSQL_DMLParser.g:1104:64: ( subquery_operation_part )*
							loop259:
							while (true) {
								int alt259=2;
								switch ( input.LA(1) ) {
								case SQL92_RESERVED_UNION:
									{
									alt259=1;
									}
									break;
								case SQL92_RESERVED_INTERSECT:
									{
									alt259=1;
									}
									break;
								case PLSQL_RESERVED_MINUS:
									{
									alt259=1;
									}
									break;
								}
								switch (alt259) {
								case 1 :
									// PLSQL_DMLParser.g:1104:64: subquery_operation_part
									{
									pushFollow(FOLLOW_subquery_operation_part_in_atom10863);
									subquery_operation_part788=subquery_operation_part();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery_operation_part788.getTree());

									}
									break;

								default :
									break loop259;
								}
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1105:17: expression_or_vector RIGHT_PAREN !
							{
							pushFollow(FOLLOW_expression_or_vector_in_atom10882);
							expression_or_vector789=expression_or_vector();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_or_vector789.getTree());

							RIGHT_PAREN790=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_atom10884); if (state.failed) return retval;
							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "atom"


	public static class expression_or_vector_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "expression_or_vector"
	// PLSQL_DMLParser.g:1109:1: expression_or_vector : expression ( vector_expr )? -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr ) -> expression ;
	public final PLSQLParser_PLSQL_DMLParser.expression_or_vector_return expression_or_vector() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.expression_or_vector_return retval = new PLSQLParser_PLSQL_DMLParser.expression_or_vector_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression791 =null;
		ParserRuleReturnScope vector_expr792 =null;

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_vector_expr=new RewriteRuleSubtreeStream(adaptor,"rule vector_expr");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:1111:5: ( expression ( vector_expr )? -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr ) -> expression )
			// PLSQL_DMLParser.g:1111:10: expression ( vector_expr )?
			{
			pushFollow(FOLLOW_expression_in_expression_or_vector10924);
			expression791=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression791.getTree());
			// PLSQL_DMLParser.g:1111:21: ( vector_expr )?
			int alt262=2;
			int LA262_0 = input.LA(1);
			if ( (LA262_0==COMMA) ) {
				alt262=1;
			}
			switch (alt262) {
				case 1 :
					// PLSQL_DMLParser.g:1111:22: vector_expr
					{
					pushFollow(FOLLOW_vector_expr_in_expression_or_vector10927);
					vector_expr792=vector_expr();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_vector_expr.add(vector_expr792.getTree());
					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;

			}

			// AST REWRITE
			// elements: vector_expr, expression, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1112:9: -> {mode == 1}? ^( VECTOR_EXPR ^( EXPR expression ) vector_expr )
			if (mode == 1) {
				// PLSQL_DMLParser.g:1112:25: ^( VECTOR_EXPR ^( EXPR expression ) vector_expr )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VECTOR_EXPR, "VECTOR_EXPR"), root_1);
				// PLSQL_DMLParser.g:1112:39: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_1, stream_vector_expr.nextTree());
				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1113:9: -> expression
			{
				adaptor.addChild(root_0, stream_expression.nextTree());
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "expression_or_vector"


	public static class vector_expr_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vector_expr"
	// PLSQL_DMLParser.g:1116:1: vector_expr : COMMA expression ( COMMA expression )* -> ( ^( EXPR expression ) )+ ;
	public final PLSQLParser_PLSQL_DMLParser.vector_expr_return vector_expr() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.vector_expr_return retval = new PLSQLParser_PLSQL_DMLParser.vector_expr_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA793=null;
		Token COMMA795=null;
		ParserRuleReturnScope expression794 =null;
		ParserRuleReturnScope expression796 =null;

		Object COMMA793_tree=null;
		Object COMMA795_tree=null;
		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");

		try {
			// PLSQL_DMLParser.g:1117:5: ( COMMA expression ( COMMA expression )* -> ( ^( EXPR expression ) )+ )
			// PLSQL_DMLParser.g:1117:10: COMMA expression ( COMMA expression )*
			{
			COMMA793=(Token)match(input,COMMA,FOLLOW_COMMA_in_vector_expr10987); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_COMMA.add(COMMA793);

			pushFollow(FOLLOW_expression_in_vector_expr10989);
			expression794=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression794.getTree());
			// PLSQL_DMLParser.g:1117:27: ( COMMA expression )*
			loop263:
			while (true) {
				int alt263=2;
				int LA263_0 = input.LA(1);
				if ( (LA263_0==COMMA) ) {
					alt263=1;
				}

				switch (alt263) {
				case 1 :
					// PLSQL_DMLParser.g:1117:28: COMMA expression
					{
					COMMA795=(Token)match(input,COMMA,FOLLOW_COMMA_in_vector_expr10992); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_COMMA.add(COMMA795);

					pushFollow(FOLLOW_expression_in_vector_expr10994);
					expression796=expression();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_expression.add(expression796.getTree());
					}
					break;

				default :
					break loop263;
				}
			}

			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1118:9: -> ( ^( EXPR expression ) )+
			{
				if ( !(stream_expression.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.hasNext() ) {
					// PLSQL_DMLParser.g:1118:12: ^( EXPR expression )
					{
					Object root_1 = (Object)adaptor.nil();
					root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_1);
					adaptor.addChild(root_1, stream_expression.nextTree());
					adaptor.addChild(root_0, root_1);
					}

				}
				stream_expression.reset();

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vector_expr"


	public static class quantified_expression_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "quantified_expression"
	// PLSQL_DMLParser.g:1121:1: quantified_expression : ( some_key ^| exists_key ^| all_key ^| any_key ^) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| LEFT_PAREN ! expression_wrapper RIGHT_PAREN !) ;
	public final PLSQLParser_PLSQL_DMLParser.quantified_expression_return quantified_expression() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.quantified_expression_return retval = new PLSQLParser_PLSQL_DMLParser.quantified_expression_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN801=null;
		Token RIGHT_PAREN803=null;
		Token LEFT_PAREN804=null;
		Token RIGHT_PAREN806=null;
		ParserRuleReturnScope some_key797 =null;
		ParserRuleReturnScope exists_key798 =null;
		ParserRuleReturnScope all_key799 =null;
		ParserRuleReturnScope any_key800 =null;
		ParserRuleReturnScope subquery802 =null;
		ParserRuleReturnScope expression_wrapper805 =null;

		Object LEFT_PAREN801_tree=null;
		Object RIGHT_PAREN803_tree=null;
		Object LEFT_PAREN804_tree=null;
		Object RIGHT_PAREN806_tree=null;

		try {
			// PLSQL_DMLParser.g:1122:5: ( ( some_key ^| exists_key ^| all_key ^| any_key ^) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| LEFT_PAREN ! expression_wrapper RIGHT_PAREN !) )
			// PLSQL_DMLParser.g:1122:10: ( some_key ^| exists_key ^| all_key ^| any_key ^) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| LEFT_PAREN ! expression_wrapper RIGHT_PAREN !)
			{
			root_0 = (Object)adaptor.nil();


			// PLSQL_DMLParser.g:1122:10: ( some_key ^| exists_key ^| all_key ^| any_key ^)
			int alt264=4;
			switch ( input.LA(1) ) {
			case REGULAR_ID:
				{
				alt264=1;
				}
				break;
			case SQL92_RESERVED_EXISTS:
				{
				alt264=2;
				}
				break;
			case SQL92_RESERVED_ALL:
				{
				alt264=3;
				}
				break;
			case SQL92_RESERVED_ANY:
				{
				alt264=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 264, 0, input);
				throw nvae;
			}
			switch (alt264) {
				case 1 :
					// PLSQL_DMLParser.g:1122:12: some_key ^
					{
					pushFollow(FOLLOW_some_key_in_quantified_expression11035);
					some_key797=gPLSQLParser.some_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(some_key797.getTree(), root_0);
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1122:24: exists_key ^
					{
					pushFollow(FOLLOW_exists_key_in_quantified_expression11040);
					exists_key798=gPLSQLParser.exists_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(exists_key798.getTree(), root_0);
					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1122:38: all_key ^
					{
					pushFollow(FOLLOW_all_key_in_quantified_expression11045);
					all_key799=gPLSQLParser.all_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(all_key799.getTree(), root_0);
					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:1122:49: any_key ^
					{
					pushFollow(FOLLOW_any_key_in_quantified_expression11050);
					any_key800=gPLSQLParser.any_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(any_key800.getTree(), root_0);
					}
					break;

			}

			// PLSQL_DMLParser.g:1123:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !| LEFT_PAREN ! expression_wrapper RIGHT_PAREN !)
			int alt265=2;
			int LA265_0 = input.LA(1);
			if ( (LA265_0==LEFT_PAREN) ) {
				int LA265_1 = input.LA(2);
				if ( (synpred47_PLSQL_DMLParser()) ) {
					alt265=1;
				}
				else if ( (true) ) {
					alt265=2;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 265, 0, input);
				throw nvae;
			}

			switch (alt265) {
				case 1 :
					// PLSQL_DMLParser.g:1123:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN ! subquery RIGHT_PAREN !
					{
					LEFT_PAREN801=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_quantified_expression11078); if (state.failed) return retval;
					pushFollow(FOLLOW_subquery_in_quantified_expression11081);
					subquery802=subquery();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery802.getTree());

					RIGHT_PAREN803=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_quantified_expression11083); if (state.failed) return retval;
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1124:14: LEFT_PAREN ! expression_wrapper RIGHT_PAREN !
					{
					LEFT_PAREN804=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_quantified_expression11099); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_quantified_expression11102);
					expression_wrapper805=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper805.getTree());

					RIGHT_PAREN806=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_quantified_expression11104); if (state.failed) return retval;
					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "quantified_expression"


	public static class standard_function_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standard_function"
	// PLSQL_DMLParser.g:1128:1: standard_function : ( stantard_function_enabling_over ^ function_argument ( over_clause )? | stantard_function_enabling_using ^ function_argument ( using_clause )? | count_key ^ LEFT_PAREN ! ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ! ( over_clause )? | ( cast_key ^| xmlcast_key ^) LEFT_PAREN ! ( ( multiset_key LEFT_PAREN ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !) | concatenation_wrapper ) as_key ! type_spec RIGHT_PAREN !| chr_key ^ LEFT_PAREN ! concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN !| collect_key ^ LEFT_PAREN ! ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN !| stantard_function_enabling_within_or_over ^ function_argument within_or_over_part | decompose_key ^ LEFT_PAREN ! concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN !| extract_key ^ LEFT_PAREN ! ( year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key ) from_key ! concatenation_wrapper RIGHT_PAREN !| ( first_value_key ^| last_value_key ^) LEFT_PAREN ! concatenation_wrapper ( ignore_key ! nulls_key )? RIGHT_PAREN ! over_clause | ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions ^ LEFT_PAREN ! expression_wrapper ( COMMA ! expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN !| translate_key ^ LEFT_PAREN ! expression_wrapper COMMA ! expression_wrapper COMMA ! expression_wrapper RIGHT_PAREN !| treat_key ^ LEFT_PAREN ! expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN !| trim_key LEFT_PAREN ( (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key ) expr_ch= expression from_key expr_src= concatenation -> ^( trim_key $expr_src $expr_ch $trim_kind) |expr1= expression ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) ) ) RIGHT_PAREN | xmlagg_key ^ LEFT_PAREN ! expression_wrapper ( order_by_clause )? RIGHT_PAREN ! ( PERIOD general_element_id )? | ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN ! xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlelement_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlexists_key ^ LEFT_PAREN ! expression_wrapper ( xml_passing_clause )? RIGHT_PAREN !| xmlparse_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlpi_key ^ LEFT_PAREN ! ( name_key id | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlquery_key ^ LEFT_PAREN ! concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlroot_key ^ LEFT_PAREN ! concatenation_wrapper COMMA ! xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlserialize_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmltable_key ^ LEFT_PAREN ! ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column )* )? RIGHT_PAREN ! ( PERIOD general_element_id )? );
	public final PLSQLParser_PLSQL_DMLParser.standard_function_return standard_function() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.standard_function_return retval = new PLSQLParser_PLSQL_DMLParser.standard_function_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN814=null;
		Token ASTERISK815=null;
		Token RIGHT_PAREN820=null;
		Token LEFT_PAREN824=null;
		Token LEFT_PAREN826=null;
		Token RIGHT_PAREN828=null;
		Token RIGHT_PAREN832=null;
		Token LEFT_PAREN834=null;
		Token RIGHT_PAREN838=null;
		Token LEFT_PAREN840=null;
		Token RIGHT_PAREN845=null;
		Token LEFT_PAREN850=null;
		Token RIGHT_PAREN854=null;
		Token LEFT_PAREN856=null;
		Token RIGHT_PAREN869=null;
		Token LEFT_PAREN872=null;
		Token RIGHT_PAREN876=null;
		Token LEFT_PAREN884=null;
		Token COMMA886=null;
		Token RIGHT_PAREN890=null;
		Token LEFT_PAREN892=null;
		Token COMMA894=null;
		Token COMMA896=null;
		Token RIGHT_PAREN898=null;
		Token LEFT_PAREN900=null;
		Token RIGHT_PAREN905=null;
		Token LEFT_PAREN907=null;
		Token RIGHT_PAREN910=null;
		Token LEFT_PAREN912=null;
		Token RIGHT_PAREN915=null;
		Token PERIOD916=null;
		Token LEFT_PAREN920=null;
		Token COMMA922=null;
		Token RIGHT_PAREN924=null;
		Token PERIOD925=null;
		Token LEFT_PAREN928=null;
		Token COMMA934=null;
		Token COMMA936=null;
		Token RIGHT_PAREN939=null;
		Token PERIOD940=null;
		Token LEFT_PAREN943=null;
		Token RIGHT_PAREN946=null;
		Token LEFT_PAREN948=null;
		Token RIGHT_PAREN953=null;
		Token PERIOD954=null;
		Token LEFT_PAREN957=null;
		Token COMMA962=null;
		Token RIGHT_PAREN964=null;
		Token PERIOD965=null;
		Token LEFT_PAREN968=null;
		Token RIGHT_PAREN976=null;
		Token PERIOD977=null;
		Token LEFT_PAREN980=null;
		Token COMMA982=null;
		Token COMMA984=null;
		Token RIGHT_PAREN986=null;
		Token PERIOD987=null;
		Token LEFT_PAREN990=null;
		Token RIGHT_PAREN1002=null;
		Token PERIOD1003=null;
		Token LEFT_PAREN1006=null;
		Token COMMA1012=null;
		Token RIGHT_PAREN1014=null;
		Token PERIOD1015=null;
		ParserRuleReturnScope trim_kind =null;
		ParserRuleReturnScope expr_ch =null;
		ParserRuleReturnScope expr_src =null;
		ParserRuleReturnScope expr1 =null;
		ParserRuleReturnScope expr2 =null;
		ParserRuleReturnScope stantard_function_enabling_over807 =null;
		ParserRuleReturnScope function_argument808 =null;
		ParserRuleReturnScope over_clause809 =null;
		ParserRuleReturnScope stantard_function_enabling_using810 =null;
		ParserRuleReturnScope function_argument811 =null;
		ParserRuleReturnScope using_clause812 =null;
		ParserRuleReturnScope count_key813 =null;
		ParserRuleReturnScope distinct_key816 =null;
		ParserRuleReturnScope unique_key817 =null;
		ParserRuleReturnScope all_key818 =null;
		ParserRuleReturnScope concatenation_wrapper819 =null;
		ParserRuleReturnScope over_clause821 =null;
		ParserRuleReturnScope cast_key822 =null;
		ParserRuleReturnScope xmlcast_key823 =null;
		ParserRuleReturnScope multiset_key825 =null;
		ParserRuleReturnScope subquery827 =null;
		ParserRuleReturnScope concatenation_wrapper829 =null;
		ParserRuleReturnScope as_key830 =null;
		ParserRuleReturnScope type_spec831 =null;
		ParserRuleReturnScope chr_key833 =null;
		ParserRuleReturnScope concatenation_wrapper835 =null;
		ParserRuleReturnScope using_key836 =null;
		ParserRuleReturnScope nchar_cs_key837 =null;
		ParserRuleReturnScope collect_key839 =null;
		ParserRuleReturnScope distinct_key841 =null;
		ParserRuleReturnScope unique_key842 =null;
		ParserRuleReturnScope concatenation_wrapper843 =null;
		ParserRuleReturnScope collect_order_by_part844 =null;
		ParserRuleReturnScope stantard_function_enabling_within_or_over846 =null;
		ParserRuleReturnScope function_argument847 =null;
		ParserRuleReturnScope within_or_over_part848 =null;
		ParserRuleReturnScope decompose_key849 =null;
		ParserRuleReturnScope concatenation_wrapper851 =null;
		ParserRuleReturnScope canonical_key852 =null;
		ParserRuleReturnScope compatibility_key853 =null;
		ParserRuleReturnScope extract_key855 =null;
		ParserRuleReturnScope year_key857 =null;
		ParserRuleReturnScope month_key858 =null;
		ParserRuleReturnScope day_key859 =null;
		ParserRuleReturnScope hour_key860 =null;
		ParserRuleReturnScope minute_key861 =null;
		ParserRuleReturnScope second_key862 =null;
		ParserRuleReturnScope timezone_hour_key863 =null;
		ParserRuleReturnScope timezone_minute_key864 =null;
		ParserRuleReturnScope timezone_region_key865 =null;
		ParserRuleReturnScope timezone_abbr_key866 =null;
		ParserRuleReturnScope from_key867 =null;
		ParserRuleReturnScope concatenation_wrapper868 =null;
		ParserRuleReturnScope first_value_key870 =null;
		ParserRuleReturnScope last_value_key871 =null;
		ParserRuleReturnScope concatenation_wrapper873 =null;
		ParserRuleReturnScope ignore_key874 =null;
		ParserRuleReturnScope nulls_key875 =null;
		ParserRuleReturnScope over_clause877 =null;
		ParserRuleReturnScope first_value_key878 =null;
		ParserRuleReturnScope last_value_key879 =null;
		ParserRuleReturnScope function_argument_analytic880 =null;
		ParserRuleReturnScope respect_or_ignore_nulls881 =null;
		ParserRuleReturnScope over_clause882 =null;
		ParserRuleReturnScope stantard_function_pedictions883 =null;
		ParserRuleReturnScope expression_wrapper885 =null;
		ParserRuleReturnScope expression_wrapper887 =null;
		ParserRuleReturnScope cost_matrix_clause888 =null;
		ParserRuleReturnScope using_clause889 =null;
		ParserRuleReturnScope translate_key891 =null;
		ParserRuleReturnScope expression_wrapper893 =null;
		ParserRuleReturnScope expression_wrapper895 =null;
		ParserRuleReturnScope expression_wrapper897 =null;
		ParserRuleReturnScope treat_key899 =null;
		ParserRuleReturnScope expression_wrapper901 =null;
		ParserRuleReturnScope as_key902 =null;
		ParserRuleReturnScope ref_key903 =null;
		ParserRuleReturnScope type_spec904 =null;
		ParserRuleReturnScope trim_key906 =null;
		ParserRuleReturnScope from_key908 =null;
		ParserRuleReturnScope from_key909 =null;
		ParserRuleReturnScope xmlagg_key911 =null;
		ParserRuleReturnScope expression_wrapper913 =null;
		ParserRuleReturnScope order_by_clause914 =null;
		ParserRuleReturnScope general_element_id917 =null;
		ParserRuleReturnScope xmlcolattval_key918 =null;
		ParserRuleReturnScope xmlforest_key919 =null;
		ParserRuleReturnScope xml_multiuse_expression_element921 =null;
		ParserRuleReturnScope xml_multiuse_expression_element923 =null;
		ParserRuleReturnScope general_element_id926 =null;
		ParserRuleReturnScope xmlelement_key927 =null;
		ParserRuleReturnScope entityescaping_key929 =null;
		ParserRuleReturnScope noentityescaping_key930 =null;
		ParserRuleReturnScope name_key931 =null;
		ParserRuleReturnScope evalname_key932 =null;
		ParserRuleReturnScope expression_wrapper933 =null;
		ParserRuleReturnScope xml_attributes_clause935 =null;
		ParserRuleReturnScope expression_wrapper937 =null;
		ParserRuleReturnScope column_alias938 =null;
		ParserRuleReturnScope general_element_id941 =null;
		ParserRuleReturnScope xmlexists_key942 =null;
		ParserRuleReturnScope expression_wrapper944 =null;
		ParserRuleReturnScope xml_passing_clause945 =null;
		ParserRuleReturnScope xmlparse_key947 =null;
		ParserRuleReturnScope document_key949 =null;
		ParserRuleReturnScope content_key950 =null;
		ParserRuleReturnScope concatenation_wrapper951 =null;
		ParserRuleReturnScope wellformed_key952 =null;
		ParserRuleReturnScope general_element_id955 =null;
		ParserRuleReturnScope xmlpi_key956 =null;
		ParserRuleReturnScope name_key958 =null;
		ParserRuleReturnScope id959 =null;
		ParserRuleReturnScope evalname_key960 =null;
		ParserRuleReturnScope concatenation_wrapper961 =null;
		ParserRuleReturnScope concatenation_wrapper963 =null;
		ParserRuleReturnScope general_element_id966 =null;
		ParserRuleReturnScope xmlquery_key967 =null;
		ParserRuleReturnScope concatenation_wrapper969 =null;
		ParserRuleReturnScope xml_passing_clause970 =null;
		ParserRuleReturnScope returning_key971 =null;
		ParserRuleReturnScope content_key972 =null;
		ParserRuleReturnScope null_key973 =null;
		ParserRuleReturnScope on_key974 =null;
		ParserRuleReturnScope empty_key975 =null;
		ParserRuleReturnScope general_element_id978 =null;
		ParserRuleReturnScope xmlroot_key979 =null;
		ParserRuleReturnScope concatenation_wrapper981 =null;
		ParserRuleReturnScope xmlroot_param_version_part983 =null;
		ParserRuleReturnScope xmlroot_param_standalone_part985 =null;
		ParserRuleReturnScope general_element_id988 =null;
		ParserRuleReturnScope xmlserialize_key989 =null;
		ParserRuleReturnScope document_key991 =null;
		ParserRuleReturnScope content_key992 =null;
		ParserRuleReturnScope concatenation_wrapper993 =null;
		ParserRuleReturnScope as_key994 =null;
		ParserRuleReturnScope type_spec995 =null;
		ParserRuleReturnScope xmlserialize_param_enconding_part996 =null;
		ParserRuleReturnScope xmlserialize_param_version_part997 =null;
		ParserRuleReturnScope xmlserialize_param_ident_part998 =null;
		ParserRuleReturnScope hide_key999 =null;
		ParserRuleReturnScope show_key1000 =null;
		ParserRuleReturnScope defaults_key1001 =null;
		ParserRuleReturnScope general_element_id1004 =null;
		ParserRuleReturnScope xmltable_key1005 =null;
		ParserRuleReturnScope xml_namespaces_clause1007 =null;
		ParserRuleReturnScope concatenation_wrapper1008 =null;
		ParserRuleReturnScope xml_passing_clause1009 =null;
		ParserRuleReturnScope columns_key1010 =null;
		ParserRuleReturnScope xml_table_column1011 =null;
		ParserRuleReturnScope xml_table_column1013 =null;
		ParserRuleReturnScope general_element_id1016 =null;

		Object LEFT_PAREN814_tree=null;
		Object ASTERISK815_tree=null;
		Object RIGHT_PAREN820_tree=null;
		Object LEFT_PAREN824_tree=null;
		Object LEFT_PAREN826_tree=null;
		Object RIGHT_PAREN828_tree=null;
		Object RIGHT_PAREN832_tree=null;
		Object LEFT_PAREN834_tree=null;
		Object RIGHT_PAREN838_tree=null;
		Object LEFT_PAREN840_tree=null;
		Object RIGHT_PAREN845_tree=null;
		Object LEFT_PAREN850_tree=null;
		Object RIGHT_PAREN854_tree=null;
		Object LEFT_PAREN856_tree=null;
		Object RIGHT_PAREN869_tree=null;
		Object LEFT_PAREN872_tree=null;
		Object RIGHT_PAREN876_tree=null;
		Object LEFT_PAREN884_tree=null;
		Object COMMA886_tree=null;
		Object RIGHT_PAREN890_tree=null;
		Object LEFT_PAREN892_tree=null;
		Object COMMA894_tree=null;
		Object COMMA896_tree=null;
		Object RIGHT_PAREN898_tree=null;
		Object LEFT_PAREN900_tree=null;
		Object RIGHT_PAREN905_tree=null;
		Object LEFT_PAREN907_tree=null;
		Object RIGHT_PAREN910_tree=null;
		Object LEFT_PAREN912_tree=null;
		Object RIGHT_PAREN915_tree=null;
		Object PERIOD916_tree=null;
		Object LEFT_PAREN920_tree=null;
		Object COMMA922_tree=null;
		Object RIGHT_PAREN924_tree=null;
		Object PERIOD925_tree=null;
		Object LEFT_PAREN928_tree=null;
		Object COMMA934_tree=null;
		Object COMMA936_tree=null;
		Object RIGHT_PAREN939_tree=null;
		Object PERIOD940_tree=null;
		Object LEFT_PAREN943_tree=null;
		Object RIGHT_PAREN946_tree=null;
		Object LEFT_PAREN948_tree=null;
		Object RIGHT_PAREN953_tree=null;
		Object PERIOD954_tree=null;
		Object LEFT_PAREN957_tree=null;
		Object COMMA962_tree=null;
		Object RIGHT_PAREN964_tree=null;
		Object PERIOD965_tree=null;
		Object LEFT_PAREN968_tree=null;
		Object RIGHT_PAREN976_tree=null;
		Object PERIOD977_tree=null;
		Object LEFT_PAREN980_tree=null;
		Object COMMA982_tree=null;
		Object COMMA984_tree=null;
		Object RIGHT_PAREN986_tree=null;
		Object PERIOD987_tree=null;
		Object LEFT_PAREN990_tree=null;
		Object RIGHT_PAREN1002_tree=null;
		Object PERIOD1003_tree=null;
		Object LEFT_PAREN1006_tree=null;
		Object COMMA1012_tree=null;
		Object RIGHT_PAREN1014_tree=null;
		Object PERIOD1015_tree=null;
		RewriteRuleTokenStream stream_RIGHT_PAREN=new RewriteRuleTokenStream(adaptor,"token RIGHT_PAREN");
		RewriteRuleTokenStream stream_LEFT_PAREN=new RewriteRuleTokenStream(adaptor,"token LEFT_PAREN");
		RewriteRuleSubtreeStream stream_leading_key=new RewriteRuleSubtreeStream(adaptor,"rule leading_key");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_trim_key=new RewriteRuleSubtreeStream(adaptor,"rule trim_key");
		RewriteRuleSubtreeStream stream_trailing_key=new RewriteRuleSubtreeStream(adaptor,"rule trailing_key");
		RewriteRuleSubtreeStream stream_both_key=new RewriteRuleSubtreeStream(adaptor,"rule both_key");
		RewriteRuleSubtreeStream stream_from_key=new RewriteRuleSubtreeStream(adaptor,"rule from_key");

		try {
			// PLSQL_DMLParser.g:1129:5: ( stantard_function_enabling_over ^ function_argument ( over_clause )? | stantard_function_enabling_using ^ function_argument ( using_clause )? | count_key ^ LEFT_PAREN ! ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ! ( over_clause )? | ( cast_key ^| xmlcast_key ^) LEFT_PAREN ! ( ( multiset_key LEFT_PAREN ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !) | concatenation_wrapper ) as_key ! type_spec RIGHT_PAREN !| chr_key ^ LEFT_PAREN ! concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN !| collect_key ^ LEFT_PAREN ! ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN !| stantard_function_enabling_within_or_over ^ function_argument within_or_over_part | decompose_key ^ LEFT_PAREN ! concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN !| extract_key ^ LEFT_PAREN ! ( year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key ) from_key ! concatenation_wrapper RIGHT_PAREN !| ( first_value_key ^| last_value_key ^) LEFT_PAREN ! concatenation_wrapper ( ignore_key ! nulls_key )? RIGHT_PAREN ! over_clause | ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions ^ LEFT_PAREN ! expression_wrapper ( COMMA ! expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN !| translate_key ^ LEFT_PAREN ! expression_wrapper COMMA ! expression_wrapper COMMA ! expression_wrapper RIGHT_PAREN !| treat_key ^ LEFT_PAREN ! expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN !| trim_key LEFT_PAREN ( (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key ) expr_ch= expression from_key expr_src= concatenation -> ^( trim_key $expr_src $expr_ch $trim_kind) |expr1= expression ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) ) ) RIGHT_PAREN | xmlagg_key ^ LEFT_PAREN ! expression_wrapper ( order_by_clause )? RIGHT_PAREN ! ( PERIOD general_element_id )? | ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN ! xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlelement_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlexists_key ^ LEFT_PAREN ! expression_wrapper ( xml_passing_clause )? RIGHT_PAREN !| xmlparse_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlpi_key ^ LEFT_PAREN ! ( name_key id | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlquery_key ^ LEFT_PAREN ! concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlroot_key ^ LEFT_PAREN ! concatenation_wrapper COMMA ! xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmlserialize_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ! ( PERIOD general_element_id )? | xmltable_key ^ LEFT_PAREN ! ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column )* )? RIGHT_PAREN ! ( PERIOD general_element_id )? )
			int alt324=25;
			int LA324_0 = input.LA(1);
			if ( (LA324_0==REGULAR_ID) ) {
				int LA324_1 = input.LA(2);
				if ( ((enablesOverClause(input.LT(1).getText()))) ) {
					alt324=1;
				}
				else if ( ((enablesUsingClause(input.LT(1).getText()))) ) {
					alt324=2;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("count"))) ) {
					alt324=3;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("cast"))||(input.LT(1).getText().equalsIgnoreCase("xmlcast")))) ) {
					alt324=4;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("chr"))) ) {
					alt324=5;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("collect"))) ) {
					alt324=6;
				}
				else if ( ((enablesWithinOrOverClause(input.LT(1).getText()))) ) {
					alt324=7;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("decompose"))) ) {
					alt324=8;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("extract"))) ) {
					alt324=9;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("last_value"))||(input.LT(1).getText().equalsIgnoreCase("first_value")))) ) {
					alt324=10;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("last_value"))||(input.LT(1).getText().equalsIgnoreCase("first_value")))) ) {
					alt324=11;
				}
				else if ( ((isStandardPredictionFunction(input.LT(1).getText()))) ) {
					alt324=12;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("translate"))) ) {
					alt324=13;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("treat"))) ) {
					alt324=14;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("trim"))) ) {
					alt324=15;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlagg"))) ) {
					alt324=16;
				}
				else if ( (((input.LT(1).getText().equalsIgnoreCase("xmlcolattval"))||(input.LT(1).getText().equalsIgnoreCase("xmlforest")))) ) {
					alt324=17;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlelement"))) ) {
					alt324=18;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlexists"))) ) {
					alt324=19;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlparse"))) ) {
					alt324=20;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlpi"))) ) {
					alt324=21;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlquery"))) ) {
					alt324=22;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlroot"))) ) {
					alt324=23;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlserialize"))) ) {
					alt324=24;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("xmltable"))) ) {
					alt324=25;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 324, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 324, 0, input);
				throw nvae;
			}

			switch (alt324) {
				case 1 :
					// PLSQL_DMLParser.g:1129:10: stantard_function_enabling_over ^ function_argument ( over_clause )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_stantard_function_enabling_over_in_standard_function11136);
					stantard_function_enabling_over807=stantard_function_enabling_over();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(stantard_function_enabling_over807.getTree(), root_0);
					pushFollow(FOLLOW_function_argument_in_standard_function11139);
					function_argument808=gPLSQLParser.function_argument();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, function_argument808.getTree());

					// PLSQL_DMLParser.g:1129:61: ( over_clause )?
					int alt266=2;
					int LA266_0 = input.LA(1);
					if ( (LA266_0==REGULAR_ID) ) {
						int LA266_1 = input.LA(2);
						if ( (LA266_1==LEFT_PAREN) ) {
							int LA266_3 = input.LA(3);
							if ( (LA266_3==REGULAR_ID) ) {
								int LA266_10 = input.LA(4);
								if ( (LA266_10==SQL92_RESERVED_BY) && ((input.LT(1).getText().equalsIgnoreCase("over")))) {
									alt266=1;
								}
							}
							else if ( (LA266_3==RIGHT_PAREN||LA266_3==SQL92_RESERVED_ORDER) && ((input.LT(1).getText().equalsIgnoreCase("over")))) {
								alt266=1;
							}
						}
					}
					switch (alt266) {
						case 1 :
							// PLSQL_DMLParser.g:1129:61: over_clause
							{
							pushFollow(FOLLOW_over_clause_in_standard_function11141);
							over_clause809=over_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, over_clause809.getTree());

							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1130:10: stantard_function_enabling_using ^ function_argument ( using_clause )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_stantard_function_enabling_using_in_standard_function11153);
					stantard_function_enabling_using810=stantard_function_enabling_using();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(stantard_function_enabling_using810.getTree(), root_0);
					pushFollow(FOLLOW_function_argument_in_standard_function11156);
					function_argument811=gPLSQLParser.function_argument();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, function_argument811.getTree());

					// PLSQL_DMLParser.g:1130:62: ( using_clause )?
					int alt267=2;
					alt267 = dfa267.predict(input);
					switch (alt267) {
						case 1 :
							// PLSQL_DMLParser.g:1130:62: using_clause
							{
							pushFollow(FOLLOW_using_clause_in_standard_function11158);
							using_clause812=using_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, using_clause812.getTree());

							}
							break;

					}

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1131:10: count_key ^ LEFT_PAREN ! ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ! ( over_clause )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_count_key_in_standard_function11170);
					count_key813=gPLSQLParser.count_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(count_key813.getTree(), root_0);
					LEFT_PAREN814=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11185); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1133:17: ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper )
					int alt269=2;
					int LA269_0 = input.LA(1);
					if ( (LA269_0==ASTERISK) ) {
						alt269=1;
					}
					else if ( (LA269_0==APPROXIMATE_NUM_LIT||LA269_0==BINDVAR||(LA269_0 >= CHAR_STRING && LA269_0 <= COLON)||LA269_0==DELIMITED_ID||LA269_0==EXACT_NUM_LIT||LA269_0==INTRODUCER||LA269_0==LEFT_PAREN||LA269_0==MINUS_SIGN||LA269_0==NATIONAL_CHAR_STRING_LIT||LA269_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA269_0==PLUS_SIGN||LA269_0==REGULAR_ID||LA269_0==SQL92_RESERVED_ALL||LA269_0==SQL92_RESERVED_ANY||LA269_0==SQL92_RESERVED_CASE||LA269_0==SQL92_RESERVED_DATE||(LA269_0 >= SQL92_RESERVED_DEFAULT && LA269_0 <= SQL92_RESERVED_DELETE)||LA269_0==SQL92_RESERVED_DISTINCT||(LA269_0 >= SQL92_RESERVED_EXISTS && LA269_0 <= SQL92_RESERVED_FALSE)||LA269_0==SQL92_RESERVED_NULL||LA269_0==SQL92_RESERVED_PRIOR||LA269_0==SQL92_RESERVED_TRUE||LA269_0==SQL92_RESERVED_UNIQUE||LA269_0==UNSIGNED_INTEGER) ) {
						alt269=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 269, 0, input);
						throw nvae;
					}

					switch (alt269) {
						case 1 :
							// PLSQL_DMLParser.g:1133:19: ASTERISK
							{
							ASTERISK815=(Token)match(input,ASTERISK,FOLLOW_ASTERISK_in_standard_function11206); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							ASTERISK815_tree = (Object)adaptor.create(ASTERISK815);
							adaptor.addChild(root_0, ASTERISK815_tree);
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1133:30: ( distinct_key | unique_key | all_key )? concatenation_wrapper
							{
							// PLSQL_DMLParser.g:1133:30: ( distinct_key | unique_key | all_key )?
							int alt268=4;
							switch ( input.LA(1) ) {
								case SQL92_RESERVED_DISTINCT:
									{
									alt268=1;
									}
									break;
								case SQL92_RESERVED_UNIQUE:
									{
									alt268=2;
									}
									break;
								case SQL92_RESERVED_ALL:
									{
									alt268=3;
									}
									break;
							}
							switch (alt268) {
								case 1 :
									// PLSQL_DMLParser.g:1133:31: distinct_key
									{
									pushFollow(FOLLOW_distinct_key_in_standard_function11211);
									distinct_key816=gPLSQLParser.distinct_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, distinct_key816.getTree());

									}
									break;
								case 2 :
									// PLSQL_DMLParser.g:1133:44: unique_key
									{
									pushFollow(FOLLOW_unique_key_in_standard_function11213);
									unique_key817=gPLSQLParser.unique_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, unique_key817.getTree());

									}
									break;
								case 3 :
									// PLSQL_DMLParser.g:1133:55: all_key
									{
									pushFollow(FOLLOW_all_key_in_standard_function11215);
									all_key818=gPLSQLParser.all_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, all_key818.getTree());

									}
									break;

							}

							pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11219);
							concatenation_wrapper819=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper819.getTree());

							}
							break;

					}

					RIGHT_PAREN820=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11235); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1134:26: ( over_clause )?
					int alt270=2;
					int LA270_0 = input.LA(1);
					if ( (LA270_0==REGULAR_ID) ) {
						int LA270_1 = input.LA(2);
						if ( (LA270_1==LEFT_PAREN) ) {
							int LA270_3 = input.LA(3);
							if ( (LA270_3==REGULAR_ID) ) {
								int LA270_10 = input.LA(4);
								if ( (LA270_10==SQL92_RESERVED_BY) && ((input.LT(1).getText().equalsIgnoreCase("over")))) {
									alt270=1;
								}
							}
							else if ( (LA270_3==RIGHT_PAREN||LA270_3==SQL92_RESERVED_ORDER) && ((input.LT(1).getText().equalsIgnoreCase("over")))) {
								alt270=1;
							}
						}
					}
					switch (alt270) {
						case 1 :
							// PLSQL_DMLParser.g:1134:26: over_clause
							{
							pushFollow(FOLLOW_over_clause_in_standard_function11238);
							over_clause821=over_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, over_clause821.getTree());

							}
							break;

					}

					}
					break;
				case 4 :
					// PLSQL_DMLParser.g:1135:10: ( cast_key ^| xmlcast_key ^) LEFT_PAREN ! ( ( multiset_key LEFT_PAREN ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !) | concatenation_wrapper ) as_key ! type_spec RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:1135:10: ( cast_key ^| xmlcast_key ^)
					int alt271=2;
					int LA271_0 = input.LA(1);
					if ( (LA271_0==REGULAR_ID) ) {
						int LA271_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("cast"))) ) {
							alt271=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlcast"))) ) {
							alt271=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 271, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 271, 0, input);
						throw nvae;
					}

					switch (alt271) {
						case 1 :
							// PLSQL_DMLParser.g:1135:11: cast_key ^
							{
							pushFollow(FOLLOW_cast_key_in_standard_function11251);
							cast_key822=gPLSQLParser.cast_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(cast_key822.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1135:21: xmlcast_key ^
							{
							pushFollow(FOLLOW_xmlcast_key_in_standard_function11254);
							xmlcast_key823=gPLSQLParser.xmlcast_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlcast_key823.getTree(), root_0);
							}
							break;

					}

					LEFT_PAREN824=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11271); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1137:17: ( ( multiset_key LEFT_PAREN ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !) | concatenation_wrapper )
					int alt272=2;
					int LA272_0 = input.LA(1);
					if ( (LA272_0==REGULAR_ID) ) {
						int LA272_1 = input.LA(2);
						if ( ((synpred48_PLSQL_DMLParser()&&(input.LT(1).getText().equalsIgnoreCase("multiset")))) ) {
							alt272=1;
						}
						else if ( (true) ) {
							alt272=2;
						}

					}
					else if ( (LA272_0==APPROXIMATE_NUM_LIT||LA272_0==BINDVAR||(LA272_0 >= CHAR_STRING && LA272_0 <= COLON)||LA272_0==DELIMITED_ID||LA272_0==EXACT_NUM_LIT||LA272_0==INTRODUCER||LA272_0==LEFT_PAREN||LA272_0==MINUS_SIGN||LA272_0==NATIONAL_CHAR_STRING_LIT||LA272_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA272_0==PLUS_SIGN||LA272_0==SQL92_RESERVED_ALL||LA272_0==SQL92_RESERVED_ANY||LA272_0==SQL92_RESERVED_CASE||LA272_0==SQL92_RESERVED_DATE||(LA272_0 >= SQL92_RESERVED_DEFAULT && LA272_0 <= SQL92_RESERVED_DELETE)||LA272_0==SQL92_RESERVED_DISTINCT||(LA272_0 >= SQL92_RESERVED_EXISTS && LA272_0 <= SQL92_RESERVED_FALSE)||LA272_0==SQL92_RESERVED_NULL||LA272_0==SQL92_RESERVED_PRIOR||LA272_0==SQL92_RESERVED_TRUE||LA272_0==UNSIGNED_INTEGER) ) {
						alt272=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 272, 0, input);
						throw nvae;
					}

					switch (alt272) {
						case 1 :
							// PLSQL_DMLParser.g:1137:19: ( multiset_key LEFT_PAREN ( select_key | with_key ) )=> ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !)
							{
							// PLSQL_DMLParser.g:1137:70: ( multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !)
							// PLSQL_DMLParser.g:1137:71: multiset_key ! LEFT_PAREN ! subquery RIGHT_PAREN !
							{
							pushFollow(FOLLOW_multiset_key_in_standard_function11307);
							multiset_key825=gPLSQLParser.multiset_key();
							state._fsp--;
							if (state.failed) return retval;
							LEFT_PAREN826=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11310); if (state.failed) return retval;
							pushFollow(FOLLOW_subquery_in_standard_function11313);
							subquery827=subquery();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, subquery827.getTree());

							RIGHT_PAREN828=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11315); if (state.failed) return retval;
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1138:19: concatenation_wrapper
							{
							pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11337);
							concatenation_wrapper829=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper829.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_as_key_in_standard_function11373);
					as_key830=gPLSQLParser.as_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_type_spec_in_standard_function11376);
					type_spec831=gPLSQLParser.type_spec();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, type_spec831.getTree());

					RIGHT_PAREN832=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11390); if (state.failed) return retval;
					}
					break;
				case 5 :
					// PLSQL_DMLParser.g:1142:10: chr_key ^ LEFT_PAREN ! concatenation_wrapper using_key ! nchar_cs_key RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_chr_key_in_standard_function11402);
					chr_key833=gPLSQLParser.chr_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(chr_key833.getTree(), root_0);
					LEFT_PAREN834=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11417); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11437);
					concatenation_wrapper835=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper835.getTree());

					pushFollow(FOLLOW_using_key_in_standard_function11439);
					using_key836=gPLSQLParser.using_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_nchar_cs_key_in_standard_function11442);
					nchar_cs_key837=gPLSQLParser.nchar_cs_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, nchar_cs_key837.getTree());

					RIGHT_PAREN838=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11457); if (state.failed) return retval;
					}
					break;
				case 6 :
					// PLSQL_DMLParser.g:1146:10: collect_key ^ LEFT_PAREN ! ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_collect_key_in_standard_function11469);
					collect_key839=gPLSQLParser.collect_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(collect_key839.getTree(), root_0);
					LEFT_PAREN840=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11484); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1148:17: ( distinct_key | unique_key )?
					int alt273=3;
					int LA273_0 = input.LA(1);
					if ( (LA273_0==SQL92_RESERVED_DISTINCT) ) {
						alt273=1;
					}
					else if ( (LA273_0==SQL92_RESERVED_UNIQUE) ) {
						alt273=2;
					}
					switch (alt273) {
						case 1 :
							// PLSQL_DMLParser.g:1148:18: distinct_key
							{
							pushFollow(FOLLOW_distinct_key_in_standard_function11505);
							distinct_key841=gPLSQLParser.distinct_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, distinct_key841.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1148:31: unique_key
							{
							pushFollow(FOLLOW_unique_key_in_standard_function11507);
							unique_key842=gPLSQLParser.unique_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, unique_key842.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11511);
					concatenation_wrapper843=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper843.getTree());

					// PLSQL_DMLParser.g:1148:66: ( collect_order_by_part )?
					int alt274=2;
					int LA274_0 = input.LA(1);
					if ( (LA274_0==SQL92_RESERVED_ORDER) ) {
						alt274=1;
					}
					switch (alt274) {
						case 1 :
							// PLSQL_DMLParser.g:1148:66: collect_order_by_part
							{
							pushFollow(FOLLOW_collect_order_by_part_in_standard_function11513);
							collect_order_by_part844=collect_order_by_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, collect_order_by_part844.getTree());

							}
							break;

					}

					RIGHT_PAREN845=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11528); if (state.failed) return retval;
					}
					break;
				case 7 :
					// PLSQL_DMLParser.g:1150:10: stantard_function_enabling_within_or_over ^ function_argument within_or_over_part
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_stantard_function_enabling_within_or_over_in_standard_function11540);
					stantard_function_enabling_within_or_over846=stantard_function_enabling_within_or_over();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(stantard_function_enabling_within_or_over846.getTree(), root_0);
					pushFollow(FOLLOW_function_argument_in_standard_function11556);
					function_argument847=gPLSQLParser.function_argument();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, function_argument847.getTree());

					pushFollow(FOLLOW_within_or_over_part_in_standard_function11558);
					within_or_over_part848=within_or_over_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, within_or_over_part848.getTree());

					}
					break;
				case 8 :
					// PLSQL_DMLParser.g:1152:10: decompose_key ^ LEFT_PAREN ! concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_decompose_key_in_standard_function11569);
					decompose_key849=gPLSQLParser.decompose_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(decompose_key849.getTree(), root_0);
					LEFT_PAREN850=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11584); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11604);
					concatenation_wrapper851=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper851.getTree());

					// PLSQL_DMLParser.g:1154:39: ( canonical_key | compatibility_key )?
					int alt275=3;
					int LA275_0 = input.LA(1);
					if ( (LA275_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("canonical"))||(input.LT(1).getText().equalsIgnoreCase("compatibility"))))) {
						int LA275_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("canonical"))) ) {
							alt275=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("compatibility"))) ) {
							alt275=2;
						}
					}
					switch (alt275) {
						case 1 :
							// PLSQL_DMLParser.g:1154:40: canonical_key
							{
							pushFollow(FOLLOW_canonical_key_in_standard_function11607);
							canonical_key852=gPLSQLParser.canonical_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, canonical_key852.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1154:54: compatibility_key
							{
							pushFollow(FOLLOW_compatibility_key_in_standard_function11609);
							compatibility_key853=gPLSQLParser.compatibility_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, compatibility_key853.getTree());

							}
							break;

					}

					RIGHT_PAREN854=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11626); if (state.failed) return retval;
					}
					break;
				case 9 :
					// PLSQL_DMLParser.g:1156:10: extract_key ^ LEFT_PAREN ! ( year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key ) from_key ! concatenation_wrapper RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_extract_key_in_standard_function11638);
					extract_key855=gPLSQLParser.extract_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(extract_key855.getTree(), root_0);
					LEFT_PAREN856=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11653); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1158:17: ( year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key )
					int alt276=10;
					int LA276_0 = input.LA(1);
					if ( (LA276_0==REGULAR_ID) ) {
						int LA276_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("year"))) ) {
							alt276=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("month"))) ) {
							alt276=2;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("day"))) ) {
							alt276=3;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("hour"))) ) {
							alt276=4;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("minute"))) ) {
							alt276=5;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("second"))) ) {
							alt276=6;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timezone_hour"))) ) {
							alt276=7;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timezone_minute"))) ) {
							alt276=8;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timezone_region"))) ) {
							alt276=9;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("timezone_abbr"))) ) {
							alt276=10;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 276, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 276, 0, input);
						throw nvae;
					}

					switch (alt276) {
						case 1 :
							// PLSQL_DMLParser.g:1159:19: year_key
							{
							pushFollow(FOLLOW_year_key_in_standard_function11692);
							year_key857=gPLSQLParser.year_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, year_key857.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1159:28: month_key
							{
							pushFollow(FOLLOW_month_key_in_standard_function11694);
							month_key858=gPLSQLParser.month_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, month_key858.getTree());

							}
							break;
						case 3 :
							// PLSQL_DMLParser.g:1159:38: day_key
							{
							pushFollow(FOLLOW_day_key_in_standard_function11696);
							day_key859=gPLSQLParser.day_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, day_key859.getTree());

							}
							break;
						case 4 :
							// PLSQL_DMLParser.g:1159:46: hour_key
							{
							pushFollow(FOLLOW_hour_key_in_standard_function11698);
							hour_key860=gPLSQLParser.hour_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, hour_key860.getTree());

							}
							break;
						case 5 :
							// PLSQL_DMLParser.g:1159:55: minute_key
							{
							pushFollow(FOLLOW_minute_key_in_standard_function11700);
							minute_key861=gPLSQLParser.minute_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, minute_key861.getTree());

							}
							break;
						case 6 :
							// PLSQL_DMLParser.g:1160:20: second_key
							{
							pushFollow(FOLLOW_second_key_in_standard_function11721);
							second_key862=gPLSQLParser.second_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, second_key862.getTree());

							}
							break;
						case 7 :
							// PLSQL_DMLParser.g:1160:31: timezone_hour_key
							{
							pushFollow(FOLLOW_timezone_hour_key_in_standard_function11723);
							timezone_hour_key863=gPLSQLParser.timezone_hour_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, timezone_hour_key863.getTree());

							}
							break;
						case 8 :
							// PLSQL_DMLParser.g:1160:49: timezone_minute_key
							{
							pushFollow(FOLLOW_timezone_minute_key_in_standard_function11725);
							timezone_minute_key864=gPLSQLParser.timezone_minute_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, timezone_minute_key864.getTree());

							}
							break;
						case 9 :
							// PLSQL_DMLParser.g:1161:20: timezone_region_key
							{
							pushFollow(FOLLOW_timezone_region_key_in_standard_function11746);
							timezone_region_key865=gPLSQLParser.timezone_region_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, timezone_region_key865.getTree());

							}
							break;
						case 10 :
							// PLSQL_DMLParser.g:1161:40: timezone_abbr_key
							{
							pushFollow(FOLLOW_timezone_abbr_key_in_standard_function11748);
							timezone_abbr_key866=gPLSQLParser.timezone_abbr_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, timezone_abbr_key866.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_from_key_in_standard_function11784);
					from_key867=gPLSQLParser.from_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11787);
					concatenation_wrapper868=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper868.getTree());

					RIGHT_PAREN869=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11802); if (state.failed) return retval;
					}
					break;
				case 10 :
					// PLSQL_DMLParser.g:1165:10: ( first_value_key ^| last_value_key ^) LEFT_PAREN ! concatenation_wrapper ( ignore_key ! nulls_key )? RIGHT_PAREN ! over_clause
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:1165:10: ( first_value_key ^| last_value_key ^)
					int alt277=2;
					int LA277_0 = input.LA(1);
					if ( (LA277_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("last_value"))||(input.LT(1).getText().equalsIgnoreCase("first_value"))))) {
						int LA277_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("first_value"))) ) {
							alt277=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("last_value"))) ) {
							alt277=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 277, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt277) {
						case 1 :
							// PLSQL_DMLParser.g:1165:11: first_value_key ^
							{
							pushFollow(FOLLOW_first_value_key_in_standard_function11815);
							first_value_key870=gPLSQLParser.first_value_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(first_value_key870.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1165:28: last_value_key ^
							{
							pushFollow(FOLLOW_last_value_key_in_standard_function11818);
							last_value_key871=gPLSQLParser.last_value_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(last_value_key871.getTree(), root_0);
							}
							break;

					}

					LEFT_PAREN872=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11835); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function11854);
					concatenation_wrapper873=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper873.getTree());

					// PLSQL_DMLParser.g:1167:39: ( ignore_key ! nulls_key )?
					int alt278=2;
					int LA278_0 = input.LA(1);
					if ( (LA278_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("ignore")))) {
						alt278=1;
					}
					switch (alt278) {
						case 1 :
							// PLSQL_DMLParser.g:1167:40: ignore_key ! nulls_key
							{
							pushFollow(FOLLOW_ignore_key_in_standard_function11857);
							ignore_key874=gPLSQLParser.ignore_key();
							state._fsp--;
							if (state.failed) return retval;
							pushFollow(FOLLOW_nulls_key_in_standard_function11860);
							nulls_key875=gPLSQLParser.nulls_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, nulls_key875.getTree());

							}
							break;

					}

					RIGHT_PAREN876=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function11877); if (state.failed) return retval;
					pushFollow(FOLLOW_over_clause_in_standard_function11880);
					over_clause877=over_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, over_clause877.getTree());

					}
					break;
				case 11 :
					// PLSQL_DMLParser.g:1169:10: ( first_value_key ^| last_value_key ^) function_argument_analytic ( respect_or_ignore_nulls )? over_clause
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:1169:10: ( first_value_key ^| last_value_key ^)
					int alt279=2;
					int LA279_0 = input.LA(1);
					if ( (LA279_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("last_value"))||(input.LT(1).getText().equalsIgnoreCase("first_value"))))) {
						int LA279_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("first_value"))) ) {
							alt279=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("last_value"))) ) {
							alt279=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 279, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt279) {
						case 1 :
							// PLSQL_DMLParser.g:1169:11: first_value_key ^
							{
							pushFollow(FOLLOW_first_value_key_in_standard_function11892);
							first_value_key878=gPLSQLParser.first_value_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(first_value_key878.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1169:28: last_value_key ^
							{
							pushFollow(FOLLOW_last_value_key_in_standard_function11895);
							last_value_key879=gPLSQLParser.last_value_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(last_value_key879.getTree(), root_0);
							}
							break;

					}

					pushFollow(FOLLOW_function_argument_analytic_in_standard_function11912);
					function_argument_analytic880=gPLSQLParser.function_argument_analytic();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, function_argument_analytic880.getTree());

					// PLSQL_DMLParser.g:1171:14: ( respect_or_ignore_nulls )?
					int alt280=2;
					int LA280_0 = input.LA(1);
					if ( (LA280_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("respect"))||(input.LT(1).getText().equalsIgnoreCase("over"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
						int LA280_1 = input.LA(2);
						if ( (LA280_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("respect"))||(input.LT(1).getText().equalsIgnoreCase("ignore"))))) {
							alt280=1;
						}
					}
					switch (alt280) {
						case 1 :
							// PLSQL_DMLParser.g:1171:14: respect_or_ignore_nulls
							{
							pushFollow(FOLLOW_respect_or_ignore_nulls_in_standard_function11927);
							respect_or_ignore_nulls881=gPLSQLParser.respect_or_ignore_nulls();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, respect_or_ignore_nulls881.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_over_clause_in_standard_function11930);
					over_clause882=over_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, over_clause882.getTree());

					}
					break;
				case 12 :
					// PLSQL_DMLParser.g:1172:10: stantard_function_pedictions ^ LEFT_PAREN ! expression_wrapper ( COMMA ! expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_stantard_function_pedictions_in_standard_function11941);
					stantard_function_pedictions883=stantard_function_pedictions();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(stantard_function_pedictions883.getTree(), root_0);
					LEFT_PAREN884=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function11956); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function11975);
					expression_wrapper885=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper885.getTree());

					// PLSQL_DMLParser.g:1174:36: ( COMMA ! expression_wrapper )*
					loop281:
					while (true) {
						int alt281=2;
						int LA281_0 = input.LA(1);
						if ( (LA281_0==COMMA) ) {
							alt281=1;
						}

						switch (alt281) {
						case 1 :
							// PLSQL_DMLParser.g:1174:37: COMMA ! expression_wrapper
							{
							COMMA886=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function11978); if (state.failed) return retval;
							pushFollow(FOLLOW_expression_wrapper_in_standard_function11981);
							expression_wrapper887=expression_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper887.getTree());

							}
							break;

						default :
							break loop281;
						}
					}

					// PLSQL_DMLParser.g:1174:65: ( cost_matrix_clause )?
					int alt282=2;
					int LA282_0 = input.LA(1);
					if ( (LA282_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("cost")))) {
						alt282=1;
					}
					switch (alt282) {
						case 1 :
							// PLSQL_DMLParser.g:1174:65: cost_matrix_clause
							{
							pushFollow(FOLLOW_cost_matrix_clause_in_standard_function11985);
							cost_matrix_clause888=cost_matrix_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, cost_matrix_clause888.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1174:85: ( using_clause )?
					int alt283=2;
					int LA283_0 = input.LA(1);
					if ( (LA283_0==PLSQL_NON_RESERVED_USING) ) {
						alt283=1;
					}
					switch (alt283) {
						case 1 :
							// PLSQL_DMLParser.g:1174:85: using_clause
							{
							pushFollow(FOLLOW_using_clause_in_standard_function11988);
							using_clause889=using_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, using_clause889.getTree());

							}
							break;

					}

					RIGHT_PAREN890=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12004); if (state.failed) return retval;
					}
					break;
				case 13 :
					// PLSQL_DMLParser.g:1176:10: translate_key ^ LEFT_PAREN ! expression_wrapper COMMA ! expression_wrapper COMMA ! expression_wrapper RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_translate_key_in_standard_function12016);
					translate_key891=gPLSQLParser.translate_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(translate_key891.getTree(), root_0);
					LEFT_PAREN892=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12031); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12051);
					expression_wrapper893=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper893.getTree());

					COMMA894=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function12070); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12073);
					expression_wrapper895=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper895.getTree());

					COMMA896=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function12091); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12094);
					expression_wrapper897=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper897.getTree());

					RIGHT_PAREN898=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12108); if (state.failed) return retval;
					}
					break;
				case 14 :
					// PLSQL_DMLParser.g:1182:10: treat_key ^ LEFT_PAREN ! expression_wrapper as_key ! ( ref_key )? type_spec RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_treat_key_in_standard_function12120);
					treat_key899=gPLSQLParser.treat_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(treat_key899.getTree(), root_0);
					LEFT_PAREN900=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12135); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12154);
					expression_wrapper901=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper901.getTree());

					pushFollow(FOLLOW_as_key_in_standard_function12156);
					as_key902=gPLSQLParser.as_key();
					state._fsp--;
					if (state.failed) return retval;
					// PLSQL_DMLParser.g:1184:44: ( ref_key )?
					int alt284=2;
					int LA284_0 = input.LA(1);
					if ( (LA284_0==REGULAR_ID) ) {
						int LA284_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("ref"))) ) {
							alt284=1;
						}
					}
					switch (alt284) {
						case 1 :
							// PLSQL_DMLParser.g:1184:44: ref_key
							{
							pushFollow(FOLLOW_ref_key_in_standard_function12159);
							ref_key903=gPLSQLParser.ref_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, ref_key903.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_type_spec_in_standard_function12162);
					type_spec904=gPLSQLParser.type_spec();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, type_spec904.getTree());

					RIGHT_PAREN905=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12177); if (state.failed) return retval;
					}
					break;
				case 15 :
					// PLSQL_DMLParser.g:1186:10: trim_key LEFT_PAREN ( (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key ) expr_ch= expression from_key expr_src= concatenation -> ^( trim_key $expr_src $expr_ch $trim_kind) |expr1= expression ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) ) ) RIGHT_PAREN
					{
					pushFollow(FOLLOW_trim_key_in_standard_function12189);
					trim_key906=gPLSQLParser.trim_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_trim_key.add(trim_key906.getTree());
					LEFT_PAREN907=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12203); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_LEFT_PAREN.add(LEFT_PAREN907);

					// PLSQL_DMLParser.g:1188:17: ( (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key ) expr_ch= expression from_key expr_src= concatenation -> ^( trim_key $expr_src $expr_ch $trim_kind) |expr1= expression ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) ) )
					int alt287=2;
					int LA287_0 = input.LA(1);
					if ( (LA287_0==REGULAR_ID) ) {
						int LA287_1 = input.LA(2);
						if ( (((input.LT(1).getText().equalsIgnoreCase("trailing"))||(input.LT(1).getText().equalsIgnoreCase("both"))||(input.LT(1).getText().equalsIgnoreCase("leading")))) ) {
							alt287=1;
						}
						else if ( (true) ) {
							alt287=2;
						}

					}
					else if ( (LA287_0==APPROXIMATE_NUM_LIT||LA287_0==BINDVAR||(LA287_0 >= CHAR_STRING && LA287_0 <= COLON)||LA287_0==DELIMITED_ID||LA287_0==EXACT_NUM_LIT||LA287_0==INTRODUCER||LA287_0==LEFT_PAREN||LA287_0==MINUS_SIGN||LA287_0==NATIONAL_CHAR_STRING_LIT||LA287_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA287_0==PLUS_SIGN||LA287_0==SQL92_RESERVED_ALL||LA287_0==SQL92_RESERVED_ANY||LA287_0==SQL92_RESERVED_CASE||(LA287_0 >= SQL92_RESERVED_CURSOR && LA287_0 <= SQL92_RESERVED_DATE)||(LA287_0 >= SQL92_RESERVED_DEFAULT && LA287_0 <= SQL92_RESERVED_DELETE)||LA287_0==SQL92_RESERVED_DISTINCT||(LA287_0 >= SQL92_RESERVED_EXISTS && LA287_0 <= SQL92_RESERVED_FALSE)||(LA287_0 >= SQL92_RESERVED_NOT && LA287_0 <= SQL92_RESERVED_NULL)||LA287_0==SQL92_RESERVED_PRIOR||LA287_0==SQL92_RESERVED_TRUE||LA287_0==UNSIGNED_INTEGER) ) {
						alt287=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 287, 0, input);
						throw nvae;
					}

					switch (alt287) {
						case 1 :
							// PLSQL_DMLParser.g:1189:19: (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key ) expr_ch= expression from_key expr_src= concatenation
							{
							// PLSQL_DMLParser.g:1189:19: (trim_kind= leading_key |trim_kind= trailing_key |trim_kind= both_key )
							int alt285=3;
							int LA285_0 = input.LA(1);
							if ( (LA285_0==REGULAR_ID) ) {
								int LA285_1 = input.LA(2);
								if ( ((input.LT(1).getText().equalsIgnoreCase("leading"))) ) {
									alt285=1;
								}
								else if ( ((input.LT(1).getText().equalsIgnoreCase("trailing"))) ) {
									alt285=2;
								}
								else if ( ((input.LT(1).getText().equalsIgnoreCase("both"))) ) {
									alt285=3;
								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										input.consume();
										NoViableAltException nvae =
											new NoViableAltException("", 285, 1, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae =
									new NoViableAltException("", 285, 0, input);
								throw nvae;
							}

							switch (alt285) {
								case 1 :
									// PLSQL_DMLParser.g:1189:20: trim_kind= leading_key
									{
									pushFollow(FOLLOW_leading_key_in_standard_function12244);
									trim_kind=gPLSQLParser.leading_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_leading_key.add(trim_kind.getTree());
									}
									break;
								case 2 :
									// PLSQL_DMLParser.g:1189:42: trim_kind= trailing_key
									{
									pushFollow(FOLLOW_trailing_key_in_standard_function12248);
									trim_kind=gPLSQLParser.trailing_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_trailing_key.add(trim_kind.getTree());
									}
									break;
								case 3 :
									// PLSQL_DMLParser.g:1189:65: trim_kind= both_key
									{
									pushFollow(FOLLOW_both_key_in_standard_function12252);
									trim_kind=gPLSQLParser.both_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_both_key.add(trim_kind.getTree());
									}
									break;

							}

							pushFollow(FOLLOW_expression_in_standard_function12275);
							expr_ch=expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_expression.add(expr_ch.getTree());
							pushFollow(FOLLOW_from_key_in_standard_function12295);
							from_key908=gPLSQLParser.from_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_from_key.add(from_key908.getTree());
							pushFollow(FOLLOW_concatenation_in_standard_function12317);
							expr_src=concatenation();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation.add(expr_src.getTree());
							// AST REWRITE
							// elements: expr_src, trim_key, expr_ch, trim_kind
							// token labels: 
							// rule labels: trim_kind, expr_ch, expr_src, retval
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
							if ( state.backtracking==0 ) {
							retval.tree = root_0;
							RewriteRuleSubtreeStream stream_trim_kind=new RewriteRuleSubtreeStream(adaptor,"rule trim_kind",trim_kind!=null?trim_kind.getTree():null);
							RewriteRuleSubtreeStream stream_expr_ch=new RewriteRuleSubtreeStream(adaptor,"rule expr_ch",expr_ch!=null?expr_ch.getTree():null);
							RewriteRuleSubtreeStream stream_expr_src=new RewriteRuleSubtreeStream(adaptor,"rule expr_src",expr_src!=null?expr_src.getTree():null);
							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

							root_0 = (Object)adaptor.nil();
							// 1193:21: -> ^( trim_key $expr_src $expr_ch $trim_kind)
							{
								// PLSQL_DMLParser.g:1193:24: ^( trim_key $expr_src $expr_ch $trim_kind)
								{
								Object root_1 = (Object)adaptor.nil();
								root_1 = (Object)adaptor.becomeRoot(stream_trim_key.nextNode(), root_1);
								adaptor.addChild(root_1, stream_expr_src.nextTree());
								adaptor.addChild(root_1, stream_expr_ch.nextTree());
								adaptor.addChild(root_1, stream_trim_kind.nextTree());
								adaptor.addChild(root_0, root_1);
								}

							}


							retval.tree = root_0;
							}

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1194:21: expr1= expression ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) )
							{
							pushFollow(FOLLOW_expression_in_standard_function12376);
							expr1=expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_expression.add(expr1.getTree());
							// PLSQL_DMLParser.g:1195:21: ( from_key expr2= expression -> ^( trim_key $expr2 $expr1) | -> ^( trim_key $expr1) )
							int alt286=2;
							int LA286_0 = input.LA(1);
							if ( (LA286_0==SQL92_RESERVED_FROM) ) {
								alt286=1;
							}
							else if ( (LA286_0==RIGHT_PAREN) ) {
								alt286=2;
							}

							else {
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae =
									new NoViableAltException("", 286, 0, input);
								throw nvae;
							}

							switch (alt286) {
								case 1 :
									// PLSQL_DMLParser.g:1196:23: from_key expr2= expression
									{
									pushFollow(FOLLOW_from_key_in_standard_function12422);
									from_key909=gPLSQLParser.from_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_from_key.add(from_key909.getTree());
									pushFollow(FOLLOW_expression_in_standard_function12426);
									expr2=expression();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) stream_expression.add(expr2.getTree());
									// AST REWRITE
									// elements: trim_key, expr2, expr1
									// token labels: 
									// rule labels: expr2, expr1, retval
									// token list labels: 
									// rule list labels: 
									// wildcard labels: 
									if ( state.backtracking==0 ) {
									retval.tree = root_0;
									RewriteRuleSubtreeStream stream_expr2=new RewriteRuleSubtreeStream(adaptor,"rule expr2",expr2!=null?expr2.getTree():null);
									RewriteRuleSubtreeStream stream_expr1=new RewriteRuleSubtreeStream(adaptor,"rule expr1",expr1!=null?expr1.getTree():null);
									RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

									root_0 = (Object)adaptor.nil();
									// 1197:25: -> ^( trim_key $expr2 $expr1)
									{
										// PLSQL_DMLParser.g:1197:28: ^( trim_key $expr2 $expr1)
										{
										Object root_1 = (Object)adaptor.nil();
										root_1 = (Object)adaptor.becomeRoot(stream_trim_key.nextNode(), root_1);
										adaptor.addChild(root_1, stream_expr2.nextTree());
										adaptor.addChild(root_1, stream_expr1.nextTree());
										adaptor.addChild(root_0, root_1);
										}

									}


									retval.tree = root_0;
									}

									}
									break;
								case 2 :
									// PLSQL_DMLParser.g:1199:25: 
									{
									// AST REWRITE
									// elements: expr1, trim_key
									// token labels: 
									// rule labels: expr1, retval
									// token list labels: 
									// rule list labels: 
									// wildcard labels: 
									if ( state.backtracking==0 ) {
									retval.tree = root_0;
									RewriteRuleSubtreeStream stream_expr1=new RewriteRuleSubtreeStream(adaptor,"rule expr1",expr1!=null?expr1.getTree():null);
									RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

									root_0 = (Object)adaptor.nil();
									// 1199:25: -> ^( trim_key $expr1)
									{
										// PLSQL_DMLParser.g:1199:28: ^( trim_key $expr1)
										{
										Object root_1 = (Object)adaptor.nil();
										root_1 = (Object)adaptor.becomeRoot(stream_trim_key.nextNode(), root_1);
										adaptor.addChild(root_1, stream_expr1.nextTree());
										adaptor.addChild(root_0, root_1);
										}

									}


									retval.tree = root_0;
									}

									}
									break;

							}

							}
							break;

					}

					RIGHT_PAREN910=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12573); if (state.failed) return retval; 
					if ( state.backtracking==0 ) stream_RIGHT_PAREN.add(RIGHT_PAREN910);

					}
					break;
				case 16 :
					// PLSQL_DMLParser.g:1203:10: xmlagg_key ^ LEFT_PAREN ! expression_wrapper ( order_by_clause )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlagg_key_in_standard_function12584);
					xmlagg_key911=gPLSQLParser.xmlagg_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlagg_key911.getTree(), root_0);
					LEFT_PAREN912=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12599); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12619);
					expression_wrapper913=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper913.getTree());

					// PLSQL_DMLParser.g:1205:36: ( order_by_clause )?
					int alt288=2;
					int LA288_0 = input.LA(1);
					if ( (LA288_0==SQL92_RESERVED_ORDER) ) {
						alt288=1;
					}
					switch (alt288) {
						case 1 :
							// PLSQL_DMLParser.g:1205:36: order_by_clause
							{
							pushFollow(FOLLOW_order_by_clause_in_standard_function12621);
							order_by_clause914=order_by_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, order_by_clause914.getTree());

							}
							break;

					}

					RIGHT_PAREN915=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12637); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1207:13: ( PERIOD general_element_id )?
					int alt289=2;
					int LA289_0 = input.LA(1);
					if ( (LA289_0==PERIOD) ) {
						alt289=1;
					}
					switch (alt289) {
						case 1 :
							// PLSQL_DMLParser.g:1207:14: PERIOD general_element_id
							{
							PERIOD916=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function12653); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD916_tree = (Object)adaptor.create(PERIOD916);
							adaptor.addChild(root_0, PERIOD916_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function12655);
							general_element_id917=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id917.getTree());

							}
							break;

					}

					}
					break;
				case 17 :
					// PLSQL_DMLParser.g:1208:10: ( xmlcolattval_key ^| xmlforest_key ^) LEFT_PAREN ! xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					// PLSQL_DMLParser.g:1208:10: ( xmlcolattval_key ^| xmlforest_key ^)
					int alt290=2;
					int LA290_0 = input.LA(1);
					if ( (LA290_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("xmlcolattval"))||(input.LT(1).getText().equalsIgnoreCase("xmlforest"))))) {
						int LA290_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("xmlcolattval"))) ) {
							alt290=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("xmlforest"))) ) {
							alt290=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 290, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt290) {
						case 1 :
							// PLSQL_DMLParser.g:1208:11: xmlcolattval_key ^
							{
							pushFollow(FOLLOW_xmlcolattval_key_in_standard_function12669);
							xmlcolattval_key918=gPLSQLParser.xmlcolattval_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlcolattval_key918.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1208:29: xmlforest_key ^
							{
							pushFollow(FOLLOW_xmlforest_key_in_standard_function12672);
							xmlforest_key919=gPLSQLParser.xmlforest_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlforest_key919.getTree(), root_0);
							}
							break;

					}

					LEFT_PAREN920=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12689); if (state.failed) return retval;
					pushFollow(FOLLOW_xml_multiuse_expression_element_in_standard_function12708);
					xml_multiuse_expression_element921=xml_multiuse_expression_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_multiuse_expression_element921.getTree());

					// PLSQL_DMLParser.g:1210:49: ( COMMA ! xml_multiuse_expression_element )*
					loop291:
					while (true) {
						int alt291=2;
						int LA291_0 = input.LA(1);
						if ( (LA291_0==COMMA) ) {
							alt291=1;
						}

						switch (alt291) {
						case 1 :
							// PLSQL_DMLParser.g:1210:50: COMMA ! xml_multiuse_expression_element
							{
							COMMA922=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function12711); if (state.failed) return retval;
							pushFollow(FOLLOW_xml_multiuse_expression_element_in_standard_function12714);
							xml_multiuse_expression_element923=xml_multiuse_expression_element();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_multiuse_expression_element923.getTree());

							}
							break;

						default :
							break loop291;
						}
					}

					RIGHT_PAREN924=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12730); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1212:13: ( PERIOD general_element_id )?
					int alt292=2;
					int LA292_0 = input.LA(1);
					if ( (LA292_0==PERIOD) ) {
						alt292=1;
					}
					switch (alt292) {
						case 1 :
							// PLSQL_DMLParser.g:1212:14: PERIOD general_element_id
							{
							PERIOD925=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function12746); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD925_tree = (Object)adaptor.create(PERIOD925);
							adaptor.addChild(root_0, PERIOD925_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function12748);
							general_element_id926=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id926.getTree());

							}
							break;

					}

					}
					break;
				case 18 :
					// PLSQL_DMLParser.g:1213:10: xmlelement_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA ! xml_attributes_clause )? ( COMMA ! expression_wrapper ( column_alias )? )* RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlelement_key_in_standard_function12761);
					xmlelement_key927=gPLSQLParser.xmlelement_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlelement_key927.getTree(), root_0);
					LEFT_PAREN928=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12776); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1215:17: ( entityescaping_key | noentityescaping_key )?
					int alt293=3;
					int LA293_0 = input.LA(1);
					if ( (LA293_0==REGULAR_ID) ) {
						int LA293_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("entityescaping"))) ) {
							alt293=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("noentityescaping"))) ) {
							alt293=2;
						}
					}
					switch (alt293) {
						case 1 :
							// PLSQL_DMLParser.g:1215:18: entityescaping_key
							{
							pushFollow(FOLLOW_entityescaping_key_in_standard_function12796);
							entityescaping_key929=gPLSQLParser.entityescaping_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, entityescaping_key929.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1215:37: noentityescaping_key
							{
							pushFollow(FOLLOW_noentityescaping_key_in_standard_function12798);
							noentityescaping_key930=gPLSQLParser.noentityescaping_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, noentityescaping_key930.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1216:17: ( name_key | evalname_key )?
					int alt294=3;
					int LA294_0 = input.LA(1);
					if ( (LA294_0==REGULAR_ID) ) {
						int LA294_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("name"))) ) {
							alt294=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("evalname"))) ) {
							alt294=2;
						}
					}
					switch (alt294) {
						case 1 :
							// PLSQL_DMLParser.g:1216:18: name_key
							{
							pushFollow(FOLLOW_name_key_in_standard_function12819);
							name_key931=gPLSQLParser.name_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, name_key931.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1216:27: evalname_key
							{
							pushFollow(FOLLOW_evalname_key_in_standard_function12821);
							evalname_key932=gPLSQLParser.evalname_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, evalname_key932.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_expression_wrapper_in_standard_function12825);
					expression_wrapper933=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper933.getTree());

					// PLSQL_DMLParser.g:1217:17: ({...}? COMMA ! xml_attributes_clause )?
					int alt295=2;
					int LA295_0 = input.LA(1);
					if ( (LA295_0==COMMA) ) {
						int LA295_1 = input.LA(2);
						if ( ((input.LT(2).getText().equalsIgnoreCase("xmlattributes"))) ) {
							alt295=1;
						}
					}
					switch (alt295) {
						case 1 :
							// PLSQL_DMLParser.g:1217:18: {...}? COMMA ! xml_attributes_clause
							{
							if ( !((input.LT(2).getText().equalsIgnoreCase("xmlattributes"))) ) {
								if (state.backtracking>0) {state.failed=true; return retval;}
								throw new FailedPredicateException(input, "standard_function", "input.LT(2).getText().equalsIgnoreCase(\"xmlattributes\")");
							}
							COMMA934=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function12846); if (state.failed) return retval;
							pushFollow(FOLLOW_xml_attributes_clause_in_standard_function12849);
							xml_attributes_clause935=xml_attributes_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_attributes_clause935.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1218:17: ( COMMA ! expression_wrapper ( column_alias )? )*
					loop297:
					while (true) {
						int alt297=2;
						int LA297_0 = input.LA(1);
						if ( (LA297_0==COMMA) ) {
							alt297=1;
						}

						switch (alt297) {
						case 1 :
							// PLSQL_DMLParser.g:1218:18: COMMA ! expression_wrapper ( column_alias )?
							{
							COMMA936=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function12870); if (state.failed) return retval;
							pushFollow(FOLLOW_expression_wrapper_in_standard_function12873);
							expression_wrapper937=expression_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper937.getTree());

							// PLSQL_DMLParser.g:1218:44: ( column_alias )?
							int alt296=2;
							int LA296_0 = input.LA(1);
							if ( ((LA296_0 >= CHAR_STRING && LA296_0 <= CHAR_STRING_PERL)||LA296_0==DELIMITED_ID||LA296_0==INTRODUCER||LA296_0==NATIONAL_CHAR_STRING_LIT||LA296_0==REGULAR_ID||LA296_0==SQL92_RESERVED_AS) ) {
								alt296=1;
							}
							switch (alt296) {
								case 1 :
									// PLSQL_DMLParser.g:1218:44: column_alias
									{
									pushFollow(FOLLOW_column_alias_in_standard_function12875);
									column_alias938=gPLSQLParser.column_alias();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, column_alias938.getTree());

									}
									break;

							}

							}
							break;

						default :
							break loop297;
						}
					}

					RIGHT_PAREN939=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12892); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1220:13: ( PERIOD general_element_id )?
					int alt298=2;
					int LA298_0 = input.LA(1);
					if ( (LA298_0==PERIOD) ) {
						alt298=1;
					}
					switch (alt298) {
						case 1 :
							// PLSQL_DMLParser.g:1220:14: PERIOD general_element_id
							{
							PERIOD940=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function12908); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD940_tree = (Object)adaptor.create(PERIOD940);
							adaptor.addChild(root_0, PERIOD940_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function12910);
							general_element_id941=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id941.getTree());

							}
							break;

					}

					}
					break;
				case 19 :
					// PLSQL_DMLParser.g:1221:10: xmlexists_key ^ LEFT_PAREN ! expression_wrapper ( xml_passing_clause )? RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlexists_key_in_standard_function12923);
					xmlexists_key942=gPLSQLParser.xmlexists_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlexists_key942.getTree(), root_0);
					LEFT_PAREN943=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function12938); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_standard_function12957);
					expression_wrapper944=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper944.getTree());

					// PLSQL_DMLParser.g:1224:17: ( xml_passing_clause )?
					int alt299=2;
					int LA299_0 = input.LA(1);
					if ( (LA299_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {
						alt299=1;
					}
					switch (alt299) {
						case 1 :
							// PLSQL_DMLParser.g:1224:17: xml_passing_clause
							{
							pushFollow(FOLLOW_xml_passing_clause_in_standard_function12975);
							xml_passing_clause945=xml_passing_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_passing_clause945.getTree());

							}
							break;

					}

					RIGHT_PAREN946=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function12990); if (state.failed) return retval;
					}
					break;
				case 20 :
					// PLSQL_DMLParser.g:1226:10: xmlparse_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlparse_key_in_standard_function13002);
					xmlparse_key947=gPLSQLParser.xmlparse_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlparse_key947.getTree(), root_0);
					LEFT_PAREN948=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13017); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1228:17: ( document_key | content_key )
					int alt300=2;
					int LA300_0 = input.LA(1);
					if ( (LA300_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("document"))||(input.LT(1).getText().equalsIgnoreCase("content"))))) {
						int LA300_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("document"))) ) {
							alt300=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("content"))) ) {
							alt300=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 300, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt300) {
						case 1 :
							// PLSQL_DMLParser.g:1228:18: document_key
							{
							pushFollow(FOLLOW_document_key_in_standard_function13038);
							document_key949=gPLSQLParser.document_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, document_key949.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1228:31: content_key
							{
							pushFollow(FOLLOW_content_key_in_standard_function13040);
							content_key950=gPLSQLParser.content_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, content_key950.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13043);
					concatenation_wrapper951=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper951.getTree());

					// PLSQL_DMLParser.g:1228:66: ( wellformed_key )?
					int alt301=2;
					int LA301_0 = input.LA(1);
					if ( (LA301_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("wellformed")))) {
						alt301=1;
					}
					switch (alt301) {
						case 1 :
							// PLSQL_DMLParser.g:1228:66: wellformed_key
							{
							pushFollow(FOLLOW_wellformed_key_in_standard_function13045);
							wellformed_key952=gPLSQLParser.wellformed_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, wellformed_key952.getTree());

							}
							break;

					}

					RIGHT_PAREN953=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13060); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1230:13: ( PERIOD general_element_id )?
					int alt302=2;
					int LA302_0 = input.LA(1);
					if ( (LA302_0==PERIOD) ) {
						alt302=1;
					}
					switch (alt302) {
						case 1 :
							// PLSQL_DMLParser.g:1230:14: PERIOD general_element_id
							{
							PERIOD954=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13076); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD954_tree = (Object)adaptor.create(PERIOD954);
							adaptor.addChild(root_0, PERIOD954_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13078);
							general_element_id955=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id955.getTree());

							}
							break;

					}

					}
					break;
				case 21 :
					// PLSQL_DMLParser.g:1231:10: xmlpi_key ^ LEFT_PAREN ! ( name_key id | evalname_key concatenation_wrapper ) ( COMMA ! concatenation_wrapper )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlpi_key_in_standard_function13091);
					xmlpi_key956=gPLSQLParser.xmlpi_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlpi_key956.getTree(), root_0);
					LEFT_PAREN957=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13106); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1233:17: ( name_key id | evalname_key concatenation_wrapper )
					int alt303=2;
					alt303 = dfa303.predict(input);
					switch (alt303) {
						case 1 :
							// PLSQL_DMLParser.g:1233:22: name_key id
							{
							pushFollow(FOLLOW_name_key_in_standard_function13131);
							name_key958=gPLSQLParser.name_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, name_key958.getTree());

							pushFollow(FOLLOW_id_in_standard_function13133);
							id959=gPLSQLParser.id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, id959.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1234:22: evalname_key concatenation_wrapper
							{
							pushFollow(FOLLOW_evalname_key_in_standard_function13156);
							evalname_key960=gPLSQLParser.evalname_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, evalname_key960.getTree());

							pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13158);
							concatenation_wrapper961=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper961.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1236:17: ( COMMA ! concatenation_wrapper )?
					int alt304=2;
					int LA304_0 = input.LA(1);
					if ( (LA304_0==COMMA) ) {
						alt304=1;
					}
					switch (alt304) {
						case 1 :
							// PLSQL_DMLParser.g:1236:18: COMMA ! concatenation_wrapper
							{
							COMMA962=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function13195); if (state.failed) return retval;
							pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13198);
							concatenation_wrapper963=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper963.getTree());

							}
							break;

					}

					RIGHT_PAREN964=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13214); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1238:13: ( PERIOD general_element_id )?
					int alt305=2;
					int LA305_0 = input.LA(1);
					if ( (LA305_0==PERIOD) ) {
						alt305=1;
					}
					switch (alt305) {
						case 1 :
							// PLSQL_DMLParser.g:1238:14: PERIOD general_element_id
							{
							PERIOD965=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13230); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD965_tree = (Object)adaptor.create(PERIOD965);
							adaptor.addChild(root_0, PERIOD965_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13232);
							general_element_id966=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id966.getTree());

							}
							break;

					}

					}
					break;
				case 22 :
					// PLSQL_DMLParser.g:1239:10: xmlquery_key ^ LEFT_PAREN ! concatenation_wrapper ( xml_passing_clause )? returning_key ! content_key ! ( null_key on_key ! empty_key !)? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlquery_key_in_standard_function13245);
					xmlquery_key967=gPLSQLParser.xmlquery_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlquery_key967.getTree(), root_0);
					LEFT_PAREN968=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13260); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13280);
					concatenation_wrapper969=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper969.getTree());

					// PLSQL_DMLParser.g:1241:39: ( xml_passing_clause )?
					int alt306=2;
					int LA306_0 = input.LA(1);
					if ( (LA306_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("passing"))||(input.LT(1).getText().equalsIgnoreCase("returning"))))) {
						int LA306_1 = input.LA(2);
						if ( (LA306_1==APPROXIMATE_NUM_LIT||LA306_1==BINDVAR||(LA306_1 >= CHAR_STRING && LA306_1 <= COLON)||LA306_1==DELIMITED_ID||LA306_1==EXACT_NUM_LIT||LA306_1==INTRODUCER||LA306_1==LEFT_PAREN||LA306_1==MINUS_SIGN||LA306_1==NATIONAL_CHAR_STRING_LIT||LA306_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA306_1==PLUS_SIGN||LA306_1==SQL92_RESERVED_ALL||LA306_1==SQL92_RESERVED_ANY||(LA306_1 >= SQL92_RESERVED_BY && LA306_1 <= SQL92_RESERVED_CASE)||(LA306_1 >= SQL92_RESERVED_CURSOR && LA306_1 <= SQL92_RESERVED_DATE)||(LA306_1 >= SQL92_RESERVED_DEFAULT && LA306_1 <= SQL92_RESERVED_DELETE)||LA306_1==SQL92_RESERVED_DISTINCT||(LA306_1 >= SQL92_RESERVED_EXISTS && LA306_1 <= SQL92_RESERVED_FALSE)||(LA306_1 >= SQL92_RESERVED_NOT && LA306_1 <= SQL92_RESERVED_NULL)||LA306_1==SQL92_RESERVED_PRIOR||LA306_1==SQL92_RESERVED_TRUE||LA306_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {
							alt306=1;
						}
						else if ( (LA306_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("passing"))||(input.LT(1).getText().equalsIgnoreCase("returning"))))) {
							int LA306_3 = input.LA(3);
							if ( (LA306_3==APPROXIMATE_NUM_LIT||LA306_3==ASTERISK||LA306_3==BINDVAR||(LA306_3 >= CARRET_OPERATOR_PART && LA306_3 <= COMMA)||LA306_3==CONCATENATION_OP||LA306_3==DELIMITED_ID||(LA306_3 >= EQUALS_OP && LA306_3 <= EXCLAMATION_OPERATOR_PART)||(LA306_3 >= GREATER_THAN_OP && LA306_3 <= GREATER_THAN_OR_EQUALS_OP)||LA306_3==INTRODUCER||(LA306_3 >= LEFT_BRACKET && LA306_3 <= LESS_THAN_OR_EQUALS_OP)||LA306_3==MINUS_SIGN||LA306_3==NATIONAL_CHAR_STRING_LIT||LA306_3==NOT_EQUAL_OP||(LA306_3 >= PERCENT && LA306_3 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)||LA306_3==PLUS_SIGN||LA306_3==REGULAR_ID||LA306_3==SOLIDUS||LA306_3==SQL92_RESERVED_ALL||(LA306_3 >= SQL92_RESERVED_AND && LA306_3 <= SQL92_RESERVED_AS)||LA306_3==SQL92_RESERVED_BETWEEN||LA306_3==SQL92_RESERVED_CASE||LA306_3==SQL92_RESERVED_DATE||(LA306_3 >= SQL92_RESERVED_DEFAULT && LA306_3 <= SQL92_RESERVED_DELETE)||LA306_3==SQL92_RESERVED_DISTINCT||(LA306_3 >= SQL92_RESERVED_EXISTS && LA306_3 <= SQL92_RESERVED_FALSE)||LA306_3==SQL92_RESERVED_IN||(LA306_3 >= SQL92_RESERVED_IS && LA306_3 <= SQL92_RESERVED_NOT)||LA306_3==SQL92_RESERVED_OR||LA306_3==SQL92_RESERVED_PRIOR||LA306_3==SQL92_RESERVED_TRUE||LA306_3==UNSIGNED_INTEGER||LA306_3==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {
								alt306=1;
							}
							else if ( (LA306_3==SQL92_RESERVED_NULL) && (((input.LT(1).getText().equalsIgnoreCase("passing"))||(input.LT(1).getText().equalsIgnoreCase("returning"))))) {
								int LA306_4 = input.LA(4);
								if ( (LA306_4==ASTERISK||(LA306_4 >= CARRET_OPERATOR_PART && LA306_4 <= CHAR_STRING_PERL)||LA306_4==COMMA||LA306_4==CONCATENATION_OP||LA306_4==DELIMITED_ID||LA306_4==EQUALS_OP||LA306_4==EXCLAMATION_OPERATOR_PART||(LA306_4 >= GREATER_THAN_OP && LA306_4 <= GREATER_THAN_OR_EQUALS_OP)||LA306_4==INTRODUCER||LA306_4==LEFT_BRACKET||(LA306_4 >= LESS_THAN_OP && LA306_4 <= LESS_THAN_OR_EQUALS_OP)||LA306_4==MINUS_SIGN||LA306_4==NATIONAL_CHAR_STRING_LIT||LA306_4==NOT_EQUAL_OP||LA306_4==PERCENT||LA306_4==PLUS_SIGN||LA306_4==REGULAR_ID||LA306_4==SOLIDUS||LA306_4==SQL92_RESERVED_AND||LA306_4==SQL92_RESERVED_AS||LA306_4==SQL92_RESERVED_BETWEEN||LA306_4==SQL92_RESERVED_IN||(LA306_4 >= SQL92_RESERVED_IS && LA306_4 <= SQL92_RESERVED_NOT)||LA306_4==SQL92_RESERVED_OR||LA306_4==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {
									alt306=1;
								}
							}
						}
					}
					switch (alt306) {
						case 1 :
							// PLSQL_DMLParser.g:1241:39: xml_passing_clause
							{
							pushFollow(FOLLOW_xml_passing_clause_in_standard_function13282);
							xml_passing_clause970=xml_passing_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_passing_clause970.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_returning_key_in_standard_function13301);
					returning_key971=gPLSQLParser.returning_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_content_key_in_standard_function13304);
					content_key972=gPLSQLParser.content_key();
					state._fsp--;
					if (state.failed) return retval;
					// PLSQL_DMLParser.g:1242:45: ( null_key on_key ! empty_key !)?
					int alt307=2;
					int LA307_0 = input.LA(1);
					if ( (LA307_0==SQL92_RESERVED_NULL) ) {
						alt307=1;
					}
					switch (alt307) {
						case 1 :
							// PLSQL_DMLParser.g:1242:46: null_key on_key ! empty_key !
							{
							pushFollow(FOLLOW_null_key_in_standard_function13308);
							null_key973=gPLSQLParser.null_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, null_key973.getTree());

							pushFollow(FOLLOW_on_key_in_standard_function13310);
							on_key974=gPLSQLParser.on_key();
							state._fsp--;
							if (state.failed) return retval;
							pushFollow(FOLLOW_empty_key_in_standard_function13313);
							empty_key975=gPLSQLParser.empty_key();
							state._fsp--;
							if (state.failed) return retval;
							}
							break;

					}

					RIGHT_PAREN976=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13330); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1244:13: ( PERIOD general_element_id )?
					int alt308=2;
					int LA308_0 = input.LA(1);
					if ( (LA308_0==PERIOD) ) {
						alt308=1;
					}
					switch (alt308) {
						case 1 :
							// PLSQL_DMLParser.g:1244:14: PERIOD general_element_id
							{
							PERIOD977=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13346); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD977_tree = (Object)adaptor.create(PERIOD977);
							adaptor.addChild(root_0, PERIOD977_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13348);
							general_element_id978=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id978.getTree());

							}
							break;

					}

					}
					break;
				case 23 :
					// PLSQL_DMLParser.g:1245:10: xmlroot_key ^ LEFT_PAREN ! concatenation_wrapper COMMA ! xmlroot_param_version_part ( COMMA ! xmlroot_param_standalone_part )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlroot_key_in_standard_function13361);
					xmlroot_key979=gPLSQLParser.xmlroot_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlroot_key979.getTree(), root_0);
					LEFT_PAREN980=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13376); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13395);
					concatenation_wrapper981=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper981.getTree());

					COMMA982=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function13413); if (state.failed) return retval;
					pushFollow(FOLLOW_xmlroot_param_version_part_in_standard_function13436);
					xmlroot_param_version_part983=xmlroot_param_version_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, xmlroot_param_version_part983.getTree());

					// PLSQL_DMLParser.g:1250:21: ( COMMA ! xmlroot_param_standalone_part )?
					int alt309=2;
					int LA309_0 = input.LA(1);
					if ( (LA309_0==COMMA) ) {
						alt309=1;
					}
					switch (alt309) {
						case 1 :
							// PLSQL_DMLParser.g:1250:22: COMMA ! xmlroot_param_standalone_part
							{
							COMMA984=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function13459); if (state.failed) return retval;
							pushFollow(FOLLOW_xmlroot_param_standalone_part_in_standard_function13462);
							xmlroot_param_standalone_part985=xmlroot_param_standalone_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xmlroot_param_standalone_part985.getTree());

							}
							break;

					}

					RIGHT_PAREN986=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13478); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1252:13: ( PERIOD general_element_id )?
					int alt310=2;
					int LA310_0 = input.LA(1);
					if ( (LA310_0==PERIOD) ) {
						alt310=1;
					}
					switch (alt310) {
						case 1 :
							// PLSQL_DMLParser.g:1252:14: PERIOD general_element_id
							{
							PERIOD987=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13494); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD987_tree = (Object)adaptor.create(PERIOD987);
							adaptor.addChild(root_0, PERIOD987_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13496);
							general_element_id988=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id988.getTree());

							}
							break;

					}

					}
					break;
				case 24 :
					// PLSQL_DMLParser.g:1253:10: xmlserialize_key ^ LEFT_PAREN ! ( document_key | content_key ) concatenation_wrapper ( as_key ! type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmlserialize_key_in_standard_function13509);
					xmlserialize_key989=gPLSQLParser.xmlserialize_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlserialize_key989.getTree(), root_0);
					LEFT_PAREN990=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13524); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1255:17: ( document_key | content_key )
					int alt311=2;
					int LA311_0 = input.LA(1);
					if ( (LA311_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("document"))||(input.LT(1).getText().equalsIgnoreCase("content"))))) {
						int LA311_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("document"))) ) {
							alt311=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("content"))) ) {
							alt311=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 311, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt311) {
						case 1 :
							// PLSQL_DMLParser.g:1255:18: document_key
							{
							pushFollow(FOLLOW_document_key_in_standard_function13544);
							document_key991=gPLSQLParser.document_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, document_key991.getTree());

							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1255:31: content_key
							{
							pushFollow(FOLLOW_content_key_in_standard_function13546);
							content_key992=gPLSQLParser.content_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, content_key992.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13565);
					concatenation_wrapper993=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper993.getTree());

					// PLSQL_DMLParser.g:1256:39: ( as_key ! type_spec )?
					int alt312=2;
					int LA312_0 = input.LA(1);
					if ( (LA312_0==SQL92_RESERVED_AS) ) {
						alt312=1;
					}
					switch (alt312) {
						case 1 :
							// PLSQL_DMLParser.g:1256:40: as_key ! type_spec
							{
							pushFollow(FOLLOW_as_key_in_standard_function13568);
							as_key994=gPLSQLParser.as_key();
							state._fsp--;
							if (state.failed) return retval;
							pushFollow(FOLLOW_type_spec_in_standard_function13571);
							type_spec995=gPLSQLParser.type_spec();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, type_spec995.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1257:17: ( xmlserialize_param_enconding_part )?
					int alt313=2;
					int LA313_0 = input.LA(1);
					if ( (LA313_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("version"))||(input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("show"))||(input.LT(1).getText().equalsIgnoreCase("no"))||(input.LT(1).getText().equalsIgnoreCase("encoding"))))) {
						int LA313_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("encoding"))) ) {
							alt313=1;
						}
					}
					switch (alt313) {
						case 1 :
							// PLSQL_DMLParser.g:1257:17: xmlserialize_param_enconding_part
							{
							pushFollow(FOLLOW_xmlserialize_param_enconding_part_in_standard_function13591);
							xmlserialize_param_enconding_part996=xmlserialize_param_enconding_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xmlserialize_param_enconding_part996.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1258:17: ( xmlserialize_param_version_part )?
					int alt314=2;
					int LA314_0 = input.LA(1);
					if ( (LA314_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("version"))||(input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("show"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
						int LA314_1 = input.LA(2);
						if ( (LA314_1==APPROXIMATE_NUM_LIT||LA314_1==BINDVAR||(LA314_1 >= CHAR_STRING && LA314_1 <= COLON)||LA314_1==DELIMITED_ID||LA314_1==EXACT_NUM_LIT||LA314_1==INTRODUCER||LA314_1==LEFT_PAREN||LA314_1==MINUS_SIGN||LA314_1==NATIONAL_CHAR_STRING_LIT||LA314_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA314_1==PLUS_SIGN||LA314_1==SQL92_RESERVED_ALL||LA314_1==SQL92_RESERVED_ANY||LA314_1==SQL92_RESERVED_CASE||LA314_1==SQL92_RESERVED_DATE||(LA314_1 >= SQL92_RESERVED_DEFAULT && LA314_1 <= SQL92_RESERVED_DELETE)||LA314_1==SQL92_RESERVED_DISTINCT||(LA314_1 >= SQL92_RESERVED_EXISTS && LA314_1 <= SQL92_RESERVED_FALSE)||LA314_1==SQL92_RESERVED_NULL||LA314_1==SQL92_RESERVED_PRIOR||LA314_1==SQL92_RESERVED_TRUE||LA314_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("version")))) {
							alt314=1;
						}
						else if ( (LA314_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("version"))||(input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("show"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
							int LA314_4 = input.LA(3);
							if ( ((input.LT(1).getText().equalsIgnoreCase("version"))) ) {
								alt314=1;
							}
						}
					}
					switch (alt314) {
						case 1 :
							// PLSQL_DMLParser.g:1258:17: xmlserialize_param_version_part
							{
							pushFollow(FOLLOW_xmlserialize_param_version_part_in_standard_function13610);
							xmlserialize_param_version_part997=xmlserialize_param_version_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xmlserialize_param_version_part997.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1259:17: ( xmlserialize_param_ident_part )?
					int alt315=2;
					int LA315_0 = input.LA(1);
					if ( (LA315_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("show"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
						int LA315_1 = input.LA(2);
						if ( (LA315_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("show"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
							int LA315_3 = input.LA(3);
							if ( (((input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("no")))) ) {
								alt315=1;
							}
						}
						else if ( (LA315_1==RIGHT_PAREN||LA315_1==SQL92_RESERVED_SIZE) && ((input.LT(1).getText().equalsIgnoreCase("indent")))) {
							alt315=1;
						}
					}
					switch (alt315) {
						case 1 :
							// PLSQL_DMLParser.g:1259:17: xmlserialize_param_ident_part
							{
							pushFollow(FOLLOW_xmlserialize_param_ident_part_in_standard_function13629);
							xmlserialize_param_ident_part998=xmlserialize_param_ident_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xmlserialize_param_ident_part998.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1260:17: ( ( hide_key | show_key ) defaults_key )?
					int alt317=2;
					int LA317_0 = input.LA(1);
					if ( (LA317_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("show"))))) {
						alt317=1;
					}
					switch (alt317) {
						case 1 :
							// PLSQL_DMLParser.g:1260:18: ( hide_key | show_key ) defaults_key
							{
							// PLSQL_DMLParser.g:1260:18: ( hide_key | show_key )
							int alt316=2;
							int LA316_0 = input.LA(1);
							if ( (LA316_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("hide"))||(input.LT(1).getText().equalsIgnoreCase("show"))))) {
								int LA316_1 = input.LA(2);
								if ( ((input.LT(1).getText().equalsIgnoreCase("hide"))) ) {
									alt316=1;
								}
								else if ( ((input.LT(1).getText().equalsIgnoreCase("show"))) ) {
									alt316=2;
								}

								else {
									if (state.backtracking>0) {state.failed=true; return retval;}
									int nvaeMark = input.mark();
									try {
										input.consume();
										NoViableAltException nvae =
											new NoViableAltException("", 316, 1, input);
										throw nvae;
									} finally {
										input.rewind(nvaeMark);
									}
								}

							}

							switch (alt316) {
								case 1 :
									// PLSQL_DMLParser.g:1260:19: hide_key
									{
									pushFollow(FOLLOW_hide_key_in_standard_function13650);
									hide_key999=gPLSQLParser.hide_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, hide_key999.getTree());

									}
									break;
								case 2 :
									// PLSQL_DMLParser.g:1260:28: show_key
									{
									pushFollow(FOLLOW_show_key_in_standard_function13652);
									show_key1000=gPLSQLParser.show_key();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, show_key1000.getTree());

									}
									break;

							}

							pushFollow(FOLLOW_defaults_key_in_standard_function13655);
							defaults_key1001=gPLSQLParser.defaults_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, defaults_key1001.getTree());

							}
							break;

					}

					RIGHT_PAREN1002=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13671); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1262:13: ( PERIOD general_element_id )?
					int alt318=2;
					int LA318_0 = input.LA(1);
					if ( (LA318_0==PERIOD) ) {
						alt318=1;
					}
					switch (alt318) {
						case 1 :
							// PLSQL_DMLParser.g:1262:14: PERIOD general_element_id
							{
							PERIOD1003=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13687); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD1003_tree = (Object)adaptor.create(PERIOD1003);
							adaptor.addChild(root_0, PERIOD1003_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13689);
							general_element_id1004=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id1004.getTree());

							}
							break;

					}

					}
					break;
				case 25 :
					// PLSQL_DMLParser.g:1263:10: xmltable_key ^ LEFT_PAREN ! ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key ! xml_table_column ( COMMA ! xml_table_column )* )? RIGHT_PAREN ! ( PERIOD general_element_id )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_xmltable_key_in_standard_function13702);
					xmltable_key1005=gPLSQLParser.xmltable_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmltable_key1005.getTree(), root_0);
					LEFT_PAREN1006=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_standard_function13717); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1265:17: ( xml_namespaces_clause )?
					int alt319=2;
					int LA319_0 = input.LA(1);
					if ( (LA319_0==REGULAR_ID) ) {
						int LA319_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("xmlnamespaces"))) ) {
							alt319=1;
						}
					}
					switch (alt319) {
						case 1 :
							// PLSQL_DMLParser.g:1265:17: xml_namespaces_clause
							{
							pushFollow(FOLLOW_xml_namespaces_clause_in_standard_function13736);
							xml_namespaces_clause1007=xml_namespaces_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_namespaces_clause1007.getTree());

							}
							break;

					}

					pushFollow(FOLLOW_concatenation_wrapper_in_standard_function13755);
					concatenation_wrapper1008=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1008.getTree());

					// PLSQL_DMLParser.g:1267:17: ( xml_passing_clause )?
					int alt320=2;
					alt320 = dfa320.predict(input);
					switch (alt320) {
						case 1 :
							// PLSQL_DMLParser.g:1267:17: xml_passing_clause
							{
							pushFollow(FOLLOW_xml_passing_clause_in_standard_function13773);
							xml_passing_clause1009=xml_passing_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_passing_clause1009.getTree());

							}
							break;

					}

					// PLSQL_DMLParser.g:1268:17: ( columns_key ! xml_table_column ( COMMA ! xml_table_column )* )?
					int alt322=2;
					int LA322_0 = input.LA(1);
					if ( (LA322_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {
						alt322=1;
					}
					switch (alt322) {
						case 1 :
							// PLSQL_DMLParser.g:1268:18: columns_key ! xml_table_column ( COMMA ! xml_table_column )*
							{
							pushFollow(FOLLOW_columns_key_in_standard_function13793);
							columns_key1010=gPLSQLParser.columns_key();
							state._fsp--;
							if (state.failed) return retval;
							pushFollow(FOLLOW_xml_table_column_in_standard_function13796);
							xml_table_column1011=xml_table_column();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_table_column1011.getTree());

							// PLSQL_DMLParser.g:1268:48: ( COMMA ! xml_table_column )*
							loop321:
							while (true) {
								int alt321=2;
								int LA321_0 = input.LA(1);
								if ( (LA321_0==COMMA) ) {
									alt321=1;
								}

								switch (alt321) {
								case 1 :
									// PLSQL_DMLParser.g:1268:49: COMMA ! xml_table_column
									{
									COMMA1012=(Token)match(input,COMMA,FOLLOW_COMMA_in_standard_function13799); if (state.failed) return retval;
									pushFollow(FOLLOW_xml_table_column_in_standard_function13802);
									xml_table_column1013=xml_table_column();
									state._fsp--;
									if (state.failed) return retval;
									if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_table_column1013.getTree());

									}
									break;

								default :
									break loop321;
								}
							}

							}
							break;

					}

					RIGHT_PAREN1014=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_standard_function13820); if (state.failed) return retval;
					// PLSQL_DMLParser.g:1270:13: ( PERIOD general_element_id )?
					int alt323=2;
					int LA323_0 = input.LA(1);
					if ( (LA323_0==PERIOD) ) {
						alt323=1;
					}
					switch (alt323) {
						case 1 :
							// PLSQL_DMLParser.g:1270:14: PERIOD general_element_id
							{
							PERIOD1015=(Token)match(input,PERIOD,FOLLOW_PERIOD_in_standard_function13836); if (state.failed) return retval;
							if ( state.backtracking==0 ) {
							PERIOD1015_tree = (Object)adaptor.create(PERIOD1015);
							adaptor.addChild(root_0, PERIOD1015_tree);
							}

							pushFollow(FOLLOW_general_element_id_in_standard_function13838);
							general_element_id1016=gPLSQLParser.general_element_id();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, general_element_id1016.getTree());

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standard_function"


	public static class stantard_function_enabling_over_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stantard_function_enabling_over"
	// PLSQL_DMLParser.g:1273:1: stantard_function_enabling_over :{...}? => REGULAR_ID -> FUNCTION_ENABLING_OVER[$REGULAR_ID] ;
	public final PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_over_return stantard_function_enabling_over() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_over_return retval = new PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_over_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID1017=null;

		Object REGULAR_ID1017_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQL_DMLParser.g:1274:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_OVER[$REGULAR_ID] )
			// PLSQL_DMLParser.g:1274:10: {...}? => REGULAR_ID
			{
			if ( !((enablesOverClause(input.LT(1).getText()))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "stantard_function_enabling_over", "enablesOverClause(input.LT(1).getText())");
			}
			REGULAR_ID1017=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_stantard_function_enabling_over13863); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID1017);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1274:67: -> FUNCTION_ENABLING_OVER[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FUNCTION_ENABLING_OVER, REGULAR_ID1017));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stantard_function_enabling_over"


	public static class stantard_function_enabling_using_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stantard_function_enabling_using"
	// PLSQL_DMLParser.g:1277:1: stantard_function_enabling_using :{...}? => REGULAR_ID -> FUNCTION_ENABLING_USING[$REGULAR_ID] ;
	public final PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_using_return stantard_function_enabling_using() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_using_return retval = new PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_using_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID1018=null;

		Object REGULAR_ID1018_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQL_DMLParser.g:1278:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_USING[$REGULAR_ID] )
			// PLSQL_DMLParser.g:1278:10: {...}? => REGULAR_ID
			{
			if ( !((enablesUsingClause(input.LT(1).getText()))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "stantard_function_enabling_using", "enablesUsingClause(input.LT(1).getText())");
			}
			REGULAR_ID1018=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_stantard_function_enabling_using13891); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID1018);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1278:68: -> FUNCTION_ENABLING_USING[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FUNCTION_ENABLING_USING, REGULAR_ID1018));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stantard_function_enabling_using"


	public static class stantard_function_enabling_within_or_over_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stantard_function_enabling_within_or_over"
	// PLSQL_DMLParser.g:1281:1: stantard_function_enabling_within_or_over :{...}? => REGULAR_ID -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID] ;
	public final PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_within_or_over_return stantard_function_enabling_within_or_over() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_within_or_over_return retval = new PLSQLParser_PLSQL_DMLParser.stantard_function_enabling_within_or_over_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID1019=null;

		Object REGULAR_ID1019_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQL_DMLParser.g:1282:5: ({...}? => REGULAR_ID -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID] )
			// PLSQL_DMLParser.g:1282:10: {...}? => REGULAR_ID
			{
			if ( !((enablesWithinOrOverClause(input.LT(1).getText()))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "stantard_function_enabling_within_or_over", "enablesWithinOrOverClause(input.LT(1).getText())");
			}
			REGULAR_ID1019=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over13919); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID1019);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1282:75: -> FUNCTION_ENABLING_WITHIN_OR_OVER[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FUNCTION_ENABLING_WITHIN_OR_OVER, REGULAR_ID1019));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stantard_function_enabling_within_or_over"


	public static class stantard_function_pedictions_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stantard_function_pedictions"
	// PLSQL_DMLParser.g:1285:1: stantard_function_pedictions :{...}? => REGULAR_ID -> PREDICTION_FUNCTION[$REGULAR_ID] ;
	public final PLSQLParser_PLSQL_DMLParser.stantard_function_pedictions_return stantard_function_pedictions() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.stantard_function_pedictions_return retval = new PLSQLParser_PLSQL_DMLParser.stantard_function_pedictions_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID1020=null;

		Object REGULAR_ID1020_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQL_DMLParser.g:1286:5: ({...}? => REGULAR_ID -> PREDICTION_FUNCTION[$REGULAR_ID] )
			// PLSQL_DMLParser.g:1286:10: {...}? => REGULAR_ID
			{
			if ( !((isStandardPredictionFunction(input.LT(1).getText()))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "stantard_function_pedictions", "isStandardPredictionFunction(input.LT(1).getText())");
			}
			REGULAR_ID1020=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_stantard_function_pedictions13947); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID1020);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1286:78: -> PREDICTION_FUNCTION[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PREDICTION_FUNCTION, REGULAR_ID1020));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stantard_function_pedictions"


	public static class over_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "over_clause"
	// PLSQL_DMLParser.g:1289:1: over_clause : over_key ^ LEFT_PAREN ! ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN !;
	public final PLSQLParser_PLSQL_DMLParser.over_clause_return over_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.over_clause_return retval = new PLSQLParser_PLSQL_DMLParser.over_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN1022=null;
		Token RIGHT_PAREN1026=null;
		ParserRuleReturnScope over_key1021 =null;
		ParserRuleReturnScope query_partition_clause1023 =null;
		ParserRuleReturnScope order_by_clause1024 =null;
		ParserRuleReturnScope windowing_clause1025 =null;

		Object LEFT_PAREN1022_tree=null;
		Object RIGHT_PAREN1026_tree=null;

		try {
			// PLSQL_DMLParser.g:1290:5: ( over_key ^ LEFT_PAREN ! ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN !)
			// PLSQL_DMLParser.g:1290:10: over_key ^ LEFT_PAREN ! ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN !
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_over_key_in_over_clause13972);
			over_key1021=gPLSQLParser.over_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(over_key1021.getTree(), root_0);
			LEFT_PAREN1022=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_over_clause13983); if (state.failed) return retval;
			// PLSQL_DMLParser.g:1292:13: ( query_partition_clause )?
			int alt325=2;
			int LA325_0 = input.LA(1);
			if ( (LA325_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("partition")))) {
				alt325=1;
			}
			switch (alt325) {
				case 1 :
					// PLSQL_DMLParser.g:1292:13: query_partition_clause
					{
					pushFollow(FOLLOW_query_partition_clause_in_over_clause13998);
					query_partition_clause1023=query_partition_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, query_partition_clause1023.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:1293:13: ( order_by_clause ( windowing_clause )? )?
			int alt327=2;
			int LA327_0 = input.LA(1);
			if ( (LA327_0==SQL92_RESERVED_ORDER) ) {
				alt327=1;
			}
			switch (alt327) {
				case 1 :
					// PLSQL_DMLParser.g:1293:14: order_by_clause ( windowing_clause )?
					{
					pushFollow(FOLLOW_order_by_clause_in_over_clause14014);
					order_by_clause1024=order_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, order_by_clause1024.getTree());

					// PLSQL_DMLParser.g:1293:30: ( windowing_clause )?
					int alt326=2;
					int LA326_0 = input.LA(1);
					if ( (LA326_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("rows"))||(input.LT(1).getText().equalsIgnoreCase("range"))))) {
						alt326=1;
					}
					switch (alt326) {
						case 1 :
							// PLSQL_DMLParser.g:1293:30: windowing_clause
							{
							pushFollow(FOLLOW_windowing_clause_in_over_clause14016);
							windowing_clause1025=windowing_clause();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, windowing_clause1025.getTree());

							}
							break;

					}

					}
					break;

			}

			RIGHT_PAREN1026=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_over_clause14029); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "over_clause"


	public static class windowing_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "windowing_clause"
	// PLSQL_DMLParser.g:1297:1: windowing_clause : windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) ) -> ^( windowing_type ( windowing_elements )+ ) ;
	public final PLSQLParser_PLSQL_DMLParser.windowing_clause_return windowing_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.windowing_clause_return retval = new PLSQLParser_PLSQL_DMLParser.windowing_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope windowing_type1027 =null;
		ParserRuleReturnScope between_key1028 =null;
		ParserRuleReturnScope windowing_elements1029 =null;
		ParserRuleReturnScope and_key1030 =null;
		ParserRuleReturnScope windowing_elements1031 =null;
		ParserRuleReturnScope windowing_elements1032 =null;

		RewriteRuleSubtreeStream stream_windowing_type=new RewriteRuleSubtreeStream(adaptor,"rule windowing_type");
		RewriteRuleSubtreeStream stream_windowing_elements=new RewriteRuleSubtreeStream(adaptor,"rule windowing_elements");
		RewriteRuleSubtreeStream stream_between_key=new RewriteRuleSubtreeStream(adaptor,"rule between_key");
		RewriteRuleSubtreeStream stream_and_key=new RewriteRuleSubtreeStream(adaptor,"rule and_key");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:1299:5: ( windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) ) -> ^( windowing_type ( windowing_elements )+ ) )
			// PLSQL_DMLParser.g:1299:10: windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements )
			{
			pushFollow(FOLLOW_windowing_type_in_windowing_clause14058);
			windowing_type1027=windowing_type();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_windowing_type.add(windowing_type1027.getTree());
			// PLSQL_DMLParser.g:1300:5: ( between_key windowing_elements and_key windowing_elements | windowing_elements )
			int alt328=2;
			int LA328_0 = input.LA(1);
			if ( (LA328_0==SQL92_RESERVED_BETWEEN) ) {
				alt328=1;
			}
			else if ( (LA328_0==APPROXIMATE_NUM_LIT||LA328_0==BINDVAR||(LA328_0 >= CHAR_STRING && LA328_0 <= COLON)||LA328_0==DELIMITED_ID||LA328_0==EXACT_NUM_LIT||LA328_0==INTRODUCER||LA328_0==LEFT_PAREN||LA328_0==MINUS_SIGN||LA328_0==NATIONAL_CHAR_STRING_LIT||LA328_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA328_0==PLUS_SIGN||LA328_0==REGULAR_ID||LA328_0==SQL92_RESERVED_ALL||LA328_0==SQL92_RESERVED_ANY||LA328_0==SQL92_RESERVED_CASE||LA328_0==SQL92_RESERVED_CURRENT||LA328_0==SQL92_RESERVED_DATE||(LA328_0 >= SQL92_RESERVED_DEFAULT && LA328_0 <= SQL92_RESERVED_DELETE)||LA328_0==SQL92_RESERVED_DISTINCT||(LA328_0 >= SQL92_RESERVED_EXISTS && LA328_0 <= SQL92_RESERVED_FALSE)||LA328_0==SQL92_RESERVED_NULL||LA328_0==SQL92_RESERVED_PRIOR||LA328_0==SQL92_RESERVED_TRUE||LA328_0==UNSIGNED_INTEGER) ) {
				alt328=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 328, 0, input);
				throw nvae;
			}

			switch (alt328) {
				case 1 :
					// PLSQL_DMLParser.g:1300:10: between_key windowing_elements and_key windowing_elements
					{
					pushFollow(FOLLOW_between_key_in_windowing_clause14069);
					between_key1028=gPLSQLParser.between_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_between_key.add(between_key1028.getTree());
					pushFollow(FOLLOW_windowing_elements_in_windowing_clause14071);
					windowing_elements1029=windowing_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_windowing_elements.add(windowing_elements1029.getTree());
					pushFollow(FOLLOW_and_key_in_windowing_clause14073);
					and_key1030=gPLSQLParser.and_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_and_key.add(and_key1030.getTree());
					pushFollow(FOLLOW_windowing_elements_in_windowing_clause14075);
					windowing_elements1031=windowing_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_windowing_elements.add(windowing_elements1031.getTree());
					if ( state.backtracking==0 ) {mode = 1;}
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1301:10: windowing_elements
					{
					pushFollow(FOLLOW_windowing_elements_in_windowing_clause14088);
					windowing_elements1032=windowing_elements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_windowing_elements.add(windowing_elements1032.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: windowing_type, windowing_elements, windowing_type, windowing_elements, between_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1302:5: -> {mode == 1}? ^( windowing_type ^( between_key ( windowing_elements )+ ) )
			if (mode == 1) {
				// PLSQL_DMLParser.g:1302:20: ^( windowing_type ^( between_key ( windowing_elements )+ ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_windowing_type.nextNode(), root_1);
				// PLSQL_DMLParser.g:1302:37: ^( between_key ( windowing_elements )+ )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot(stream_between_key.nextNode(), root_2);
				if ( !(stream_windowing_elements.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_windowing_elements.hasNext() ) {
					adaptor.addChild(root_2, stream_windowing_elements.nextTree());
				}
				stream_windowing_elements.reset();

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1303:5: -> ^( windowing_type ( windowing_elements )+ )
			{
				// PLSQL_DMLParser.g:1303:8: ^( windowing_type ( windowing_elements )+ )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot(stream_windowing_type.nextNode(), root_1);
				if ( !(stream_windowing_elements.hasNext()) ) {
					throw new RewriteEarlyExitException();
				}
				while ( stream_windowing_elements.hasNext() ) {
					adaptor.addChild(root_1, stream_windowing_elements.nextTree());
				}
				stream_windowing_elements.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "windowing_clause"


	public static class windowing_type_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "windowing_type"
	// PLSQL_DMLParser.g:1306:1: windowing_type : ( rows_key | range_key );
	public final PLSQLParser_PLSQL_DMLParser.windowing_type_return windowing_type() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.windowing_type_return retval = new PLSQLParser_PLSQL_DMLParser.windowing_type_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope rows_key1033 =null;
		ParserRuleReturnScope range_key1034 =null;


		try {
			// PLSQL_DMLParser.g:1307:5: ( rows_key | range_key )
			int alt329=2;
			int LA329_0 = input.LA(1);
			if ( (LA329_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("rows"))||(input.LT(1).getText().equalsIgnoreCase("range"))))) {
				int LA329_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("rows"))) ) {
					alt329=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("range"))) ) {
					alt329=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 329, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt329) {
				case 1 :
					// PLSQL_DMLParser.g:1307:10: rows_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_rows_key_in_windowing_type14147);
					rows_key1033=gPLSQLParser.rows_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, rows_key1033.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1308:10: range_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_range_key_in_windowing_type14158);
					range_key1034=gPLSQLParser.range_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, range_key1034.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "windowing_type"


	public static class windowing_elements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "windowing_elements"
	// PLSQL_DMLParser.g:1311:1: windowing_elements : ( unbounded_key ^ preceding_key | current_key ^ row_key | concatenation_wrapper ( preceding_key ^| following_key ^) );
	public final PLSQLParser_PLSQL_DMLParser.windowing_elements_return windowing_elements() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.windowing_elements_return retval = new PLSQLParser_PLSQL_DMLParser.windowing_elements_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope unbounded_key1035 =null;
		ParserRuleReturnScope preceding_key1036 =null;
		ParserRuleReturnScope current_key1037 =null;
		ParserRuleReturnScope row_key1038 =null;
		ParserRuleReturnScope concatenation_wrapper1039 =null;
		ParserRuleReturnScope preceding_key1040 =null;
		ParserRuleReturnScope following_key1041 =null;


		try {
			// PLSQL_DMLParser.g:1312:5: ( unbounded_key ^ preceding_key | current_key ^ row_key | concatenation_wrapper ( preceding_key ^| following_key ^) )
			int alt331=3;
			switch ( input.LA(1) ) {
			case REGULAR_ID:
				{
				int LA331_1 = input.LA(2);
				if ( (LA331_1==REGULAR_ID) ) {
					int LA331_4 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("unbounded"))) ) {
						alt331=1;
					}
					else if ( (true) ) {
						alt331=3;
					}

				}
				else if ( (LA331_1==MINUS_SIGN||LA331_1==PLUS_SIGN) ) {
					alt331=3;
				}
				else if ( (LA331_1==SQL92_RESERVED_PRIOR) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt331=3;
				}
				else if ( (LA331_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA331_1==SQL92_RESERVED_ALL||LA331_1==SQL92_RESERVED_CASE||LA331_1==SQL92_RESERVED_DISTINCT) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt331=3;
				}
				else if ( (LA331_1==SQL92_RESERVED_EXISTS) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt331=3;
				}
				else if ( (LA331_1==SQL92_RESERVED_ANY) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt331=3;
				}
				else if ( (LA331_1==DELIMITED_ID||LA331_1==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt331=3;
				}
				else if ( (LA331_1==BINDVAR||LA331_1==COLON) ) {
					alt331=3;
				}
				else if ( (LA331_1==SQL92_RESERVED_DELETE) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt331=3;
				}
				else if ( (LA331_1==APPROXIMATE_NUM_LIT||LA331_1==EXACT_NUM_LIT||LA331_1==SQL92_RESERVED_DATE||LA331_1==UNSIGNED_INTEGER) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt331=3;
				}
				else if ( ((LA331_1 >= CHAR_STRING && LA331_1 <= CHAR_STRING_PERL)||LA331_1==NATIONAL_CHAR_STRING_LIT) ) {
					alt331=3;
				}
				else if ( (LA331_1==SQL92_RESERVED_DEFAULT||LA331_1==SQL92_RESERVED_FALSE||LA331_1==SQL92_RESERVED_NULL||LA331_1==SQL92_RESERVED_TRUE) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt331=3;
				}
				else if ( (LA331_1==ASTERISK||LA331_1==CONCATENATION_OP||(LA331_1 >= LEFT_BRACKET && LA331_1 <= LEFT_PAREN)||(LA331_1 >= PERCENT && LA331_1 <= PERIOD)||LA331_1==SOLIDUS||LA331_1==VERTICAL_BAR) ) {
					alt331=3;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 331, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case SQL92_RESERVED_CURRENT:
				{
				alt331=2;
				}
				break;
			case APPROXIMATE_NUM_LIT:
			case BINDVAR:
			case CHAR_STRING:
			case CHAR_STRING_PERL:
			case COLON:
			case DELIMITED_ID:
			case EXACT_NUM_LIT:
			case INTRODUCER:
			case LEFT_PAREN:
			case MINUS_SIGN:
			case NATIONAL_CHAR_STRING_LIT:
			case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
			case PLUS_SIGN:
			case SQL92_RESERVED_ALL:
			case SQL92_RESERVED_ANY:
			case SQL92_RESERVED_CASE:
			case SQL92_RESERVED_DATE:
			case SQL92_RESERVED_DEFAULT:
			case SQL92_RESERVED_DELETE:
			case SQL92_RESERVED_DISTINCT:
			case SQL92_RESERVED_EXISTS:
			case SQL92_RESERVED_FALSE:
			case SQL92_RESERVED_NULL:
			case SQL92_RESERVED_PRIOR:
			case SQL92_RESERVED_TRUE:
			case UNSIGNED_INTEGER:
				{
				alt331=3;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 331, 0, input);
				throw nvae;
			}
			switch (alt331) {
				case 1 :
					// PLSQL_DMLParser.g:1312:10: unbounded_key ^ preceding_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_unbounded_key_in_windowing_elements14178);
					unbounded_key1035=gPLSQLParser.unbounded_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(unbounded_key1035.getTree(), root_0);
					pushFollow(FOLLOW_preceding_key_in_windowing_elements14181);
					preceding_key1036=gPLSQLParser.preceding_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, preceding_key1036.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1313:10: current_key ^ row_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_current_key_in_windowing_elements14192);
					current_key1037=gPLSQLParser.current_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(current_key1037.getTree(), root_0);
					pushFollow(FOLLOW_row_key_in_windowing_elements14195);
					row_key1038=gPLSQLParser.row_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, row_key1038.getTree());

					}
					break;
				case 3 :
					// PLSQL_DMLParser.g:1314:10: concatenation_wrapper ( preceding_key ^| following_key ^)
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_concatenation_wrapper_in_windowing_elements14206);
					concatenation_wrapper1039=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1039.getTree());

					// PLSQL_DMLParser.g:1314:32: ( preceding_key ^| following_key ^)
					int alt330=2;
					int LA330_0 = input.LA(1);
					if ( (LA330_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("preceding"))||(input.LT(1).getText().equalsIgnoreCase("following"))))) {
						int LA330_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("preceding"))) ) {
							alt330=1;
						}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("following"))) ) {
							alt330=2;
						}

						else {
							if (state.backtracking>0) {state.failed=true; return retval;}
							int nvaeMark = input.mark();
							try {
								input.consume();
								NoViableAltException nvae =
									new NoViableAltException("", 330, 1, input);
								throw nvae;
							} finally {
								input.rewind(nvaeMark);
							}
						}

					}

					switch (alt330) {
						case 1 :
							// PLSQL_DMLParser.g:1314:33: preceding_key ^
							{
							pushFollow(FOLLOW_preceding_key_in_windowing_elements14209);
							preceding_key1040=gPLSQLParser.preceding_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(preceding_key1040.getTree(), root_0);
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1314:48: following_key ^
							{
							pushFollow(FOLLOW_following_key_in_windowing_elements14212);
							following_key1041=gPLSQLParser.following_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(following_key1041.getTree(), root_0);
							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "windowing_elements"


	public static class using_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "using_clause"
	// PLSQL_DMLParser.g:1317:1: using_clause : using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* ) ;
	public final PLSQLParser_PLSQL_DMLParser.using_clause_return using_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.using_clause_return retval = new PLSQLParser_PLSQL_DMLParser.using_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token ASTERISK1043=null;
		Token COMMA1045=null;
		ParserRuleReturnScope using_key1042 =null;
		ParserRuleReturnScope using_element1044 =null;
		ParserRuleReturnScope using_element1046 =null;

		Object ASTERISK1043_tree=null;
		Object COMMA1045_tree=null;

		try {
			// PLSQL_DMLParser.g:1318:5: ( using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* ) )
			// PLSQL_DMLParser.g:1318:10: using_key ^ ( ASTERISK | using_element ( COMMA ! using_element )* )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_using_key_in_using_clause14234);
			using_key1042=gPLSQLParser.using_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(using_key1042.getTree(), root_0);
			// PLSQL_DMLParser.g:1319:5: ( ASTERISK | using_element ( COMMA ! using_element )* )
			int alt333=2;
			int LA333_0 = input.LA(1);
			if ( (LA333_0==ASTERISK) ) {
				alt333=1;
			}
			else if ( (LA333_0==APPROXIMATE_NUM_LIT||LA333_0==BINDVAR||(LA333_0 >= CHAR_STRING && LA333_0 <= COLON)||LA333_0==DELIMITED_ID||LA333_0==EXACT_NUM_LIT||LA333_0==INTRODUCER||LA333_0==LEFT_PAREN||LA333_0==MINUS_SIGN||LA333_0==NATIONAL_CHAR_STRING_LIT||LA333_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA333_0==PLUS_SIGN||LA333_0==REGULAR_ID||LA333_0==SQL92_RESERVED_ALL||LA333_0==SQL92_RESERVED_ANY||LA333_0==SQL92_RESERVED_CASE||(LA333_0 >= SQL92_RESERVED_CURSOR && LA333_0 <= SQL92_RESERVED_DATE)||(LA333_0 >= SQL92_RESERVED_DEFAULT && LA333_0 <= SQL92_RESERVED_DELETE)||LA333_0==SQL92_RESERVED_DISTINCT||(LA333_0 >= SQL92_RESERVED_EXISTS && LA333_0 <= SQL92_RESERVED_FALSE)||LA333_0==SQL92_RESERVED_IN||(LA333_0 >= SQL92_RESERVED_NOT && LA333_0 <= SQL92_RESERVED_NULL)||LA333_0==SQL92_RESERVED_PRIOR||LA333_0==SQL92_RESERVED_TRUE||LA333_0==UNSIGNED_INTEGER) ) {
				alt333=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 333, 0, input);
				throw nvae;
			}

			switch (alt333) {
				case 1 :
					// PLSQL_DMLParser.g:1319:10: ASTERISK
					{
					ASTERISK1043=(Token)match(input,ASTERISK,FOLLOW_ASTERISK_in_using_clause14246); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ASTERISK1043_tree = (Object)adaptor.create(ASTERISK1043);
					adaptor.addChild(root_0, ASTERISK1043_tree);
					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1320:10: using_element ( COMMA ! using_element )*
					{
					pushFollow(FOLLOW_using_element_in_using_clause14257);
					using_element1044=using_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, using_element1044.getTree());

					// PLSQL_DMLParser.g:1320:24: ( COMMA ! using_element )*
					loop332:
					while (true) {
						int alt332=2;
						int LA332_0 = input.LA(1);
						if ( (LA332_0==COMMA) ) {
							alt332=1;
						}

						switch (alt332) {
						case 1 :
							// PLSQL_DMLParser.g:1320:25: COMMA ! using_element
							{
							COMMA1045=(Token)match(input,COMMA,FOLLOW_COMMA_in_using_clause14260); if (state.failed) return retval;
							pushFollow(FOLLOW_using_element_in_using_clause14263);
							using_element1046=using_element();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, using_element1046.getTree());

							}
							break;

						default :
							break loop332;
						}
					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "using_clause"


	public static class using_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "using_element"
	// PLSQL_DMLParser.g:1324:1: using_element : ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.using_element_return using_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.using_element_return retval = new PLSQLParser_PLSQL_DMLParser.using_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope in_key1047 =null;
		ParserRuleReturnScope out_key1048 =null;
		ParserRuleReturnScope out_key1049 =null;
		ParserRuleReturnScope select_list_elements1050 =null;
		ParserRuleReturnScope column_alias1051 =null;

		RewriteRuleSubtreeStream stream_in_key=new RewriteRuleSubtreeStream(adaptor,"rule in_key");
		RewriteRuleSubtreeStream stream_out_key=new RewriteRuleSubtreeStream(adaptor,"rule out_key");
		RewriteRuleSubtreeStream stream_column_alias=new RewriteRuleSubtreeStream(adaptor,"rule column_alias");
		RewriteRuleSubtreeStream stream_select_list_elements=new RewriteRuleSubtreeStream(adaptor,"rule select_list_elements");

		try {
			// PLSQL_DMLParser.g:1325:5: ( ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? ) )
			// PLSQL_DMLParser.g:1325:10: ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )?
			{
			// PLSQL_DMLParser.g:1325:10: ( in_key ( out_key )? | out_key )?
			int alt335=3;
			int LA335_0 = input.LA(1);
			if ( (LA335_0==SQL92_RESERVED_IN) ) {
				alt335=1;
			}
			else if ( (LA335_0==REGULAR_ID) ) {
				int LA335_2 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("out"))) ) {
					alt335=2;
				}
			}
			switch (alt335) {
				case 1 :
					// PLSQL_DMLParser.g:1325:11: in_key ( out_key )?
					{
					pushFollow(FOLLOW_in_key_in_using_element14292);
					in_key1047=gPLSQLParser.in_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_in_key.add(in_key1047.getTree());
					// PLSQL_DMLParser.g:1325:18: ( out_key )?
					int alt334=2;
					int LA334_0 = input.LA(1);
					if ( (LA334_0==REGULAR_ID) ) {
						int LA334_1 = input.LA(2);
						if ( ((input.LT(1).getText().equalsIgnoreCase("out"))) ) {
							alt334=1;
						}
					}
					switch (alt334) {
						case 1 :
							// PLSQL_DMLParser.g:1325:18: out_key
							{
							pushFollow(FOLLOW_out_key_in_using_element14294);
							out_key1048=gPLSQLParser.out_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_out_key.add(out_key1048.getTree());
							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1325:27: out_key
					{
					pushFollow(FOLLOW_out_key_in_using_element14297);
					out_key1049=gPLSQLParser.out_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_out_key.add(out_key1049.getTree());
					}
					break;

			}

			pushFollow(FOLLOW_select_list_elements_in_using_element14301);
			select_list_elements1050=select_list_elements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_select_list_elements.add(select_list_elements1050.getTree());
			// PLSQL_DMLParser.g:1325:58: ( column_alias )?
			int alt336=2;
			switch ( input.LA(1) ) {
				case SQL92_RESERVED_AS:
					{
					alt336=1;
					}
					break;
				case INTRODUCER:
					{
					alt336=1;
					}
					break;
				case REGULAR_ID:
					{
					alt336=1;
					}
					break;
				case DELIMITED_ID:
					{
					alt336=1;
					}
					break;
				case CHAR_STRING:
				case CHAR_STRING_PERL:
				case NATIONAL_CHAR_STRING_LIT:
					{
					alt336=1;
					}
					break;
			}
			switch (alt336) {
				case 1 :
					// PLSQL_DMLParser.g:1325:58: column_alias
					{
					pushFollow(FOLLOW_column_alias_in_using_element14303);
					column_alias1051=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_column_alias.add(column_alias1051.getTree());
					}
					break;

			}

			// AST REWRITE
			// elements: out_key, column_alias, select_list_elements, in_key
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1326:9: -> ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? )
			{
				// PLSQL_DMLParser.g:1326:12: ^( ELEMENT ( in_key )? ( out_key )? select_list_elements ( column_alias )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ELEMENT, "ELEMENT"), root_1);
				// PLSQL_DMLParser.g:1326:22: ( in_key )?
				if ( stream_in_key.hasNext() ) {
					adaptor.addChild(root_1, stream_in_key.nextTree());
				}
				stream_in_key.reset();

				// PLSQL_DMLParser.g:1326:30: ( out_key )?
				if ( stream_out_key.hasNext() ) {
					adaptor.addChild(root_1, stream_out_key.nextTree());
				}
				stream_out_key.reset();

				adaptor.addChild(root_1, stream_select_list_elements.nextTree());
				// PLSQL_DMLParser.g:1326:60: ( column_alias )?
				if ( stream_column_alias.hasNext() ) {
					adaptor.addChild(root_1, stream_column_alias.nextTree());
				}
				stream_column_alias.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "using_element"


	public static class collect_order_by_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "collect_order_by_part"
	// PLSQL_DMLParser.g:1329:1: collect_order_by_part : order_key ^ by_key ! concatenation_wrapper ;
	public final PLSQLParser_PLSQL_DMLParser.collect_order_by_part_return collect_order_by_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.collect_order_by_part_return retval = new PLSQLParser_PLSQL_DMLParser.collect_order_by_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope order_key1052 =null;
		ParserRuleReturnScope by_key1053 =null;
		ParserRuleReturnScope concatenation_wrapper1054 =null;


		try {
			// PLSQL_DMLParser.g:1330:5: ( order_key ^ by_key ! concatenation_wrapper )
			// PLSQL_DMLParser.g:1330:10: order_key ^ by_key ! concatenation_wrapper
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_order_key_in_collect_order_by_part14349);
			order_key1052=gPLSQLParser.order_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(order_key1052.getTree(), root_0);
			pushFollow(FOLLOW_by_key_in_collect_order_by_part14352);
			by_key1053=gPLSQLParser.by_key();
			state._fsp--;
			if (state.failed) return retval;
			pushFollow(FOLLOW_concatenation_wrapper_in_collect_order_by_part14355);
			concatenation_wrapper1054=concatenation_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1054.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "collect_order_by_part"


	public static class within_or_over_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "within_or_over_part"
	// PLSQL_DMLParser.g:1333:1: within_or_over_part : ( within_key ^ group_key ! LEFT_PAREN ! order_by_clause RIGHT_PAREN !| over_clause );
	public final PLSQLParser_PLSQL_DMLParser.within_or_over_part_return within_or_over_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.within_or_over_part_return retval = new PLSQLParser_PLSQL_DMLParser.within_or_over_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN1057=null;
		Token RIGHT_PAREN1059=null;
		ParserRuleReturnScope within_key1055 =null;
		ParserRuleReturnScope group_key1056 =null;
		ParserRuleReturnScope order_by_clause1058 =null;
		ParserRuleReturnScope over_clause1060 =null;

		Object LEFT_PAREN1057_tree=null;
		Object RIGHT_PAREN1059_tree=null;

		try {
			// PLSQL_DMLParser.g:1334:5: ( within_key ^ group_key ! LEFT_PAREN ! order_by_clause RIGHT_PAREN !| over_clause )
			int alt337=2;
			int LA337_0 = input.LA(1);
			if ( (LA337_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("within"))||(input.LT(1).getText().equalsIgnoreCase("over"))))) {
				int LA337_1 = input.LA(2);
				if ( (LA337_1==SQL92_RESERVED_GROUP) && ((input.LT(1).getText().equalsIgnoreCase("within")))) {
					alt337=1;
				}
				else if ( (LA337_1==LEFT_PAREN) && ((input.LT(1).getText().equalsIgnoreCase("over")))) {
					alt337=2;
				}

			}

			switch (alt337) {
				case 1 :
					// PLSQL_DMLParser.g:1334:10: within_key ^ group_key ! LEFT_PAREN ! order_by_clause RIGHT_PAREN !
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_within_key_in_within_or_over_part14375);
					within_key1055=gPLSQLParser.within_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(within_key1055.getTree(), root_0);
					pushFollow(FOLLOW_group_key_in_within_or_over_part14378);
					group_key1056=gPLSQLParser.group_key();
					state._fsp--;
					if (state.failed) return retval;
					LEFT_PAREN1057=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_within_or_over_part14381); if (state.failed) return retval;
					pushFollow(FOLLOW_order_by_clause_in_within_or_over_part14384);
					order_by_clause1058=order_by_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, order_by_clause1058.getTree());

					RIGHT_PAREN1059=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_within_or_over_part14386); if (state.failed) return retval;
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1335:10: over_clause
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_over_clause_in_within_or_over_part14398);
					over_clause1060=over_clause();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, over_clause1060.getTree());

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "within_or_over_part"


	public static class cost_matrix_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cost_matrix_clause"
	// PLSQL_DMLParser.g:1338:1: cost_matrix_clause : cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN ! cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN ! values_key ! expression_list ) ;
	public final PLSQLParser_PLSQL_DMLParser.cost_matrix_clause_return cost_matrix_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.cost_matrix_clause_return retval = new PLSQLParser_PLSQL_DMLParser.cost_matrix_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN1064=null;
		Token COMMA1066=null;
		Token RIGHT_PAREN1068=null;
		ParserRuleReturnScope cost_key1061 =null;
		ParserRuleReturnScope model_key1062 =null;
		ParserRuleReturnScope auto_key1063 =null;
		ParserRuleReturnScope cost_class_name1065 =null;
		ParserRuleReturnScope cost_class_name1067 =null;
		ParserRuleReturnScope values_key1069 =null;
		ParserRuleReturnScope expression_list1070 =null;

		Object LEFT_PAREN1064_tree=null;
		Object COMMA1066_tree=null;
		Object RIGHT_PAREN1068_tree=null;

		try {
			// PLSQL_DMLParser.g:1339:5: ( cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN ! cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN ! values_key ! expression_list ) )
			// PLSQL_DMLParser.g:1339:10: cost_key ^ ( model_key ( auto_key )? | LEFT_PAREN ! cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN ! values_key ! expression_list )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_cost_key_in_cost_matrix_clause14418);
			cost_key1061=gPLSQLParser.cost_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(cost_key1061.getTree(), root_0);
			// PLSQL_DMLParser.g:1340:5: ( model_key ( auto_key )? | LEFT_PAREN ! cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN ! values_key ! expression_list )
			int alt340=2;
			int LA340_0 = input.LA(1);
			if ( (LA340_0==PLSQL_NON_RESERVED_MODEL) ) {
				alt340=1;
			}
			else if ( (LA340_0==LEFT_PAREN) ) {
				alt340=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 340, 0, input);
				throw nvae;
			}

			switch (alt340) {
				case 1 :
					// PLSQL_DMLParser.g:1340:10: model_key ( auto_key )?
					{
					pushFollow(FOLLOW_model_key_in_cost_matrix_clause14430);
					model_key1062=gPLSQLParser.model_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, model_key1062.getTree());

					// PLSQL_DMLParser.g:1340:20: ( auto_key )?
					int alt338=2;
					int LA338_0 = input.LA(1);
					if ( (LA338_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("auto")))) {
						alt338=1;
					}
					switch (alt338) {
						case 1 :
							// PLSQL_DMLParser.g:1340:20: auto_key
							{
							pushFollow(FOLLOW_auto_key_in_cost_matrix_clause14432);
							auto_key1063=gPLSQLParser.auto_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, auto_key1063.getTree());

							}
							break;

					}

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1341:10: LEFT_PAREN ! cost_class_name ( COMMA ! cost_class_name )* RIGHT_PAREN ! values_key ! expression_list
					{
					LEFT_PAREN1064=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_cost_matrix_clause14444); if (state.failed) return retval;
					pushFollow(FOLLOW_cost_class_name_in_cost_matrix_clause14447);
					cost_class_name1065=gPLSQLParser.cost_class_name();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, cost_class_name1065.getTree());

					// PLSQL_DMLParser.g:1341:38: ( COMMA ! cost_class_name )*
					loop339:
					while (true) {
						int alt339=2;
						int LA339_0 = input.LA(1);
						if ( (LA339_0==COMMA) ) {
							alt339=1;
						}

						switch (alt339) {
						case 1 :
							// PLSQL_DMLParser.g:1341:39: COMMA ! cost_class_name
							{
							COMMA1066=(Token)match(input,COMMA,FOLLOW_COMMA_in_cost_matrix_clause14450); if (state.failed) return retval;
							pushFollow(FOLLOW_cost_class_name_in_cost_matrix_clause14453);
							cost_class_name1067=gPLSQLParser.cost_class_name();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, cost_class_name1067.getTree());

							}
							break;

						default :
							break loop339;
						}
					}

					RIGHT_PAREN1068=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14457); if (state.failed) return retval;
					pushFollow(FOLLOW_values_key_in_cost_matrix_clause14460);
					values_key1069=gPLSQLParser.values_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_expression_list_in_cost_matrix_clause14476);
					expression_list1070=expression_list();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_list1070.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cost_matrix_clause"


	public static class xml_passing_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_passing_clause"
	// PLSQL_DMLParser.g:1346:1: xml_passing_clause : passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? )* ;
	public final PLSQLParser_PLSQL_DMLParser.xml_passing_clause_return xml_passing_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_passing_clause_return retval = new PLSQLParser_PLSQL_DMLParser.xml_passing_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token COMMA1076=null;
		ParserRuleReturnScope passing_key1071 =null;
		ParserRuleReturnScope by_key1072 =null;
		ParserRuleReturnScope value_key1073 =null;
		ParserRuleReturnScope expression_wrapper1074 =null;
		ParserRuleReturnScope column_alias1075 =null;
		ParserRuleReturnScope expression_wrapper1077 =null;
		ParserRuleReturnScope column_alias1078 =null;

		Object COMMA1076_tree=null;

		try {
			// PLSQL_DMLParser.g:1347:5: ( passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? )* )
			// PLSQL_DMLParser.g:1347:10: passing_key ^ ( by_key ! value_key )? expression_wrapper ( column_alias )? ( COMMA ! expression_wrapper ( column_alias )? )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_passing_key_in_xml_passing_clause14502);
			passing_key1071=gPLSQLParser.passing_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(passing_key1071.getTree(), root_0);
			// PLSQL_DMLParser.g:1347:23: ( by_key ! value_key )?
			int alt341=2;
			int LA341_0 = input.LA(1);
			if ( (LA341_0==SQL92_RESERVED_BY) ) {
				alt341=1;
			}
			switch (alt341) {
				case 1 :
					// PLSQL_DMLParser.g:1347:24: by_key ! value_key
					{
					pushFollow(FOLLOW_by_key_in_xml_passing_clause14506);
					by_key1072=gPLSQLParser.by_key();
					state._fsp--;
					if (state.failed) return retval;
					pushFollow(FOLLOW_value_key_in_xml_passing_clause14509);
					value_key1073=gPLSQLParser.value_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, value_key1073.getTree());

					}
					break;

			}

			pushFollow(FOLLOW_expression_wrapper_in_xml_passing_clause14525);
			expression_wrapper1074=expression_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper1074.getTree());

			// PLSQL_DMLParser.g:1348:32: ( column_alias )?
			int alt342=2;
			int LA342_0 = input.LA(1);
			if ( ((LA342_0 >= CHAR_STRING && LA342_0 <= CHAR_STRING_PERL)||LA342_0==DELIMITED_ID||LA342_0==INTRODUCER||LA342_0==NATIONAL_CHAR_STRING_LIT||LA342_0==SQL92_RESERVED_AS) ) {
				alt342=1;
			}
			else if ( (LA342_0==REGULAR_ID) ) {
				int LA342_3 = input.LA(2);
				if ( (!((((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("returning")))))) ) {
					alt342=1;
				}
			}
			switch (alt342) {
				case 1 :
					// PLSQL_DMLParser.g:1348:32: column_alias
					{
					pushFollow(FOLLOW_column_alias_in_xml_passing_clause14527);
					column_alias1075=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_alias1075.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:1348:46: ( COMMA ! expression_wrapper ( column_alias )? )*
			loop344:
			while (true) {
				int alt344=2;
				int LA344_0 = input.LA(1);
				if ( (LA344_0==COMMA) ) {
					alt344=1;
				}

				switch (alt344) {
				case 1 :
					// PLSQL_DMLParser.g:1348:47: COMMA ! expression_wrapper ( column_alias )?
					{
					COMMA1076=(Token)match(input,COMMA,FOLLOW_COMMA_in_xml_passing_clause14531); if (state.failed) return retval;
					pushFollow(FOLLOW_expression_wrapper_in_xml_passing_clause14534);
					expression_wrapper1077=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper1077.getTree());

					// PLSQL_DMLParser.g:1348:73: ( column_alias )?
					int alt343=2;
					int LA343_0 = input.LA(1);
					if ( ((LA343_0 >= CHAR_STRING && LA343_0 <= CHAR_STRING_PERL)||LA343_0==DELIMITED_ID||LA343_0==INTRODUCER||LA343_0==NATIONAL_CHAR_STRING_LIT||LA343_0==SQL92_RESERVED_AS) ) {
						alt343=1;
					}
					else if ( (LA343_0==REGULAR_ID) ) {
						int LA343_3 = input.LA(2);
						if ( (!((((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("returning")))))) ) {
							alt343=1;
						}
					}
					switch (alt343) {
						case 1 :
							// PLSQL_DMLParser.g:1348:73: column_alias
							{
							pushFollow(FOLLOW_column_alias_in_xml_passing_clause14536);
							column_alias1078=gPLSQLParser.column_alias();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, column_alias1078.getTree());

							}
							break;

					}

					}
					break;

				default :
					break loop344;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_passing_clause"


	public static class xml_attributes_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_attributes_clause"
	// PLSQL_DMLParser.g:1351:1: xml_attributes_clause : xmlattributes_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN !;
	public final PLSQLParser_PLSQL_DMLParser.xml_attributes_clause_return xml_attributes_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_attributes_clause_return retval = new PLSQLParser_PLSQL_DMLParser.xml_attributes_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN1080=null;
		Token COMMA1086=null;
		Token RIGHT_PAREN1088=null;
		ParserRuleReturnScope xmlattributes_key1079 =null;
		ParserRuleReturnScope entityescaping_key1081 =null;
		ParserRuleReturnScope noentityescaping_key1082 =null;
		ParserRuleReturnScope schemacheck_key1083 =null;
		ParserRuleReturnScope noschemacheck_key1084 =null;
		ParserRuleReturnScope xml_multiuse_expression_element1085 =null;
		ParserRuleReturnScope xml_multiuse_expression_element1087 =null;

		Object LEFT_PAREN1080_tree=null;
		Object COMMA1086_tree=null;
		Object RIGHT_PAREN1088_tree=null;

		try {
			// PLSQL_DMLParser.g:1352:5: ( xmlattributes_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN !)
			// PLSQL_DMLParser.g:1352:10: xmlattributes_key ^ LEFT_PAREN ! ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA ! xml_multiuse_expression_element )* RIGHT_PAREN !
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_xmlattributes_key_in_xml_attributes_clause14559);
			xmlattributes_key1079=gPLSQLParser.xmlattributes_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlattributes_key1079.getTree(), root_0);
			LEFT_PAREN1080=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_xml_attributes_clause14570); if (state.failed) return retval;
			// PLSQL_DMLParser.g:1354:13: ( entityescaping_key | noentityescaping_key )?
			int alt345=3;
			int LA345_0 = input.LA(1);
			if ( (LA345_0==REGULAR_ID) ) {
				int LA345_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("entityescaping"))) ) {
					alt345=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("noentityescaping"))) ) {
					alt345=2;
				}
			}
			switch (alt345) {
				case 1 :
					// PLSQL_DMLParser.g:1354:14: entityescaping_key
					{
					pushFollow(FOLLOW_entityescaping_key_in_xml_attributes_clause14586);
					entityescaping_key1081=gPLSQLParser.entityescaping_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, entityescaping_key1081.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1354:33: noentityescaping_key
					{
					pushFollow(FOLLOW_noentityescaping_key_in_xml_attributes_clause14588);
					noentityescaping_key1082=gPLSQLParser.noentityescaping_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, noentityescaping_key1082.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:1355:13: ( schemacheck_key | noschemacheck_key )?
			int alt346=3;
			int LA346_0 = input.LA(1);
			if ( (LA346_0==REGULAR_ID) ) {
				int LA346_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("schemacheck"))) ) {
					alt346=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("noschemacheck"))) ) {
					alt346=2;
				}
			}
			switch (alt346) {
				case 1 :
					// PLSQL_DMLParser.g:1355:14: schemacheck_key
					{
					pushFollow(FOLLOW_schemacheck_key_in_xml_attributes_clause14605);
					schemacheck_key1083=gPLSQLParser.schemacheck_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, schemacheck_key1083.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1355:30: noschemacheck_key
					{
					pushFollow(FOLLOW_noschemacheck_key_in_xml_attributes_clause14607);
					noschemacheck_key1084=gPLSQLParser.noschemacheck_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, noschemacheck_key1084.getTree());

					}
					break;

			}

			pushFollow(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause14623);
			xml_multiuse_expression_element1085=xml_multiuse_expression_element();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_multiuse_expression_element1085.getTree());

			// PLSQL_DMLParser.g:1356:45: ( COMMA ! xml_multiuse_expression_element )*
			loop347:
			while (true) {
				int alt347=2;
				int LA347_0 = input.LA(1);
				if ( (LA347_0==COMMA) ) {
					alt347=1;
				}

				switch (alt347) {
				case 1 :
					// PLSQL_DMLParser.g:1356:46: COMMA ! xml_multiuse_expression_element
					{
					COMMA1086=(Token)match(input,COMMA,FOLLOW_COMMA_in_xml_attributes_clause14626); if (state.failed) return retval;
					pushFollow(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause14629);
					xml_multiuse_expression_element1087=xml_multiuse_expression_element();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_multiuse_expression_element1087.getTree());

					}
					break;

				default :
					break loop347;
				}
			}

			RIGHT_PAREN1088=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_xml_attributes_clause14641); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_attributes_clause"


	public static class xml_namespaces_clause_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_namespaces_clause"
	// PLSQL_DMLParser.g:1360:1: xml_namespaces_clause : xmlnamespaces_key ^ LEFT_PAREN ! ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN !;
	public final PLSQLParser_PLSQL_DMLParser.xml_namespaces_clause_return xml_namespaces_clause() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_namespaces_clause_return retval = new PLSQLParser_PLSQL_DMLParser.xml_namespaces_clause_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token LEFT_PAREN1090=null;
		Token COMMA1093=null;
		Token RIGHT_PAREN1097=null;
		ParserRuleReturnScope xmlnamespaces_key1089 =null;
		ParserRuleReturnScope concatenation_wrapper1091 =null;
		ParserRuleReturnScope column_alias1092 =null;
		ParserRuleReturnScope concatenation_wrapper1094 =null;
		ParserRuleReturnScope column_alias1095 =null;
		ParserRuleReturnScope xml_general_default_part1096 =null;

		Object LEFT_PAREN1090_tree=null;
		Object COMMA1093_tree=null;
		Object RIGHT_PAREN1097_tree=null;

		try {
			// PLSQL_DMLParser.g:1361:5: ( xmlnamespaces_key ^ LEFT_PAREN ! ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN !)
			// PLSQL_DMLParser.g:1361:10: xmlnamespaces_key ^ LEFT_PAREN ! ( concatenation_wrapper column_alias )? ( COMMA ! concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN !
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause14662);
			xmlnamespaces_key1089=gPLSQLParser.xmlnamespaces_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(xmlnamespaces_key1089.getTree(), root_0);
			LEFT_PAREN1090=(Token)match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_xml_namespaces_clause14673); if (state.failed) return retval;
			// PLSQL_DMLParser.g:1363:13: ( concatenation_wrapper column_alias )?
			int alt348=2;
			int LA348_0 = input.LA(1);
			if ( (LA348_0==APPROXIMATE_NUM_LIT||LA348_0==BINDVAR||(LA348_0 >= CHAR_STRING && LA348_0 <= COLON)||LA348_0==DELIMITED_ID||LA348_0==EXACT_NUM_LIT||LA348_0==INTRODUCER||LA348_0==LEFT_PAREN||LA348_0==MINUS_SIGN||LA348_0==NATIONAL_CHAR_STRING_LIT||LA348_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA348_0==PLUS_SIGN||LA348_0==REGULAR_ID||LA348_0==SQL92_RESERVED_ALL||LA348_0==SQL92_RESERVED_ANY||LA348_0==SQL92_RESERVED_CASE||LA348_0==SQL92_RESERVED_DATE||LA348_0==SQL92_RESERVED_DELETE||LA348_0==SQL92_RESERVED_DISTINCT||(LA348_0 >= SQL92_RESERVED_EXISTS && LA348_0 <= SQL92_RESERVED_FALSE)||LA348_0==SQL92_RESERVED_NULL||LA348_0==SQL92_RESERVED_PRIOR||LA348_0==SQL92_RESERVED_TRUE||LA348_0==UNSIGNED_INTEGER) ) {
				alt348=1;
			}
			else if ( (LA348_0==SQL92_RESERVED_DEFAULT) ) {
				alt348=1;
			}
			switch (alt348) {
				case 1 :
					// PLSQL_DMLParser.g:1363:14: concatenation_wrapper column_alias
					{
					pushFollow(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause14689);
					concatenation_wrapper1091=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1091.getTree());

					pushFollow(FOLLOW_column_alias_in_xml_namespaces_clause14691);
					column_alias1092=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_alias1092.getTree());

					}
					break;

			}

			// PLSQL_DMLParser.g:1364:17: ( COMMA ! concatenation_wrapper column_alias )*
			loop349:
			while (true) {
				int alt349=2;
				int LA349_0 = input.LA(1);
				if ( (LA349_0==COMMA) ) {
					alt349=1;
				}

				switch (alt349) {
				case 1 :
					// PLSQL_DMLParser.g:1364:18: COMMA ! concatenation_wrapper column_alias
					{
					COMMA1093=(Token)match(input,COMMA,FOLLOW_COMMA_in_xml_namespaces_clause14712); if (state.failed) return retval;
					pushFollow(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause14715);
					concatenation_wrapper1094=concatenation_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1094.getTree());

					pushFollow(FOLLOW_column_alias_in_xml_namespaces_clause14717);
					column_alias1095=gPLSQLParser.column_alias();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, column_alias1095.getTree());

					}
					break;

				default :
					break loop349;
				}
			}

			// PLSQL_DMLParser.g:1365:13: ( ( default_key )=> xml_general_default_part )?
			int alt350=2;
			int LA350_0 = input.LA(1);
			if ( (LA350_0==SQL92_RESERVED_DEFAULT) && (synpred49_PLSQL_DMLParser())) {
				alt350=1;
			}
			switch (alt350) {
				case 1 :
					// PLSQL_DMLParser.g:1365:14: ( default_key )=> xml_general_default_part
					{
					pushFollow(FOLLOW_xml_general_default_part_in_xml_namespaces_clause14739);
					xml_general_default_part1096=xml_general_default_part();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, xml_general_default_part1096.getTree());

					}
					break;

			}

			RIGHT_PAREN1097=(Token)match(input,RIGHT_PAREN,FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause14751); if (state.failed) return retval;
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_namespaces_clause"


	public static class xml_table_column_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_table_column"
	// PLSQL_DMLParser.g:1369:1: xml_table_column : xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.xml_table_column_return xml_table_column() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_table_column_return retval = new PLSQLParser_PLSQL_DMLParser.xml_table_column_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope xml_column_name1098 =null;
		ParserRuleReturnScope for_key1099 =null;
		ParserRuleReturnScope ordinality_key1100 =null;
		ParserRuleReturnScope type_spec1101 =null;
		ParserRuleReturnScope path_key1102 =null;
		ParserRuleReturnScope concatenation_wrapper1103 =null;
		ParserRuleReturnScope xml_general_default_part1104 =null;

		RewriteRuleSubtreeStream stream_for_key=new RewriteRuleSubtreeStream(adaptor,"rule for_key");
		RewriteRuleSubtreeStream stream_type_spec=new RewriteRuleSubtreeStream(adaptor,"rule type_spec");
		RewriteRuleSubtreeStream stream_xml_general_default_part=new RewriteRuleSubtreeStream(adaptor,"rule xml_general_default_part");
		RewriteRuleSubtreeStream stream_ordinality_key=new RewriteRuleSubtreeStream(adaptor,"rule ordinality_key");
		RewriteRuleSubtreeStream stream_xml_column_name=new RewriteRuleSubtreeStream(adaptor,"rule xml_column_name");
		RewriteRuleSubtreeStream stream_path_key=new RewriteRuleSubtreeStream(adaptor,"rule path_key");
		RewriteRuleSubtreeStream stream_concatenation_wrapper=new RewriteRuleSubtreeStream(adaptor,"rule concatenation_wrapper");

		try {
			// PLSQL_DMLParser.g:1370:5: ( xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? ) )
			// PLSQL_DMLParser.g:1370:10: xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
			{
			pushFollow(FOLLOW_xml_column_name_in_xml_table_column14772);
			xml_column_name1098=gPLSQLParser.xml_column_name();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_xml_column_name.add(xml_column_name1098.getTree());
			// PLSQL_DMLParser.g:1371:5: ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
			int alt353=2;
			int LA353_0 = input.LA(1);
			if ( (LA353_0==SQL92_RESERVED_FOR) ) {
				alt353=1;
			}
			else if ( (LA353_0==DELIMITED_ID||LA353_0==REGULAR_ID||LA353_0==SQL92_RESERVED_DATE) ) {
				alt353=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 353, 0, input);
				throw nvae;
			}

			switch (alt353) {
				case 1 :
					// PLSQL_DMLParser.g:1371:10: for_key ordinality_key
					{
					pushFollow(FOLLOW_for_key_in_xml_table_column14783);
					for_key1099=gPLSQLParser.for_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_for_key.add(for_key1099.getTree());
					pushFollow(FOLLOW_ordinality_key_in_xml_table_column14785);
					ordinality_key1100=gPLSQLParser.ordinality_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_ordinality_key.add(ordinality_key1100.getTree());
					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1372:10: type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )?
					{
					pushFollow(FOLLOW_type_spec_in_xml_table_column14796);
					type_spec1101=gPLSQLParser.type_spec();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_type_spec.add(type_spec1101.getTree());
					// PLSQL_DMLParser.g:1372:20: ( path_key concatenation_wrapper )?
					int alt351=2;
					int LA351_0 = input.LA(1);
					if ( (LA351_0==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("path")))) {
						alt351=1;
					}
					switch (alt351) {
						case 1 :
							// PLSQL_DMLParser.g:1372:21: path_key concatenation_wrapper
							{
							pushFollow(FOLLOW_path_key_in_xml_table_column14799);
							path_key1102=gPLSQLParser.path_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_path_key.add(path_key1102.getTree());
							pushFollow(FOLLOW_concatenation_wrapper_in_xml_table_column14801);
							concatenation_wrapper1103=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation_wrapper.add(concatenation_wrapper1103.getTree());
							}
							break;

					}

					// PLSQL_DMLParser.g:1372:54: ( ( default_key )=> xml_general_default_part )?
					int alt352=2;
					int LA352_0 = input.LA(1);
					if ( (LA352_0==SQL92_RESERVED_DEFAULT) && (synpred50_PLSQL_DMLParser())) {
						alt352=1;
					}
					switch (alt352) {
						case 1 :
							// PLSQL_DMLParser.g:1372:55: ( default_key )=> xml_general_default_part
							{
							pushFollow(FOLLOW_xml_general_default_part_in_xml_table_column14811);
							xml_general_default_part1104=xml_general_default_part();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_xml_general_default_part.add(xml_general_default_part1104.getTree());
							}
							break;

					}

					}
					break;

			}

			// AST REWRITE
			// elements: ordinality_key, type_spec, xml_general_default_part, concatenation_wrapper, xml_column_name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1374:9: -> ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? )
			{
				// PLSQL_DMLParser.g:1374:12: ^( XML_COLUMN xml_column_name ( ordinality_key )? ( type_spec )? ( concatenation_wrapper )? ( xml_general_default_part )? )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_COLUMN, "XML_COLUMN"), root_1);
				adaptor.addChild(root_1, stream_xml_column_name.nextTree());
				// PLSQL_DMLParser.g:1374:41: ( ordinality_key )?
				if ( stream_ordinality_key.hasNext() ) {
					adaptor.addChild(root_1, stream_ordinality_key.nextTree());
				}
				stream_ordinality_key.reset();

				// PLSQL_DMLParser.g:1374:57: ( type_spec )?
				if ( stream_type_spec.hasNext() ) {
					adaptor.addChild(root_1, stream_type_spec.nextTree());
				}
				stream_type_spec.reset();

				// PLSQL_DMLParser.g:1374:68: ( concatenation_wrapper )?
				if ( stream_concatenation_wrapper.hasNext() ) {
					adaptor.addChild(root_1, stream_concatenation_wrapper.nextTree());
				}
				stream_concatenation_wrapper.reset();

				// PLSQL_DMLParser.g:1374:91: ( xml_general_default_part )?
				if ( stream_xml_general_default_part.hasNext() ) {
					adaptor.addChild(root_1, stream_xml_general_default_part.nextTree());
				}
				stream_xml_general_default_part.reset();

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_table_column"


	public static class xml_general_default_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_general_default_part"
	// PLSQL_DMLParser.g:1377:1: xml_general_default_part : default_key ^ concatenation_wrapper ;
	public final PLSQLParser_PLSQL_DMLParser.xml_general_default_part_return xml_general_default_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_general_default_part_return retval = new PLSQLParser_PLSQL_DMLParser.xml_general_default_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope default_key1105 =null;
		ParserRuleReturnScope concatenation_wrapper1106 =null;


		try {
			// PLSQL_DMLParser.g:1378:5: ( default_key ^ concatenation_wrapper )
			// PLSQL_DMLParser.g:1378:10: default_key ^ concatenation_wrapper
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_default_key_in_xml_general_default_part14867);
			default_key1105=gPLSQLParser.default_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(default_key1105.getTree(), root_0);
			pushFollow(FOLLOW_concatenation_wrapper_in_xml_general_default_part14870);
			concatenation_wrapper1106=concatenation_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1106.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_general_default_part"


	public static class xml_multiuse_expression_element_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_multiuse_expression_element"
	// PLSQL_DMLParser.g:1381:1: xml_multiuse_expression_element : expression ( as_key ( id_expression | evalname_key concatenation ) )? -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) ) -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) ) -> ^( XML_ELEMENT ^( EXPR expression ) ) ;
	public final PLSQLParser_PLSQL_DMLParser.xml_multiuse_expression_element_return xml_multiuse_expression_element() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xml_multiuse_expression_element_return retval = new PLSQLParser_PLSQL_DMLParser.xml_multiuse_expression_element_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope expression1107 =null;
		ParserRuleReturnScope as_key1108 =null;
		ParserRuleReturnScope id_expression1109 =null;
		ParserRuleReturnScope evalname_key1110 =null;
		ParserRuleReturnScope concatenation1111 =null;

		RewriteRuleSubtreeStream stream_id_expression=new RewriteRuleSubtreeStream(adaptor,"rule id_expression");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_concatenation=new RewriteRuleSubtreeStream(adaptor,"rule concatenation");
		RewriteRuleSubtreeStream stream_as_key=new RewriteRuleSubtreeStream(adaptor,"rule as_key");
		RewriteRuleSubtreeStream stream_evalname_key=new RewriteRuleSubtreeStream(adaptor,"rule evalname_key");

		    int mode = 0;    
		try {
			// PLSQL_DMLParser.g:1383:5: ( expression ( as_key ( id_expression | evalname_key concatenation ) )? -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) ) -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) ) -> ^( XML_ELEMENT ^( EXPR expression ) ) )
			// PLSQL_DMLParser.g:1383:10: expression ( as_key ( id_expression | evalname_key concatenation ) )?
			{
			pushFollow(FOLLOW_expression_in_xml_multiuse_expression_element14898);
			expression1107=expression();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) stream_expression.add(expression1107.getTree());
			// PLSQL_DMLParser.g:1383:21: ( as_key ( id_expression | evalname_key concatenation ) )?
			int alt355=2;
			int LA355_0 = input.LA(1);
			if ( (LA355_0==SQL92_RESERVED_AS) ) {
				alt355=1;
			}
			switch (alt355) {
				case 1 :
					// PLSQL_DMLParser.g:1383:22: as_key ( id_expression | evalname_key concatenation )
					{
					pushFollow(FOLLOW_as_key_in_xml_multiuse_expression_element14901);
					as_key1108=gPLSQLParser.as_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) stream_as_key.add(as_key1108.getTree());
					// PLSQL_DMLParser.g:1383:29: ( id_expression | evalname_key concatenation )
					int alt354=2;
					int LA354_0 = input.LA(1);
					if ( (LA354_0==REGULAR_ID) ) {
						int LA354_1 = input.LA(2);
						if ( (LA354_1==COMMA||LA354_1==RIGHT_PAREN) ) {
							alt354=1;
						}
						else if ( (LA354_1==APPROXIMATE_NUM_LIT||LA354_1==BINDVAR||(LA354_1 >= CHAR_STRING && LA354_1 <= COLON)||LA354_1==DELIMITED_ID||LA354_1==EXACT_NUM_LIT||LA354_1==INTRODUCER||LA354_1==LEFT_PAREN||LA354_1==MINUS_SIGN||LA354_1==NATIONAL_CHAR_STRING_LIT||LA354_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA354_1==PLUS_SIGN||LA354_1==REGULAR_ID||LA354_1==SQL92_RESERVED_ALL||LA354_1==SQL92_RESERVED_ANY||LA354_1==SQL92_RESERVED_CASE||LA354_1==SQL92_RESERVED_DATE||(LA354_1 >= SQL92_RESERVED_DEFAULT && LA354_1 <= SQL92_RESERVED_DELETE)||LA354_1==SQL92_RESERVED_DISTINCT||(LA354_1 >= SQL92_RESERVED_EXISTS && LA354_1 <= SQL92_RESERVED_FALSE)||LA354_1==SQL92_RESERVED_NULL||LA354_1==SQL92_RESERVED_PRIOR||LA354_1==SQL92_RESERVED_TRUE||LA354_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {
							alt354=2;
						}

					}
					else if ( (LA354_0==DELIMITED_ID) ) {
						alt354=1;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 354, 0, input);
						throw nvae;
					}

					switch (alt354) {
						case 1 :
							// PLSQL_DMLParser.g:1383:30: id_expression
							{
							pushFollow(FOLLOW_id_expression_in_xml_multiuse_expression_element14904);
							id_expression1109=gPLSQLParser.id_expression();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_id_expression.add(id_expression1109.getTree());
							if ( state.backtracking==0 ) {mode = 1;}
							}
							break;
						case 2 :
							// PLSQL_DMLParser.g:1383:56: evalname_key concatenation
							{
							pushFollow(FOLLOW_evalname_key_in_xml_multiuse_expression_element14908);
							evalname_key1110=gPLSQLParser.evalname_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_evalname_key.add(evalname_key1110.getTree());
							pushFollow(FOLLOW_concatenation_in_xml_multiuse_expression_element14910);
							concatenation1111=concatenation();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) stream_concatenation.add(concatenation1111.getTree());
							if ( state.backtracking==0 ) {mode = 2;}
							}
							break;

					}

					}
					break;

			}

			// AST REWRITE
			// elements: evalname_key, expression, concatenation, expression, id_expression, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1384:9: -> {mode == 1}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) )
			if (mode == 1) {
				// PLSQL_DMLParser.g:1384:25: ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] id_expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_ELEMENT, "XML_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:1384:39: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:1384:58: ^( XML_ALIAS[$as_key.start] id_expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_ALIAS, (as_key1108!=null?(as_key1108.start):null)), root_2);
				adaptor.addChild(root_2, stream_id_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1385:9: -> {mode == 2}? ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) )
			if (mode == 2) {
				// PLSQL_DMLParser.g:1385:25: ^( XML_ELEMENT ^( EXPR expression ) ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_ELEMENT, "XML_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:1385:39: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				// PLSQL_DMLParser.g:1385:58: ^( XML_ALIAS[$as_key.start] ^( evalname_key ^( EXPR concatenation ) ) )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_ALIAS, (as_key1108!=null?(as_key1108.start):null)), root_2);
				// PLSQL_DMLParser.g:1385:85: ^( evalname_key ^( EXPR concatenation ) )
				{
				Object root_3 = (Object)adaptor.nil();
				root_3 = (Object)adaptor.becomeRoot(stream_evalname_key.nextNode(), root_3);
				// PLSQL_DMLParser.g:1385:100: ^( EXPR concatenation )
				{
				Object root_4 = (Object)adaptor.nil();
				root_4 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_4);
				adaptor.addChild(root_4, stream_concatenation.nextTree());
				adaptor.addChild(root_3, root_4);
				}

				adaptor.addChild(root_2, root_3);
				}

				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}

			else // 1386:9: -> ^( XML_ELEMENT ^( EXPR expression ) )
			{
				// PLSQL_DMLParser.g:1386:12: ^( XML_ELEMENT ^( EXPR expression ) )
				{
				Object root_1 = (Object)adaptor.nil();
				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(XML_ELEMENT, "XML_ELEMENT"), root_1);
				// PLSQL_DMLParser.g:1386:26: ^( EXPR expression )
				{
				Object root_2 = (Object)adaptor.nil();
				root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(EXPR, "EXPR"), root_2);
				adaptor.addChild(root_2, stream_expression.nextTree());
				adaptor.addChild(root_1, root_2);
				}

				adaptor.addChild(root_0, root_1);
				}

			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_multiuse_expression_element"


	public static class xmlroot_param_version_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlroot_param_version_part"
	// PLSQL_DMLParser.g:1389:1: xmlroot_param_version_part : version_key ^ ( no_key value_key | expression_wrapper ) ;
	public final PLSQLParser_PLSQL_DMLParser.xmlroot_param_version_part_return xmlroot_param_version_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xmlroot_param_version_part_return retval = new PLSQLParser_PLSQL_DMLParser.xmlroot_param_version_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope version_key1112 =null;
		ParserRuleReturnScope no_key1113 =null;
		ParserRuleReturnScope value_key1114 =null;
		ParserRuleReturnScope expression_wrapper1115 =null;


		try {
			// PLSQL_DMLParser.g:1390:5: ( version_key ^ ( no_key value_key | expression_wrapper ) )
			// PLSQL_DMLParser.g:1390:10: version_key ^ ( no_key value_key | expression_wrapper )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_version_key_in_xmlroot_param_version_part15021);
			version_key1112=gPLSQLParser.version_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(version_key1112.getTree(), root_0);
			// PLSQL_DMLParser.g:1390:23: ( no_key value_key | expression_wrapper )
			int alt356=2;
			int LA356_0 = input.LA(1);
			if ( (LA356_0==REGULAR_ID) ) {
				int LA356_1 = input.LA(2);
				if ( (LA356_1==REGULAR_ID) ) {
					int LA356_3 = input.LA(3);
					if ( ((input.LT(1).getText().equalsIgnoreCase("no"))) ) {
						alt356=1;
					}
					else if ( (true) ) {
						alt356=2;
					}

				}
				else if ( (LA356_1==MINUS_SIGN||LA356_1==PLUS_SIGN) ) {
					alt356=2;
				}
				else if ( (LA356_1==SQL92_RESERVED_PRIOR) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt356=2;
				}
				else if ( (LA356_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA356_1==SQL92_RESERVED_ALL||LA356_1==SQL92_RESERVED_CASE||LA356_1==SQL92_RESERVED_DISTINCT) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt356=2;
				}
				else if ( (LA356_1==SQL92_RESERVED_EXISTS) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt356=2;
				}
				else if ( (LA356_1==SQL92_RESERVED_ANY) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt356=2;
				}
				else if ( (LA356_1==DELIMITED_ID||LA356_1==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt356=2;
				}
				else if ( (LA356_1==BINDVAR||LA356_1==COLON) ) {
					alt356=2;
				}
				else if ( (LA356_1==SQL92_RESERVED_DELETE) && (((input.LT(1).getText().equalsIgnoreCase("interval"))||((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")))))) {
					alt356=2;
				}
				else if ( (LA356_1==APPROXIMATE_NUM_LIT||LA356_1==EXACT_NUM_LIT||LA356_1==SQL92_RESERVED_DATE||LA356_1==UNSIGNED_INTEGER) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt356=2;
				}
				else if ( ((LA356_1 >= CHAR_STRING && LA356_1 <= CHAR_STRING_PERL)||LA356_1==NATIONAL_CHAR_STRING_LIT) ) {
					alt356=2;
				}
				else if ( (LA356_1==SQL92_RESERVED_DEFAULT||LA356_1==SQL92_RESERVED_FALSE||LA356_1==SQL92_RESERVED_NULL||LA356_1==SQL92_RESERVED_TRUE) && (((input.LT(1).getText().equalsIgnoreCase("new"))&&(input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))))) {
					alt356=2;
				}
				else if ( (LA356_1==ASTERISK||LA356_1==CARRET_OPERATOR_PART||LA356_1==COMMA||LA356_1==CONCATENATION_OP||LA356_1==EQUALS_OP||LA356_1==EXCLAMATION_OPERATOR_PART||(LA356_1 >= GREATER_THAN_OP && LA356_1 <= GREATER_THAN_OR_EQUALS_OP)||(LA356_1 >= LEFT_BRACKET && LA356_1 <= LESS_THAN_OR_EQUALS_OP)||LA356_1==NOT_EQUAL_OP||(LA356_1 >= PERCENT && LA356_1 <= PERIOD)||LA356_1==RIGHT_PAREN||LA356_1==SOLIDUS||LA356_1==SQL92_RESERVED_AND||LA356_1==SQL92_RESERVED_BETWEEN||LA356_1==SQL92_RESERVED_IN||(LA356_1 >= SQL92_RESERVED_IS && LA356_1 <= SQL92_RESERVED_NOT)||LA356_1==SQL92_RESERVED_OR||LA356_1==VERTICAL_BAR) ) {
					alt356=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 356, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}
			else if ( (LA356_0==APPROXIMATE_NUM_LIT||LA356_0==BINDVAR||(LA356_0 >= CHAR_STRING && LA356_0 <= COLON)||LA356_0==DELIMITED_ID||LA356_0==EXACT_NUM_LIT||LA356_0==INTRODUCER||LA356_0==LEFT_PAREN||LA356_0==MINUS_SIGN||LA356_0==NATIONAL_CHAR_STRING_LIT||LA356_0==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA356_0==PLUS_SIGN||LA356_0==SQL92_RESERVED_ALL||LA356_0==SQL92_RESERVED_ANY||LA356_0==SQL92_RESERVED_CASE||(LA356_0 >= SQL92_RESERVED_CURSOR && LA356_0 <= SQL92_RESERVED_DATE)||(LA356_0 >= SQL92_RESERVED_DEFAULT && LA356_0 <= SQL92_RESERVED_DELETE)||LA356_0==SQL92_RESERVED_DISTINCT||(LA356_0 >= SQL92_RESERVED_EXISTS && LA356_0 <= SQL92_RESERVED_FALSE)||(LA356_0 >= SQL92_RESERVED_NOT && LA356_0 <= SQL92_RESERVED_NULL)||LA356_0==SQL92_RESERVED_PRIOR||LA356_0==SQL92_RESERVED_TRUE||LA356_0==UNSIGNED_INTEGER) ) {
				alt356=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 356, 0, input);
				throw nvae;
			}

			switch (alt356) {
				case 1 :
					// PLSQL_DMLParser.g:1390:24: no_key value_key
					{
					pushFollow(FOLLOW_no_key_in_xmlroot_param_version_part15025);
					no_key1113=gPLSQLParser.no_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, no_key1113.getTree());

					pushFollow(FOLLOW_value_key_in_xmlroot_param_version_part15027);
					value_key1114=gPLSQLParser.value_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, value_key1114.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1390:41: expression_wrapper
					{
					pushFollow(FOLLOW_expression_wrapper_in_xmlroot_param_version_part15029);
					expression_wrapper1115=expression_wrapper();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, expression_wrapper1115.getTree());

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlroot_param_version_part"


	public static class xmlroot_param_standalone_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlroot_param_standalone_part"
	// PLSQL_DMLParser.g:1393:1: xmlroot_param_standalone_part : standalone_key ^ ( yes_key | no_key ( value_key )? ) ;
	public final PLSQLParser_PLSQL_DMLParser.xmlroot_param_standalone_part_return xmlroot_param_standalone_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xmlroot_param_standalone_part_return retval = new PLSQLParser_PLSQL_DMLParser.xmlroot_param_standalone_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope standalone_key1116 =null;
		ParserRuleReturnScope yes_key1117 =null;
		ParserRuleReturnScope no_key1118 =null;
		ParserRuleReturnScope value_key1119 =null;


		try {
			// PLSQL_DMLParser.g:1394:5: ( standalone_key ^ ( yes_key | no_key ( value_key )? ) )
			// PLSQL_DMLParser.g:1394:10: standalone_key ^ ( yes_key | no_key ( value_key )? )
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_standalone_key_in_xmlroot_param_standalone_part15050);
			standalone_key1116=gPLSQLParser.standalone_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(standalone_key1116.getTree(), root_0);
			// PLSQL_DMLParser.g:1394:26: ( yes_key | no_key ( value_key )? )
			int alt358=2;
			int LA358_0 = input.LA(1);
			if ( (LA358_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("yes"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
				int LA358_1 = input.LA(2);
				if ( ((input.LT(1).getText().equalsIgnoreCase("yes"))) ) {
					alt358=1;
				}
				else if ( ((input.LT(1).getText().equalsIgnoreCase("no"))) ) {
					alt358=2;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 358, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

			switch (alt358) {
				case 1 :
					// PLSQL_DMLParser.g:1394:27: yes_key
					{
					pushFollow(FOLLOW_yes_key_in_xmlroot_param_standalone_part15054);
					yes_key1117=gPLSQLParser.yes_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, yes_key1117.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1394:35: no_key ( value_key )?
					{
					pushFollow(FOLLOW_no_key_in_xmlroot_param_standalone_part15056);
					no_key1118=gPLSQLParser.no_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, no_key1118.getTree());

					// PLSQL_DMLParser.g:1394:42: ( value_key )?
					int alt357=2;
					int LA357_0 = input.LA(1);
					if ( (LA357_0==REGULAR_ID) ) {
						alt357=1;
					}
					switch (alt357) {
						case 1 :
							// PLSQL_DMLParser.g:1394:42: value_key
							{
							pushFollow(FOLLOW_value_key_in_xmlroot_param_standalone_part15058);
							value_key1119=gPLSQLParser.value_key();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, value_key1119.getTree());

							}
							break;

					}

					}
					break;

			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlroot_param_standalone_part"


	public static class xmlserialize_param_enconding_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlserialize_param_enconding_part"
	// PLSQL_DMLParser.g:1397:1: xmlserialize_param_enconding_part : encoding_key ^ concatenation_wrapper ;
	public final PLSQLParser_PLSQL_DMLParser.xmlserialize_param_enconding_part_return xmlserialize_param_enconding_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xmlserialize_param_enconding_part_return retval = new PLSQLParser_PLSQL_DMLParser.xmlserialize_param_enconding_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope encoding_key1120 =null;
		ParserRuleReturnScope concatenation_wrapper1121 =null;


		try {
			// PLSQL_DMLParser.g:1398:5: ( encoding_key ^ concatenation_wrapper )
			// PLSQL_DMLParser.g:1398:10: encoding_key ^ concatenation_wrapper
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15080);
			encoding_key1120=gPLSQLParser.encoding_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(encoding_key1120.getTree(), root_0);
			pushFollow(FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15083);
			concatenation_wrapper1121=concatenation_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1121.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlserialize_param_enconding_part"


	public static class xmlserialize_param_version_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlserialize_param_version_part"
	// PLSQL_DMLParser.g:1401:1: xmlserialize_param_version_part : version_key ^ concatenation_wrapper ;
	public final PLSQLParser_PLSQL_DMLParser.xmlserialize_param_version_part_return xmlserialize_param_version_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xmlserialize_param_version_part_return retval = new PLSQLParser_PLSQL_DMLParser.xmlserialize_param_version_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		ParserRuleReturnScope version_key1122 =null;
		ParserRuleReturnScope concatenation_wrapper1123 =null;


		try {
			// PLSQL_DMLParser.g:1402:5: ( version_key ^ concatenation_wrapper )
			// PLSQL_DMLParser.g:1402:10: version_key ^ concatenation_wrapper
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_version_key_in_xmlserialize_param_version_part15103);
			version_key1122=gPLSQLParser.version_key();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(version_key1122.getTree(), root_0);
			pushFollow(FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15106);
			concatenation_wrapper1123=concatenation_wrapper();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1123.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlserialize_param_version_part"


	public static class xmlserialize_param_ident_part_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlserialize_param_ident_part"
	// PLSQL_DMLParser.g:1405:1: xmlserialize_param_ident_part : ( no_key indent_key | indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )? );
	public final PLSQLParser_PLSQL_DMLParser.xmlserialize_param_ident_part_return xmlserialize_param_ident_part() throws RecognitionException {
		PLSQLParser_PLSQL_DMLParser.xmlserialize_param_ident_part_return retval = new PLSQLParser_PLSQL_DMLParser.xmlserialize_param_ident_part_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token EQUALS_OP1128=null;
		ParserRuleReturnScope no_key1124 =null;
		ParserRuleReturnScope indent_key1125 =null;
		ParserRuleReturnScope indent_key1126 =null;
		ParserRuleReturnScope size_key1127 =null;
		ParserRuleReturnScope concatenation_wrapper1129 =null;

		Object EQUALS_OP1128_tree=null;

		try {
			// PLSQL_DMLParser.g:1406:5: ( no_key indent_key | indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )? )
			int alt360=2;
			int LA360_0 = input.LA(1);
			if ( (LA360_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
				int LA360_1 = input.LA(2);
				if ( (LA360_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
					int LA360_2 = input.LA(3);
					if ( (LA360_2==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("indent"))||(input.LT(1).getText().equalsIgnoreCase("no"))))) {
						int LA360_4 = input.LA(4);
						if ( (LA360_4==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("no")))) {
							alt360=1;
						}
						else if ( (LA360_4==RIGHT_PAREN) && ((input.LT(1).getText().equalsIgnoreCase("indent")))) {
							alt360=2;
						}

					}
					else if ( (LA360_2==RIGHT_PAREN) && ((input.LT(1).getText().equalsIgnoreCase("no")))) {
						alt360=1;
					}

				}
				else if ( (LA360_1==RIGHT_PAREN||LA360_1==SQL92_RESERVED_SIZE) && ((input.LT(1).getText().equalsIgnoreCase("indent")))) {
					alt360=2;
				}

			}

			switch (alt360) {
				case 1 :
					// PLSQL_DMLParser.g:1406:10: no_key indent_key
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_no_key_in_xmlserialize_param_ident_part15126);
					no_key1124=gPLSQLParser.no_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, no_key1124.getTree());

					pushFollow(FOLLOW_indent_key_in_xmlserialize_param_ident_part15128);
					indent_key1125=gPLSQLParser.indent_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, indent_key1125.getTree());

					}
					break;
				case 2 :
					// PLSQL_DMLParser.g:1407:10: indent_key ^ ( size_key ! EQUALS_OP ! concatenation_wrapper )?
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_indent_key_in_xmlserialize_param_ident_part15139);
					indent_key1126=gPLSQLParser.indent_key();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(indent_key1126.getTree(), root_0);
					// PLSQL_DMLParser.g:1407:22: ( size_key ! EQUALS_OP ! concatenation_wrapper )?
					int alt359=2;
					int LA359_0 = input.LA(1);
					if ( (LA359_0==SQL92_RESERVED_SIZE) ) {
						alt359=1;
					}
					switch (alt359) {
						case 1 :
							// PLSQL_DMLParser.g:1407:23: size_key ! EQUALS_OP ! concatenation_wrapper
							{
							pushFollow(FOLLOW_size_key_in_xmlserialize_param_ident_part15143);
							size_key1127=gPLSQLParser.size_key();
							state._fsp--;
							if (state.failed) return retval;
							EQUALS_OP1128=(Token)match(input,EQUALS_OP,FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15146); if (state.failed) return retval;
							pushFollow(FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15149);
							concatenation_wrapper1129=concatenation_wrapper();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, concatenation_wrapper1129.getTree());

							}
							break;

					}

					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlserialize_param_ident_part"

	// $ANTLR start synpred1_PLSQL_DMLParser
	public final void synpred1_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:265:10: ( distinct_key | unique_key | all_key )
		int alt361=3;
		switch ( input.LA(1) ) {
		case SQL92_RESERVED_DISTINCT:
			{
			alt361=1;
			}
			break;
		case SQL92_RESERVED_UNIQUE:
			{
			alt361=2;
			}
			break;
		case SQL92_RESERVED_ALL:
			{
			alt361=3;
			}
			break;
		default:
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 361, 0, input);
			throw nvae;
		}
		switch (alt361) {
			case 1 :
				// PLSQL_DMLParser.g:265:11: distinct_key
				{
				pushFollow(FOLLOW_distinct_key_in_synpred1_PLSQL_DMLParser1432);
				gPLSQLParser.distinct_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:265:24: unique_key
				{
				pushFollow(FOLLOW_unique_key_in_synpred1_PLSQL_DMLParser1434);
				gPLSQLParser.unique_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 3 :
				// PLSQL_DMLParser.g:265:35: all_key
				{
				pushFollow(FOLLOW_all_key_in_synpred1_PLSQL_DMLParser1436);
				gPLSQLParser.all_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred1_PLSQL_DMLParser

	// $ANTLR start synpred2_PLSQL_DMLParser
	public final void synpred2_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:289:10: ( tableview_name PERIOD ASTERISK )
		// PLSQL_DMLParser.g:289:11: tableview_name PERIOD ASTERISK
		{
		pushFollow(FOLLOW_tableview_name_in_synpred2_PLSQL_DMLParser1749);
		gPLSQLParser.tableview_name();
		state._fsp--;
		if (state.failed) return;

		match(input,PERIOD,FOLLOW_PERIOD_in_synpred2_PLSQL_DMLParser1751); if (state.failed) return;

		match(input,ASTERISK,FOLLOW_ASTERISK_in_synpred2_PLSQL_DMLParser1753); if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_PLSQL_DMLParser

	// $ANTLR start synpred3_PLSQL_DMLParser
	public final void synpred3_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:308:10: ( LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:308:11: LEFT_PAREN ( select_key | with_key )
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred3_PLSQL_DMLParser1909); if (state.failed) return;

		// PLSQL_DMLParser.g:308:22: ( select_key | with_key )
		int alt362=2;
		int LA362_0 = input.LA(1);
		if ( (LA362_0==SQL92_RESERVED_SELECT) ) {
			alt362=1;
		}
		else if ( (LA362_0==SQL92_RESERVED_WITH) ) {
			alt362=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 362, 0, input);
			throw nvae;
		}

		switch (alt362) {
			case 1 :
				// PLSQL_DMLParser.g:308:23: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred3_PLSQL_DMLParser1912);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:308:34: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred3_PLSQL_DMLParser1914);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred3_PLSQL_DMLParser

	// $ANTLR start synpred4_PLSQL_DMLParser
	public final void synpred4_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:309:10: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:309:11: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1948); if (state.failed) return;

		}

	}
	// $ANTLR end synpred4_PLSQL_DMLParser

	// $ANTLR start synpred5_PLSQL_DMLParser
	public final void synpred5_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:310:10: ( only_key LEFT_PAREN )
		// PLSQL_DMLParser.g:310:11: only_key LEFT_PAREN
		{
		pushFollow(FOLLOW_only_key_in_synpred5_PLSQL_DMLParser1988);
		gPLSQLParser.only_key();
		state._fsp--;
		if (state.failed) return;

		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1990); if (state.failed) return;

		}

	}
	// $ANTLR end synpred5_PLSQL_DMLParser

	// $ANTLR start synpred6_PLSQL_DMLParser
	public final void synpred6_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:352:9: ( LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:352:10: LEFT_PAREN ( select_key | with_key )
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser2451); if (state.failed) return;

		// PLSQL_DMLParser.g:352:21: ( select_key | with_key )
		int alt363=2;
		int LA363_0 = input.LA(1);
		if ( (LA363_0==SQL92_RESERVED_SELECT) ) {
			alt363=1;
		}
		else if ( (LA363_0==SQL92_RESERVED_WITH) ) {
			alt363=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 363, 0, input);
			throw nvae;
		}

		switch (alt363) {
			case 1 :
				// PLSQL_DMLParser.g:352:22: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred6_PLSQL_DMLParser2454);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:352:33: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred6_PLSQL_DMLParser2456);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred6_PLSQL_DMLParser

	// $ANTLR start synpred7_PLSQL_DMLParser
	public final void synpred7_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:353:10: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:353:11: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser2480); if (state.failed) return;

		}

	}
	// $ANTLR end synpred7_PLSQL_DMLParser

	// $ANTLR start synpred8_PLSQL_DMLParser
	public final void synpred8_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:389:18: ( select_key )
		// PLSQL_DMLParser.g:389:19: select_key
		{
		pushFollow(FOLLOW_select_key_in_synpred8_PLSQL_DMLParser2926);
		gPLSQLParser.select_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred8_PLSQL_DMLParser

	// $ANTLR start synpred9_PLSQL_DMLParser
	public final void synpred9_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:390:18: ( any_key )
		// PLSQL_DMLParser.g:390:19: any_key
		{
		pushFollow(FOLLOW_any_key_in_synpred9_PLSQL_DMLParser2952);
		gPLSQLParser.any_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred9_PLSQL_DMLParser

	// $ANTLR start synpred10_PLSQL_DMLParser
	public final void synpred10_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:406:10: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:406:11: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred10_PLSQL_DMLParser3157); if (state.failed) return;

		}

	}
	// $ANTLR end synpred10_PLSQL_DMLParser

	// $ANTLR start synpred11_PLSQL_DMLParser
	public final void synpred11_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:436:14: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:436:15: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser3531); if (state.failed) return;

		}

	}
	// $ANTLR end synpred11_PLSQL_DMLParser

	// $ANTLR start synpred12_PLSQL_DMLParser
	public final void synpred12_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:455:10: ( group_key )
		// PLSQL_DMLParser.g:455:11: group_key
		{
		pushFollow(FOLLOW_group_key_in_synpred12_PLSQL_DMLParser3761);
		gPLSQLParser.group_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred12_PLSQL_DMLParser

	// $ANTLR start synpred13_PLSQL_DMLParser
	public final void synpred13_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:455:61: ( COMMA group_by_elements )
		// PLSQL_DMLParser.g:455:62: COMMA group_by_elements
		{
		match(input,COMMA,FOLLOW_COMMA_in_synpred13_PLSQL_DMLParser3774); if (state.failed) return;

		pushFollow(FOLLOW_group_by_elements_in_synpred13_PLSQL_DMLParser3776);
		group_by_elements();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred13_PLSQL_DMLParser

	// $ANTLR start synpred14_PLSQL_DMLParser
	public final void synpred14_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:457:10: ( having_key )
		// PLSQL_DMLParser.g:457:11: having_key
		{
		pushFollow(FOLLOW_having_key_in_synpred14_PLSQL_DMLParser3824);
		gPLSQLParser.having_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred14_PLSQL_DMLParser

	// $ANTLR start synpred15_PLSQL_DMLParser
	public final void synpred15_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:457:77: ( COMMA group_by_elements )
		// PLSQL_DMLParser.g:457:78: COMMA group_by_elements
		{
		match(input,COMMA,FOLLOW_COMMA_in_synpred15_PLSQL_DMLParser3840); if (state.failed) return;

		pushFollow(FOLLOW_group_by_elements_in_synpred15_PLSQL_DMLParser3842);
		group_by_elements();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred15_PLSQL_DMLParser

	// $ANTLR start synpred16_PLSQL_DMLParser
	public final void synpred16_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:478:10: ( rollup_key | cube_key )
		int alt364=2;
		int LA364_0 = input.LA(1);
		if ( (LA364_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("cube"))||(input.LT(1).getText().equalsIgnoreCase("rollup"))))) {
			int LA364_1 = input.LA(2);
			if ( ((input.LT(1).getText().equalsIgnoreCase("rollup"))) ) {
				alt364=1;
			}
			else if ( ((input.LT(1).getText().equalsIgnoreCase("cube"))) ) {
				alt364=2;
			}

			else {
				if (state.backtracking>0) {state.failed=true; return;}
				int nvaeMark = input.mark();
				try {
					input.consume();
					NoViableAltException nvae =
						new NoViableAltException("", 364, 1, input);
					throw nvae;
				} finally {
					input.rewind(nvaeMark);
				}
			}

		}

		switch (alt364) {
			case 1 :
				// PLSQL_DMLParser.g:478:11: rollup_key
				{
				pushFollow(FOLLOW_rollup_key_in_synpred16_PLSQL_DMLParser4056);
				gPLSQLParser.rollup_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:478:22: cube_key
				{
				pushFollow(FOLLOW_cube_key_in_synpred16_PLSQL_DMLParser4058);
				gPLSQLParser.cube_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred16_PLSQL_DMLParser

	// $ANTLR start synpred17_PLSQL_DMLParser
	public final void synpred17_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:479:10: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:479:11: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred17_PLSQL_DMLParser4074); if (state.failed) return;

		}

	}
	// $ANTLR end synpred17_PLSQL_DMLParser

	// $ANTLR start synpred18_PLSQL_DMLParser
	public final void synpred18_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:544:34: ( all_key )
		// PLSQL_DMLParser.g:544:35: all_key
		{
		pushFollow(FOLLOW_all_key_in_synpred18_PLSQL_DMLParser4742);
		gPLSQLParser.all_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred18_PLSQL_DMLParser

	// $ANTLR start synpred19_PLSQL_DMLParser
	public final void synpred19_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:767:10: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:767:11: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred19_PLSQL_DMLParser6915); if (state.failed) return;

		}

	}
	// $ANTLR end synpred19_PLSQL_DMLParser

	// $ANTLR start synpred20_PLSQL_DMLParser
	public final void synpred20_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:777:34: ( unlimited_key )
		// PLSQL_DMLParser.g:777:35: unlimited_key
		{
		pushFollow(FOLLOW_unlimited_key_in_synpred20_PLSQL_DMLParser7006);
		gPLSQLParser.unlimited_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred20_PLSQL_DMLParser

	// $ANTLR start synpred21_PLSQL_DMLParser
	public final void synpred21_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:787:10: ( routine_id ( PERIOD routine_id )* LEFT_PAREN )
		// PLSQL_DMLParser.g:787:11: routine_id ( PERIOD routine_id )* LEFT_PAREN
		{
		pushFollow(FOLLOW_routine_id_in_synpred21_PLSQL_DMLParser7127);
		gPLSQLParser.routine_id();
		state._fsp--;
		if (state.failed) return;

		// PLSQL_DMLParser.g:787:22: ( PERIOD routine_id )*
		loop365:
		while (true) {
			int alt365=2;
			int LA365_0 = input.LA(1);
			if ( (LA365_0==PERIOD) ) {
				alt365=1;
			}

			switch (alt365) {
			case 1 :
				// PLSQL_DMLParser.g:787:23: PERIOD routine_id
				{
				match(input,PERIOD,FOLLOW_PERIOD_in_synpred21_PLSQL_DMLParser7130); if (state.failed) return;

				pushFollow(FOLLOW_routine_id_in_synpred21_PLSQL_DMLParser7132);
				gPLSQLParser.routine_id();
				state._fsp--;
				if (state.failed) return;

				}
				break;

			default :
				break loop365;
			}
		}

		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred21_PLSQL_DMLParser7136); if (state.failed) return;

		}

	}
	// $ANTLR end synpred21_PLSQL_DMLParser

	// $ANTLR start synpred22_PLSQL_DMLParser
	public final void synpred22_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:789:10: ( standard_function )
		// PLSQL_DMLParser.g:789:11: standard_function
		{
		pushFollow(FOLLOW_standard_function_in_synpred22_PLSQL_DMLParser7172);
		standard_function();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred22_PLSQL_DMLParser

	// $ANTLR start synpred23_PLSQL_DMLParser
	public final void synpred23_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:795:12: ( LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:795:13: LEFT_PAREN ( select_key | with_key )
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred23_PLSQL_DMLParser7237); if (state.failed) return;

		// PLSQL_DMLParser.g:795:24: ( select_key | with_key )
		int alt366=2;
		int LA366_0 = input.LA(1);
		if ( (LA366_0==SQL92_RESERVED_SELECT) ) {
			alt366=1;
		}
		else if ( (LA366_0==SQL92_RESERVED_WITH) ) {
			alt366=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 366, 0, input);
			throw nvae;
		}

		switch (alt366) {
			case 1 :
				// PLSQL_DMLParser.g:795:25: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred23_PLSQL_DMLParser7240);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:795:38: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred23_PLSQL_DMLParser7244);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred23_PLSQL_DMLParser

	// $ANTLR start synpred24_PLSQL_DMLParser
	public final void synpred24_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:843:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:843:11: cursor_key LEFT_PAREN ( select_key | with_key )
		{
		pushFollow(FOLLOW_cursor_key_in_synpred24_PLSQL_DMLParser7698);
		gPLSQLParser.cursor_key();
		state._fsp--;
		if (state.failed) return;

		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser7700); if (state.failed) return;

		// PLSQL_DMLParser.g:843:33: ( select_key | with_key )
		int alt367=2;
		int LA367_0 = input.LA(1);
		if ( (LA367_0==SQL92_RESERVED_SELECT) ) {
			alt367=1;
		}
		else if ( (LA367_0==SQL92_RESERVED_WITH) ) {
			alt367=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 367, 0, input);
			throw nvae;
		}

		switch (alt367) {
			case 1 :
				// PLSQL_DMLParser.g:843:34: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred24_PLSQL_DMLParser7703);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:843:45: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred24_PLSQL_DMLParser7705);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred24_PLSQL_DMLParser

	// $ANTLR start synpred25_PLSQL_DMLParser
	public final void synpred25_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:937:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )
		// PLSQL_DMLParser.g:937:11: ( LEFT_PAREN )+ ( select_key | with_key )
		{
		// PLSQL_DMLParser.g:937:11: ( LEFT_PAREN )+
		int cnt368=0;
		loop368:
		while (true) {
			int alt368=2;
			int LA368_0 = input.LA(1);
			if ( (LA368_0==LEFT_PAREN) ) {
				alt368=1;
			}

			switch (alt368) {
			case 1 :
				// PLSQL_DMLParser.g:937:11: LEFT_PAREN
				{
				match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser8969); if (state.failed) return;

				}
				break;

			default :
				if ( cnt368 >= 1 ) break loop368;
				if (state.backtracking>0) {state.failed=true; return;}
				EarlyExitException eee = new EarlyExitException(368, input);
				throw eee;
			}
			cnt368++;
		}

		// PLSQL_DMLParser.g:937:23: ( select_key | with_key )
		int alt369=2;
		int LA369_0 = input.LA(1);
		if ( (LA369_0==SQL92_RESERVED_SELECT) ) {
			alt369=1;
		}
		else if ( (LA369_0==SQL92_RESERVED_WITH) ) {
			alt369=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 369, 0, input);
			throw nvae;
		}

		switch (alt369) {
			case 1 :
				// PLSQL_DMLParser.g:937:24: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred25_PLSQL_DMLParser8973);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:937:35: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred25_PLSQL_DMLParser8975);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred25_PLSQL_DMLParser

	// $ANTLR start synpred26_PLSQL_DMLParser
	public final void synpred26_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:971:15: ( mod_key datetime_expression )
		// PLSQL_DMLParser.g:971:16: mod_key datetime_expression
		{
		pushFollow(FOLLOW_mod_key_in_synpred26_PLSQL_DMLParser9348);
		gPLSQLParser.mod_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_datetime_expression_in_synpred26_PLSQL_DMLParser9350);
		datetime_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred26_PLSQL_DMLParser

	// $ANTLR start synpred27_PLSQL_DMLParser
	public final void synpred27_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:972:15: ( div_key datetime_expression )
		// PLSQL_DMLParser.g:972:16: div_key datetime_expression
		{
		pushFollow(FOLLOW_div_key_in_synpred27_PLSQL_DMLParser9375);
		gPLSQLParser.div_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_datetime_expression_in_synpred27_PLSQL_DMLParser9377);
		datetime_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred27_PLSQL_DMLParser

	// $ANTLR start synpred28_PLSQL_DMLParser
	public final void synpred28_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:980:10: ( interval_expression )
		// PLSQL_DMLParser.g:980:11: interval_expression
		{
		pushFollow(FOLLOW_interval_expression_in_synpred28_PLSQL_DMLParser9489);
		interval_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred28_PLSQL_DMLParser

	// $ANTLR start synpred29_PLSQL_DMLParser
	public final void synpred29_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:999:11: ( any_key )
		// PLSQL_DMLParser.g:999:12: any_key
		{
		pushFollow(FOLLOW_any_key_in_synpred29_PLSQL_DMLParser9727);
		gPLSQLParser.any_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred29_PLSQL_DMLParser

	// $ANTLR start synpred30_PLSQL_DMLParser
	public final void synpred30_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:999:59: ( any_key )
		// PLSQL_DMLParser.g:999:60: any_key
		{
		pushFollow(FOLLOW_any_key_in_synpred30_PLSQL_DMLParser9742);
		gPLSQLParser.any_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred30_PLSQL_DMLParser

	// $ANTLR start synpred31_PLSQL_DMLParser
	public final void synpred31_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1028:18: ( select_key )
		// PLSQL_DMLParser.g:1028:19: select_key
		{
		pushFollow(FOLLOW_select_key_in_synpred31_PLSQL_DMLParser10096);
		gPLSQLParser.select_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred31_PLSQL_DMLParser

	// $ANTLR start synpred32_PLSQL_DMLParser
	public final void synpred32_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1029:18: ( LEFT_PAREN )
		// PLSQL_DMLParser.g:1029:19: LEFT_PAREN
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred32_PLSQL_DMLParser10120); if (state.failed) return;

		}

	}
	// $ANTLR end synpred32_PLSQL_DMLParser

	// $ANTLR start synpred33_PLSQL_DMLParser
	public final void synpred33_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1040:10: ( MINUS_SIGN unary_expression )
		// PLSQL_DMLParser.g:1040:10: MINUS_SIGN unary_expression
		{
		match(input,MINUS_SIGN,FOLLOW_MINUS_SIGN_in_synpred33_PLSQL_DMLParser10216); if (state.failed) return;

		pushFollow(FOLLOW_unary_expression_in_synpred33_PLSQL_DMLParser10218);
		unary_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred33_PLSQL_DMLParser

	// $ANTLR start synpred35_PLSQL_DMLParser
	public final void synpred35_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1042:10: ( prior_key unary_expression )
		// PLSQL_DMLParser.g:1042:10: prior_key unary_expression
		{
		pushFollow(FOLLOW_prior_key_in_synpred35_PLSQL_DMLParser10260);
		gPLSQLParser.prior_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_unary_expression_in_synpred35_PLSQL_DMLParser10263);
		unary_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred35_PLSQL_DMLParser

	// $ANTLR start synpred37_PLSQL_DMLParser
	public final void synpred37_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1044:10: ({...}? => new_key unary_expression )
		// PLSQL_DMLParser.g:1044:10: {...}? => new_key unary_expression
		{
		if ( !((input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals("."))) ) {
			if (state.backtracking>0) {state.failed=true; return;}
			throw new FailedPredicateException(input, "synpred37_PLSQL_DMLParser", "input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")");
		}
		pushFollow(FOLLOW_new_key_in_synpred37_PLSQL_DMLParser10291);
		gPLSQLParser.new_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_unary_expression_in_synpred37_PLSQL_DMLParser10294);
		unary_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred37_PLSQL_DMLParser

	// $ANTLR start synpred39_PLSQL_DMLParser
	public final void synpred39_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1046:10: ( all_key unary_expression )
		// PLSQL_DMLParser.g:1046:10: all_key unary_expression
		{
		pushFollow(FOLLOW_all_key_in_synpred39_PLSQL_DMLParser10319);
		gPLSQLParser.all_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_unary_expression_in_synpred39_PLSQL_DMLParser10322);
		unary_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred39_PLSQL_DMLParser

	// $ANTLR start synpred41_PLSQL_DMLParser
	public final void synpred41_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1048:10: ( quantified_expression )
		// PLSQL_DMLParser.g:1048:10: quantified_expression
		{
		pushFollow(FOLLOW_quantified_expression_in_synpred41_PLSQL_DMLParser10347);
		quantified_expression();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred41_PLSQL_DMLParser

	// $ANTLR start synpred42_PLSQL_DMLParser
	public final void synpred42_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1049:10: ( cursor_name ( percent_notfound_key | percent_found_key | percent_isopen_key | percent_rowcount_key ) )
		// PLSQL_DMLParser.g:1049:10: cursor_name ( percent_notfound_key | percent_found_key | percent_isopen_key | percent_rowcount_key )
		{
		pushFollow(FOLLOW_cursor_name_in_synpred42_PLSQL_DMLParser10358);
		gPLSQLParser.cursor_name();
		state._fsp--;
		if (state.failed) return;

		// PLSQL_DMLParser.g:1049:22: ( percent_notfound_key | percent_found_key | percent_isopen_key | percent_rowcount_key )
		int alt370=4;
		int LA370_0 = input.LA(1);
		if ( (LA370_0==PERCENT) && (((input.LT(2).getText().equalsIgnoreCase("found"))||(input.LT(2).getText().equalsIgnoreCase("isopen"))||(input.LT(2).getText().equalsIgnoreCase("notfound"))||(input.LT(2).getText().equalsIgnoreCase("rowcount"))))) {
			int LA370_1 = input.LA(2);
			if ( (LA370_1==REGULAR_ID) && (((input.LT(2).getText().equalsIgnoreCase("found"))||(input.LT(2).getText().equalsIgnoreCase("isopen"))||(input.LT(2).getText().equalsIgnoreCase("notfound"))||(input.LT(2).getText().equalsIgnoreCase("rowcount"))))) {
				int LA370_2 = input.LA(3);
				if ( ((input.LT(2).getText().equalsIgnoreCase("notfound"))) ) {
					alt370=1;
				}
				else if ( ((input.LT(2).getText().equalsIgnoreCase("found"))) ) {
					alt370=2;
				}
				else if ( ((input.LT(2).getText().equalsIgnoreCase("isopen"))) ) {
					alt370=3;
				}
				else if ( ((input.LT(2).getText().equalsIgnoreCase("rowcount"))) ) {
					alt370=4;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return;}
					int nvaeMark = input.mark();
					try {
						for (int nvaeConsume = 0; nvaeConsume < 3 - 1; nvaeConsume++) {
							input.consume();
						}
						NoViableAltException nvae =
							new NoViableAltException("", 370, 2, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

			}

		}

		switch (alt370) {
			case 1 :
				// PLSQL_DMLParser.g:1049:23: percent_notfound_key
				{
				pushFollow(FOLLOW_percent_notfound_key_in_synpred42_PLSQL_DMLParser10361);
				gPLSQLParser.percent_notfound_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:1049:45: percent_found_key
				{
				pushFollow(FOLLOW_percent_found_key_in_synpred42_PLSQL_DMLParser10364);
				gPLSQLParser.percent_found_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 3 :
				// PLSQL_DMLParser.g:1049:64: percent_isopen_key
				{
				pushFollow(FOLLOW_percent_isopen_key_in_synpred42_PLSQL_DMLParser10367);
				gPLSQLParser.percent_isopen_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 4 :
				// PLSQL_DMLParser.g:1049:84: percent_rowcount_key
				{
				pushFollow(FOLLOW_percent_rowcount_key_in_synpred42_PLSQL_DMLParser10370);
				gPLSQLParser.percent_rowcount_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred42_PLSQL_DMLParser

	// $ANTLR start synpred43_PLSQL_DMLParser
	public final void synpred43_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1058:10: ( case_key when_key )
		// PLSQL_DMLParser.g:1058:11: case_key when_key
		{
		pushFollow(FOLLOW_case_key_in_synpred43_PLSQL_DMLParser10425);
		gPLSQLParser.case_key();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_when_key_in_synpred43_PLSQL_DMLParser10427);
		gPLSQLParser.when_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred43_PLSQL_DMLParser

	// $ANTLR start synpred44_PLSQL_DMLParser
	public final void synpred44_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1098:10: ( routine_id ( PERIOD routine_id )* outer_join_sign )
		// PLSQL_DMLParser.g:1098:11: routine_id ( PERIOD routine_id )* outer_join_sign
		{
		pushFollow(FOLLOW_routine_id_in_synpred44_PLSQL_DMLParser10745);
		gPLSQLParser.routine_id();
		state._fsp--;
		if (state.failed) return;

		// PLSQL_DMLParser.g:1098:22: ( PERIOD routine_id )*
		loop371:
		while (true) {
			int alt371=2;
			int LA371_0 = input.LA(1);
			if ( (LA371_0==PERIOD) ) {
				alt371=1;
			}

			switch (alt371) {
			case 1 :
				// PLSQL_DMLParser.g:1098:23: PERIOD routine_id
				{
				match(input,PERIOD,FOLLOW_PERIOD_in_synpred44_PLSQL_DMLParser10748); if (state.failed) return;

				pushFollow(FOLLOW_routine_id_in_synpred44_PLSQL_DMLParser10750);
				gPLSQLParser.routine_id();
				state._fsp--;
				if (state.failed) return;

				}
				break;

			default :
				break loop371;
			}
		}

		pushFollow(FOLLOW_outer_join_sign_in_synpred44_PLSQL_DMLParser10754);
		gPLSQLParser.outer_join_sign();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred44_PLSQL_DMLParser

	// $ANTLR start synpred45_PLSQL_DMLParser
	public final void synpred45_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1100:10: ( standard_function )
		// PLSQL_DMLParser.g:1100:11: standard_function
		{
		pushFollow(FOLLOW_standard_function_in_synpred45_PLSQL_DMLParser10785);
		standard_function();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred45_PLSQL_DMLParser

	// $ANTLR start synpred46_PLSQL_DMLParser
	public final void synpred46_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1104:15: ( select_key | with_key )
		int alt372=2;
		int LA372_0 = input.LA(1);
		if ( (LA372_0==SQL92_RESERVED_SELECT) ) {
			alt372=1;
		}
		else if ( (LA372_0==SQL92_RESERVED_WITH) ) {
			alt372=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 372, 0, input);
			throw nvae;
		}

		switch (alt372) {
			case 1 :
				// PLSQL_DMLParser.g:1104:17: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred46_PLSQL_DMLParser10850);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:1104:30: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred46_PLSQL_DMLParser10854);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}
	}
	// $ANTLR end synpred46_PLSQL_DMLParser

	// $ANTLR start synpred47_PLSQL_DMLParser
	public final void synpred47_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1123:12: ( LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:1123:13: LEFT_PAREN ( select_key | with_key )
		{
		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred47_PLSQL_DMLParser11067); if (state.failed) return;

		// PLSQL_DMLParser.g:1123:24: ( select_key | with_key )
		int alt373=2;
		int LA373_0 = input.LA(1);
		if ( (LA373_0==SQL92_RESERVED_SELECT) ) {
			alt373=1;
		}
		else if ( (LA373_0==SQL92_RESERVED_WITH) ) {
			alt373=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 373, 0, input);
			throw nvae;
		}

		switch (alt373) {
			case 1 :
				// PLSQL_DMLParser.g:1123:25: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred47_PLSQL_DMLParser11070);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:1123:36: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred47_PLSQL_DMLParser11072);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred47_PLSQL_DMLParser

	// $ANTLR start synpred48_PLSQL_DMLParser
	public final void synpred48_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1137:19: ( multiset_key LEFT_PAREN ( select_key | with_key ) )
		// PLSQL_DMLParser.g:1137:20: multiset_key LEFT_PAREN ( select_key | with_key )
		{
		pushFollow(FOLLOW_multiset_key_in_synpred48_PLSQL_DMLParser11293);
		gPLSQLParser.multiset_key();
		state._fsp--;
		if (state.failed) return;

		match(input,LEFT_PAREN,FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser11295); if (state.failed) return;

		// PLSQL_DMLParser.g:1137:44: ( select_key | with_key )
		int alt374=2;
		int LA374_0 = input.LA(1);
		if ( (LA374_0==SQL92_RESERVED_SELECT) ) {
			alt374=1;
		}
		else if ( (LA374_0==SQL92_RESERVED_WITH) ) {
			alt374=2;
		}

		else {
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae =
				new NoViableAltException("", 374, 0, input);
			throw nvae;
		}

		switch (alt374) {
			case 1 :
				// PLSQL_DMLParser.g:1137:45: select_key
				{
				pushFollow(FOLLOW_select_key_in_synpred48_PLSQL_DMLParser11298);
				gPLSQLParser.select_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;
			case 2 :
				// PLSQL_DMLParser.g:1137:56: with_key
				{
				pushFollow(FOLLOW_with_key_in_synpred48_PLSQL_DMLParser11300);
				gPLSQLParser.with_key();
				state._fsp--;
				if (state.failed) return;

				}
				break;

		}

		}

	}
	// $ANTLR end synpred48_PLSQL_DMLParser

	// $ANTLR start synpred49_PLSQL_DMLParser
	public final void synpred49_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1365:14: ( default_key )
		// PLSQL_DMLParser.g:1365:15: default_key
		{
		pushFollow(FOLLOW_default_key_in_synpred49_PLSQL_DMLParser14735);
		gPLSQLParser.default_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred49_PLSQL_DMLParser

	// $ANTLR start synpred50_PLSQL_DMLParser
	public final void synpred50_PLSQL_DMLParser_fragment() throws RecognitionException {
		// PLSQL_DMLParser.g:1372:55: ( default_key )
		// PLSQL_DMLParser.g:1372:56: default_key
		{
		pushFollow(FOLLOW_default_key_in_synpred50_PLSQL_DMLParser14807);
		gPLSQLParser.default_key();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred50_PLSQL_DMLParser

	// Delegated rules

	public final boolean synpred33_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred33_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred4_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred4_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred48_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred48_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred45_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred45_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred17_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred17_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred14_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred14_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred21_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred21_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred26_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred26_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred23_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred23_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred29_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred29_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred43_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred43_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred19_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred19_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred35_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred35_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred3_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred31_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred31_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred6_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred6_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred9_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred9_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred13_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred13_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred28_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred28_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred47_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred47_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred22_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred22_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred16_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred16_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred50_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred50_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred10_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred10_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred41_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred41_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred8_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred8_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred25_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred25_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred37_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred37_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred44_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred44_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred5_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred5_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred49_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred49_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred18_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred18_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred32_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred32_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred15_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred15_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred20_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred20_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred46_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred46_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred12_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred12_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred27_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred27_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred24_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred24_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred11_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred11_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred7_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred7_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred42_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred42_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred1_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred30_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred30_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred39_PLSQL_DMLParser() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred39_PLSQL_DMLParser_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}


	protected DFA20 dfa20 = new DFA20(this);
	protected DFA24 dfa24 = new DFA24(this);
	protected DFA45 dfa45 = new DFA45(this);
	protected DFA47 dfa47 = new DFA47(this);
	protected DFA48 dfa48 = new DFA48(this);
	protected DFA102 dfa102 = new DFA102(this);
	protected DFA182 dfa182 = new DFA182(this);
	protected DFA187 dfa187 = new DFA187(this);
	protected DFA189 dfa189 = new DFA189(this);
	protected DFA197 dfa197 = new DFA197(this);
	protected DFA230 dfa230 = new DFA230(this);
	protected DFA267 dfa267 = new DFA267(this);
	protected DFA303 dfa303 = new DFA303(this);
	protected DFA320 dfa320 = new DFA320(this);
	static final String DFA20_eotS =
		"\60\uffff";
	static final String DFA20_eofS =
		"\60\uffff";
	static final String DFA20_minS =
		"\1\22\1\27\1\uffff\1\22\1\uffff\3\27\2\22\1\27\2\22\2\27\1\uffff\7\27"+
		"\2\22\1\27\2\22\1\27\2\22\12\27\2\22\5\27";
	static final String DFA20_maxS =
		"\2\134\1\uffff\1\u0099\1\uffff\3\134\2\170\1\134\2\u0099\2\134\1\uffff"+
		"\7\134\2\u0099\1\134\2\u009e\1\134\2\151\12\134\2\u009e\5\134";
	static final String DFA20_acceptS =
		"\2\uffff\1\2\1\uffff\1\2\12\uffff\1\1\40\uffff";
	static final String DFA20_specialS =
		"\1\26\1\17\1\uffff\1\30\1\uffff\1\13\1\14\1\20\1\21\1\16\1\22\1\31\1\45"+
		"\1\35\1\46\1\uffff\1\36\1\47\1\5\1\25\1\52\1\37\1\40\1\0\1\15\1\23\1\27"+
		"\1\32\1\24\1\33\1\34\1\1\1\7\1\2\1\10\1\41\1\50\1\6\1\42\1\51\1\43\1\53"+
		"\1\54\1\44\1\3\1\11\1\4\1\12}>";
	static final String[] DFA20_transitionS = {
			"\1\2\111\uffff\1\1",
			"\1\4\15\uffff\1\4\66\uffff\1\3",
			"",
			"\1\5\27\uffff\1\4\13\uffff\1\4\45\uffff\1\6\74\uffff\1\4",
			"",
			"\1\11\15\uffff\1\7\66\uffff\1\10",
			"\1\14\15\uffff\1\12\66\uffff\1\13",
			"\1\16\104\uffff\1\15",
			"\1\17\27\uffff\1\4\13\uffff\1\17\45\uffff\1\17\14\uffff\1\4\1\17\15"+
			"\uffff\1\17",
			"\1\17\27\uffff\1\4\13\uffff\1\17\45\uffff\1\17\14\uffff\1\4\1\17\15"+
			"\uffff\1\17",
			"\1\21\104\uffff\1\20",
			"\1\24\27\uffff\1\17\13\uffff\1\22\45\uffff\1\23\74\uffff\1\17",
			"\1\24\27\uffff\1\17\13\uffff\1\22\45\uffff\1\23\74\uffff\1\17",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"",
			"\1\14\36\uffff\1\26\45\uffff\1\13",
			"\1\14\36\uffff\1\26\45\uffff\1\13",
			"\1\30\104\uffff\1\27",
			"\1\33\15\uffff\1\31\66\uffff\1\32",
			"\1\36\15\uffff\1\34\66\uffff\1\35",
			"\1\40\104\uffff\1\37",
			"\1\42\104\uffff\1\41",
			"\1\24\27\uffff\1\17\13\uffff\1\22\45\uffff\1\23\74\uffff\1\17",
			"\1\24\27\uffff\1\17\13\uffff\1\22\45\uffff\1\23\74\uffff\1\17",
			"\1\44\104\uffff\1\43",
			"\1\17\43\uffff\1\45\45\uffff\1\17\101\uffff\1\4",
			"\1\17\43\uffff\1\45\45\uffff\1\17\101\uffff\1\4",
			"\1\47\104\uffff\1\46",
			"\1\4\27\uffff\1\17\13\uffff\1\4\45\uffff\1\4\14\uffff\1\17",
			"\1\4\27\uffff\1\17\13\uffff\1\4\45\uffff\1\4\14\uffff\1\17",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\14\36\uffff\1\26\45\uffff\1\13",
			"\1\14\36\uffff\1\26\45\uffff\1\13",
			"\1\33\36\uffff\1\50\45\uffff\1\32",
			"\1\33\36\uffff\1\50\45\uffff\1\32",
			"\1\52\104\uffff\1\51",
			"\1\36\36\uffff\1\53\45\uffff\1\35",
			"\1\36\36\uffff\1\53\45\uffff\1\35",
			"\1\55\104\uffff\1\54",
			"\1\17\43\uffff\1\45\45\uffff\1\17\101\uffff\1\4",
			"\1\17\43\uffff\1\45\45\uffff\1\17\101\uffff\1\4",
			"\1\57\104\uffff\1\56",
			"\1\33\36\uffff\1\50\45\uffff\1\32",
			"\1\33\36\uffff\1\50\45\uffff\1\32",
			"\1\36\36\uffff\1\53\45\uffff\1\35",
			"\1\36\36\uffff\1\53\45\uffff\1\35"
	};

	static final short[] DFA20_eot = DFA.unpackEncodedString(DFA20_eotS);
	static final short[] DFA20_eof = DFA.unpackEncodedString(DFA20_eofS);
	static final char[] DFA20_min = DFA.unpackEncodedStringToUnsignedChars(DFA20_minS);
	static final char[] DFA20_max = DFA.unpackEncodedStringToUnsignedChars(DFA20_maxS);
	static final short[] DFA20_accept = DFA.unpackEncodedString(DFA20_acceptS);
	static final short[] DFA20_special = DFA.unpackEncodedString(DFA20_specialS);
	static final short[][] DFA20_transition;

	static {
		int numStates = DFA20_transitionS.length;
		DFA20_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA20_transition[i] = DFA.unpackEncodedString(DFA20_transitionS[i]);
		}
	}

	protected class DFA20 extends DFA {

		public DFA20(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 20;
			this.eot = DFA20_eot;
			this.eof = DFA20_eof;
			this.min = DFA20_min;
			this.max = DFA20_max;
			this.accept = DFA20_accept;
			this.special = DFA20_special;
			this.transition = DFA20_transition;
		}
		@Override
		public String getDescription() {
			return "239:70: ( nulls_key last_key )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA20_23 = input.LA(1);
						 
						int index20_23 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_23==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 19;}
						else if ( (LA20_23==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 20;}
						else if ( (LA20_23==LEFT_PAREN||LA20_23==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_23==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 18;}
						 
						input.seek(index20_23);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA20_31 = input.LA(1);
						 
						int index20_31 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_31==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA20_31==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						else if ( (LA20_31==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						 
						input.seek(index20_31);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA20_33 = input.LA(1);
						 
						int index20_33 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_33==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA20_33==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						else if ( (LA20_33==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 22;}
						 
						input.seek(index20_33);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA20_44 = input.LA(1);
						 
						int index20_44 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_44==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA20_44==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						else if ( (LA20_44==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						 
						input.seek(index20_44);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA20_46 = input.LA(1);
						 
						int index20_46 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_46==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA20_46==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						else if ( (LA20_46==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						 
						input.seek(index20_46);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA20_18 = input.LA(1);
						 
						int index20_18 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_18==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 23;}
						else if ( (LA20_18==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 24;}
						 
						input.seek(index20_18);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA20_37 = input.LA(1);
						 
						int index20_37 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_37==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 41;}
						else if ( (LA20_37==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 42;}
						 
						input.seek(index20_37);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA20_32 = input.LA(1);
						 
						int index20_32 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_32==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA20_32==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						else if ( (LA20_32==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						 
						input.seek(index20_32);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA20_34 = input.LA(1);
						 
						int index20_34 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_34==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA20_34==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						else if ( (LA20_34==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 22;}
						 
						input.seek(index20_34);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA20_45 = input.LA(1);
						 
						int index20_45 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_45==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA20_45==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						else if ( (LA20_45==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						 
						input.seek(index20_45);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA20_47 = input.LA(1);
						 
						int index20_47 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_47==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA20_47==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						else if ( (LA20_47==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						 
						input.seek(index20_47);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA20_5 = input.LA(1);
						 
						int index20_5 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_5==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 7;}
						else if ( (LA20_5==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA20_5==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index20_5);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA20_6 = input.LA(1);
						 
						int index20_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_6==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 10;}
						else if ( (LA20_6==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA20_6==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index20_6);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA20_24 = input.LA(1);
						 
						int index20_24 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_24==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 19;}
						else if ( (LA20_24==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 20;}
						else if ( (LA20_24==LEFT_PAREN||LA20_24==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_24==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 18;}
						 
						input.seek(index20_24);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA20_9 = input.LA(1);
						 
						int index20_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_9==COMMA||LA20_9==PERIOD||LA20_9==REGULAR_ID||LA20_9==SQL92_RESERVED_ASC||LA20_9==SQL92_RESERVED_DESC) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_9==LEFT_PAREN||LA20_9==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_9);
						if ( s>=0 ) return s;
						break;

					case 15 : 
						int LA20_1 = input.LA(1);
						 
						int index20_1 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 3;}
						else if ( (LA20_1==DELIMITED_ID||LA20_1==INTRODUCER) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_1);
						if ( s>=0 ) return s;
						break;

					case 16 : 
						int LA20_7 = input.LA(1);
						 
						int index20_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_7==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 13;}
						else if ( (LA20_7==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 14;}
						 
						input.seek(index20_7);
						if ( s>=0 ) return s;
						break;

					case 17 : 
						int LA20_8 = input.LA(1);
						 
						int index20_8 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_8==COMMA||LA20_8==PERIOD||LA20_8==REGULAR_ID||LA20_8==SQL92_RESERVED_ASC||LA20_8==SQL92_RESERVED_DESC) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_8==LEFT_PAREN||LA20_8==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_8);
						if ( s>=0 ) return s;
						break;

					case 18 : 
						int LA20_10 = input.LA(1);
						 
						int index20_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_10==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 16;}
						else if ( (LA20_10==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 17;}
						 
						input.seek(index20_10);
						if ( s>=0 ) return s;
						break;

					case 19 : 
						int LA20_25 = input.LA(1);
						 
						int index20_25 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_25==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 35;}
						else if ( (LA20_25==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 36;}
						 
						input.seek(index20_25);
						if ( s>=0 ) return s;
						break;

					case 20 : 
						int LA20_28 = input.LA(1);
						 
						int index20_28 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_28==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 38;}
						else if ( (LA20_28==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 39;}
						 
						input.seek(index20_28);
						if ( s>=0 ) return s;
						break;

					case 21 : 
						int LA20_19 = input.LA(1);
						 
						int index20_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_19==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA20_19==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA20_19==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						 
						input.seek(index20_19);
						if ( s>=0 ) return s;
						break;

					case 22 : 
						int LA20_0 = input.LA(1);
						 
						int index20_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 1;}
						else if ( (LA20_0==COMMA) ) {s = 2;}
						 
						input.seek(index20_0);
						if ( s>=0 ) return s;
						break;

					case 23 : 
						int LA20_26 = input.LA(1);
						 
						int index20_26 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_26==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 37;}
						else if ( (LA20_26==COMMA||LA20_26==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_26==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_26);
						if ( s>=0 ) return s;
						break;

					case 24 : 
						int LA20_3 = input.LA(1);
						 
						int index20_3 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_3==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 5;}
						else if ( (LA20_3==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 6;}
						else if ( (LA20_3==LEFT_PAREN||LA20_3==PERIOD||LA20_3==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_3);
						if ( s>=0 ) return s;
						break;

					case 25 : 
						int LA20_11 = input.LA(1);
						 
						int index20_11 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_11==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 18;}
						else if ( (LA20_11==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 19;}
						else if ( (LA20_11==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 20;}
						else if ( (LA20_11==LEFT_PAREN||LA20_11==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						 
						input.seek(index20_11);
						if ( s>=0 ) return s;
						break;

					case 26 : 
						int LA20_27 = input.LA(1);
						 
						int index20_27 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_27==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 37;}
						else if ( (LA20_27==COMMA||LA20_27==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_27==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_27);
						if ( s>=0 ) return s;
						break;

					case 27 : 
						int LA20_29 = input.LA(1);
						 
						int index20_29 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_29==LEFT_PAREN||LA20_29==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_29==COMMA||LA20_29==PERIOD||LA20_29==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_29);
						if ( s>=0 ) return s;
						break;

					case 28 : 
						int LA20_30 = input.LA(1);
						 
						int index20_30 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_30==LEFT_PAREN||LA20_30==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_30==COMMA||LA20_30==PERIOD||LA20_30==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_30);
						if ( s>=0 ) return s;
						break;

					case 29 : 
						int LA20_13 = input.LA(1);
						 
						int index20_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_13==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						else if ( (LA20_13==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA20_13==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index20_13);
						if ( s>=0 ) return s;
						break;

					case 30 : 
						int LA20_16 = input.LA(1);
						 
						int index20_16 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_16==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 22;}
						else if ( (LA20_16==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA20_16==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index20_16);
						if ( s>=0 ) return s;
						break;

					case 31 : 
						int LA20_21 = input.LA(1);
						 
						int index20_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_21==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 31;}
						else if ( (LA20_21==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 32;}
						 
						input.seek(index20_21);
						if ( s>=0 ) return s;
						break;

					case 32 : 
						int LA20_22 = input.LA(1);
						 
						int index20_22 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_22==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 33;}
						else if ( (LA20_22==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 34;}
						 
						input.seek(index20_22);
						if ( s>=0 ) return s;
						break;

					case 33 : 
						int LA20_35 = input.LA(1);
						 
						int index20_35 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_35==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						else if ( (LA20_35==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA20_35==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						 
						input.seek(index20_35);
						if ( s>=0 ) return s;
						break;

					case 34 : 
						int LA20_38 = input.LA(1);
						 
						int index20_38 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_38==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						else if ( (LA20_38==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA20_38==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						 
						input.seek(index20_38);
						if ( s>=0 ) return s;
						break;

					case 35 : 
						int LA20_40 = input.LA(1);
						 
						int index20_40 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_40==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 44;}
						else if ( (LA20_40==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 45;}
						 
						input.seek(index20_40);
						if ( s>=0 ) return s;
						break;

					case 36 : 
						int LA20_43 = input.LA(1);
						 
						int index20_43 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_43==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 46;}
						else if ( (LA20_43==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 47;}
						 
						input.seek(index20_43);
						if ( s>=0 ) return s;
						break;

					case 37 : 
						int LA20_12 = input.LA(1);
						 
						int index20_12 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_12==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 18;}
						else if ( (LA20_12==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 19;}
						else if ( (LA20_12==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 20;}
						else if ( (LA20_12==LEFT_PAREN||LA20_12==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						 
						input.seek(index20_12);
						if ( s>=0 ) return s;
						break;

					case 38 : 
						int LA20_14 = input.LA(1);
						 
						int index20_14 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_14==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						else if ( (LA20_14==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA20_14==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index20_14);
						if ( s>=0 ) return s;
						break;

					case 39 : 
						int LA20_17 = input.LA(1);
						 
						int index20_17 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_17==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 22;}
						else if ( (LA20_17==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA20_17==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index20_17);
						if ( s>=0 ) return s;
						break;

					case 40 : 
						int LA20_36 = input.LA(1);
						 
						int index20_36 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_36==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						else if ( (LA20_36==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA20_36==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						 
						input.seek(index20_36);
						if ( s>=0 ) return s;
						break;

					case 41 : 
						int LA20_39 = input.LA(1);
						 
						int index20_39 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_39==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						else if ( (LA20_39==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA20_39==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						 
						input.seek(index20_39);
						if ( s>=0 ) return s;
						break;

					case 42 : 
						int LA20_20 = input.LA(1);
						 
						int index20_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_20==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA20_20==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA20_20==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						 
						input.seek(index20_20);
						if ( s>=0 ) return s;
						break;

					case 43 : 
						int LA20_41 = input.LA(1);
						 
						int index20_41 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_41==COMMA||LA20_41==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_41==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 37;}
						else if ( (LA20_41==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_41);
						if ( s>=0 ) return s;
						break;

					case 44 : 
						int LA20_42 = input.LA(1);
						 
						int index20_42 = input.index();
						input.rewind();
						s = -1;
						if ( (LA20_42==COMMA||LA20_42==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 15;}
						else if ( (LA20_42==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 37;}
						else if ( (LA20_42==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index20_42);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 20, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA24_eotS =
		"\60\uffff";
	static final String DFA24_eofS =
		"\60\uffff";
	static final String DFA24_minS =
		"\1\22\1\27\1\uffff\1\22\1\uffff\3\27\2\22\1\27\2\22\5\27\1\uffff\3\27"+
		"\2\22\1\27\2\22\1\27\2\22\13\27\2\22\5\27";
	static final String DFA24_maxS =
		"\2\134\1\uffff\1\u0099\1\uffff\3\134\2\u0099\1\134\2\170\5\134\1\uffff"+
		"\3\134\2\u0099\1\134\2\u009e\1\134\2\151\13\134\2\u009e\5\134";
	static final String DFA24_acceptS =
		"\2\uffff\1\2\1\uffff\1\2\15\uffff\1\1\35\uffff";
	static final String DFA24_specialS =
		"\1\43\1\5\1\uffff\1\51\1\uffff\1\15\1\14\1\20\1\27\1\44\1\21\1\22\1\17"+
		"\1\33\1\45\1\6\1\25\1\52\1\uffff\1\34\1\46\1\35\1\0\1\16\1\23\1\26\1\30"+
		"\1\24\1\31\1\32\1\36\1\1\1\10\1\37\1\47\1\7\1\40\1\50\1\2\1\11\1\41\1"+
		"\53\1\54\1\42\1\3\1\12\1\4\1\13}>";
	static final String[] DFA24_transitionS = {
			"\1\2\111\uffff\1\1",
			"\1\4\15\uffff\1\4\66\uffff\1\3",
			"",
			"\1\6\27\uffff\1\4\13\uffff\1\4\45\uffff\1\5\74\uffff\1\4",
			"",
			"\1\11\15\uffff\1\7\66\uffff\1\10",
			"\1\14\15\uffff\1\12\66\uffff\1\13",
			"\1\16\104\uffff\1\15",
			"\1\21\27\uffff\1\22\13\uffff\1\17\45\uffff\1\20\74\uffff\1\22",
			"\1\21\27\uffff\1\22\13\uffff\1\17\45\uffff\1\20\74\uffff\1\22",
			"\1\24\104\uffff\1\23",
			"\1\22\27\uffff\1\4\13\uffff\1\22\45\uffff\1\22\14\uffff\1\4\1\22\15"+
			"\uffff\1\22",
			"\1\22\27\uffff\1\4\13\uffff\1\22\45\uffff\1\22\14\uffff\1\4\1\22\15"+
			"\uffff\1\22",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\27\104\uffff\1\26",
			"\1\32\15\uffff\1\30\66\uffff\1\31",
			"\1\35\15\uffff\1\33\66\uffff\1\34",
			"",
			"\1\14\36\uffff\1\36\45\uffff\1\13",
			"\1\14\36\uffff\1\36\45\uffff\1\13",
			"\1\40\104\uffff\1\37",
			"\1\21\27\uffff\1\22\13\uffff\1\17\45\uffff\1\20\74\uffff\1\22",
			"\1\21\27\uffff\1\22\13\uffff\1\17\45\uffff\1\20\74\uffff\1\22",
			"\1\42\104\uffff\1\41",
			"\1\22\43\uffff\1\43\45\uffff\1\22\101\uffff\1\4",
			"\1\22\43\uffff\1\43\45\uffff\1\22\101\uffff\1\4",
			"\1\45\104\uffff\1\44",
			"\1\4\27\uffff\1\22\13\uffff\1\4\45\uffff\1\4\14\uffff\1\22",
			"\1\4\27\uffff\1\22\13\uffff\1\4\45\uffff\1\4\14\uffff\1\22",
			"\1\47\104\uffff\1\46",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\11\36\uffff\1\25\45\uffff\1\10",
			"\1\32\36\uffff\1\50\45\uffff\1\31",
			"\1\32\36\uffff\1\50\45\uffff\1\31",
			"\1\52\104\uffff\1\51",
			"\1\35\36\uffff\1\53\45\uffff\1\34",
			"\1\35\36\uffff\1\53\45\uffff\1\34",
			"\1\14\36\uffff\1\36\45\uffff\1\13",
			"\1\14\36\uffff\1\36\45\uffff\1\13",
			"\1\55\104\uffff\1\54",
			"\1\22\43\uffff\1\43\45\uffff\1\22\101\uffff\1\4",
			"\1\22\43\uffff\1\43\45\uffff\1\22\101\uffff\1\4",
			"\1\57\104\uffff\1\56",
			"\1\32\36\uffff\1\50\45\uffff\1\31",
			"\1\32\36\uffff\1\50\45\uffff\1\31",
			"\1\35\36\uffff\1\53\45\uffff\1\34",
			"\1\35\36\uffff\1\53\45\uffff\1\34"
	};

	static final short[] DFA24_eot = DFA.unpackEncodedString(DFA24_eotS);
	static final short[] DFA24_eof = DFA.unpackEncodedString(DFA24_eofS);
	static final char[] DFA24_min = DFA.unpackEncodedStringToUnsignedChars(DFA24_minS);
	static final char[] DFA24_max = DFA.unpackEncodedStringToUnsignedChars(DFA24_maxS);
	static final short[] DFA24_accept = DFA.unpackEncodedString(DFA24_acceptS);
	static final short[] DFA24_special = DFA.unpackEncodedString(DFA24_specialS);
	static final short[][] DFA24_transition;

	static {
		int numStates = DFA24_transitionS.length;
		DFA24_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA24_transition[i] = DFA.unpackEncodedString(DFA24_transitionS[i]);
		}
	}

	protected class DFA24 extends DFA {

		public DFA24(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 24;
			this.eot = DFA24_eot;
			this.eof = DFA24_eof;
			this.min = DFA24_min;
			this.max = DFA24_max;
			this.accept = DFA24_accept;
			this.special = DFA24_special;
			this.transition = DFA24_transition;
		}
		@Override
		public String getDescription() {
			return "240:78: ( nulls_key last_key )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA24_22 = input.LA(1);
						 
						int index24_22 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_22==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 16;}
						else if ( (LA24_22==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 17;}
						else if ( (LA24_22==LEFT_PAREN||LA24_22==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_22==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 15;}
						 
						input.seek(index24_22);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA24_31 = input.LA(1);
						 
						int index24_31 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_31==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA24_31==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						else if ( (LA24_31==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						 
						input.seek(index24_31);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA24_38 = input.LA(1);
						 
						int index24_38 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_38==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA24_38==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						else if ( (LA24_38==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						 
						input.seek(index24_38);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA24_44 = input.LA(1);
						 
						int index24_44 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_44==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA24_44==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA24_44==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						 
						input.seek(index24_44);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA24_46 = input.LA(1);
						 
						int index24_46 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_46==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA24_46==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA24_46==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						 
						input.seek(index24_46);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA24_1 = input.LA(1);
						 
						int index24_1 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 3;}
						else if ( (LA24_1==DELIMITED_ID||LA24_1==INTRODUCER) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_1);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA24_15 = input.LA(1);
						 
						int index24_15 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_15==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 22;}
						else if ( (LA24_15==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 23;}
						 
						input.seek(index24_15);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA24_35 = input.LA(1);
						 
						int index24_35 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_35==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 41;}
						else if ( (LA24_35==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 42;}
						 
						input.seek(index24_35);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA24_32 = input.LA(1);
						 
						int index24_32 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_32==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA24_32==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						else if ( (LA24_32==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						 
						input.seek(index24_32);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA24_39 = input.LA(1);
						 
						int index24_39 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_39==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA24_39==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						else if ( (LA24_39==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						 
						input.seek(index24_39);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA24_45 = input.LA(1);
						 
						int index24_45 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_45==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA24_45==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						else if ( (LA24_45==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						 
						input.seek(index24_45);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA24_47 = input.LA(1);
						 
						int index24_47 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_47==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA24_47==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						else if ( (LA24_47==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						 
						input.seek(index24_47);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA24_6 = input.LA(1);
						 
						int index24_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_6==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 10;}
						else if ( (LA24_6==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA24_6==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index24_6);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA24_5 = input.LA(1);
						 
						int index24_5 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_5==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 7;}
						else if ( (LA24_5==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA24_5==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index24_5);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA24_23 = input.LA(1);
						 
						int index24_23 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_23==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 16;}
						else if ( (LA24_23==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 17;}
						else if ( (LA24_23==LEFT_PAREN||LA24_23==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_23==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 15;}
						 
						input.seek(index24_23);
						if ( s>=0 ) return s;
						break;

					case 15 : 
						int LA24_12 = input.LA(1);
						 
						int index24_12 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_12==COMMA||LA24_12==PERIOD||LA24_12==REGULAR_ID||LA24_12==SQL92_RESERVED_ASC||LA24_12==SQL92_RESERVED_DESC) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_12==LEFT_PAREN||LA24_12==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_12);
						if ( s>=0 ) return s;
						break;

					case 16 : 
						int LA24_7 = input.LA(1);
						 
						int index24_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_7==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 13;}
						else if ( (LA24_7==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 14;}
						 
						input.seek(index24_7);
						if ( s>=0 ) return s;
						break;

					case 17 : 
						int LA24_10 = input.LA(1);
						 
						int index24_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_10==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 19;}
						else if ( (LA24_10==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 20;}
						 
						input.seek(index24_10);
						if ( s>=0 ) return s;
						break;

					case 18 : 
						int LA24_11 = input.LA(1);
						 
						int index24_11 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_11==COMMA||LA24_11==PERIOD||LA24_11==REGULAR_ID||LA24_11==SQL92_RESERVED_ASC||LA24_11==SQL92_RESERVED_DESC) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_11==LEFT_PAREN||LA24_11==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_11);
						if ( s>=0 ) return s;
						break;

					case 19 : 
						int LA24_24 = input.LA(1);
						 
						int index24_24 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_24==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 33;}
						else if ( (LA24_24==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 34;}
						 
						input.seek(index24_24);
						if ( s>=0 ) return s;
						break;

					case 20 : 
						int LA24_27 = input.LA(1);
						 
						int index24_27 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_27==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 36;}
						else if ( (LA24_27==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 37;}
						 
						input.seek(index24_27);
						if ( s>=0 ) return s;
						break;

					case 21 : 
						int LA24_16 = input.LA(1);
						 
						int index24_16 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_16==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 24;}
						else if ( (LA24_16==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA24_16==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						 
						input.seek(index24_16);
						if ( s>=0 ) return s;
						break;

					case 22 : 
						int LA24_25 = input.LA(1);
						 
						int index24_25 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_25==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 35;}
						else if ( (LA24_25==COMMA||LA24_25==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_25==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_25);
						if ( s>=0 ) return s;
						break;

					case 23 : 
						int LA24_8 = input.LA(1);
						 
						int index24_8 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_8==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 15;}
						else if ( (LA24_8==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 16;}
						else if ( (LA24_8==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 17;}
						else if ( (LA24_8==LEFT_PAREN||LA24_8==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						 
						input.seek(index24_8);
						if ( s>=0 ) return s;
						break;

					case 24 : 
						int LA24_26 = input.LA(1);
						 
						int index24_26 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_26==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 35;}
						else if ( (LA24_26==COMMA||LA24_26==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_26==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_26);
						if ( s>=0 ) return s;
						break;

					case 25 : 
						int LA24_28 = input.LA(1);
						 
						int index24_28 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_28==LEFT_PAREN||LA24_28==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_28==COMMA||LA24_28==PERIOD||LA24_28==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_28);
						if ( s>=0 ) return s;
						break;

					case 26 : 
						int LA24_29 = input.LA(1);
						 
						int index24_29 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_29==LEFT_PAREN||LA24_29==SQL92_RESERVED_AS) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_29==COMMA||LA24_29==PERIOD||LA24_29==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_29);
						if ( s>=0 ) return s;
						break;

					case 27 : 
						int LA24_13 = input.LA(1);
						 
						int index24_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_13==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						else if ( (LA24_13==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA24_13==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index24_13);
						if ( s>=0 ) return s;
						break;

					case 28 : 
						int LA24_19 = input.LA(1);
						 
						int index24_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_19==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						else if ( (LA24_19==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA24_19==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index24_19);
						if ( s>=0 ) return s;
						break;

					case 29 : 
						int LA24_21 = input.LA(1);
						 
						int index24_21 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_21==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 31;}
						else if ( (LA24_21==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 32;}
						 
						input.seek(index24_21);
						if ( s>=0 ) return s;
						break;

					case 30 : 
						int LA24_30 = input.LA(1);
						 
						int index24_30 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_30==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 38;}
						else if ( (LA24_30==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 39;}
						 
						input.seek(index24_30);
						if ( s>=0 ) return s;
						break;

					case 31 : 
						int LA24_33 = input.LA(1);
						 
						int index24_33 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_33==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						else if ( (LA24_33==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA24_33==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						 
						input.seek(index24_33);
						if ( s>=0 ) return s;
						break;

					case 32 : 
						int LA24_36 = input.LA(1);
						 
						int index24_36 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_36==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						else if ( (LA24_36==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA24_36==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						 
						input.seek(index24_36);
						if ( s>=0 ) return s;
						break;

					case 33 : 
						int LA24_40 = input.LA(1);
						 
						int index24_40 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_40==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 44;}
						else if ( (LA24_40==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 45;}
						 
						input.seek(index24_40);
						if ( s>=0 ) return s;
						break;

					case 34 : 
						int LA24_43 = input.LA(1);
						 
						int index24_43 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_43==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 46;}
						else if ( (LA24_43==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 47;}
						 
						input.seek(index24_43);
						if ( s>=0 ) return s;
						break;

					case 35 : 
						int LA24_0 = input.LA(1);
						 
						int index24_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 1;}
						else if ( (LA24_0==COMMA) ) {s = 2;}
						 
						input.seek(index24_0);
						if ( s>=0 ) return s;
						break;

					case 36 : 
						int LA24_9 = input.LA(1);
						 
						int index24_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_9==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 15;}
						else if ( (LA24_9==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 16;}
						else if ( (LA24_9==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 17;}
						else if ( (LA24_9==LEFT_PAREN||LA24_9==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						 
						input.seek(index24_9);
						if ( s>=0 ) return s;
						break;

					case 37 : 
						int LA24_14 = input.LA(1);
						 
						int index24_14 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_14==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 21;}
						else if ( (LA24_14==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 8;}
						else if ( (LA24_14==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 9;}
						 
						input.seek(index24_14);
						if ( s>=0 ) return s;
						break;

					case 38 : 
						int LA24_20 = input.LA(1);
						 
						int index24_20 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_20==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 30;}
						else if ( (LA24_20==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 11;}
						else if ( (LA24_20==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 12;}
						 
						input.seek(index24_20);
						if ( s>=0 ) return s;
						break;

					case 39 : 
						int LA24_34 = input.LA(1);
						 
						int index24_34 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_34==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 40;}
						else if ( (LA24_34==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 25;}
						else if ( (LA24_34==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 26;}
						 
						input.seek(index24_34);
						if ( s>=0 ) return s;
						break;

					case 40 : 
						int LA24_37 = input.LA(1);
						 
						int index24_37 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_37==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 43;}
						else if ( (LA24_37==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA24_37==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						 
						input.seek(index24_37);
						if ( s>=0 ) return s;
						break;

					case 41 : 
						int LA24_3 = input.LA(1);
						 
						int index24_3 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_3==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 5;}
						else if ( (LA24_3==COMMA) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 6;}
						else if ( (LA24_3==LEFT_PAREN||LA24_3==PERIOD||LA24_3==SQL92_RESERVED_SELECT) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_3);
						if ( s>=0 ) return s;
						break;

					case 42 : 
						int LA24_17 = input.LA(1);
						 
						int index24_17 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_17==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 27;}
						else if ( (LA24_17==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 28;}
						else if ( (LA24_17==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 29;}
						 
						input.seek(index24_17);
						if ( s>=0 ) return s;
						break;

					case 43 : 
						int LA24_41 = input.LA(1);
						 
						int index24_41 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_41==COMMA||LA24_41==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_41==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 35;}
						else if ( (LA24_41==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_41);
						if ( s>=0 ) return s;
						break;

					case 44 : 
						int LA24_42 = input.LA(1);
						 
						int index24_42 = input.index();
						input.rewind();
						s = -1;
						if ( (LA24_42==COMMA||LA24_42==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("nulls")))) {s = 18;}
						else if ( (LA24_42==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("nulls"))||(input.LT(1).getText().equalsIgnoreCase("set"))))) {s = 35;}
						else if ( (LA24_42==SQL92_RESERVED_TO) && ((input.LT(1).getText().equalsIgnoreCase("set")))) {s = 4;}
						 
						input.seek(index24_42);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 24, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA45_eotS =
		"\105\uffff";
	static final String DFA45_eofS =
		"\1\2\104\uffff";
	static final String DFA45_minS =
		"\1\10\1\0\103\uffff";
	static final String DFA45_maxS =
		"\1\u00ae\1\0\103\uffff";
	static final String DFA45_acceptS =
		"\2\uffff\1\3\100\uffff\1\1\1\2";
	static final String DFA45_specialS =
		"\1\uffff\1\0\103\uffff}>";
	static final String[] DFA45_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\1\1\2\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2"+
			"\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\3\2\6\uffff\1\2",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA45_eot = DFA.unpackEncodedString(DFA45_eotS);
	static final short[] DFA45_eof = DFA.unpackEncodedString(DFA45_eofS);
	static final char[] DFA45_min = DFA.unpackEncodedStringToUnsignedChars(DFA45_minS);
	static final char[] DFA45_max = DFA.unpackEncodedStringToUnsignedChars(DFA45_maxS);
	static final short[] DFA45_accept = DFA.unpackEncodedString(DFA45_acceptS);
	static final short[] DFA45_special = DFA.unpackEncodedString(DFA45_specialS);
	static final short[][] DFA45_transition;

	static {
		int numStates = DFA45_transitionS.length;
		DFA45_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA45_transition[i] = DFA.unpackEncodedString(DFA45_transitionS[i]);
		}
	}

	protected class DFA45 extends DFA {

		public DFA45(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 45;
			this.eot = DFA45_eot;
			this.eof = DFA45_eof;
			this.min = DFA45_min;
			this.max = DFA45_max;
			this.accept = DFA45_accept;
			this.special = DFA45_special;
			this.transition = DFA45_transition;
		}
		@Override
		public String getDescription() {
			return "308:76: ( options {k=1; } : pivot_clause | unpivot_clause )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA45_1 = input.LA(1);
						 
						int index45_1 = input.index();
						input.rewind();
						s = -1;
						if ( (((input.LT(1).getText().equalsIgnoreCase("pivot")))) ) {s = 67;}
						else if ( (((input.LT(1).getText().equalsIgnoreCase("unpivot")))) ) {s = 68;}
						else if ( (true) ) {s = 2;}
						 
						input.seek(index45_1);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 45, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA47_eotS =
		"\105\uffff";
	static final String DFA47_eofS =
		"\1\2\104\uffff";
	static final String DFA47_minS =
		"\1\10\1\0\103\uffff";
	static final String DFA47_maxS =
		"\1\u00ae\1\0\103\uffff";
	static final String DFA47_acceptS =
		"\2\uffff\1\3\100\uffff\1\1\1\2";
	static final String DFA47_specialS =
		"\1\uffff\1\0\103\uffff}>";
	static final String[] DFA47_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\1\1\2\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2"+
			"\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\3\2\6\uffff\1\2",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA47_eot = DFA.unpackEncodedString(DFA47_eotS);
	static final short[] DFA47_eof = DFA.unpackEncodedString(DFA47_eofS);
	static final char[] DFA47_min = DFA.unpackEncodedStringToUnsignedChars(DFA47_minS);
	static final char[] DFA47_max = DFA.unpackEncodedStringToUnsignedChars(DFA47_maxS);
	static final short[] DFA47_accept = DFA.unpackEncodedString(DFA47_acceptS);
	static final short[] DFA47_special = DFA.unpackEncodedString(DFA47_specialS);
	static final short[][] DFA47_transition;

	static {
		int numStates = DFA47_transitionS.length;
		DFA47_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA47_transition[i] = DFA.unpackEncodedString(DFA47_transitionS[i]);
		}
	}

	protected class DFA47 extends DFA {

		public DFA47(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 47;
			this.eot = DFA47_eot;
			this.eof = DFA47_eof;
			this.min = DFA47_min;
			this.max = DFA47_max;
			this.accept = DFA47_accept;
			this.special = DFA47_special;
			this.transition = DFA47_transition;
		}
		@Override
		public String getDescription() {
			return "309:84: ( options {k=1; } : pivot_clause | unpivot_clause )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA47_1 = input.LA(1);
						 
						int index47_1 = input.index();
						input.rewind();
						s = -1;
						if ( (((input.LT(1).getText().equalsIgnoreCase("pivot")))) ) {s = 67;}
						else if ( (((input.LT(1).getText().equalsIgnoreCase("unpivot")))) ) {s = 68;}
						else if ( (true) ) {s = 2;}
						 
						input.seek(index47_1);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 47, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA48_eotS =
		"\105\uffff";
	static final String DFA48_eofS =
		"\1\2\104\uffff";
	static final String DFA48_minS =
		"\1\10\1\0\103\uffff";
	static final String DFA48_maxS =
		"\1\u00ae\1\0\103\uffff";
	static final String DFA48_acceptS =
		"\2\uffff\1\3\100\uffff\1\1\1\2";
	static final String DFA48_specialS =
		"\1\uffff\1\0\103\uffff}>";
	static final String[] DFA48_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\1\1\2\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2"+
			"\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\3\2\6\uffff\1\2",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA48_eot = DFA.unpackEncodedString(DFA48_eotS);
	static final short[] DFA48_eof = DFA.unpackEncodedString(DFA48_eofS);
	static final char[] DFA48_min = DFA.unpackEncodedStringToUnsignedChars(DFA48_minS);
	static final char[] DFA48_max = DFA.unpackEncodedStringToUnsignedChars(DFA48_maxS);
	static final short[] DFA48_accept = DFA.unpackEncodedString(DFA48_acceptS);
	static final short[] DFA48_special = DFA.unpackEncodedString(DFA48_specialS);
	static final short[][] DFA48_transition;

	static {
		int numStates = DFA48_transitionS.length;
		DFA48_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA48_transition[i] = DFA.unpackEncodedString(DFA48_transitionS[i]);
		}
	}

	protected class DFA48 extends DFA {

		public DFA48(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 48;
			this.eot = DFA48_eot;
			this.eof = DFA48_eof;
			this.min = DFA48_min;
			this.max = DFA48_max;
			this.accept = DFA48_accept;
			this.special = DFA48_special;
			this.transition = DFA48_transition;
		}
		@Override
		public String getDescription() {
			return "311:38: ( options {k=1; } : pivot_clause | unpivot_clause )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA48_1 = input.LA(1);
						 
						int index48_1 = input.index();
						input.rewind();
						s = -1;
						if ( (((input.LT(1).getText().equalsIgnoreCase("pivot")))) ) {s = 67;}
						else if ( (((input.LT(1).getText().equalsIgnoreCase("unpivot")))) ) {s = 68;}
						else if ( (true) ) {s = 2;}
						 
						input.seek(index48_1);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 48, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA102_eotS =
		"\15\uffff";
	static final String DFA102_eofS =
		"\15\uffff";
	static final String DFA102_minS =
		"\1\134\2\27\2\134\1\uffff\2\27\2\uffff\3\27";
	static final String DFA102_maxS =
		"\1\134\1\155\1\134\2\u0090\1\uffff\2\134\2\uffff\3\134";
	static final String DFA102_acceptS =
		"\5\uffff\1\2\2\uffff\1\2\1\1\3\uffff";
	static final String DFA102_specialS =
		"\1\3\1\10\1\0\1\2\1\5\1\uffff\1\6\1\11\2\uffff\1\7\1\1\1\4}>";
	static final String[] DFA102_transitionS = {
			"\1\1",
			"\1\4\15\uffff\1\2\66\uffff\1\3\20\uffff\1\5",
			"\1\7\104\uffff\1\6",
			"\1\10\63\uffff\1\11",
			"\1\10\63\uffff\1\11",
			"",
			"\1\4\36\uffff\1\12\45\uffff\1\3",
			"\1\4\36\uffff\1\12\45\uffff\1\3",
			"",
			"",
			"\1\14\104\uffff\1\13",
			"\1\4\36\uffff\1\12\45\uffff\1\3",
			"\1\4\36\uffff\1\12\45\uffff\1\3"
	};

	static final short[] DFA102_eot = DFA.unpackEncodedString(DFA102_eotS);
	static final short[] DFA102_eof = DFA.unpackEncodedString(DFA102_eofS);
	static final char[] DFA102_min = DFA.unpackEncodedStringToUnsignedChars(DFA102_minS);
	static final char[] DFA102_max = DFA.unpackEncodedStringToUnsignedChars(DFA102_maxS);
	static final short[] DFA102_accept = DFA.unpackEncodedString(DFA102_acceptS);
	static final short[] DFA102_special = DFA.unpackEncodedString(DFA102_specialS);
	static final short[][] DFA102_transition;

	static {
		int numStates = DFA102_transitionS.length;
		DFA102_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA102_transition[i] = DFA.unpackEncodedString(DFA102_transitionS[i]);
		}
	}

	protected class DFA102 extends DFA {

		public DFA102(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 102;
			this.eot = DFA102_eot;
			this.eof = DFA102_eof;
			this.min = DFA102_min;
			this.max = DFA102_max;
			this.accept = DFA102_accept;
			this.special = DFA102_special;
			this.transition = DFA102_transition;
		}
		@Override
		public String getDescription() {
			return "()* loopback of 489:64: ( reference_model )*";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA102_2 = input.LA(1);
						 
						int index102_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_2==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 6;}
						else if ( (LA102_2==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 7;}
						 
						input.seek(index102_2);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA102_11 = input.LA(1);
						 
						int index102_11 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_11==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 3;}
						else if ( (LA102_11==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 4;}
						else if ( (LA102_11==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 10;}
						 
						input.seek(index102_11);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA102_3 = input.LA(1);
						 
						int index102_3 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_3==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("main")))) {s = 8;}
						else if ( (LA102_3==SQL92_RESERVED_ON) && ((input.LT(1).getText().equalsIgnoreCase("reference")))) {s = 9;}
						 
						input.seek(index102_3);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA102_0 = input.LA(1);
						 
						int index102_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 1;}
						 
						input.seek(index102_0);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA102_12 = input.LA(1);
						 
						int index102_12 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_12==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 3;}
						else if ( (LA102_12==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 4;}
						else if ( (LA102_12==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 10;}
						 
						input.seek(index102_12);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA102_4 = input.LA(1);
						 
						int index102_4 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_4==REGULAR_ID) && ((input.LT(1).getText().equalsIgnoreCase("main")))) {s = 8;}
						else if ( (LA102_4==SQL92_RESERVED_ON) && ((input.LT(1).getText().equalsIgnoreCase("reference")))) {s = 9;}
						 
						input.seek(index102_4);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA102_6 = input.LA(1);
						 
						int index102_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_6==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 10;}
						else if ( (LA102_6==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 3;}
						else if ( (LA102_6==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 4;}
						 
						input.seek(index102_6);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA102_10 = input.LA(1);
						 
						int index102_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_10==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 11;}
						else if ( (LA102_10==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 12;}
						 
						input.seek(index102_10);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA102_1 = input.LA(1);
						 
						int index102_1 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_1==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 2;}
						else if ( (LA102_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 3;}
						else if ( (LA102_1==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 4;}
						else if ( (LA102_1==SQL92_RESERVED_BY) && (((input.LT(1).getText().equalsIgnoreCase("partition"))||(input.LT(1).getText().equalsIgnoreCase("dimension"))))) {s = 5;}
						 
						input.seek(index102_1);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA102_7 = input.LA(1);
						 
						int index102_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA102_7==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 10;}
						else if ( (LA102_7==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 3;}
						else if ( (LA102_7==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("main"))||(input.LT(1).getText().equalsIgnoreCase("reference"))))) {s = 4;}
						 
						input.seek(index102_7);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 102, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA182_eotS =
		"\14\uffff";
	static final String DFA182_eofS =
		"\1\2\13\uffff";
	static final String DFA182_minS =
		"\1\6\1\27\1\uffff\1\27\2\uffff\3\27\1\uffff\2\27";
	static final String DFA182_maxS =
		"\1\u00ac\1\u009c\1\uffff\1\134\2\uffff\3\134\1\uffff\2\134";
	static final String DFA182_acceptS =
		"\2\uffff\1\2\1\uffff\2\1\3\uffff\1\1\2\uffff";
	static final String DFA182_specialS =
		"\14\uffff}>";
	static final String[] DFA182_transitionS = {
			"\1\2\4\uffff\1\2\3\uffff\3\2\5\uffff\1\2\4\uffff\1\2\10\uffff\1\2\4\uffff"+
			"\1\2\3\uffff\1\2\1\uffff\1\2\6\uffff\1\2\30\uffff\1\2\13\uffff\1\2\3"+
			"\uffff\1\2\4\uffff\1\2\2\uffff\1\2\5\uffff\1\2\4\uffff\2\2\1\uffff\2"+
			"\2\1\uffff\1\2\1\uffff\1\2\2\uffff\2\2\12\uffff\1\1\2\uffff\2\2\6\uffff"+
			"\1\2\3\uffff\1\2\5\uffff\1\2\5\uffff\1\2\1\uffff\1\2\4\uffff\1\2",
			"\1\5\15\uffff\1\3\4\uffff\1\2\61\uffff\1\4\76\uffff\2\2",
			"",
			"\1\7\104\uffff\1\6",
			"",
			"",
			"\1\5\36\uffff\1\10\45\uffff\1\11",
			"\1\5\36\uffff\1\10\45\uffff\1\11",
			"\1\13\104\uffff\1\12",
			"",
			"\1\5\36\uffff\1\10\45\uffff\1\11",
			"\1\5\36\uffff\1\10\45\uffff\1\11"
	};

	static final short[] DFA182_eot = DFA.unpackEncodedString(DFA182_eotS);
	static final short[] DFA182_eof = DFA.unpackEncodedString(DFA182_eofS);
	static final char[] DFA182_min = DFA.unpackEncodedStringToUnsignedChars(DFA182_minS);
	static final char[] DFA182_max = DFA.unpackEncodedStringToUnsignedChars(DFA182_maxS);
	static final short[] DFA182_accept = DFA.unpackEncodedString(DFA182_acceptS);
	static final short[] DFA182_special = DFA.unpackEncodedString(DFA182_specialS);
	static final short[][] DFA182_transition;

	static {
		int numStates = DFA182_transitionS.length;
		DFA182_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA182_transition[i] = DFA.unpackEncodedString(DFA182_transitionS[i]);
		}
	}

	protected class DFA182 extends DFA {

		public DFA182(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 182;
			this.eot = DFA182_eot;
			this.eof = DFA182_eof;
			this.min = DFA182_min;
			this.max = DFA182_max;
			this.accept = DFA182_accept;
			this.special = DFA182_special;
			this.transition = DFA182_transition;
		}
		@Override
		public String getDescription() {
			return "766:9: ( error_logging_into_part )?";
		}
	}

	static final String DFA187_eotS =
		"\105\uffff";
	static final String DFA187_eofS =
		"\1\2\104\uffff";
	static final String DFA187_minS =
		"\1\10\1\0\103\uffff";
	static final String DFA187_maxS =
		"\1\u00ae\1\0\103\uffff";
	static final String DFA187_acceptS =
		"\2\uffff\1\2\101\uffff\1\1";
	static final String DFA187_specialS =
		"\1\uffff\1\0\103\uffff}>";
	static final String[] DFA187_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\1\1\2\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2"+
			"\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\2\2\1\uffff\3\2\6\uffff\1\2",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA187_eot = DFA.unpackEncodedString(DFA187_eotS);
	static final short[] DFA187_eof = DFA.unpackEncodedString(DFA187_eofS);
	static final char[] DFA187_min = DFA.unpackEncodedStringToUnsignedChars(DFA187_minS);
	static final char[] DFA187_max = DFA.unpackEncodedStringToUnsignedChars(DFA187_maxS);
	static final short[] DFA187_accept = DFA.unpackEncodedString(DFA187_acceptS);
	static final short[] DFA187_special = DFA.unpackEncodedString(DFA187_specialS);
	static final short[][] DFA187_transition;

	static {
		int numStates = DFA187_transitionS.length;
		DFA187_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA187_transition[i] = DFA.unpackEncodedString(DFA187_transitionS[i]);
		}
	}

	protected class DFA187 extends DFA {

		public DFA187(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 187;
			this.eot = DFA187_eot;
			this.eof = DFA187_eof;
			this.min = DFA187_min;
			this.max = DFA187_max;
			this.accept = DFA187_accept;
			this.special = DFA187_special;
			this.transition = DFA187_transition;
		}
		@Override
		public String getDescription() {
			return "783:25: ( sample_clause )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA187_1 = input.LA(1);
						 
						int index187_1 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("sample"))) ) {s = 68;}
						else if ( (true) ) {s = 2;}
						 
						input.seek(index187_1);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 187, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA189_eotS =
		"\30\uffff";
	static final String DFA189_eofS =
		"\30\uffff";
	static final String DFA189_minS =
		"\1\13\1\27\1\52\1\0\6\uffff\2\27\1\uffff\1\27\4\0\2\27\4\0";
	static final String DFA189_maxS =
		"\1\u009c\1\134\1\52\1\0\6\uffff\2\u0095\1\uffff\1\134\4\0\2\u0095\4\0";
	static final String DFA189_acceptS =
		"\4\uffff\5\1\1\2\2\uffff\1\3\13\uffff";
	static final String DFA189_specialS =
		"\1\1\1\uffff\1\2\1\4\6\uffff\1\15\1\16\2\uffff\1\11\1\5\1\12\1\6\1\0\1"+
		"\3\1\13\1\7\1\14\1\10}>";
	static final String[] DFA189_transitionS = {
			"\1\7\5\uffff\1\10\5\uffff\1\3\15\uffff\1\1\4\uffff\1\11\61\uffff\1\2"+
			"\32\uffff\1\4\6\uffff\1\5\26\uffff\1\6\5\uffff\2\11",
			"\1\13\104\uffff\1\12",
			"\1\14",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"\1\17\36\uffff\1\15\45\uffff\1\16\32\uffff\1\4\6\uffff\1\5\26\uffff"+
			"\1\6",
			"\1\21\36\uffff\1\15\45\uffff\1\20\32\uffff\1\4\6\uffff\1\5\26\uffff"+
			"\1\6",
			"",
			"\1\23\104\uffff\1\22",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff",
			"\1\25\36\uffff\1\15\45\uffff\1\24\32\uffff\1\4\6\uffff\1\5\26\uffff"+
			"\1\6",
			"\1\27\36\uffff\1\15\45\uffff\1\26\32\uffff\1\4\6\uffff\1\5\26\uffff"+
			"\1\6",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff",
			"\1\uffff"
	};

	static final short[] DFA189_eot = DFA.unpackEncodedString(DFA189_eotS);
	static final short[] DFA189_eof = DFA.unpackEncodedString(DFA189_eofS);
	static final char[] DFA189_min = DFA.unpackEncodedStringToUnsignedChars(DFA189_minS);
	static final char[] DFA189_max = DFA.unpackEncodedStringToUnsignedChars(DFA189_maxS);
	static final short[] DFA189_accept = DFA.unpackEncodedString(DFA189_acceptS);
	static final short[] DFA189_special = DFA.unpackEncodedString(DFA189_specialS);
	static final short[][] DFA189_transition;

	static {
		int numStates = DFA189_transitionS.length;
		DFA189_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA189_transition[i] = DFA.unpackEncodedString(DFA189_transitionS[i]);
		}
	}

	protected class DFA189 extends DFA {

		public DFA189(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 189;
			this.eot = DFA189_eot;
			this.eof = DFA189_eof;
			this.min = DFA189_min;
			this.max = DFA189_max;
			this.accept = DFA189_accept;
			this.special = DFA189_special;
			this.transition = DFA189_transition;
		}
		@Override
		public String getDescription() {
			return "786:1: dml_table_expression_clause : ( ( routine_id ( PERIOD routine_id )* LEFT_PAREN )=> general_element -> ^( TABLE_EXPRESSION general_element ) | dml_table_expression_clause_simple | ( standard_function )=> standard_function -> ^( TABLE_EXPRESSION standard_function ) );";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA189_18 = input.LA(1);
						 
						int index189_18 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_18==REGULAR_ID) ) {s = 20;}
						else if ( (LA189_18==DELIMITED_ID) ) {s = 21;}
						else if ( (LA189_18==SQL92_RESERVED_DELETE) && (synpred21_PLSQL_DMLParser())) {s = 4;}
						else if ( (LA189_18==SQL92_RESERVED_EXISTS) && (synpred21_PLSQL_DMLParser())) {s = 5;}
						else if ( (LA189_18==SQL92_RESERVED_PRIOR) && (synpred21_PLSQL_DMLParser())) {s = 6;}
						else if ( (LA189_18==PERIOD) ) {s = 13;}
						 
						input.seek(index189_18);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA189_0 = input.LA(1);
						 
						int index189_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_0==INTRODUCER) ) {s = 1;}
						else if ( (LA189_0==REGULAR_ID) ) {s = 2;}
						else if ( (LA189_0==DELIMITED_ID) ) {s = 3;}
						else if ( (LA189_0==SQL92_RESERVED_DELETE) && (synpred21_PLSQL_DMLParser())) {s = 4;}
						else if ( (LA189_0==SQL92_RESERVED_EXISTS) && (synpred21_PLSQL_DMLParser())) {s = 5;}
						else if ( (LA189_0==SQL92_RESERVED_PRIOR) && (synpred21_PLSQL_DMLParser())) {s = 6;}
						else if ( (LA189_0==BINDVAR) && (synpred21_PLSQL_DMLParser())) {s = 7;}
						else if ( (LA189_0==COLON) && (synpred21_PLSQL_DMLParser())) {s = 8;}
						else if ( (LA189_0==LEFT_PAREN||(LA189_0 >= SQL92_RESERVED_TABLE && LA189_0 <= SQL92_RESERVED_THE)) ) {s = 9;}
						 
						input.seek(index189_0);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA189_2 = input.LA(1);
						 
						int index189_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_2==LEFT_PAREN) && (synpred22_PLSQL_DMLParser())) {s = 12;}
						else if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_2);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA189_19 = input.LA(1);
						 
						int index189_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_19==REGULAR_ID) ) {s = 22;}
						else if ( (LA189_19==DELIMITED_ID) ) {s = 23;}
						else if ( (LA189_19==SQL92_RESERVED_DELETE) && (synpred21_PLSQL_DMLParser())) {s = 4;}
						else if ( (LA189_19==SQL92_RESERVED_EXISTS) && (synpred21_PLSQL_DMLParser())) {s = 5;}
						else if ( (LA189_19==SQL92_RESERVED_PRIOR) && (synpred21_PLSQL_DMLParser())) {s = 6;}
						else if ( (LA189_19==PERIOD) ) {s = 13;}
						 
						input.seek(index189_19);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA189_3 = input.LA(1);
						 
						int index189_3 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_3);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA189_15 = input.LA(1);
						 
						int index189_15 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_15);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA189_17 = input.LA(1);
						 
						int index189_17 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_17);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA189_21 = input.LA(1);
						 
						int index189_21 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_21);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA189_23 = input.LA(1);
						 
						int index189_23 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_23);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA189_14 = input.LA(1);
						 
						int index189_14 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_14);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA189_16 = input.LA(1);
						 
						int index189_16 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_16);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA189_20 = input.LA(1);
						 
						int index189_20 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_20);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA189_22 = input.LA(1);
						 
						int index189_22 = input.index();
						input.rewind();
						s = -1;
						if ( (synpred21_PLSQL_DMLParser()) ) {s = 8;}
						else if ( (true) ) {s = 9;}
						 
						input.seek(index189_22);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA189_10 = input.LA(1);
						 
						int index189_10 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_10==PERIOD) ) {s = 13;}
						else if ( (LA189_10==REGULAR_ID) ) {s = 14;}
						else if ( (LA189_10==DELIMITED_ID) ) {s = 15;}
						else if ( (LA189_10==SQL92_RESERVED_DELETE) && (synpred21_PLSQL_DMLParser())) {s = 4;}
						else if ( (LA189_10==SQL92_RESERVED_EXISTS) && (synpred21_PLSQL_DMLParser())) {s = 5;}
						else if ( (LA189_10==SQL92_RESERVED_PRIOR) && (synpred21_PLSQL_DMLParser())) {s = 6;}
						 
						input.seek(index189_10);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA189_11 = input.LA(1);
						 
						int index189_11 = input.index();
						input.rewind();
						s = -1;
						if ( (LA189_11==PERIOD) ) {s = 13;}
						else if ( (LA189_11==REGULAR_ID) ) {s = 16;}
						else if ( (LA189_11==DELIMITED_ID) ) {s = 17;}
						else if ( (LA189_11==SQL92_RESERVED_DELETE) && (synpred21_PLSQL_DMLParser())) {s = 4;}
						else if ( (LA189_11==SQL92_RESERVED_EXISTS) && (synpred21_PLSQL_DMLParser())) {s = 5;}
						else if ( (LA189_11==SQL92_RESERVED_PRIOR) && (synpred21_PLSQL_DMLParser())) {s = 6;}
						 
						input.seek(index189_11);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 189, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA197_eotS =
		"\105\uffff";
	static final String DFA197_eofS =
		"\1\2\104\uffff";
	static final String DFA197_minS =
		"\1\10\1\0\103\uffff";
	static final String DFA197_maxS =
		"\1\u00ae\1\0\103\uffff";
	static final String DFA197_acceptS =
		"\2\uffff\1\2\101\uffff\1\1";
	static final String DFA197_specialS =
		"\1\uffff\1\0\103\uffff}>";
	static final String[] DFA197_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\1\1\2\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2"+
			"\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\2\2\1\uffff\3\2\6\uffff\1\2",
			"\1\uffff",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA197_eot = DFA.unpackEncodedString(DFA197_eotS);
	static final short[] DFA197_eof = DFA.unpackEncodedString(DFA197_eofS);
	static final char[] DFA197_min = DFA.unpackEncodedStringToUnsignedChars(DFA197_minS);
	static final char[] DFA197_max = DFA.unpackEncodedStringToUnsignedChars(DFA197_maxS);
	static final short[] DFA197_accept = DFA.unpackEncodedString(DFA197_acceptS);
	static final short[] DFA197_special = DFA.unpackEncodedString(DFA197_specialS);
	static final short[][] DFA197_transition;

	static {
		int numStates = DFA197_transitionS.length;
		DFA197_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA197_transition[i] = DFA.unpackEncodedString(DFA197_transitionS[i]);
		}
	}

	protected class DFA197 extends DFA {

		public DFA197(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 197;
			this.eot = DFA197_eot;
			this.eof = DFA197_eof;
			this.min = DFA197_min;
			this.max = DFA197_max;
			this.accept = DFA197_accept;
			this.special = DFA197_special;
			this.transition = DFA197_transition;
		}
		@Override
		public String getDescription() {
			return "812:9: ( seed_part )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA197_1 = input.LA(1);
						 
						int index197_1 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("seed"))) ) {s = 68;}
						else if ( (true) ) {s = 2;}
						 
						input.seek(index197_1);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 197, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA230_eotS =
		"\103\uffff";
	static final String DFA230_eofS =
		"\1\2\102\uffff";
	static final String DFA230_minS =
		"\1\10\102\uffff";
	static final String DFA230_maxS =
		"\1\u00ae\102\uffff";
	static final String DFA230_acceptS =
		"\1\uffff\1\1\1\2\100\uffff";
	static final String DFA230_specialS =
		"\103\uffff}>";
	static final String[] DFA230_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\1\2\1\1\2\2\1\uffff"+
			"\1\2\1\uffff\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\2\11\uffff"+
			"\2\2\5\uffff\1\2\2\uffff\1\2\13\uffff\3\2\1\uffff\1\2\2\uffff\1\2\3\uffff"+
			"\1\2\1\uffff\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff"+
			"\3\2\2\uffff\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\3\2\6\uffff\1\2",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA230_eot = DFA.unpackEncodedString(DFA230_eotS);
	static final short[] DFA230_eof = DFA.unpackEncodedString(DFA230_eofS);
	static final char[] DFA230_min = DFA.unpackEncodedStringToUnsignedChars(DFA230_minS);
	static final char[] DFA230_max = DFA.unpackEncodedStringToUnsignedChars(DFA230_maxS);
	static final short[] DFA230_accept = DFA.unpackEncodedString(DFA230_acceptS);
	static final short[] DFA230_special = DFA.unpackEncodedString(DFA230_specialS);
	static final short[][] DFA230_transition;

	static {
		int numStates = DFA230_transitionS.length;
		DFA230_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA230_transition[i] = DFA.unpackEncodedString(DFA230_transitionS[i]);
		}
	}

	protected class DFA230 extends DFA {

		public DFA230(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 230;
			this.eot = DFA230_eot;
			this.eof = DFA230_eof;
			this.min = DFA230_min;
			this.max = DFA230_max;
			this.accept = DFA230_accept;
			this.special = DFA230_special;
			this.transition = DFA230_transition;
		}
		@Override
		public String getDescription() {
			return "986:91: ( LEFT_PAREN cn2= concatenation_wrapper RIGHT_PAREN )?";
		}
	}

	static final String DFA267_eotS =
		"\103\uffff";
	static final String DFA267_eofS =
		"\1\2\102\uffff";
	static final String DFA267_minS =
		"\1\10\102\uffff";
	static final String DFA267_maxS =
		"\1\u00ae\102\uffff";
	static final String DFA267_acceptS =
		"\1\uffff\1\1\1\2\100\uffff";
	static final String DFA267_specialS =
		"\103\uffff}>";
	static final String[] DFA267_transitionS = {
			"\1\2\5\uffff\3\2\1\uffff\1\2\2\uffff\1\2\1\uffff\1\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\2\2\3\uffff\1\2\3\uffff\4\2\1\uffff\1\2\1\uffff"+
			"\1\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\2\uffff\1\1\11\uffff\2\2\5\uffff"+
			"\1\2\2\uffff\1\2\13\uffff\3\2\1\uffff\1\2\2\uffff\1\2\3\uffff\1\2\1\uffff"+
			"\2\2\1\uffff\2\2\2\uffff\1\2\5\uffff\3\2\2\uffff\2\2\3\uffff\3\2\2\uffff"+
			"\11\2\2\uffff\1\2\1\uffff\2\2\5\uffff\1\2\3\uffff\2\2\1\uffff\1\2\1\uffff"+
			"\1\2\2\uffff\3\2\6\uffff\1\2",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
	};

	static final short[] DFA267_eot = DFA.unpackEncodedString(DFA267_eotS);
	static final short[] DFA267_eof = DFA.unpackEncodedString(DFA267_eofS);
	static final char[] DFA267_min = DFA.unpackEncodedStringToUnsignedChars(DFA267_minS);
	static final char[] DFA267_max = DFA.unpackEncodedStringToUnsignedChars(DFA267_maxS);
	static final short[] DFA267_accept = DFA.unpackEncodedString(DFA267_acceptS);
	static final short[] DFA267_special = DFA.unpackEncodedString(DFA267_specialS);
	static final short[][] DFA267_transition;

	static {
		int numStates = DFA267_transitionS.length;
		DFA267_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA267_transition[i] = DFA.unpackEncodedString(DFA267_transitionS[i]);
		}
	}

	protected class DFA267 extends DFA {

		public DFA267(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 267;
			this.eot = DFA267_eot;
			this.eof = DFA267_eof;
			this.min = DFA267_min;
			this.max = DFA267_max;
			this.accept = DFA267_accept;
			this.special = DFA267_special;
			this.transition = DFA267_transition;
		}
		@Override
		public String getDescription() {
			return "1130:62: ( using_clause )?";
		}
	}

	static final String DFA303_eotS =
		"\15\uffff";
	static final String DFA303_eofS =
		"\15\uffff";
	static final String DFA303_minS =
		"\1\134\1\6\1\27\2\0\1\uffff\2\27\1\uffff\1\27\1\0\2\27";
	static final String DFA303_maxS =
		"\1\134\1\u00ac\1\134\2\0\1\uffff\2\u0095\1\uffff\1\134\1\0\2\u0095";
	static final String DFA303_acceptS =
		"\5\uffff\1\2\2\uffff\1\1\4\uffff";
	static final String DFA303_specialS =
		"\1\1\1\3\1\7\1\10\1\6\1\uffff\1\0\1\5\1\uffff\1\4\1\2\1\11\1\12}>";
	static final String[] DFA303_transitionS = {
			"\1\1",
			"\1\5\4\uffff\1\5\3\uffff\3\5\5\uffff\1\4\4\uffff\1\5\10\uffff\1\2\4"+
			"\uffff\1\5\3\uffff\1\5\1\uffff\1\5\6\uffff\1\5\30\uffff\1\5\13\uffff"+
			"\1\3\10\uffff\1\5\2\uffff\1\5\5\uffff\1\5\5\uffff\1\5\1\uffff\2\5\1\uffff"+
			"\1\5\4\uffff\2\5\16\uffff\1\5\6\uffff\1\5\11\uffff\1\5\14\uffff\1\5",
			"\1\7\104\uffff\1\6",
			"\1\uffff",
			"\1\uffff",
			"",
			"\1\4\36\uffff\1\11\45\uffff\1\12\32\uffff\1\5\6\uffff\1\5\26\uffff\1"+
			"\5",
			"\1\4\36\uffff\1\11\45\uffff\1\12\32\uffff\1\5\6\uffff\1\5\26\uffff\1"+
			"\5",
			"",
			"\1\14\104\uffff\1\13",
			"\1\uffff",
			"\1\4\36\uffff\1\11\45\uffff\1\12\32\uffff\1\5\6\uffff\1\5\26\uffff\1"+
			"\5",
			"\1\4\36\uffff\1\11\45\uffff\1\12\32\uffff\1\5\6\uffff\1\5\26\uffff\1"+
			"\5"
	};

	static final short[] DFA303_eot = DFA.unpackEncodedString(DFA303_eotS);
	static final short[] DFA303_eof = DFA.unpackEncodedString(DFA303_eofS);
	static final char[] DFA303_min = DFA.unpackEncodedStringToUnsignedChars(DFA303_minS);
	static final char[] DFA303_max = DFA.unpackEncodedStringToUnsignedChars(DFA303_maxS);
	static final short[] DFA303_accept = DFA.unpackEncodedString(DFA303_acceptS);
	static final short[] DFA303_special = DFA.unpackEncodedString(DFA303_specialS);
	static final short[][] DFA303_transition;

	static {
		int numStates = DFA303_transitionS.length;
		DFA303_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA303_transition[i] = DFA.unpackEncodedString(DFA303_transitionS[i]);
		}
	}

	protected class DFA303 extends DFA {

		public DFA303(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 303;
			this.eot = DFA303_eot;
			this.eof = DFA303_eof;
			this.min = DFA303_min;
			this.max = DFA303_max;
			this.accept = DFA303_accept;
			this.special = DFA303_special;
			this.transition = DFA303_transition;
		}
		@Override
		public String getDescription() {
			return "1233:17: ( name_key id | evalname_key concatenation_wrapper )";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA303_6 = input.LA(1);
						 
						int index303_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_6==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 9;}
						else if ( (LA303_6==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 10;}
						else if ( (LA303_6==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 4;}
						else if ( (LA303_6==SQL92_RESERVED_DELETE||LA303_6==SQL92_RESERVED_EXISTS||LA303_6==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {s = 5;}
						 
						input.seek(index303_6);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA303_0 = input.LA(1);
						 
						int index303_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 1;}
						 
						input.seek(index303_0);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA303_10 = input.LA(1);
						 
						int index303_10 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("name"))) ) {s = 8;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("evalname"))) ) {s = 5;}
						 
						input.seek(index303_10);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA303_1 = input.LA(1);
						 
						int index303_1 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_1==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 2;}
						else if ( (LA303_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 3;}
						else if ( (LA303_1==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 4;}
						else if ( (LA303_1==APPROXIMATE_NUM_LIT||LA303_1==BINDVAR||(LA303_1 >= CHAR_STRING && LA303_1 <= COLON)||LA303_1==EXACT_NUM_LIT||LA303_1==LEFT_PAREN||LA303_1==MINUS_SIGN||LA303_1==NATIONAL_CHAR_STRING_LIT||LA303_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA303_1==PLUS_SIGN||LA303_1==SQL92_RESERVED_ALL||LA303_1==SQL92_RESERVED_ANY||LA303_1==SQL92_RESERVED_CASE||LA303_1==SQL92_RESERVED_DATE||(LA303_1 >= SQL92_RESERVED_DEFAULT && LA303_1 <= SQL92_RESERVED_DELETE)||LA303_1==SQL92_RESERVED_DISTINCT||(LA303_1 >= SQL92_RESERVED_EXISTS && LA303_1 <= SQL92_RESERVED_FALSE)||LA303_1==SQL92_RESERVED_NULL||LA303_1==SQL92_RESERVED_PRIOR||LA303_1==SQL92_RESERVED_TRUE||LA303_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {s = 5;}
						 
						input.seek(index303_1);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA303_9 = input.LA(1);
						 
						int index303_9 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_9==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 11;}
						else if ( (LA303_9==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 12;}
						 
						input.seek(index303_9);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA303_7 = input.LA(1);
						 
						int index303_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_7==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 9;}
						else if ( (LA303_7==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 10;}
						else if ( (LA303_7==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 4;}
						else if ( (LA303_7==SQL92_RESERVED_DELETE||LA303_7==SQL92_RESERVED_EXISTS||LA303_7==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {s = 5;}
						 
						input.seek(index303_7);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA303_4 = input.LA(1);
						 
						int index303_4 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("name"))) ) {s = 8;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("evalname"))) ) {s = 5;}
						 
						input.seek(index303_4);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA303_2 = input.LA(1);
						 
						int index303_2 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_2==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 6;}
						else if ( (LA303_2==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 7;}
						 
						input.seek(index303_2);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA303_3 = input.LA(1);
						 
						int index303_3 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("name"))) ) {s = 8;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("evalname"))) ) {s = 5;}
						 
						input.seek(index303_3);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA303_11 = input.LA(1);
						 
						int index303_11 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_11==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 10;}
						else if ( (LA303_11==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 4;}
						else if ( (LA303_11==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 9;}
						else if ( (LA303_11==SQL92_RESERVED_DELETE||LA303_11==SQL92_RESERVED_EXISTS||LA303_11==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {s = 5;}
						 
						input.seek(index303_11);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA303_12 = input.LA(1);
						 
						int index303_12 = input.index();
						input.rewind();
						s = -1;
						if ( (LA303_12==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 10;}
						else if ( (LA303_12==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 4;}
						else if ( (LA303_12==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("evalname"))||(input.LT(1).getText().equalsIgnoreCase("name"))))) {s = 9;}
						else if ( (LA303_12==SQL92_RESERVED_DELETE||LA303_12==SQL92_RESERVED_EXISTS||LA303_12==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("evalname")))) {s = 5;}
						 
						input.seek(index303_12);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 303, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	static final String DFA320_eotS =
		"\24\uffff";
	static final String DFA320_eofS =
		"\24\uffff";
	static final String DFA320_minS =
		"\1\134\1\6\2\uffff\1\6\1\27\2\10\2\0\1\17\1\uffff\2\27\2\0\1\27\1\10\2"+
		"\27";
	static final String DFA320_maxS =
		"\1\136\1\u00ac\2\uffff\1\u00ae\1\134\2\u00ae\2\0\1\u00a7\1\uffff\2\u0095"+
		"\2\0\1\134\1\u00ae\2\u0095";
	static final String DFA320_acceptS =
		"\2\uffff\1\2\1\1\7\uffff\1\2\10\uffff";
	static final String DFA320_specialS =
		"\1\3\1\0\2\uffff\1\1\1\13\1\7\1\4\1\10\1\17\1\14\1\uffff\1\11\1\20\1\6"+
		"\1\5\1\15\1\16\1\12\1\2}>";
	static final String[] DFA320_transitionS = {
			"\1\1\1\uffff\1\2",
			"\1\3\4\uffff\1\3\3\uffff\2\7\1\3\5\uffff\1\6\4\uffff\1\3\10\uffff\1"+
			"\5\4\uffff\1\3\3\uffff\1\3\1\uffff\1\7\6\uffff\1\3\30\uffff\1\3\13\uffff"+
			"\1\4\10\uffff\1\3\2\uffff\1\3\4\uffff\2\3\4\uffff\2\3\1\uffff\2\3\1\uffff"+
			"\1\3\4\uffff\2\3\15\uffff\2\3\6\uffff\1\3\11\uffff\1\3\14\uffff\1\3",
			"",
			"",
			"\1\3\1\uffff\1\3\2\uffff\1\3\2\uffff\5\3\2\uffff\1\3\1\uffff\1\11\3"+
			"\uffff\3\3\2\uffff\2\3\3\uffff\1\3\3\uffff\4\3\1\uffff\1\3\1\uffff\1"+
			"\3\1\uffff\1\3\2\uffff\3\3\30\uffff\1\3\13\uffff\1\10\1\uffff\1\3\4\uffff"+
			"\1\3\1\uffff\1\3\1\uffff\3\3\2\uffff\1\3\1\uffff\1\3\5\uffff\1\12\1\uffff"+
			"\2\3\1\uffff\1\3\4\uffff\2\3\1\uffff\1\13\5\uffff\1\3\3\uffff\4\3\3\uffff"+
			"\1\3\2\uffff\1\3\11\uffff\1\3\14\uffff\1\3\1\uffff\1\3",
			"\1\15\104\uffff\1\14",
			"\1\3\5\uffff\3\3\1\uffff\1\3\2\uffff\1\3\1\uffff\1\17\3\uffff\1\3\1"+
			"\uffff\1\3\2\uffff\2\3\3\uffff\1\3\3\uffff\4\3\1\uffff\1\3\1\uffff\1"+
			"\3\1\uffff\1\3\2\uffff\2\3\31\uffff\1\3\13\uffff\1\16\1\uffff\1\3\4\uffff"+
			"\1\3\3\uffff\1\3\1\uffff\1\3\2\uffff\1\3\7\uffff\1\13\14\uffff\1\13\5"+
			"\uffff\1\3\3\uffff\3\3\4\uffff\1\3\33\uffff\1\3",
			"\1\3\5\uffff\3\3\1\uffff\1\3\2\uffff\1\3\1\uffff\1\17\3\uffff\1\3\1"+
			"\uffff\1\3\2\uffff\2\3\3\uffff\1\3\3\uffff\1\3\1\uffff\2\3\1\uffff\1"+
			"\3\1\uffff\1\3\1\uffff\1\3\2\uffff\1\3\32\uffff\1\3\13\uffff\1\16\1\uffff"+
			"\1\3\4\uffff\1\3\3\uffff\1\3\1\uffff\1\3\2\uffff\1\3\7\uffff\1\13\14"+
			"\uffff\1\13\5\uffff\1\3\3\uffff\3\3\4\uffff\1\3\33\uffff\1\3",
			"\1\uffff",
			"\1\uffff",
			"\2\3\1\uffff\1\13\27\uffff\1\13\5\uffff\1\3\53\uffff\1\13\1\uffff\1"+
			"\13\27\uffff\1\13\60\uffff\1\13",
			"",
			"\1\6\36\uffff\1\20\45\uffff\1\21\32\uffff\1\3\6\uffff\1\3\26\uffff\1"+
			"\3",
			"\1\6\36\uffff\1\20\45\uffff\1\21\32\uffff\1\3\6\uffff\1\3\26\uffff\1"+
			"\3",
			"\1\uffff",
			"\1\uffff",
			"\1\23\104\uffff\1\22",
			"\1\3\5\uffff\3\3\1\uffff\1\3\2\uffff\1\3\1\uffff\1\17\3\uffff\1\3\1"+
			"\uffff\1\3\2\uffff\2\3\3\uffff\1\3\3\uffff\4\3\1\uffff\1\3\1\uffff\1"+
			"\3\1\uffff\1\3\2\uffff\2\3\31\uffff\1\3\13\uffff\1\16\1\uffff\1\3\4\uffff"+
			"\1\3\3\uffff\1\3\1\uffff\1\3\2\uffff\1\3\7\uffff\1\13\14\uffff\1\13\5"+
			"\uffff\1\3\3\uffff\3\3\4\uffff\1\3\33\uffff\1\3",
			"\1\6\36\uffff\1\20\45\uffff\1\21\32\uffff\1\3\6\uffff\1\3\26\uffff\1"+
			"\3",
			"\1\6\36\uffff\1\20\45\uffff\1\21\32\uffff\1\3\6\uffff\1\3\26\uffff\1"+
			"\3"
	};

	static final short[] DFA320_eot = DFA.unpackEncodedString(DFA320_eotS);
	static final short[] DFA320_eof = DFA.unpackEncodedString(DFA320_eofS);
	static final char[] DFA320_min = DFA.unpackEncodedStringToUnsignedChars(DFA320_minS);
	static final char[] DFA320_max = DFA.unpackEncodedStringToUnsignedChars(DFA320_maxS);
	static final short[] DFA320_accept = DFA.unpackEncodedString(DFA320_acceptS);
	static final short[] DFA320_special = DFA.unpackEncodedString(DFA320_specialS);
	static final short[][] DFA320_transition;

	static {
		int numStates = DFA320_transitionS.length;
		DFA320_transition = new short[numStates][];
		for (int i=0; i<numStates; i++) {
			DFA320_transition[i] = DFA.unpackEncodedString(DFA320_transitionS[i]);
		}
	}

	protected class DFA320 extends DFA {

		public DFA320(BaseRecognizer recognizer) {
			this.recognizer = recognizer;
			this.decisionNumber = 320;
			this.eot = DFA320_eot;
			this.eof = DFA320_eof;
			this.min = DFA320_min;
			this.max = DFA320_max;
			this.accept = DFA320_accept;
			this.special = DFA320_special;
			this.transition = DFA320_transition;
		}
		@Override
		public String getDescription() {
			return "1267:17: ( xml_passing_clause )?";
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			TokenStream input = (TokenStream)_input;
			int _s = s;
			switch ( s ) {
					case 0 : 
						int LA320_1 = input.LA(1);
						 
						int index320_1 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_1==APPROXIMATE_NUM_LIT||LA320_1==BINDVAR||LA320_1==COLON||LA320_1==EXACT_NUM_LIT||LA320_1==LEFT_PAREN||LA320_1==MINUS_SIGN||LA320_1==PLSQL_NON_RESERVED_CONNECT_BY_ROOT||LA320_1==PLUS_SIGN||LA320_1==SQL92_RESERVED_ALL||LA320_1==SQL92_RESERVED_ANY||(LA320_1 >= SQL92_RESERVED_BY && LA320_1 <= SQL92_RESERVED_CASE)||(LA320_1 >= SQL92_RESERVED_CURSOR && LA320_1 <= SQL92_RESERVED_DATE)||(LA320_1 >= SQL92_RESERVED_DEFAULT && LA320_1 <= SQL92_RESERVED_DELETE)||LA320_1==SQL92_RESERVED_DISTINCT||(LA320_1 >= SQL92_RESERVED_EXISTS && LA320_1 <= SQL92_RESERVED_FALSE)||(LA320_1 >= SQL92_RESERVED_NOT && LA320_1 <= SQL92_RESERVED_NULL)||LA320_1==SQL92_RESERVED_PRIOR||LA320_1==SQL92_RESERVED_TRUE||LA320_1==UNSIGNED_INTEGER) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_1==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 4;}
						else if ( (LA320_1==INTRODUCER) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 5;}
						else if ( (LA320_1==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 6;}
						else if ( ((LA320_1 >= CHAR_STRING && LA320_1 <= CHAR_STRING_PERL)||LA320_1==NATIONAL_CHAR_STRING_LIT) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 7;}
						 
						input.seek(index320_1);
						if ( s>=0 ) return s;
						break;

					case 1 : 
						int LA320_4 = input.LA(1);
						 
						int index320_4 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_4==APPROXIMATE_NUM_LIT||LA320_4==ASTERISK||LA320_4==BINDVAR||(LA320_4 >= CARRET_OPERATOR_PART && LA320_4 <= COMMA)||LA320_4==CONCATENATION_OP||(LA320_4 >= EQUALS_OP && LA320_4 <= EXCLAMATION_OPERATOR_PART)||(LA320_4 >= GREATER_THAN_OP && LA320_4 <= GREATER_THAN_OR_EQUALS_OP)||LA320_4==INTRODUCER||(LA320_4 >= LEFT_BRACKET && LA320_4 <= LESS_THAN_OR_EQUALS_OP)||LA320_4==MINUS_SIGN||LA320_4==NATIONAL_CHAR_STRING_LIT||LA320_4==NOT_EQUAL_OP||(LA320_4 >= PERCENT && LA320_4 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)||LA320_4==PLUS_SIGN||LA320_4==RIGHT_PAREN||LA320_4==SOLIDUS||LA320_4==SQL92_RESERVED_ALL||(LA320_4 >= SQL92_RESERVED_AND && LA320_4 <= SQL92_RESERVED_AS)||LA320_4==SQL92_RESERVED_BETWEEN||LA320_4==SQL92_RESERVED_CASE||(LA320_4 >= SQL92_RESERVED_DEFAULT && LA320_4 <= SQL92_RESERVED_DELETE)||LA320_4==SQL92_RESERVED_DISTINCT||(LA320_4 >= SQL92_RESERVED_EXISTS && LA320_4 <= SQL92_RESERVED_FALSE)||LA320_4==SQL92_RESERVED_IN||(LA320_4 >= SQL92_RESERVED_IS && LA320_4 <= SQL92_RESERVED_NULL)||LA320_4==SQL92_RESERVED_OR||LA320_4==SQL92_RESERVED_PRIOR||LA320_4==SQL92_RESERVED_TRUE||LA320_4==UNSIGNED_INTEGER||LA320_4==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_4==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 8;}
						else if ( (LA320_4==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 9;}
						else if ( (LA320_4==SQL92_RESERVED_DATE) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 10;}
						else if ( (LA320_4==SQL92_RESERVED_FOR) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {s = 11;}
						 
						input.seek(index320_4);
						if ( s>=0 ) return s;
						break;

					case 2 : 
						int LA320_19 = input.LA(1);
						 
						int index320_19 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_19==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 17;}
						else if ( (LA320_19==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 6;}
						else if ( (LA320_19==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 16;}
						else if ( (LA320_19==SQL92_RESERVED_DELETE||LA320_19==SQL92_RESERVED_EXISTS||LA320_19==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						 
						input.seek(index320_19);
						if ( s>=0 ) return s;
						break;

					case 3 : 
						int LA320_0 = input.LA(1);
						 
						int index320_0 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_0==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 1;}
						else if ( (LA320_0==RIGHT_PAREN) ) {s = 2;}
						 
						input.seek(index320_0);
						if ( s>=0 ) return s;
						break;

					case 4 : 
						int LA320_7 = input.LA(1);
						 
						int index320_7 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_7==ASTERISK||(LA320_7 >= CARRET_OPERATOR_PART && LA320_7 <= CHAR_STRING_PERL)||LA320_7==COMMA||LA320_7==CONCATENATION_OP||LA320_7==EQUALS_OP||LA320_7==EXCLAMATION_OPERATOR_PART||(LA320_7 >= GREATER_THAN_OP && LA320_7 <= GREATER_THAN_OR_EQUALS_OP)||LA320_7==INTRODUCER||LA320_7==LEFT_BRACKET||(LA320_7 >= LESS_THAN_OP && LA320_7 <= LESS_THAN_OR_EQUALS_OP)||LA320_7==MINUS_SIGN||LA320_7==NATIONAL_CHAR_STRING_LIT||LA320_7==NOT_EQUAL_OP||LA320_7==PERCENT||LA320_7==PLUS_SIGN||LA320_7==RIGHT_PAREN||LA320_7==SOLIDUS||LA320_7==SQL92_RESERVED_AND||LA320_7==SQL92_RESERVED_AS||LA320_7==SQL92_RESERVED_BETWEEN||LA320_7==SQL92_RESERVED_IN||(LA320_7 >= SQL92_RESERVED_IS && LA320_7 <= SQL92_RESERVED_NOT)||LA320_7==SQL92_RESERVED_OR||LA320_7==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_7==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 14;}
						else if ( (LA320_7==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 15;}
						else if ( (LA320_7==SQL92_RESERVED_DATE||LA320_7==SQL92_RESERVED_FOR) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {s = 11;}
						 
						input.seek(index320_7);
						if ( s>=0 ) return s;
						break;

					case 5 : 
						int LA320_15 = input.LA(1);
						 
						int index320_15 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("passing"))) ) {s = 3;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("columns"))) ) {s = 11;}
						 
						input.seek(index320_15);
						if ( s>=0 ) return s;
						break;

					case 6 : 
						int LA320_14 = input.LA(1);
						 
						int index320_14 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("passing"))) ) {s = 3;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("columns"))) ) {s = 11;}
						 
						input.seek(index320_14);
						if ( s>=0 ) return s;
						break;

					case 7 : 
						int LA320_6 = input.LA(1);
						 
						int index320_6 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_6==ASTERISK||(LA320_6 >= CARRET_OPERATOR_PART && LA320_6 <= CHAR_STRING_PERL)||LA320_6==COMMA||LA320_6==CONCATENATION_OP||LA320_6==EQUALS_OP||LA320_6==EXCLAMATION_OPERATOR_PART||(LA320_6 >= GREATER_THAN_OP && LA320_6 <= GREATER_THAN_OR_EQUALS_OP)||LA320_6==INTRODUCER||(LA320_6 >= LEFT_BRACKET && LA320_6 <= LESS_THAN_OR_EQUALS_OP)||LA320_6==MINUS_SIGN||LA320_6==NATIONAL_CHAR_STRING_LIT||LA320_6==NOT_EQUAL_OP||(LA320_6 >= PERCENT && LA320_6 <= PERIOD)||LA320_6==PLUS_SIGN||LA320_6==RIGHT_PAREN||LA320_6==SOLIDUS||LA320_6==SQL92_RESERVED_AND||LA320_6==SQL92_RESERVED_AS||LA320_6==SQL92_RESERVED_BETWEEN||LA320_6==SQL92_RESERVED_IN||(LA320_6 >= SQL92_RESERVED_IS && LA320_6 <= SQL92_RESERVED_NOT)||LA320_6==SQL92_RESERVED_OR||LA320_6==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_6==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 14;}
						else if ( (LA320_6==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 15;}
						else if ( (LA320_6==SQL92_RESERVED_DATE||LA320_6==SQL92_RESERVED_FOR) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {s = 11;}
						 
						input.seek(index320_6);
						if ( s>=0 ) return s;
						break;

					case 8 : 
						int LA320_8 = input.LA(1);
						 
						int index320_8 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("passing"))) ) {s = 3;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("columns"))) ) {s = 11;}
						 
						input.seek(index320_8);
						if ( s>=0 ) return s;
						break;

					case 9 : 
						int LA320_12 = input.LA(1);
						 
						int index320_12 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_12==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 16;}
						else if ( (LA320_12==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 17;}
						else if ( (LA320_12==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 6;}
						else if ( (LA320_12==SQL92_RESERVED_DELETE||LA320_12==SQL92_RESERVED_EXISTS||LA320_12==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						 
						input.seek(index320_12);
						if ( s>=0 ) return s;
						break;

					case 10 : 
						int LA320_18 = input.LA(1);
						 
						int index320_18 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_18==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 17;}
						else if ( (LA320_18==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 6;}
						else if ( (LA320_18==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 16;}
						else if ( (LA320_18==SQL92_RESERVED_DELETE||LA320_18==SQL92_RESERVED_EXISTS||LA320_18==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						 
						input.seek(index320_18);
						if ( s>=0 ) return s;
						break;

					case 11 : 
						int LA320_5 = input.LA(1);
						 
						int index320_5 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_5==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 12;}
						else if ( (LA320_5==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 13;}
						 
						input.seek(index320_5);
						if ( s>=0 ) return s;
						break;

					case 12 : 
						int LA320_10 = input.LA(1);
						 
						int index320_10 = input.index();
						input.rewind();
						s = -1;
						if ( ((LA320_10 >= CHAR_STRING && LA320_10 <= CHAR_STRING_PERL)||LA320_10==NATIONAL_CHAR_STRING_LIT) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_10==COMMA||LA320_10==LEFT_PAREN||LA320_10==REGULAR_ID||LA320_10==RIGHT_PAREN||LA320_10==SQL92_RESERVED_DEFAULT||LA320_10==SQL92_RESERVED_WITH) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {s = 11;}
						 
						input.seek(index320_10);
						if ( s>=0 ) return s;
						break;

					case 13 : 
						int LA320_16 = input.LA(1);
						 
						int index320_16 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_16==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 18;}
						else if ( (LA320_16==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 19;}
						 
						input.seek(index320_16);
						if ( s>=0 ) return s;
						break;

					case 14 : 
						int LA320_17 = input.LA(1);
						 
						int index320_17 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_17==ASTERISK||(LA320_17 >= CARRET_OPERATOR_PART && LA320_17 <= CHAR_STRING_PERL)||LA320_17==COMMA||LA320_17==CONCATENATION_OP||LA320_17==EQUALS_OP||LA320_17==EXCLAMATION_OPERATOR_PART||(LA320_17 >= GREATER_THAN_OP && LA320_17 <= GREATER_THAN_OR_EQUALS_OP)||LA320_17==INTRODUCER||(LA320_17 >= LEFT_BRACKET && LA320_17 <= LESS_THAN_OR_EQUALS_OP)||LA320_17==MINUS_SIGN||LA320_17==NATIONAL_CHAR_STRING_LIT||LA320_17==NOT_EQUAL_OP||(LA320_17 >= PERCENT && LA320_17 <= PERIOD)||LA320_17==PLUS_SIGN||LA320_17==RIGHT_PAREN||LA320_17==SOLIDUS||LA320_17==SQL92_RESERVED_AND||LA320_17==SQL92_RESERVED_AS||LA320_17==SQL92_RESERVED_BETWEEN||LA320_17==SQL92_RESERVED_IN||(LA320_17 >= SQL92_RESERVED_IS && LA320_17 <= SQL92_RESERVED_NOT)||LA320_17==SQL92_RESERVED_OR||LA320_17==VERTICAL_BAR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						else if ( (LA320_17==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 14;}
						else if ( (LA320_17==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 15;}
						else if ( (LA320_17==SQL92_RESERVED_DATE||LA320_17==SQL92_RESERVED_FOR) && ((input.LT(1).getText().equalsIgnoreCase("columns")))) {s = 11;}
						 
						input.seek(index320_17);
						if ( s>=0 ) return s;
						break;

					case 15 : 
						int LA320_9 = input.LA(1);
						 
						int index320_9 = input.index();
						input.rewind();
						s = -1;
						if ( ((input.LT(1).getText().equalsIgnoreCase("passing"))) ) {s = 3;}
						else if ( ((input.LT(1).getText().equalsIgnoreCase("columns"))) ) {s = 11;}
						 
						input.seek(index320_9);
						if ( s>=0 ) return s;
						break;

					case 16 : 
						int LA320_13 = input.LA(1);
						 
						int index320_13 = input.index();
						input.rewind();
						s = -1;
						if ( (LA320_13==PERIOD) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 16;}
						else if ( (LA320_13==REGULAR_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 17;}
						else if ( (LA320_13==DELIMITED_ID) && (((input.LT(1).getText().equalsIgnoreCase("columns"))||(input.LT(1).getText().equalsIgnoreCase("passing"))))) {s = 6;}
						else if ( (LA320_13==SQL92_RESERVED_DELETE||LA320_13==SQL92_RESERVED_EXISTS||LA320_13==SQL92_RESERVED_PRIOR) && ((input.LT(1).getText().equalsIgnoreCase("passing")))) {s = 3;}
						 
						input.seek(index320_13);
						if ( s>=0 ) return s;
						break;
			}
			if (state.backtracking>0) {state.failed=true; return -1;}
			NoViableAltException nvae =
				new NoViableAltException(getDescription(), 320, _s, input);
			error(nvae);
			throw nvae;
		}
	}

	public static final BitSet FOLLOW_explain_key_in_explain_statement712 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_plan_key_in_explain_statement714 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x0000000000000402L});
	public static final BitSet FOLLOW_set_key_in_explain_statement726 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_statement_id_key_in_explain_statement728 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_explain_statement730 = new BitSet(new long[]{0x0001000000018000L});
	public static final BitSet FOLLOW_quoted_string_in_explain_statement732 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000402L});
	public static final BitSet FOLLOW_into_key_in_explain_statement746 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_tableview_name_in_explain_statement748 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_explain_statement761 = new BitSet(new long[]{0x0000040000000000L,0x0080000010000000L,0x0000008402000100L});
	public static final BitSet FOLLOW_select_statement_in_explain_statement774 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_update_statement_in_explain_statement787 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_delete_statement_in_explain_statement800 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_insert_statement_in_explain_statement813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_merge_statement_in_explain_statement826 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subquery_factoring_clause_in_select_statement886 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_select_statement897 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000080002L});
	public static final BitSet FOLLOW_order_by_clause_in_select_statement907 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_for_update_clause_in_select_statement918 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_subquery_factoring_clause967 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_recursive_key_in_subquery_factoring_clause970 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_factoring_element_in_subquery_factoring_clause973 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_subquery_factoring_clause976 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_factoring_element_in_subquery_factoring_clause979 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_query_name_in_factoring_element1001 = new BitSet(new long[]{0x0000040000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_factoring_element1013 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_factoring_element1017 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_factoring_element1020 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_factoring_element1024 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_factoring_element1028 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_as_key_in_factoring_element1041 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_factoring_element1043 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_factoring_element1045 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_by_clause_in_factoring_element1047 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_factoring_element1050 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_search_clause_in_factoring_element1061 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_cycle_clause_in_factoring_element1073 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_search_key_in_search_clause1125 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_depth_key_in_search_clause1129 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_breadth_key_in_search_clause1133 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_first_key_in_search_clause1137 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_search_clause1139 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_search_clause1154 = new BitSet(new long[]{0x0000000000040000L,0x0100040010000000L});
	public static final BitSet FOLLOW_asc_key_in_search_clause1156 = new BitSet(new long[]{0x0000000000040000L,0x0100000010000000L});
	public static final BitSet FOLLOW_desc_key_in_search_clause1160 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_search_clause1165 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_first_key_in_search_clause1167 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_search_clause1172 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_last_key_in_search_clause1174 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_COMMA_in_search_clause1192 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_search_clause1195 = new BitSet(new long[]{0x0000000000040000L,0x0100040010000000L});
	public static final BitSet FOLLOW_asc_key_in_search_clause1197 = new BitSet(new long[]{0x0000000000040000L,0x0100000010000000L});
	public static final BitSet FOLLOW_desc_key_in_search_clause1201 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_search_clause1206 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_first_key_in_search_clause1208 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_search_clause1213 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_last_key_in_search_clause1215 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_set_key_in_search_clause1235 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_search_clause1237 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cycle_key_in_cycle_clause1257 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_cycle_clause1259 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_COMMA_in_cycle_clause1263 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_cycle_clause1265 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L});
	public static final BitSet FOLLOW_set_key_in_cycle_clause1269 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_cycle_clause1271 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_to_key_in_cycle_clause1273 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_cycle_clause1275 = new BitSet(new long[]{0x0000000000000000L,0x0040000000000000L});
	public static final BitSet FOLLOW_default_key_in_cycle_clause1277 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_cycle_clause1279 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_subquery_basic_elements_in_subquery1299 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_subquery_operation_part_in_subquery1301 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_union_key_in_subquery_operation_part1342 = new BitSet(new long[]{0x0000040000000000L,0x0000002000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_all_key_in_subquery_operation_part1345 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_intersect_key_in_subquery_operation_part1348 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_minus_key_in_subquery_operation_part1351 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_basic_elements_in_subquery_operation_part1355 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_query_block_in_subquery_basic_elements1375 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_subquery_basic_elements1386 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_subquery_basic_elements1389 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_subquery_basic_elements1391 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_select_key_in_query_block1420 = new BitSet(new long[]{0x0081442010838940L,0xC2D8412010010000L,0x0000100280206000L});
	public static final BitSet FOLLOW_distinct_key_in_query_block1441 = new BitSet(new long[]{0x0081442010838940L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_unique_key_in_query_block1443 = new BitSet(new long[]{0x0081442010838940L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_all_key_in_query_block1445 = new BitSet(new long[]{0x0081442010838940L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_ASTERISK_in_query_block1459 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x0000000000000404L});
	public static final BitSet FOLLOW_selected_element_in_query_block1464 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L,0x0000000000000404L});
	public static final BitSet FOLLOW_COMMA_in_query_block1467 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_selected_element_in_query_block1469 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L,0x0000000000000404L});
	public static final BitSet FOLLOW_into_clause_in_query_block1482 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_from_clause_in_query_block1493 = new BitSet(new long[]{0x0200000000000002L,0x0001000000002000L,0x0000004000000060L});
	public static final BitSet FOLLOW_where_clause_in_query_block1504 = new BitSet(new long[]{0x0200000000000002L,0x0001000000002000L,0x0000000000000060L});
	public static final BitSet FOLLOW_hierarchical_query_clause_in_query_block1516 = new BitSet(new long[]{0x0200000000000002L,0x0000000000000000L,0x0000000000000060L});
	public static final BitSet FOLLOW_group_by_clause_in_query_block1528 = new BitSet(new long[]{0x0200000000000002L});
	public static final BitSet FOLLOW_model_clause_in_query_block1539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_select_list_elements_in_selected_element1683 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_selected_element1685 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_from_key_in_from_clause1725 = new BitSet(new long[]{0x0000042000820800L,0x4080000010000000L,0x0000000018200000L});
	public static final BitSet FOLLOW_table_ref_list_in_from_clause1728 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tableview_name_in_select_list_elements1757 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_PERIOD_in_select_list_elements1759 = new BitSet(new long[]{0x0000000000000100L});
	public static final BitSet FOLLOW_ASTERISK_in_select_list_elements1761 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_select_list_elements1787 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_table_ref_in_table_ref_list1815 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_table_ref_list1818 = new BitSet(new long[]{0x0000042000820800L,0x4080000010000000L,0x0000000018200000L});
	public static final BitSet FOLLOW_table_ref_in_table_ref_list1821 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_table_ref_aux_in_table_ref1847 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_join_clause_in_table_ref1849 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_pivot_clause_in_table_ref1853 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unpivot_clause_in_table_ref1855 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dml_table_expression_clause_in_table_ref_aux1920 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_pivot_clause_in_table_ref_aux1932 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_unpivot_clause_in_table_ref_aux1934 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_table_ref_aux1953 = new BitSet(new long[]{0x0000042000820800L,0x4080000010000000L,0x0000000018200000L});
	public static final BitSet FOLLOW_table_ref_in_table_ref_aux1955 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_subquery_operation_part_in_table_ref_aux1957 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_table_ref_aux1960 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_pivot_clause_in_table_ref_aux1972 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_unpivot_clause_in_table_ref_aux1974 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_only_key_in_table_ref_aux1995 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_table_ref_aux1997 = new BitSet(new long[]{0x0000042000820800L,0x4080000010000000L,0x0000000018200000L});
	public static final BitSet FOLLOW_dml_table_expression_clause_in_table_ref_aux1999 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_table_ref_aux2001 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_dml_table_expression_clause_in_table_ref_aux2012 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_pivot_clause_in_table_ref_aux2024 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_unpivot_clause_in_table_ref_aux2026 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_flashback_query_clause_in_table_ref_aux2044 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_table_alias_in_table_ref_aux2058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_query_partition_clause_in_join_clause2120 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_cross_key_in_join_clause2132 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_natural_key_in_join_clause2134 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_inner_key_in_join_clause2139 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_outer_join_type_in_join_clause2141 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_join_key_in_join_clause2145 = new BitSet(new long[]{0x0000042000820800L,0x4080000010000000L,0x0000000018200000L});
	public static final BitSet FOLLOW_table_ref_aux_in_join_clause2155 = new BitSet(new long[]{0x1000000000000000L,0x0000000010000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_query_partition_clause_in_join_clause2167 = new BitSet(new long[]{0x1000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_join_on_part_in_join_clause2183 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_join_using_part_in_join_clause2198 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_on_key_in_join_on_part2271 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_join_on_part2273 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_using_key_in_join_using_part2314 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_join_using_part2317 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_join_using_part2320 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_join_using_part2323 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_join_using_part2326 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_join_using_part2330 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_full_key_in_outer_join_type2361 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_left_key_in_outer_join_type2372 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_right_key_in_outer_join_type2383 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_outer_key_in_outer_join_type2399 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_partition_key_in_query_partition_clause2421 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_query_partition_clause2424 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_query_partition_clause_spec_in_query_partition_clause2427 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_query_partition_clause_spec2462 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_query_partition_clause_spec2465 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_query_partition_clause_spec2467 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_list_in_query_partition_clause_spec2484 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_query_partition_clause_spec2495 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_query_partition_clause_spec2498 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_query_partition_clause_spec2500 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_versions_key_in_flashback_query_clause2531 = new BitSet(new long[]{0x0000000000000000L,0x0000100000000000L});
	public static final BitSet FOLLOW_between_key_in_flashback_query_clause2533 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_scn_key_in_flashback_query_clause2536 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_timestamp_key_in_flashback_query_clause2538 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_flashback_query_clause2541 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_as_key_in_flashback_query_clause2571 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000008000L});
	public static final BitSet FOLLOW_of_key_in_flashback_query_clause2573 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_scn_key_in_flashback_query_clause2576 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_timestamp_key_in_flashback_query_clause2578 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_snapshot_key_in_flashback_query_clause2580 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_flashback_query_clause2583 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_pivot_key_in_pivot_clause2623 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xml_key_in_pivot_clause2625 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_pivot_clause2636 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_pivot_element_in_pivot_clause2650 = new BitSet(new long[]{0x0000000000040000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_pivot_clause2653 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_pivot_element_in_pivot_clause2655 = new BitSet(new long[]{0x0000000000040000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_pivot_for_clause_in_pivot_clause2671 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000080L});
	public static final BitSet FOLLOW_pivot_in_clause_in_pivot_clause2685 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_pivot_clause2697 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_aggregate_function_name_in_pivot_element2741 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_pivot_element2743 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_pivot_element2745 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_pivot_element2747 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_pivot_element2749 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_pivot_for_clause2811 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_pivot_for_clause2823 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_pivot_for_clause2834 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_pivot_for_clause2836 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_pivot_for_clause2839 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_pivot_for_clause2841 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_pivot_for_clause2845 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_in_key_in_pivot_in_clause2896 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_pivot_in_clause2906 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100082206000L});
	public static final BitSet FOLLOW_subquery_in_pivot_in_clause2930 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_any_key_in_pivot_in_clause2956 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_pivot_in_clause2959 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});
	public static final BitSet FOLLOW_any_key_in_pivot_in_clause2961 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_pivot_in_clause_element_in_pivot_in_clause2984 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_pivot_in_clause2987 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_pivot_in_clause_element_in_pivot_in_clause2989 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_pivot_in_clause3015 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element3095 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_pivot_in_clause_element3097 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_pivot_in_clause_elements3137 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_list_in_pivot_in_clause_elements3161 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unpivot_key_in_unpivot_clause3181 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_include_key_in_unpivot_clause3194 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_exclude_key_in_unpivot_clause3196 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_unpivot_clause3199 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_unpivot_clause3211 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_unpivot_clause3230 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_unpivot_clause3249 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_unpivot_clause3251 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_unpivot_clause3254 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_unpivot_clause3256 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_unpivot_clause3260 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_pivot_for_clause_in_unpivot_clause3288 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000080L});
	public static final BitSet FOLLOW_unpivot_in_clause_in_unpivot_clause3302 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_unpivot_clause3312 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_in_key_in_unpivot_in_clause3362 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_unpivot_in_clause3372 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_unpivot_in_elements_in_unpivot_in_clause3386 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_unpivot_in_clause3389 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_unpivot_in_elements_in_unpivot_in_clause3391 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_unpivot_in_clause3403 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_column_name_in_unpivot_in_elements3448 = new BitSet(new long[]{0x0001440010018042L,0x8050020010000000L,0x0000100080004000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_unpivot_in_elements3463 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_unpivot_in_elements3465 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_unpivot_in_elements3468 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_unpivot_in_elements3470 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3474 = new BitSet(new long[]{0x0001440010018042L,0x8050020010000000L,0x0000100080004000L});
	public static final BitSet FOLLOW_as_key_in_unpivot_in_elements3499 = new BitSet(new long[]{0x0001440010018040L,0x8050000010000000L,0x0000100080004000L});
	public static final BitSet FOLLOW_constant_in_unpivot_in_elements3515 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_unpivot_in_elements3535 = new BitSet(new long[]{0x0001400010018040L,0x8050000010000000L,0x0000100080004000L});
	public static final BitSet FOLLOW_constant_in_unpivot_in_elements3537 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_unpivot_in_elements3540 = new BitSet(new long[]{0x0001400010018040L,0x8050000010000000L,0x0000100080004000L});
	public static final BitSet FOLLOW_constant_in_unpivot_in_elements3542 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_unpivot_in_elements3546 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_connect_key_in_hierarchical_query_clause3607 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_hierarchical_query_clause3609 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_nocycle_key_in_hierarchical_query_clause3611 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_hierarchical_query_clause3614 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});
	public static final BitSet FOLLOW_start_part_in_hierarchical_query_clause3616 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_start_part_in_hierarchical_query_clause3658 = new BitSet(new long[]{0x0000000000000000L,0x0001000000000000L});
	public static final BitSet FOLLOW_connect_key_in_hierarchical_query_clause3660 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_hierarchical_query_clause3662 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_nocycle_key_in_hierarchical_query_clause3664 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_hierarchical_query_clause3667 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_start_key_in_start_part3716 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_with_key_in_start_part3718 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_start_part3720 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_group_key_in_group_by_clause3766 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_group_by_clause3768 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_group_by_clause3770 = new BitSet(new long[]{0x0000000000040002L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_COMMA_in_group_by_clause3780 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_group_by_clause3782 = new BitSet(new long[]{0x0000000000040002L,0x0000000000000000L,0x0000000000000040L});
	public static final BitSet FOLLOW_having_clause_in_group_by_clause3786 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_having_clause_in_group_by_clause3829 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_group_key_in_group_by_clause3832 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_group_by_clause3834 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_group_by_clause3836 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_group_by_clause3846 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_group_by_clause3848 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_grouping_sets_clause_in_group_by_elements3896 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rollup_cube_clause_in_group_by_elements3907 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_group_by_elements3919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rollup_key_in_rollup_cube_clause3948 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_cube_key_in_rollup_cube_clause3951 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_rollup_cube_clause3955 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_grouping_sets_elements_in_rollup_cube_clause3958 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_rollup_cube_clause3961 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_grouping_sets_elements_in_rollup_cube_clause3964 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_rollup_cube_clause3968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_grouping_key_in_grouping_sets_clause3990 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_sets_key_in_grouping_sets_clause3992 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_grouping_sets_clause4003 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_grouping_sets_elements_in_grouping_sets_clause4005 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_grouping_sets_clause4008 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_grouping_sets_elements_in_grouping_sets_clause4010 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_grouping_sets_clause4014 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rollup_cube_clause_in_grouping_sets_elements4062 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_list_in_grouping_sets_elements4078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_grouping_sets_elements4089 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_having_key_in_having_clause4117 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_having_clause4119 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_model_key_in_model_clause4159 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_cell_reference_options_in_model_clause4161 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_return_rows_clause_in_model_clause4164 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_reference_model_in_model_clause4167 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_main_model_in_model_clause4170 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ignore_key_in_cell_reference_options4216 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_keep_key_in_cell_reference_options4219 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nav_key_in_cell_reference_options4223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_key_in_cell_reference_options4234 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_dimension_key_in_cell_reference_options4238 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_single_key_in_cell_reference_options4240 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_reference_key_in_cell_reference_options4242 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_return_key_in_return_rows_clause4265 = new BitSet(new long[]{0x0000000000000000L,0x0000002010000000L});
	public static final BitSet FOLLOW_updated_key_in_return_rows_clause4269 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_all_key_in_return_rows_clause4271 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_rows_key_in_return_rows_clause4274 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_reference_key_in_reference_model4295 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_reference_model_name_in_reference_model4298 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_on_key_in_reference_model4300 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_reference_model4316 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_reference_model4319 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_reference_model4321 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_model_column_clauses_in_reference_model4324 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_cell_reference_options_in_reference_model4339 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_main_key_in_main_model4361 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_main_model_name_in_main_model4363 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_model_column_clauses_in_main_model4367 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_cell_reference_options_in_main_model4369 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L,0x0000000200000000L});
	public static final BitSet FOLLOW_model_rules_clause_in_main_model4372 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_model_column_partition_part_in_model_column_clauses4416 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_dimension_key_in_model_column_clauses4427 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_model_column_clauses4429 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_model_column_list_in_model_column_clauses4431 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_measures_key_in_model_column_clauses4433 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_model_column_list_in_model_column_clauses4435 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_partition_key_in_model_column_partition_part4484 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_model_column_partition_part4487 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_model_column_list_in_model_column_partition_part4490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_model_column_list4510 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_model_column_in_model_column_list4512 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_model_column_list4515 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_model_column_in_model_column_list4517 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_model_column_list4522 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_model_column4559 = new BitSet(new long[]{0x0001002000818002L,0x0000000010000000L});
	public static final BitSet FOLLOW_table_alias_in_model_column4561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_model_rules_part_in_model_rules_clause4605 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_model_rules_clause4608 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100480204000L});
	public static final BitSet FOLLOW_model_rules_element_in_model_rules_clause4610 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_model_rules_clause4613 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100480204000L});
	public static final BitSet FOLLOW_model_rules_element_in_model_rules_clause4615 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_model_rules_clause4619 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rules_key_in_model_rules_part4659 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_update_key_in_model_rules_part4662 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_upsert_key_in_model_rules_part4664 = new BitSet(new long[]{0x0000000000000002L,0x0000002010000000L});
	public static final BitSet FOLLOW_all_key_in_model_rules_part4666 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_automatic_key_in_model_rules_part4673 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_sequential_key_in_model_rules_part4675 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_key_in_model_rules_part4678 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_model_iterate_clause_in_model_rules_part4682 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_update_key_in_model_rules_element4736 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_upsert_key_in_model_rules_element4738 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_all_key_in_model_rules_element4746 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_cell_assignment_in_model_rules_element4760 = new BitSet(new long[]{0x0000000008000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_by_clause_in_model_rules_element4778 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_model_rules_element4793 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_model_rules_element4795 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_model_expression_in_cell_assignment4854 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_iterate_key_in_model_iterate_clause4874 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_model_iterate_clause4876 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_model_iterate_clause4878 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_model_iterate_clause4880 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_until_part_in_model_iterate_clause4882 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_until_key_in_until_part4925 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_until_part4927 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_until_part4929 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_until_part4931 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_order_key_in_order_by_clause4971 = new BitSet(new long[]{0x0000000000000000L,0x0000200010000000L});
	public static final BitSet FOLLOW_siblings_key_in_order_by_clause4973 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_order_by_clause4976 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_order_by_elements_in_order_by_clause4978 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_order_by_clause4981 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_order_by_elements_in_order_by_clause4983 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_expression_in_order_by_elements5029 = new BitSet(new long[]{0x0000000000000002L,0x0100040010000000L});
	public static final BitSet FOLLOW_asc_key_in_order_by_elements5032 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_desc_key_in_order_by_elements5034 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_order_by_elements5039 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_first_key_in_order_by_elements5042 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_last_key_in_order_by_elements5044 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_for_update_clause5102 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_update_key_in_for_update_clause5104 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000400L,0x0000000000008000L});
	public static final BitSet FOLLOW_for_update_of_part_in_for_update_clause5106 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000400L});
	public static final BitSet FOLLOW_for_update_options_in_for_update_clause5109 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_of_key_in_for_update_of_part5150 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_for_update_of_part5153 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_for_update_of_part5156 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_for_update_of_part5159 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_skip_key_in_for_update_options5181 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_locked_key_in_for_update_options5183 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_nowait_key_in_for_update_options5195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wait_key_in_for_update_options5206 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_for_update_options5208 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_update_key_in_update_statement5242 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L,0x0000000018000000L});
	public static final BitSet FOLLOW_general_table_ref_in_update_statement5245 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_update_set_clause_in_update_statement5255 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_where_clause_in_update_statement5265 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_static_returning_clause_in_update_statement5268 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_clause_in_update_statement5271 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_set_key_in_update_set_clause5301 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_based_update_set_clause_in_update_set_clause5312 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_update_set_clause5315 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_based_update_set_clause_in_update_set_clause5317 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_value_key_in_update_set_clause5332 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_update_set_clause5334 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_id_in_update_set_clause5336 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_update_set_clause5338 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_update_set_clause5340 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_update_set_clause5342 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_column_name_in_column_based_update_set_clause5412 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_column_based_update_set_clause5414 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_column_based_update_set_clause5416 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_column_based_update_set_clause5442 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_column_based_update_set_clause5444 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_column_based_update_set_clause5447 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_column_based_update_set_clause5449 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause5453 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_column_based_update_set_clause5455 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_column_based_update_set_clause5457 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_delete_key_in_delete_statement5491 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L,0x0000000018000004L});
	public static final BitSet FOLLOW_from_key_in_delete_statement5494 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L,0x0000000018000000L});
	public static final BitSet FOLLOW_general_table_ref_in_delete_statement5506 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_where_clause_in_delete_statement5516 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_static_returning_clause_in_delete_statement5519 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_clause_in_delete_statement5522 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_insert_key_in_insert_statement5543 = new BitSet(new long[]{0x0000000000000000L,0x0000002010000000L,0x0000002000000400L});
	public static final BitSet FOLLOW_single_table_insert_in_insert_statement5555 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_multi_table_insert_in_insert_statement5566 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_insert_into_clause_in_single_table_insert5594 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008802000000L});
	public static final BitSet FOLLOW_values_clause_in_single_table_insert5605 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_static_returning_clause_in_single_table_insert5607 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_select_statement_in_single_table_insert5619 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_clause_in_single_table_insert5635 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_multi_table_insert5694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_multi_table_element_in_multi_table_insert5696 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008002000400L});
	public static final BitSet FOLLOW_conditional_insert_clause_in_multi_table_insert5708 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_statement_in_multi_table_insert5724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_insert_into_clause_in_multi_table_element5766 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_values_clause_in_multi_table_element5768 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_clause_in_multi_table_element5771 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_conditional_insert_clause5815 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_first_key_in_conditional_insert_clause5817 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_conditional_insert_when_part_in_conditional_insert_clause5829 = new BitSet(new long[]{0x0000000000000002L,0x0800000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_conditional_insert_else_part_in_conditional_insert_clause5832 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_key_in_conditional_insert_when_part5880 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_conditional_insert_when_part5882 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_then_key_in_conditional_insert_when_part5884 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_multi_table_element_in_conditional_insert_when_part5886 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_else_key_in_conditional_insert_else_part5930 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_multi_table_element_in_conditional_insert_else_part5933 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_into_key_in_insert_into_clause5954 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L,0x0000000018000000L});
	public static final BitSet FOLLOW_general_table_ref_in_insert_into_clause5956 = new BitSet(new long[]{0x0000040000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_insert_into_clause5968 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_insert_into_clause5970 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_insert_into_clause5973 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_insert_into_clause5975 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_insert_into_clause5979 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_values_key_in_values_clause6024 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_list_in_values_clause6028 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_values_clause6032 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_merge_key_in_merge_statement6054 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_into_key_in_merge_statement6056 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_tableview_name_in_merge_statement6058 = new BitSet(new long[]{0x1001002000818000L,0x0000000010000000L});
	public static final BitSet FOLLOW_table_alias_in_merge_statement6060 = new BitSet(new long[]{0x1000000000000000L});
	public static final BitSet FOLLOW_using_key_in_merge_statement6071 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_selected_tableview_in_merge_statement6073 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_on_key_in_merge_statement6075 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_merge_statement6077 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_in_merge_statement6079 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_merge_statement6081 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_merge_update_clause_in_merge_statement6091 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_merge_insert_clause_in_merge_statement6094 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_clause_in_merge_statement6105 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_key_in_merge_update_clause6185 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_matched_key_in_merge_update_clause6187 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_then_key_in_merge_update_clause6189 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_update_key_in_merge_update_clause6191 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_set_key_in_merge_update_clause6193 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_merge_element_in_merge_update_clause6204 = new BitSet(new long[]{0x0000000000040002L,0x0080000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_COMMA_in_merge_update_clause6207 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_merge_element_in_merge_update_clause6209 = new BitSet(new long[]{0x0000000000040002L,0x0080000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_where_clause_in_merge_update_clause6221 = new BitSet(new long[]{0x0000000000000002L,0x0080000000000000L});
	public static final BitSet FOLLOW_merge_update_delete_part_in_merge_update_clause6224 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_column_name_in_merge_element6267 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_merge_element6269 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_merge_element6271 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_delete_key_in_merge_update_delete_part6314 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_where_clause_in_merge_update_delete_part6317 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_key_in_merge_insert_clause6337 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000002000L});
	public static final BitSet FOLLOW_not_key_in_merge_insert_clause6339 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_matched_key_in_merge_insert_clause6341 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_then_key_in_merge_insert_clause6343 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000100L});
	public static final BitSet FOLLOW_insert_key_in_merge_insert_clause6345 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_merge_insert_clause6357 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_merge_insert_clause6359 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_merge_insert_clause6362 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_merge_insert_clause6364 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_merge_insert_clause6368 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_values_key_in_merge_insert_clause6380 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_expression_list_in_merge_insert_clause6382 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000004000000000L});
	public static final BitSet FOLLOW_where_clause_in_merge_insert_clause6384 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tableview_name_in_selected_tableview6434 = new BitSet(new long[]{0x0001002000818002L,0x0000000010000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_selected_tableview6438 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_statement_in_selected_tableview6440 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_selected_tableview6442 = new BitSet(new long[]{0x0001002000818002L,0x0000000010000000L});
	public static final BitSet FOLLOW_table_alias_in_selected_tableview6445 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_lock_key_in_lock_table_statement6491 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000008000000L});
	public static final BitSet FOLLOW_table_key_in_lock_table_statement6493 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_lock_table_element_in_lock_table_statement6504 = new BitSet(new long[]{0x0000000000040000L,0x0000000000000000L,0x0000000000000080L});
	public static final BitSet FOLLOW_COMMA_in_lock_table_statement6507 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_lock_table_element_in_lock_table_statement6509 = new BitSet(new long[]{0x0000000000040000L,0x0000000000000000L,0x0000000000000080L});
	public static final BitSet FOLLOW_in_key_in_lock_table_statement6522 = new BitSet(new long[]{0x0000000000000000L,0x0000000010001002L});
	public static final BitSet FOLLOW_lock_mode_in_lock_table_statement6524 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000100L});
	public static final BitSet FOLLOW_mode_key_in_lock_table_statement6526 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000400L});
	public static final BitSet FOLLOW_wait_nowait_part_in_lock_table_statement6528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_wait_key_in_wait_nowait_part6571 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_wait_nowait_part6573 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_nowait_key_in_wait_nowait_part6596 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tableview_name_in_lock_table_element6618 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_partition_extension_clause_in_lock_table_element6620 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_row_key_in_lock_mode6660 = new BitSet(new long[]{0x0000000000000000L,0x0000000000001000L});
	public static final BitSet FOLLOW_share_key_in_lock_mode6662 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_row_key_in_lock_mode6673 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_exclusive_key_in_lock_mode6675 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_share_key_in_lock_mode6686 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000400000000L});
	public static final BitSet FOLLOW_update_key_in_lock_mode6688 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_share_key_in_lock_mode6700 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_row_key_in_lock_mode6702 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_exclusive_key_in_lock_mode6704 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_exclusive_key_in_lock_mode6715 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dml_table_expression_clause_simple_in_general_table_ref6743 = new BitSet(new long[]{0x0001002000818002L,0x0000000010000000L});
	public static final BitSet FOLLOW_only_key_in_general_table_ref6758 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_general_table_ref6760 = new BitSet(new long[]{0x0000042000800000L,0x0000000010000000L,0x0000000018000000L});
	public static final BitSet FOLLOW_dml_table_expression_clause_simple_in_general_table_ref6762 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_general_table_ref6764 = new BitSet(new long[]{0x0001002000818002L,0x0000000010000000L});
	public static final BitSet FOLLOW_table_alias_in_general_table_ref6779 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_returning_key_in_static_returning_clause6823 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_return_key_in_static_returning_clause6825 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_static_returning_clause6828 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_COMMA_in_static_returning_clause6831 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_static_returning_clause6833 = new BitSet(new long[]{0x0000000000040000L,0x0000000010000000L,0x0000000000000400L});
	public static final BitSet FOLLOW_into_clause_in_static_returning_clause6846 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_log_key_in_error_logging_clause6889 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_errors_key_in_error_logging_clause6891 = new BitSet(new long[]{0x0081442010838842L,0xC2D8412010010000L,0x0000100080206400L});
	public static final BitSet FOLLOW_error_logging_into_part_in_error_logging_clause6902 = new BitSet(new long[]{0x0081442010838842L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_error_logging_clause6919 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_error_logging_reject_part_in_error_logging_clause6931 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_into_key_in_error_logging_into_part6975 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_tableview_name_in_error_logging_into_part6978 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_reject_key_in_error_logging_reject_part6998 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_limit_key_in_error_logging_reject_part7001 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_unlimited_key_in_error_logging_reject_part7009 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_error_logging_reject_part7011 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_table_collection_expression_in_dml_table_expression_clause_simple7032 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_dml_table_expression_clause_simple7055 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_statement_in_dml_table_expression_clause_simple7057 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause_simple7059 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause_simple7062 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tableview_name_in_dml_table_expression_clause_simple7088 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_sample_clause_in_dml_table_expression_clause_simple7090 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_general_element_in_dml_table_expression_clause7141 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_dml_table_expression_clause_simple_in_dml_table_expression_clause7160 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standard_function_in_dml_table_expression_clause7177 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_table_key_in_table_collection_expression7207 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_the_key_in_table_collection_expression7211 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_table_collection_expression7250 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_table_collection_expression7252 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_table_collection_expression7254 = new BitSet(new long[]{0x0000040000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_table_collection_expression7273 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_table_collection_expression7275 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_table_collection_expression7277 = new BitSet(new long[]{0x0000040000000002L});
	public static final BitSet FOLLOW_outer_join_sign_in_table_collection_expression7304 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_subquery_restriction_clause7335 = new BitSet(new long[]{0x0000000000000000L,0x0000800010000000L});
	public static final BitSet FOLLOW_read_key_in_subquery_restriction_clause7346 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_only_key_in_subquery_restriction_clause7348 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_check_key_in_subquery_restriction_clause7359 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000020000L});
	public static final BitSet FOLLOW_option_key_in_subquery_restriction_clause7361 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_constraint_key_in_subquery_restriction_clause7364 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_constraint_name_in_subquery_restriction_clause7366 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_sample_key_in_sample_clause7417 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_block_key_in_sample_clause7419 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_sample_clause7431 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_sample_clause7435 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_sample_clause7438 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_sample_clause7442 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_sample_clause7446 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_seed_part_in_sample_clause7456 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_seed_key_in_seed_part7512 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_seed_part7514 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_seed_part7516 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_seed_part7518 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cursor_key_in_cursor_expression7561 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_cursor_expression7563 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_cursor_expression7565 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_cursor_expression7567 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_expression_list7587 = new BitSet(new long[]{0x0081442010878840L,0xC2D8412050010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_expression_list7589 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_expression_list7593 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_expression_list7595 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_expression_list7599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_condition7641 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_condition_wrapper7661 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cursor_expression_in_expression7711 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_logical_and_expression_in_expression7722 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_or_key_in_expression7726 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_logical_and_expression_in_expression7729 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000040000L});
	public static final BitSet FOLLOW_expression_in_expression_wrapper7752 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_negated_expression_in_logical_and_expression7788 = new BitSet(new long[]{0x0000000000000002L,0x0000008000000000L});
	public static final BitSet FOLLOW_and_key_in_logical_and_expression7792 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_negated_expression_in_logical_and_expression7795 = new BitSet(new long[]{0x0000000000000002L,0x0000008000000000L});
	public static final BitSet FOLLOW_not_key_in_negated_expression7818 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_negated_expression_in_negated_expression7821 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_equality_expression_in_negated_expression7832 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_multiset_expression_in_equality_expression7861 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_is_key_in_equality_expression7877 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x000000000000E000L});
	public static final BitSet FOLLOW_not_key_in_equality_expression7880 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L,0x000000000000C000L});
	public static final BitSet FOLLOW_null_key_in_equality_expression7899 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_nan_key_in_equality_expression7966 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_present_key_in_equality_expression8033 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_infinite_key_in_equality_expression8100 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_a_key_in_equality_expression8167 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_set_key_in_equality_expression8169 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_empty_key_in_equality_expression8236 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_of_key_in_equality_expression8303 = new BitSet(new long[]{0x0000040000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_type_key_in_equality_expression8305 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_equality_expression8308 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_only_key_in_equality_expression8310 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_type_spec_in_equality_expression8313 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_equality_expression8316 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_type_spec_in_equality_expression8318 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_equality_expression8322 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000800L});
	public static final BitSet FOLLOW_relational_expression_in_multiset_expression8419 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_multiset_type_in_multiset_expression8435 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x000010008020C000L});
	public static final BitSet FOLLOW_of_key_in_multiset_expression8437 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_multiset_expression8440 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_member_key_in_multiset_type8485 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_submultiset_key_in_multiset_type8496 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_compound_expression_in_relational_expression8516 = new BitSet(new long[]{0x0004180328004002L});
	public static final BitSet FOLLOW_EQUALS_OP_in_relational_expression8526 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_not_equal_op_in_relational_expression8531 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_LESS_THAN_OP_in_relational_expression8536 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_GREATER_THAN_OP_in_relational_expression8541 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_less_than_or_equals_op_in_relational_expression8546 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_greater_than_or_equals_op_in_relational_expression8551 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_compound_expression_in_relational_expression8556 = new BitSet(new long[]{0x0004180328004002L});
	public static final BitSet FOLLOW_concatenation_in_compound_expression8589 = new BitSet(new long[]{0x0000000000000002L,0x0000100010000000L,0x0000000000003080L});
	public static final BitSet FOLLOW_not_key_in_compound_expression8607 = new BitSet(new long[]{0x0000000000000000L,0x0000100010000000L,0x0000000000001080L});
	public static final BitSet FOLLOW_in_key_in_compound_expression8627 = new BitSet(new long[]{0x0001442010838840L,0xC0D0000010000000L,0x0000100080204000L});
	public static final BitSet FOLLOW_in_elements_in_compound_expression8629 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_between_key_in_compound_expression8700 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_between_elements_in_compound_expression8702 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_like_type_in_compound_expression8773 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_compound_expression8777 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_like_escape_part_in_compound_expression8779 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_like_key_in_like_type8881 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_likec_key_in_like_type8892 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_like2_key_in_like_type8903 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_like4_key_in_like_type8914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_escape_key_in_like_escape_part8934 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_like_escape_part8936 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_in_elements8982 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_in_elements8984 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_in_elements8986 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_in_elements9010 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_in_elements9012 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_in_elements9015 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_in_elements9017 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_in_elements9021 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_constant_in_in_elements9050 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_bind_variable_in_in_elements9078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_general_element_in_in_elements9106 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_concatenation_in_between_elements9145 = new BitSet(new long[]{0x0000000000000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_and_key_in_between_elements9147 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_between_elements9151 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_additive_expression_in_concatenation9187 = new BitSet(new long[]{0x0000000000200002L,0x0000000000000000L,0x0000400000000000L});
	public static final BitSet FOLLOW_concatenation_op_in_concatenation9190 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_additive_expression_in_concatenation9193 = new BitSet(new long[]{0x0000000000200002L,0x0000000000000000L,0x0000400000000000L});
	public static final BitSet FOLLOW_concatenation_in_concatenation_wrapper9215 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_multiply_expression_in_additive_expression9251 = new BitSet(new long[]{0x0000400000000002L,0x0000000000010000L});
	public static final BitSet FOLLOW_PLUS_SIGN_in_additive_expression9257 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_MINUS_SIGN_in_additive_expression9262 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_multiply_expression_in_additive_expression9267 = new BitSet(new long[]{0x0000400000000002L,0x0000000000010000L});
	public static final BitSet FOLLOW_datetime_expression_in_multiply_expression9289 = new BitSet(new long[]{0x0020000000000102L,0x0000000810000000L});
	public static final BitSet FOLLOW_ASTERISK_in_multiply_expression9316 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_SOLIDUS_in_multiply_expression9321 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_PERCENT_in_multiply_expression9326 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_datetime_expression_in_multiply_expression9331 = new BitSet(new long[]{0x0020000000000102L,0x0000000810000000L});
	public static final BitSet FOLLOW_mod_key_in_multiply_expression9355 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_datetime_expression_in_multiply_expression9358 = new BitSet(new long[]{0x0020000000000102L,0x0000000810000000L});
	public static final BitSet FOLLOW_div_key_in_multiply_expression9382 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_datetime_expression_in_multiply_expression9385 = new BitSet(new long[]{0x0020000000000102L,0x0000000810000000L});
	public static final BitSet FOLLOW_model_expression_in_datetime_expression9418 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_at_key_in_datetime_expression9434 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_local_key_in_datetime_expression9437 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_time_key_in_datetime_expression9439 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_zone_key_in_datetime_expression9441 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_datetime_expression9443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_interval_expression_in_datetime_expression9493 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_day_key_in_interval_expression9543 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_interval_expression9549 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_interval_expression9553 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_interval_expression9555 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_to_key_in_interval_expression9559 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_second_key_in_interval_expression9561 = new BitSet(new long[]{0x0000040000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_interval_expression9564 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_interval_expression9568 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_interval_expression9570 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_year_key_in_interval_expression9607 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_interval_expression9610 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_interval_expression9612 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_interval_expression9614 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_to_key_in_interval_expression9618 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_month_key_in_interval_expression9620 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unary_expression_in_model_expression9659 = new BitSet(new long[]{0x0000020000000002L});
	public static final BitSet FOLLOW_LEFT_BRACKET_in_model_expression9675 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206002L});
	public static final BitSet FOLLOW_model_expression_element_in_model_expression9677 = new BitSet(new long[]{0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_RIGHT_BRACKET_in_model_expression9679 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_any_key_in_model_expression_element9731 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_condition_wrapper_in_model_expression_element9733 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_model_expression_element9737 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_any_key_in_model_expression_element9746 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_condition_wrapper_in_model_expression_element9748 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_single_column_for_loop_in_model_expression_element9762 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_model_expression_element9765 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_single_column_for_loop_in_model_expression_element9768 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_multi_column_for_loop_in_model_expression_element9781 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_single_column_for_loop9809 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_single_column_for_loop9811 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000001084L});
	public static final BitSet FOLLOW_in_key_in_single_column_for_loop9823 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_expression_list_in_single_column_for_loop9825 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_like_part_in_single_column_for_loop9838 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_from_key_in_single_column_for_loop9841 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_single_column_for_loop9845 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_to_key_in_single_column_for_loop9859 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_single_column_for_loop9863 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_for_increment_decrement_type_in_single_column_for_loop9865 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_single_column_for_loop9869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_like_key_in_for_like_part9978 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_for_like_part9980 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_increment_key_in_for_increment_decrement_type10020 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_decrement_key_in_for_increment_decrement_type10031 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_multi_column_for_loop10051 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_multi_column_for_loop10053 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_multi_column_for_loop10055 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_multi_column_for_loop10058 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_column_name_in_multi_column_for_loop10060 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10064 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000080L});
	public static final BitSet FOLLOW_in_key_in_multi_column_for_loop10066 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_multi_column_for_loop10076 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_multi_column_for_loop10100 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_multi_column_for_loop10124 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_expression_list_in_multi_column_for_loop10126 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_multi_column_for_loop10129 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_expression_list_in_multi_column_for_loop10131 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10135 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_multi_column_for_loop10159 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_SIGN_in_unary_expression10216 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLUS_SIGN_in_unary_expression10238 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_prior_key_in_unary_expression10260 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_connect_by_root_key_in_unary_expression10274 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10277 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_new_key_in_unary_expression10291 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10294 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_distinct_key_in_unary_expression10305 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10308 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_unary_expression10319 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_unary_expression10322 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_statement_in_unary_expression10335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_expression_in_unary_expression10347 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cursor_name_in_unary_expression10358 = new BitSet(new long[]{0x0020000000000000L});
	public static final BitSet FOLLOW_percent_notfound_key_in_unary_expression10361 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_found_key_in_unary_expression10364 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_isopen_key_in_unary_expression10367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_rowcount_key_in_unary_expression10370 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_atom_in_unary_expression10383 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_searched_case_statement_in_case_statement10431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_simple_case_statement_in_case_statement10442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_key_in_simple_case_statement10466 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_simple_case_statement10468 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_simple_case_when_part_in_simple_case_statement10478 = new BitSet(new long[]{0x0000000000000000L,0x1800000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_case_else_part_in_simple_case_statement10490 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_end_key_in_simple_case_statement10501 = new BitSet(new long[]{0x0000000000800002L,0x0000400010000000L});
	public static final BitSet FOLLOW_case_key_in_simple_case_statement10503 = new BitSet(new long[]{0x0000000000800002L,0x0000000010000000L});
	public static final BitSet FOLLOW_label_name_in_simple_case_statement10506 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_key_in_simple_case_when_part10552 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_simple_case_when_part10557 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_then_key_in_simple_case_when_part10559 = new BitSet(new long[]{0x00814C2010838840L,0xC2FA496010010048L,0x000010848260611BL});
	public static final BitSet FOLLOW_seq_of_statements_in_simple_case_when_part10565 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_simple_case_when_part10571 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_key_in_searched_case_statement10594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_searched_case_when_part_in_searched_case_statement10604 = new BitSet(new long[]{0x0000000000000000L,0x1800000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_case_else_part_in_searched_case_statement10615 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});
	public static final BitSet FOLLOW_end_key_in_searched_case_statement10626 = new BitSet(new long[]{0x0000000000800002L,0x0000400010000000L});
	public static final BitSet FOLLOW_case_key_in_searched_case_statement10628 = new BitSet(new long[]{0x0000000000800002L,0x0000000010000000L});
	public static final BitSet FOLLOW_label_name_in_searched_case_statement10631 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_when_key_in_searched_case_when_part10674 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_condition_wrapper_in_searched_case_when_part10677 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});
	public static final BitSet FOLLOW_then_key_in_searched_case_when_part10679 = new BitSet(new long[]{0x00814C2010838840L,0xC2FA496010010048L,0x000010848260611BL});
	public static final BitSet FOLLOW_seq_of_statements_in_searched_case_when_part10685 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_searched_case_when_part10689 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_else_key_in_case_else_part10710 = new BitSet(new long[]{0x00814C2010838840L,0xC2FA496010010048L,0x000010848260611BL});
	public static final BitSet FOLLOW_seq_of_statements_in_case_else_part10716 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_case_else_part10720 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_general_element_in_atom10759 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_outer_join_sign_in_atom10761 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_constant_in_atom10773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standard_function_in_atom10790 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_general_element_in_atom10809 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_atom10820 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100082206000L});
	public static final BitSet FOLLOW_subquery_in_atom10858 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_atom10860 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_subquery_operation_part_in_atom10863 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L,0x0000000100000200L});
	public static final BitSet FOLLOW_expression_or_vector_in_atom10882 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_atom10884 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_expression_or_vector10924 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_vector_expr_in_expression_or_vector10927 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_vector_expr10987 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_vector_expr10989 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_vector_expr10992 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_vector_expr10994 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_some_key_in_quantified_expression11035 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_exists_key_in_quantified_expression11040 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_all_key_in_quantified_expression11045 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_any_key_in_quantified_expression11050 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_quantified_expression11078 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_quantified_expression11081 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_quantified_expression11083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_quantified_expression11099 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_quantified_expression11102 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_quantified_expression11104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stantard_function_enabling_over_in_standard_function11136 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_function_argument_in_standard_function11139 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_over_clause_in_standard_function11141 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stantard_function_enabling_using_in_standard_function11153 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_function_argument_in_standard_function11156 = new BitSet(new long[]{0x1000000000000002L});
	public static final BitSet FOLLOW_using_clause_in_standard_function11158 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_count_key_in_standard_function11170 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11185 = new BitSet(new long[]{0x0081442010838940L,0xC2D0412010010000L,0x0000100280204000L});
	public static final BitSet FOLLOW_ASTERISK_in_standard_function11206 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_distinct_key_in_standard_function11211 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unique_key_in_standard_function11213 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_all_key_in_standard_function11215 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11219 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11235 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_over_clause_in_standard_function11238 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cast_key_in_standard_function11251 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_xmlcast_key_in_standard_function11254 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11271 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_multiset_key_in_standard_function11307 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11310 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000000002000000L});
	public static final BitSet FOLLOW_subquery_in_standard_function11313 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11315 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11337 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_as_key_in_standard_function11373 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_type_spec_in_standard_function11376 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11390 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_chr_key_in_standard_function11402 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11417 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11437 = new BitSet(new long[]{0x1000000000000000L});
	public static final BitSet FOLLOW_using_key_in_standard_function11439 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nchar_cs_key_in_standard_function11442 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11457 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_collect_key_in_standard_function11469 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11484 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100280204000L});
	public static final BitSet FOLLOW_distinct_key_in_standard_function11505 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unique_key_in_standard_function11507 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11511 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_collect_order_by_part_in_standard_function11513 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stantard_function_enabling_within_or_over_in_standard_function11540 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_function_argument_in_standard_function11556 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_within_or_over_part_in_standard_function11558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_decompose_key_in_standard_function11569 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11584 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11604 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_canonical_key_in_standard_function11607 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_compatibility_key_in_standard_function11609 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11626 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_extract_key_in_standard_function11638 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11653 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_year_key_in_standard_function11692 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_month_key_in_standard_function11694 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_day_key_in_standard_function11696 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_hour_key_in_standard_function11698 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_minute_key_in_standard_function11700 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_second_key_in_standard_function11721 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_timezone_hour_key_in_standard_function11723 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_timezone_minute_key_in_standard_function11725 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_timezone_region_key_in_standard_function11746 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_timezone_abbr_key_in_standard_function11748 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_from_key_in_standard_function11784 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11787 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11802 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_first_value_key_in_standard_function11815 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_last_value_key_in_standard_function11818 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11835 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function11854 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_ignore_key_in_standard_function11857 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_nulls_key_in_standard_function11860 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function11877 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_over_clause_in_standard_function11880 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_first_value_key_in_standard_function11892 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_last_value_key_in_standard_function11895 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_function_argument_analytic_in_standard_function11912 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_respect_or_ignore_nulls_in_standard_function11927 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_over_clause_in_standard_function11930 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_stantard_function_pedictions_in_standard_function11941 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function11956 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function11975 = new BitSet(new long[]{0x1000000000040000L,0x0000000050000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function11978 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function11981 = new BitSet(new long[]{0x1000000000040000L,0x0000000050000000L});
	public static final BitSet FOLLOW_cost_matrix_clause_in_standard_function11985 = new BitSet(new long[]{0x1000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_using_clause_in_standard_function11988 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12004 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_translate_key_in_standard_function12016 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12031 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12051 = new BitSet(new long[]{0x0000000000040000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function12070 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12073 = new BitSet(new long[]{0x0000000000040000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function12091 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12094 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12108 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_treat_key_in_standard_function12120 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12135 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12154 = new BitSet(new long[]{0x0000000000000000L,0x0000020000000000L});
	public static final BitSet FOLLOW_as_key_in_standard_function12156 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_ref_key_in_standard_function12159 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_type_spec_in_standard_function12162 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12177 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_trim_key_in_standard_function12189 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12203 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_leading_key_in_standard_function12244 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_trailing_key_in_standard_function12248 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_both_key_in_standard_function12252 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_standard_function12275 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_from_key_in_standard_function12295 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_standard_function12317 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_expression_in_standard_function12376 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000000004L});
	public static final BitSet FOLLOW_from_key_in_standard_function12422 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_in_standard_function12426 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12573 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlagg_key_in_standard_function12584 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12599 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12619 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_by_clause_in_standard_function12621 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12637 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function12653 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function12655 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlcolattval_key_in_standard_function12669 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_xmlforest_key_in_standard_function12672 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12689 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_xml_multiuse_expression_element_in_standard_function12708 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function12711 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_xml_multiuse_expression_element_in_standard_function12714 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12730 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function12746 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function12748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlelement_key_in_standard_function12761 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12776 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_entityescaping_key_in_standard_function12796 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_noentityescaping_key_in_standard_function12798 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_name_key_in_standard_function12819 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_evalname_key_in_standard_function12821 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12825 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function12846 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xml_attributes_clause_in_standard_function12849 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function12870 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12873 = new BitSet(new long[]{0x0001002000858000L,0x0000020050000000L});
	public static final BitSet FOLLOW_column_alias_in_standard_function12875 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12892 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function12908 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function12910 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlexists_key_in_standard_function12923 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function12938 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_standard_function12957 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_xml_passing_clause_in_standard_function12975 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function12990 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlparse_key_in_standard_function13002 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13017 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_document_key_in_standard_function13038 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_content_key_in_standard_function13040 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13043 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_wellformed_key_in_standard_function13045 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13060 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13076 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13078 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlpi_key_in_standard_function13091 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13106 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_name_key_in_standard_function13131 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_id_in_standard_function13133 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_evalname_key_in_standard_function13156 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13158 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function13195 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13198 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13214 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13230 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13232 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlquery_key_in_standard_function13245 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13260 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13280 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xml_passing_clause_in_standard_function13282 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_returning_key_in_standard_function13301 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_content_key_in_standard_function13304 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000004000L});
	public static final BitSet FOLLOW_null_key_in_standard_function13308 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000010000L});
	public static final BitSet FOLLOW_on_key_in_standard_function13310 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_empty_key_in_standard_function13313 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13330 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13346 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13348 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlroot_key_in_standard_function13361 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13376 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13395 = new BitSet(new long[]{0x0000000000040000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function13413 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xmlroot_param_version_part_in_standard_function13436 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function13459 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xmlroot_param_standalone_part_in_standard_function13462 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13478 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13494 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13496 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlserialize_key_in_standard_function13509 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13524 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_document_key_in_standard_function13544 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_content_key_in_standard_function13546 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13565 = new BitSet(new long[]{0x0000000000000000L,0x0000020050000000L});
	public static final BitSet FOLLOW_as_key_in_standard_function13568 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L});
	public static final BitSet FOLLOW_type_spec_in_standard_function13571 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_xmlserialize_param_enconding_part_in_standard_function13591 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_xmlserialize_param_version_part_in_standard_function13610 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_xmlserialize_param_ident_part_in_standard_function13629 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_hide_key_in_standard_function13650 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_show_key_in_standard_function13652 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_defaults_key_in_standard_function13655 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13671 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13687 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13689 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmltable_key_in_standard_function13702 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_standard_function13717 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_xml_namespaces_clause_in_standard_function13736 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_standard_function13755 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_xml_passing_clause_in_standard_function13773 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_columns_key_in_standard_function13793 = new BitSet(new long[]{0x0001002000818000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xml_table_column_in_standard_function13796 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_standard_function13799 = new BitSet(new long[]{0x0001002000818000L,0x0000000010000000L});
	public static final BitSet FOLLOW_xml_table_column_in_standard_function13802 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_standard_function13820 = new BitSet(new long[]{0x0040000000000002L});
	public static final BitSet FOLLOW_PERIOD_in_standard_function13836 = new BitSet(new long[]{0x0000002000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_general_element_id_in_standard_function13838 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_stantard_function_enabling_over13863 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_stantard_function_enabling_using13891 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over13919 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_stantard_function_pedictions13947 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_over_key_in_over_clause13972 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_over_clause13983 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_query_partition_clause_in_over_clause13998 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_by_clause_in_over_clause14014 = new BitSet(new long[]{0x0000000000000000L,0x0000000050000000L});
	public static final BitSet FOLLOW_windowing_clause_in_over_clause14016 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_over_clause14029 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_windowing_type_in_windowing_clause14058 = new BitSet(new long[]{0x0081442010838840L,0xC2D4512010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_between_key_in_windowing_clause14069 = new BitSet(new long[]{0x0081442010838840L,0xC2D4412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_windowing_elements_in_windowing_clause14071 = new BitSet(new long[]{0x0000000000000000L,0x0000008000000000L});
	public static final BitSet FOLLOW_and_key_in_windowing_clause14073 = new BitSet(new long[]{0x0081442010838840L,0xC2D4412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_windowing_elements_in_windowing_clause14075 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_windowing_elements_in_windowing_clause14088 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rows_key_in_windowing_type14147 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_range_key_in_windowing_type14158 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unbounded_key_in_windowing_elements14178 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_preceding_key_in_windowing_elements14181 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_current_key_in_windowing_elements14192 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_row_key_in_windowing_elements14195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_windowing_elements14206 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_preceding_key_in_windowing_elements14209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_following_key_in_windowing_elements14212 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_using_key_in_using_clause14234 = new BitSet(new long[]{0x0081442010838940L,0xC2D8412010010000L,0x0000100080206080L});
	public static final BitSet FOLLOW_ASTERISK_in_using_clause14246 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_using_element_in_using_clause14257 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_using_clause14260 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206080L});
	public static final BitSet FOLLOW_using_element_in_using_clause14263 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_in_key_in_using_element14292 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_out_key_in_using_element14294 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_out_key_in_using_element14297 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_select_list_elements_in_using_element14301 = new BitSet(new long[]{0x0001002000818002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_using_element14303 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_order_key_in_collect_order_by_part14349 = new BitSet(new long[]{0x0000000000000000L,0x0000200000000000L});
	public static final BitSet FOLLOW_by_key_in_collect_order_by_part14352 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_collect_order_by_part14355 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_within_key_in_within_or_over_part14375 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000020L});
	public static final BitSet FOLLOW_group_key_in_within_or_over_part14378 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_within_or_over_part14381 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000080000L});
	public static final BitSet FOLLOW_order_by_clause_in_within_or_over_part14384 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_within_or_over_part14386 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_over_clause_in_within_or_over_part14398 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cost_key_in_cost_matrix_clause14418 = new BitSet(new long[]{0x0200040000000000L});
	public static final BitSet FOLLOW_model_key_in_cost_matrix_clause14430 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_auto_key_in_cost_matrix_clause14432 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_cost_matrix_clause14444 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_cost_class_name_in_cost_matrix_clause14447 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_cost_matrix_clause14450 = new BitSet(new long[]{0x0000002000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_cost_class_name_in_cost_matrix_clause14453 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_cost_matrix_clause14457 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000800000000L});
	public static final BitSet FOLLOW_values_key_in_cost_matrix_clause14460 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_expression_list_in_cost_matrix_clause14476 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_passing_key_in_xml_passing_clause14502 = new BitSet(new long[]{0x0081442010838840L,0xC2D8612010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_by_key_in_xml_passing_clause14506 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_value_key_in_xml_passing_clause14509 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_xml_passing_clause14525 = new BitSet(new long[]{0x0001002000858002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_xml_passing_clause14527 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_COMMA_in_xml_passing_clause14531 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_expression_wrapper_in_xml_passing_clause14534 = new BitSet(new long[]{0x0001002000858002L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_xml_passing_clause14536 = new BitSet(new long[]{0x0000000000040002L});
	public static final BitSet FOLLOW_xmlattributes_key_in_xml_attributes_clause14559 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_xml_attributes_clause14570 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_entityescaping_key_in_xml_attributes_clause14586 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_noentityescaping_key_in_xml_attributes_clause14588 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_schemacheck_key_in_xml_attributes_clause14605 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_noschemacheck_key_in_xml_attributes_clause14607 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause14623 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_COMMA_in_xml_attributes_clause14626 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause14629 = new BitSet(new long[]{0x0000000000040000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_xml_attributes_clause14641 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause14662 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_xml_namespaces_clause14673 = new BitSet(new long[]{0x0081442010878840L,0xC2D0412050010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xml_namespaces_clause14689 = new BitSet(new long[]{0x0001002000818000L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_xml_namespaces_clause14691 = new BitSet(new long[]{0x0000000000040000L,0x0040000040000000L});
	public static final BitSet FOLLOW_COMMA_in_xml_namespaces_clause14712 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xml_namespaces_clause14715 = new BitSet(new long[]{0x0001002000818000L,0x0000020010000000L});
	public static final BitSet FOLLOW_column_alias_in_xml_namespaces_clause14717 = new BitSet(new long[]{0x0000000000040000L,0x0040000040000000L});
	public static final BitSet FOLLOW_xml_general_default_part_in_xml_namespaces_clause14739 = new BitSet(new long[]{0x0000000000000000L,0x0000000040000000L});
	public static final BitSet FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause14751 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_xml_column_name_in_xml_table_column14772 = new BitSet(new long[]{0x0000000000800000L,0x0010000010000000L,0x0000000000000002L});
	public static final BitSet FOLLOW_for_key_in_xml_table_column14783 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_ordinality_key_in_xml_table_column14785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_type_spec_in_xml_table_column14796 = new BitSet(new long[]{0x0000000000000002L,0x0040000010000000L});
	public static final BitSet FOLLOW_path_key_in_xml_table_column14799 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xml_table_column14801 = new BitSet(new long[]{0x0000000000000002L,0x0040000000000000L});
	public static final BitSet FOLLOW_xml_general_default_part_in_xml_table_column14811 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_default_key_in_xml_general_default_part14867 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xml_general_default_part14870 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_in_xml_multiuse_expression_element14898 = new BitSet(new long[]{0x0000000000000002L,0x0000020000000000L});
	public static final BitSet FOLLOW_as_key_in_xml_multiuse_expression_element14901 = new BitSet(new long[]{0x0000000000800000L,0x0000000010000000L});
	public static final BitSet FOLLOW_id_expression_in_xml_multiuse_expression_element14904 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_evalname_key_in_xml_multiuse_expression_element14908 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_in_xml_multiuse_expression_element14910 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_version_key_in_xmlroot_param_version_part15021 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_no_key_in_xmlroot_param_version_part15025 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_value_key_in_xmlroot_param_version_part15027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_expression_wrapper_in_xmlroot_param_version_part15029 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standalone_key_in_xmlroot_param_standalone_part15050 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_yes_key_in_xmlroot_param_standalone_part15054 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_no_key_in_xmlroot_param_standalone_part15056 = new BitSet(new long[]{0x0000000000000002L,0x0000000010000000L});
	public static final BitSet FOLLOW_value_key_in_xmlroot_param_standalone_part15058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_encoding_key_in_xmlserialize_param_enconding_part15080 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part15083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_version_key_in_xmlserialize_param_version_part15103 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part15106 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_no_key_in_xmlserialize_param_ident_part15126 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_indent_key_in_xmlserialize_param_ident_part15128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_indent_key_in_xmlserialize_param_ident_part15139 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000004000000L});
	public static final BitSet FOLLOW_size_key_in_xmlserialize_param_ident_part15143 = new BitSet(new long[]{0x0000000008000000L});
	public static final BitSet FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part15146 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part15149 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_distinct_key_in_synpred1_PLSQL_DMLParser1432 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unique_key_in_synpred1_PLSQL_DMLParser1434 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_synpred1_PLSQL_DMLParser1436 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_tableview_name_in_synpred2_PLSQL_DMLParser1749 = new BitSet(new long[]{0x0040000000000000L});
	public static final BitSet FOLLOW_PERIOD_in_synpred2_PLSQL_DMLParser1751 = new BitSet(new long[]{0x0000000000000100L});
	public static final BitSet FOLLOW_ASTERISK_in_synpred2_PLSQL_DMLParser1753 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred3_PLSQL_DMLParser1909 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred3_PLSQL_DMLParser1912 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred3_PLSQL_DMLParser1914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_only_key_in_synpred5_PLSQL_DMLParser1988 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1990 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser2451 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred6_PLSQL_DMLParser2454 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred6_PLSQL_DMLParser2456 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser2480 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_select_key_in_synpred8_PLSQL_DMLParser2926 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_any_key_in_synpred9_PLSQL_DMLParser2952 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred10_PLSQL_DMLParser3157 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser3531 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_group_key_in_synpred12_PLSQL_DMLParser3761 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_synpred13_PLSQL_DMLParser3774 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_synpred13_PLSQL_DMLParser3776 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_having_key_in_synpred14_PLSQL_DMLParser3824 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_COMMA_in_synpred15_PLSQL_DMLParser3840 = new BitSet(new long[]{0x0081442010838840L,0xC2D8412010010000L,0x0000100080206000L});
	public static final BitSet FOLLOW_group_by_elements_in_synpred15_PLSQL_DMLParser3842 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_rollup_key_in_synpred16_PLSQL_DMLParser4056 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cube_key_in_synpred16_PLSQL_DMLParser4058 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred17_PLSQL_DMLParser4074 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_synpred18_PLSQL_DMLParser4742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred19_PLSQL_DMLParser6915 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_unlimited_key_in_synpred20_PLSQL_DMLParser7006 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_routine_id_in_synpred21_PLSQL_DMLParser7127 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_PERIOD_in_synpred21_PLSQL_DMLParser7130 = new BitSet(new long[]{0x0000000000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_routine_id_in_synpred21_PLSQL_DMLParser7132 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred21_PLSQL_DMLParser7136 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standard_function_in_synpred22_PLSQL_DMLParser7172 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred23_PLSQL_DMLParser7237 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred23_PLSQL_DMLParser7240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred23_PLSQL_DMLParser7244 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cursor_key_in_synpred24_PLSQL_DMLParser7698 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser7700 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred24_PLSQL_DMLParser7703 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred24_PLSQL_DMLParser7705 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser8969 = new BitSet(new long[]{0x0000040000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred25_PLSQL_DMLParser8973 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred25_PLSQL_DMLParser8975 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_mod_key_in_synpred26_PLSQL_DMLParser9348 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_datetime_expression_in_synpred26_PLSQL_DMLParser9350 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_div_key_in_synpred27_PLSQL_DMLParser9375 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_datetime_expression_in_synpred27_PLSQL_DMLParser9377 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_interval_expression_in_synpred28_PLSQL_DMLParser9489 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_any_key_in_synpred29_PLSQL_DMLParser9727 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_any_key_in_synpred30_PLSQL_DMLParser9742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_select_key_in_synpred31_PLSQL_DMLParser10096 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred32_PLSQL_DMLParser10120 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_MINUS_SIGN_in_synpred33_PLSQL_DMLParser10216 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_synpred33_PLSQL_DMLParser10218 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_prior_key_in_synpred35_PLSQL_DMLParser10260 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_synpred35_PLSQL_DMLParser10263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_new_key_in_synpred37_PLSQL_DMLParser10291 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_synpred37_PLSQL_DMLParser10294 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_all_key_in_synpred39_PLSQL_DMLParser10319 = new BitSet(new long[]{0x0081442010838840L,0xC2D0412010010000L,0x0000100080204000L});
	public static final BitSet FOLLOW_unary_expression_in_synpred39_PLSQL_DMLParser10322 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_quantified_expression_in_synpred41_PLSQL_DMLParser10347 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_cursor_name_in_synpred42_PLSQL_DMLParser10358 = new BitSet(new long[]{0x0020000000000000L});
	public static final BitSet FOLLOW_percent_notfound_key_in_synpred42_PLSQL_DMLParser10361 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_found_key_in_synpred42_PLSQL_DMLParser10364 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_isopen_key_in_synpred42_PLSQL_DMLParser10367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_percent_rowcount_key_in_synpred42_PLSQL_DMLParser10370 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_case_key_in_synpred43_PLSQL_DMLParser10425 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});
	public static final BitSet FOLLOW_when_key_in_synpred43_PLSQL_DMLParser10427 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_routine_id_in_synpred44_PLSQL_DMLParser10745 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_PERIOD_in_synpred44_PLSQL_DMLParser10748 = new BitSet(new long[]{0x0000000000800000L,0x4080000010000000L,0x0000000000200000L});
	public static final BitSet FOLLOW_routine_id_in_synpred44_PLSQL_DMLParser10750 = new BitSet(new long[]{0x0040040000000000L});
	public static final BitSet FOLLOW_outer_join_sign_in_synpred44_PLSQL_DMLParser10754 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_standard_function_in_synpred45_PLSQL_DMLParser10785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_select_key_in_synpred46_PLSQL_DMLParser10850 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred46_PLSQL_DMLParser10854 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred47_PLSQL_DMLParser11067 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred47_PLSQL_DMLParser11070 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred47_PLSQL_DMLParser11072 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_multiset_key_in_synpred48_PLSQL_DMLParser11293 = new BitSet(new long[]{0x0000040000000000L});
	public static final BitSet FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser11295 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000008002000000L});
	public static final BitSet FOLLOW_select_key_in_synpred48_PLSQL_DMLParser11298 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_with_key_in_synpred48_PLSQL_DMLParser11300 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_default_key_in_synpred49_PLSQL_DMLParser14735 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_default_key_in_synpred50_PLSQL_DMLParser14807 = new BitSet(new long[]{0x0000000000000002L});
}
