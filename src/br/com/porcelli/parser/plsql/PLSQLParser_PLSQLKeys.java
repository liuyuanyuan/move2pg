// $ANTLR 3.5.2 PLSQLKeys.g 2018-10-06 11:19:16

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package br.com.porcelli.parser.plsql;



import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@SuppressWarnings("all")
public class PLSQLParser_PLSQLKeys extends Parser {
	public static final int EOF=-1;
	public static final int A=4;
	public static final int AMPERSAND=5;
	public static final int APPROXIMATE_NUM_LIT=6;
	public static final int ASSIGN_OP=7;
	public static final int ASTERISK=8;
	public static final int AT_SIGN=9;
	public static final int B=10;
	public static final int BINDVAR=11;
	public static final int BIT_STRING_LIT=12;
	public static final int C=13;
	public static final int CARRET_OPERATOR_PART=14;
	public static final int CHAR_STRING=15;
	public static final int CHAR_STRING_PERL=16;
	public static final int COLON=17;
	public static final int COMMA=18;
	public static final int COMMENT=19;
	public static final int COMMENT_FRAGMENT=20;
	public static final int CONCATENATION_OP=21;
	public static final int D=22;
	public static final int DELIMITED_ID=23;
	public static final int DOUBLE_ASTERISK=24;
	public static final int DOUBLE_PERIOD=25;
	public static final int E=26;
	public static final int EQUALS_OP=27;
	public static final int EXACT_NUM_LIT=28;
	public static final int EXCLAMATION_OPERATOR_PART=29;
	public static final int F=30;
	public static final int G=31;
	public static final int GREATER_THAN_OP=32;
	public static final int GREATER_THAN_OR_EQUALS_OP=33;
	public static final int H=34;
	public static final int HEX_STRING_LIT=35;
	public static final int I=36;
	public static final int INTRODUCER=37;
	public static final int J=38;
	public static final int K=39;
	public static final int L=40;
	public static final int LEFT_BRACKET=41;
	public static final int LEFT_PAREN=42;
	public static final int LESS_THAN_OP=43;
	public static final int LESS_THAN_OR_EQUALS_OP=44;
	public static final int M=45;
	public static final int MINUS_SIGN=46;
	public static final int N=47;
	public static final int NATIONAL_CHAR_STRING_LIT=48;
	public static final int NEWLINE=49;
	public static final int NOT_EQUAL_OP=50;
	public static final int O=51;
	public static final int P=52;
	public static final int PERCENT=53;
	public static final int PERIOD=54;
	public static final int PLSQL_NON_RESERVED_CONNECT_BY_ROOT=55;
	public static final int PLSQL_NON_RESERVED_ELSIF=56;
	public static final int PLSQL_NON_RESERVED_MODEL=57;
	public static final int PLSQL_NON_RESERVED_PIVOT=58;
	public static final int PLSQL_NON_RESERVED_UNPIVOT=59;
	public static final int PLSQL_NON_RESERVED_USING=60;
	public static final int PLSQL_RESERVED_CLUSTERS=61;
	public static final int PLSQL_RESERVED_COLAUTH=62;
	public static final int PLSQL_RESERVED_COMPRESS=63;
	public static final int PLSQL_RESERVED_CRASH=64;
	public static final int PLSQL_RESERVED_EXCLUSIVE=65;
	public static final int PLSQL_RESERVED_IDENTIFIED=66;
	public static final int PLSQL_RESERVED_IF=67;
	public static final int PLSQL_RESERVED_INDEX=68;
	public static final int PLSQL_RESERVED_INDEXES=69;
	public static final int PLSQL_RESERVED_LOCK=70;
	public static final int PLSQL_RESERVED_MINUS=71;
	public static final int PLSQL_RESERVED_MODE=72;
	public static final int PLSQL_RESERVED_NOCOMPRESS=73;
	public static final int PLSQL_RESERVED_NOWAIT=74;
	public static final int PLSQL_RESERVED_RESOURCE=75;
	public static final int PLSQL_RESERVED_SHARE=76;
	public static final int PLSQL_RESERVED_START=77;
	public static final int PLSQL_RESERVED_TABAUTH=78;
	public static final int PLSQL_RESERVED_VIEWS=79;
	public static final int PLUS_SIGN=80;
	public static final int PROMPT=81;
	public static final int Q=82;
	public static final int QS_ANGLE=83;
	public static final int QS_BRACE=84;
	public static final int QS_BRACK=85;
	public static final int QS_OTHER=86;
	public static final int QS_OTHER_CH=87;
	public static final int QS_PAREN=88;
	public static final int QUESTION_MARK=89;
	public static final int QUOTE=90;
	public static final int R=91;
	public static final int REGULAR_ID=92;
	public static final int RIGHT_BRACKET=93;
	public static final int RIGHT_PAREN=94;
	public static final int S=95;
	public static final int SEMICOLON=96;
	public static final int SEPARATOR=97;
	public static final int SIMPLE_LETTER=98;
	public static final int SOLIDUS=99;
	public static final int SPACE=100;
	public static final int SQL92_RESERVED_ALL=101;
	public static final int SQL92_RESERVED_ALTER=102;
	public static final int SQL92_RESERVED_AND=103;
	public static final int SQL92_RESERVED_ANY=104;
	public static final int SQL92_RESERVED_AS=105;
	public static final int SQL92_RESERVED_ASC=106;
	public static final int SQL92_RESERVED_BEGIN=107;
	public static final int SQL92_RESERVED_BETWEEN=108;
	public static final int SQL92_RESERVED_BY=109;
	public static final int SQL92_RESERVED_CASE=110;
	public static final int SQL92_RESERVED_CHECK=111;
	public static final int SQL92_RESERVED_CONNECT=112;
	public static final int SQL92_RESERVED_CREATE=113;
	public static final int SQL92_RESERVED_CURRENT=114;
	public static final int SQL92_RESERVED_CURSOR=115;
	public static final int SQL92_RESERVED_DATE=116;
	public static final int SQL92_RESERVED_DECLARE=117;
	public static final int SQL92_RESERVED_DEFAULT=118;
	public static final int SQL92_RESERVED_DELETE=119;
	public static final int SQL92_RESERVED_DESC=120;
	public static final int SQL92_RESERVED_DISTINCT=121;
	public static final int SQL92_RESERVED_DROP=122;
	public static final int SQL92_RESERVED_ELSE=123;
	public static final int SQL92_RESERVED_END=124;
	public static final int SQL92_RESERVED_EXCEPTION=125;
	public static final int SQL92_RESERVED_EXISTS=126;
	public static final int SQL92_RESERVED_FALSE=127;
	public static final int SQL92_RESERVED_FETCH=128;
	public static final int SQL92_RESERVED_FOR=129;
	public static final int SQL92_RESERVED_FROM=130;
	public static final int SQL92_RESERVED_GOTO=131;
	public static final int SQL92_RESERVED_GRANT=132;
	public static final int SQL92_RESERVED_GROUP=133;
	public static final int SQL92_RESERVED_HAVING=134;
	public static final int SQL92_RESERVED_IN=135;
	public static final int SQL92_RESERVED_INSERT=136;
	public static final int SQL92_RESERVED_INTERSECT=137;
	public static final int SQL92_RESERVED_INTO=138;
	public static final int SQL92_RESERVED_IS=139;
	public static final int SQL92_RESERVED_LIKE=140;
	public static final int SQL92_RESERVED_NOT=141;
	public static final int SQL92_RESERVED_NULL=142;
	public static final int SQL92_RESERVED_OF=143;
	public static final int SQL92_RESERVED_ON=144;
	public static final int SQL92_RESERVED_OPTION=145;
	public static final int SQL92_RESERVED_OR=146;
	public static final int SQL92_RESERVED_ORDER=147;
	public static final int SQL92_RESERVED_OVERLAPS=148;
	public static final int SQL92_RESERVED_PRIOR=149;
	public static final int SQL92_RESERVED_PROCEDURE=150;
	public static final int SQL92_RESERVED_PUBLIC=151;
	public static final int SQL92_RESERVED_REVOKE=152;
	public static final int SQL92_RESERVED_SELECT=153;
	public static final int SQL92_RESERVED_SIZE=154;
	public static final int SQL92_RESERVED_TABLE=155;
	public static final int SQL92_RESERVED_THE=156;
	public static final int SQL92_RESERVED_THEN=157;
	public static final int SQL92_RESERVED_TO=158;
	public static final int SQL92_RESERVED_TRUE=159;
	public static final int SQL92_RESERVED_UNION=160;
	public static final int SQL92_RESERVED_UNIQUE=161;
	public static final int SQL92_RESERVED_UPDATE=162;
	public static final int SQL92_RESERVED_VALUES=163;
	public static final int SQL92_RESERVED_VIEW=164;
	public static final int SQL92_RESERVED_WHEN=165;
	public static final int SQL92_RESERVED_WHERE=166;
	public static final int SQL92_RESERVED_WITH=167;
	public static final int T=168;
	public static final int TILDE_OPERATOR_PART=169;
	public static final int U=170;
	public static final int UNDERSCORE=171;
	public static final int UNSIGNED_INTEGER=172;
	public static final int V=173;
	public static final int VERTICAL_BAR=174;
	public static final int W=175;
	public static final int X=176;
	public static final int Y=177;
	public static final int Z=178;
	public static final int ZV=179;
	public static final int ADD_VK=180;
	public static final int AFTER_EACH_ROW=181;
	public static final int AFTER_STATEMENT=182;
	public static final int AFTER_VK=183;
	public static final int AGENT_VK=184;
	public static final int AGGREGATE_VK=185;
	public static final int ALTER_ATTRIBUTE=186;
	public static final int ALTER_COLLECTION=187;
	public static final int ALTER_FUNCTION=188;
	public static final int ALTER_METHOD=189;
	public static final int ALTER_METHOD_ELEMENT=190;
	public static final int ALTER_PACKAGE=191;
	public static final int ALTER_PROCEDURE=192;
	public static final int ALTER_SEQUENCE=193;
	public static final int ALTER_TRIGGER=194;
	public static final int ALTER_TYPE=195;
	public static final int ANALYZE_VK=196;
	public static final int ANY_ELEMENT=197;
	public static final int ANY_MODE=198;
	public static final int ARGUMENT=200;
	public static final int ARGUMENTS=201;
	public static final int ASSIGN=202;
	public static final int ASSOCIATE_VK=203;
	public static final int ATTRIBUTE=205;
	public static final int ATTRIBUTES=206;
	public static final int ATTRIBUTE_NAME=207;
	public static final int AT_VK=209;
	public static final int AUDIT_VK=210;
	public static final int AUTHID_VK=211;
	public static final int AUTOMATIC_VK=212;
	public static final int AUTONOMOUS_TRANSACTION_VK=213;
	public static final int AUTO_VK=214;
	public static final int BATCH_VK=215;
	public static final int BEFORE_EACH_ROW=216;
	public static final int BEFORE_STATEMENT=217;
	public static final int BEFORE_VK=218;
	public static final int BFILE_VK=219;
	public static final int BINARY_DOUBLE_VK=220;
	public static final int BINARY_FLOAT_VK=221;
	public static final int BINARY_INTEGER_VK=222;
	public static final int BIT_VK=224;
	public static final int BLOB_VK=225;
	public static final int BLOCK=226;
	public static final int BLOCK_VK=227;
	public static final int BODY=228;
	public static final int BODY_MODE=229;
	public static final int BODY_VK=230;
	public static final int BOOLEAN_VK=231;
	public static final int BOTH_VK=232;
	public static final int BREADTH_VK=233;
	public static final int BULK_VK=234;
	public static final int BYTE_VK=235;
	public static final int CACHE_VK=236;
	public static final int CALL_MODE=237;
	public static final int CALL_VK=238;
	public static final int CANONICAL_VK=239;
	public static final int CASCADE_VK=241;
	public static final int CASCATED_ELEMENT=242;
	public static final int CAST_VK=243;
	public static final int CHARACTER_VK=244;
	public static final int CHAR_CS_VK=245;
	public static final int CHAR_SET_NAME=246;
	public static final int CHAR_VK=249;
	public static final int CHR_VK=250;
	public static final int CLOB_VK=251;
	public static final int CLOSE_VK=252;
	public static final int CLUSTER_VK=253;
	public static final int COLLECTION_MODE=254;
	public static final int COLLECTION_NAME=255;
	public static final int COLLECT_VK=256;
	public static final int COLUMNS=258;
	public static final int COLUMN_ALIAS=259;
	public static final int COLUMN_NAME=260;
	public static final int COMMENT_VK=262;
	public static final int COMMITTED_VK=263;
	public static final int COMMIT_VK=264;
	public static final int COMPATIBILITY_VK=265;
	public static final int COMPILATION_UNIT=266;
	public static final int COMPILER_PARAMETER=267;
	public static final int COMPILE_VK=268;
	public static final int COMPOUND_DML=269;
	public static final int COMPOUND_VK=270;
	public static final int CONDITIONAL_INSERT=272;
	public static final int CONSTANT_NEGATED=273;
	public static final int CONSTANT_VK=274;
	public static final int CONSTRAINT_NAME=275;
	public static final int CONSTRAINT_STATE=276;
	public static final int CONSTRAINT_VK=277;
	public static final int CONSTRUCTOR_SPEC=278;
	public static final int CONSTRUCTOR_VK=279;
	public static final int CONTENT_VK=280;
	public static final int CONTEXT_VK=281;
	public static final int CONTINUE_VK=282;
	public static final int CONVERT_VK=283;
	public static final int CORRUPT_XID_ALL_VK=284;
	public static final int CORRUPT_XID_VK=285;
	public static final int COST_CLASS_NAME=286;
	public static final int COST_VK=287;
	public static final int COUNT_VK=288;
	public static final int CREATE_FUNCTION=289;
	public static final int CREATE_PACKAGE_BODY=290;
	public static final int CREATE_PACKAGE_SPEC=291;
	public static final int CREATE_PROCEDURE=292;
	public static final int CREATE_SEQUENCE=293;
	public static final int CREATE_TRIGGER=294;
	public static final int CREATE_TYPE_BODY=295;
	public static final int CREATE_TYPE_SPEC=296;
	public static final int CREATE_VIEW=297;
	public static final int CROSS_VK=298;
	public static final int CUBE_VK=299;
	public static final int CURRENT_USER_VK=300;
	public static final int CURRENT_VK=301;
	public static final int CURSOR_BASED_FOR=302;
	public static final int CURSOR_DECLARE=303;
	public static final int CURSOR_NAME=304;
	public static final int CUSTOMDATUM_VK=305;
	public static final int CUSTOM_TYPE=306;
	public static final int CYCLE_VK=307;
	public static final int C_VK=308;
	public static final int DATABASE_VK=309;
	public static final int DATETIME_OP=310;
	public static final int DAY_VK=311;
	public static final int DBTIMEZONE_VK=312;
	public static final int DB_ROLE_CHANGE_VK=313;
	public static final int DDL_VK=314;
	public static final int DEBUG_VK=315;
	public static final int DECIMAL_VK=316;
	public static final int DECOMPOSE_VK=317;
	public static final int DECREMENT_VK=318;
	public static final int DEC_VK=319;
	public static final int DEFAULTS_VK=320;
	public static final int DEFAULT_VALUE=321;
	public static final int DEFERRABLE_VK=322;
	public static final int DEFERRED_VK=323;
	public static final int DEFINER_VK=324;
	public static final int DENSE_RANK_VK=326;
	public static final int DEPENDENT_HANDLING=327;
	public static final int DEPTH_VK=328;
	public static final int DETERMINISTIC_VK=329;
	public static final int DIMENSION_VK=330;
	public static final int DIRECT_MODE=331;
	public static final int DISABLE_VK=332;
	public static final int DISASSOCIATE_VK=333;
	public static final int DIV_VK=334;
	public static final int DML_EVENT=335;
	public static final int DML_EVENT_ELEMENT=336;
	public static final int DOCUMENT_VK=337;
	public static final int DOT_ASTERISK=338;
	public static final int DOUBLE_VK=339;
	public static final int DROP_FUNCTION=340;
	public static final int DROP_PACKAGE=341;
	public static final int DROP_PROCEDURE=342;
	public static final int DROP_SEQUENCE=343;
	public static final int DROP_TRIGGER=344;
	public static final int DROP_TYPE=345;
	public static final int DSINTERVAL_UNCONSTRAINED_VK=346;
	public static final int DYNAMIC_RETURN=347;
	public static final int ELEMENT=348;
	public static final int ELEMENTS_MODE=349;
	public static final int ELEMENT_SPEC=350;
	public static final int ENABLE_VK=351;
	public static final int ENCODING_VK=352;
	public static final int ENTITYESCAPING_VK=353;
	public static final int EVALNAME_VK=355;
	public static final int EXCEPTIONS_VK=357;
	public static final int EXCEPTION_DECLARE=358;
	public static final int EXCEPTION_INIT_VK=359;
	public static final int EXCEPTION_NAME=360;
	public static final int EXCLUDE_VK=362;
	public static final int EXECUTE_VK=363;
	public static final int EXIT_VK=364;
	public static final int EXPLAIN_STATEMENT=365;
	public static final int EXPR=366;
	public static final int EXPR_LIST=367;
	public static final int EXTERNAL_MODE=368;
	public static final int EXTERNAL_VK=369;
	public static final int EXTRACT_VK=370;
	public static final int FACTORING=371;
	public static final int FAILURE_VK=372;
	public static final int FIELDS=373;
	public static final int FIELD_SPEC=374;
	public static final int FINAL_VK=375;
	public static final int FIRST_VALUE_VK=376;
	public static final int FIRST_VK=377;
	public static final int FLOAT_VK=378;
	public static final int FOLLOWING_VK=379;
	public static final int FOLLOWS_VK=380;
	public static final int FORALL_VK=381;
	public static final int FORCE_VK=382;
	public static final int FOREIGN_KEY=383;
	public static final int FOREIGN_VK=384;
	public static final int FOR_EACH_ROW=385;
	public static final int FOR_LOOP=386;
	public static final int FOR_MULTI_COLUMN=387;
	public static final int FOR_SINGLE_COLUMN=388;
	public static final int FULL_VK=389;
	public static final int FUNCTION_ENABLING_OVER=390;
	public static final int FUNCTION_ENABLING_USING=391;
	public static final int FUNCTION_ENABLING_WITHIN_OR_OVER=392;
	public static final int FUNCTION_NAME=393;
	public static final int FUNCTION_SPEC=394;
	public static final int GROUPING_VK=397;
	public static final int GROUPIN_SET=398;
	public static final int GROUP_BY_ELEMENT=399;
	public static final int HASH_VK=400;
	public static final int HIDE_VK=401;
	public static final int HIERARCHICAL=402;
	public static final int HOSTED_VARIABLE=403;
	public static final int HOSTED_VARIABLE_NAME=404;
	public static final int HOSTED_VARIABLE_ROUTINE_CALL=405;
	public static final int HOUR_VK=406;
	public static final int ID=407;
	public static final int IGNORE_VK=408;
	public static final int IMMEDIATE_VK=409;
	public static final int IMPLEMENTATION_TYPE_NAME=410;
	public static final int INCLUDE_VK=411;
	public static final int INCLUDING_VK=412;
	public static final int INCREMENT_VK=413;
	public static final int INDENT_VK=414;
	public static final int INDEXED_BY=415;
	public static final int INDEXED_FOR=416;
	public static final int INDEX_NAME=417;
	public static final int INDICES_BOUND=418;
	public static final int INITIALLY_VK=419;
	public static final int INLINE_CONSTRAINT_CLAUSE=420;
	public static final int INLINE_VK=421;
	public static final int INNER_VK=422;
	public static final int INOUT_VK=423;
	public static final int INSTANTIABLE_VK=424;
	public static final int INSTEAD_VK=425;
	public static final int INTEGER_VK=426;
	public static final int INTERVAL_DATATYPE=427;
	public static final int INT_VK=429;
	public static final int INVALIDATE_VK=430;
	public static final int ISOLATION_VK=431;
	public static final int IS_A_SET=432;
	public static final int IS_EMPTY=433;
	public static final int IS_INFINITE=434;
	public static final int IS_NAN=435;
	public static final int IS_NOT_A_SET=436;
	public static final int IS_NOT_EMPTY=437;
	public static final int IS_NOT_INFINITE=438;
	public static final int IS_NOT_NAN=439;
	public static final int IS_NOT_NULL=440;
	public static final int IS_NOT_OF_TYPE=441;
	public static final int IS_NOT_PRESENT=442;
	public static final int IS_NULL=443;
	public static final int IS_OF_TYPE=444;
	public static final int IS_PRESENT=445;
	public static final int ITERATE_VK=446;
	public static final int JAVA_VK=447;
	public static final int JOIN_DEF=448;
	public static final int KEEP_VK=449;
	public static final int KEY_VK=450;
	public static final int LABEL_DECLARE=451;
	public static final int LABEL_NAME=452;
	public static final int LANGUAGE_VK=453;
	public static final int LAST_VALUE_VK=454;
	public static final int LAST_VK=455;
	public static final int LEADING_VK=456;
	public static final int LEFT_VK=459;
	public static final int LIBRARY_VK=462;
	public static final int LIKE2_VK=463;
	public static final int LIKE4_VK=464;
	public static final int LIKEC_VK=465;
	public static final int LIMIT_VK=466;
	public static final int LINK_NAME=467;
	public static final int LOCAL_VK=468;
	public static final int LOCK_TABLE_ELEMENT=469;
	public static final int LOGIC_EXPR=470;
	public static final int LOGOFF_VK=471;
	public static final int LOGON_VK=472;
	public static final int LOG_VK=473;
	public static final int LONG_RAW=474;
	public static final int LONG_VK=475;
	public static final int LOOP_VK=476;
	public static final int MAIN_MODEL=477;
	public static final int MAIN_MODEL_NAME=478;
	public static final int MAP_VK=479;
	public static final int MAXVALUE_VK=480;
	public static final int MEASURES_VK=481;
	public static final int MEMBER_VK=482;
	public static final int MERGE_INSERT=483;
	public static final int MERGE_UPDATE=484;
	public static final int MERGE_VK=485;
	public static final int MINUTE_VK=487;
	public static final int MINVALUE_VK=488;
	public static final int MLSLABEL_VK=489;
	public static final int MODEL_COLUMN=490;
	public static final int MODEL_COLUMNS=491;
	public static final int MODEL_EXPRESSION=492;
	public static final int MODEL_RULE=493;
	public static final int MODEL_RULES=494;
	public static final int MODIFIER=495;
	public static final int MODIFY_VK=496;
	public static final int MOD_VK=497;
	public static final int MONTH_VK=498;
	public static final int MULTI_TABLE_MODE=499;
	public static final int NAME_VK=500;
	public static final int NATIVE_DATATYPE=502;
	public static final int NATURALN_VK=503;
	public static final int NATURAL_VK=504;
	public static final int NAV_VK=505;
	public static final int NCHAR_CS_VK=506;
	public static final int NCHAR_VK=507;
	public static final int NCLOB_VK=508;
	public static final int NESTED_TABLE_TYPE_DEF=509;
	public static final int NESTED_VK=510;
	public static final int NEW_VK=511;
	public static final int NOAUDIT_VK=512;
	public static final int NOCACHE_VK=513;
	public static final int NOCOPY_VK=514;
	public static final int NOCYCLE_VK=515;
	public static final int NOENTITYESCAPING_VK=516;
	public static final int NOFORCE=517;
	public static final int NOMAXVALUE_VK=518;
	public static final int NOMINVALUE_VK=519;
	public static final int NONE_VK=520;
	public static final int NON_DML=521;
	public static final int NOORDER_VK=522;
	public static final int NORELY_VK=523;
	public static final int NOSCHEMACHECK_VK=524;
	public static final int NOT_BETWEEN=525;
	public static final int NOT_DEFERRABLE=526;
	public static final int NOT_IN=528;
	public static final int NOT_LIKE=529;
	public static final int NOT_NULL=530;
	public static final int NOVALIDATE_VK=531;
	public static final int NO_VK=532;
	public static final int NULLS_VK=533;
	public static final int NUMBER_VK=534;
	public static final int NUMERIC_VK=535;
	public static final int NVARCHAR2_VK=536;
	public static final int OBJECT_AS=537;
	public static final int OBJECT_MEMBERS=538;
	public static final int OBJECT_TYPE_DEF=539;
	public static final int OBJECT_VK=540;
	public static final int OFF_VK=541;
	public static final int OLD_VK=542;
	public static final int ONLY_VK=543;
	public static final int ON_DELETE=544;
	public static final int OPEN_FOR=545;
	public static final int OPEN_VK=546;
	public static final int ORADATA_VK=547;
	public static final int ORDER_BY_ELEMENT=548;
	public static final int ORDER_BY_ELEMENTS=549;
	public static final int ORDINALITY_VK=550;
	public static final int OSERROR_VK=551;
	public static final int OUTER_JOIN_SIGN=552;
	public static final int OUT_OF_LINE_CONSTRAINT=553;
	public static final int OUT_VK=554;
	public static final int OVERRIDING_VK=555;
	public static final int OVER_VK=556;
	public static final int PACKAGE_NAME=557;
	public static final int PACKAGE_VK=558;
	public static final int PARALLEL_ENABLE_VK=559;
	public static final int PARAMETER=560;
	public static final int PARAMETERS=561;
	public static final int PARAMETERS_VK=562;
	public static final int PARAMETER_NAME=563;
	public static final int PARENT_VK=564;
	public static final int PARTITION_VK=565;
	public static final int PASSING_VK=566;
	public static final int PERCENT_FOUND_VK=568;
	public static final int PERCENT_ISOPEN_VK=569;
	public static final int PERCENT_NOTFOUND_VK=570;
	public static final int PERCENT_ROWCOUNT_VK=571;
	public static final int PERCENT_ROWTYPE_VK=572;
	public static final int PERCENT_TYPE_VK=573;
	public static final int PIPELINED_VK=575;
	public static final int PIPE_ROW=576;
	public static final int PIPE_VK=577;
	public static final int PIVOT_ALIAS=578;
	public static final int PIVOT_ELEMENT=579;
	public static final int PIVOT_IN_ELEMENT=580;
	public static final int PIVOT_VK=581;
	public static final int PLS_INTEGER_VK=596;
	public static final int POSITIVEN_VK=598;
	public static final int POSITIVE_VK=599;
	public static final int PRAGMA_DECLARE=600;
	public static final int PRAGMA_VK=601;
	public static final int PRECEDING_VK=602;
	public static final int PRECISION=603;
	public static final int PRECISION_VK=604;
	public static final int PREDICTION_FUNCTION=605;
	public static final int PRIMARY_KEY=606;
	public static final int PRIMARY_VK=607;
	public static final int PROCEDURE_NAME=608;
	public static final int PROCEDURE_SPEC=609;
	public static final int QUERY_NAME=611;
	public static final int QUERY_PARTITION_CLAUSE_SPEC_EXPRESSIONS=612;
	public static final int RAISE_VK=613;
	public static final int RANGE_VK=614;
	public static final int RAW_VK=615;
	public static final int READ_VK=616;
	public static final int REAL_VK=617;
	public static final int RECORD_NAME=618;
	public static final int RECORD_TYPE_DECLARE_FIELDS=619;
	public static final int RECORD_TYPE_DECLARE_REFCURSOR=620;
	public static final int RECORD_VAR_DECLARE=621;
	public static final int RECURSIVE_VK=622;
	public static final int REFERENCES_CLAUSE=623;
	public static final int REFERENCES_VK=624;
	public static final int REFERENCE_MODEL_NAME=625;
	public static final int REFERENCE_VK=626;
	public static final int REFERENCING_VK=627;
	public static final int REF_VK=628;
	public static final int REJECT_VK=630;
	public static final int RELIES_ON_VK=631;
	public static final int RELY_VK=632;
	public static final int RENAME_VK=633;
	public static final int REPLACE_VK=634;
	public static final int RESPECT_VK=635;
	public static final int RESTRICT_REFERENCES_VK=636;
	public static final int RESULT_CACHE_VK=637;
	public static final int RETURN_VK=638;
	public static final int REUSE_VK=639;
	public static final int REVERSE_VK=640;
	public static final int RIGHT_VK=643;
	public static final int ROLLBACK_SEGMENT_NAME=644;
	public static final int ROLLBACK_VK=645;
	public static final int ROLLUP_VK=646;
	public static final int ROUTINE_CALL=647;
	public static final int ROUTINE_NAME=648;
	public static final int ROWID_VK=649;
	public static final int ROWS_VK=650;
	public static final int ROW_VK=651;
	public static final int RULES_VK=652;
	public static final int SAMPLE_VK=653;
	public static final int SAVEPOINT_NAME=654;
	public static final int SAVEPOINT_VK=655;
	public static final int SCHEMACHECK_VK=656;
	public static final int SCHEMA_NAME=657;
	public static final int SCHEMA_VK=658;
	public static final int SCN_VK=659;
	public static final int SEARCHED_CASE=660;
	public static final int SEARCH_VK=661;
	public static final int SECOND_VK=662;
	public static final int SEED_VK=663;
	public static final int SELECTED_TABLEVIEW=664;
	public static final int SELECT_BASED_FOR=665;
	public static final int SELECT_ITEM=666;
	public static final int SELECT_LIST=667;
	public static final int SELECT_MODE=668;
	public static final int SELECT_STATEMENT=669;
	public static final int SELF_VK=670;
	public static final int SEQUENCE_NAME=672;
	public static final int SEQUENCE_VK=673;
	public static final int SEQUENTIAL_VK=674;
	public static final int SERIALIZABLE_VK=675;
	public static final int SERIALLY_REUSABLE_VK=676;
	public static final int SERVERERROR_VK=677;
	public static final int SESSIONTIMEZONE_VK=678;
	public static final int SET_CONSTRAINT=679;
	public static final int SET_NULL=680;
	public static final int SET_SERVEROUTPUT=681;
	public static final int SET_TRANSACTION=682;
	public static final int SET_VK=683;
	public static final int SHOW_VK=684;
	public static final int SHUTDOWN_VK=685;
	public static final int SIBLINGS_VK=686;
	public static final int SIGNTYPE_VK=687;
	public static final int SIMPLE_BOUND=688;
	public static final int SIMPLE_CASE=689;
	public static final int SIMPLE_DML=690;
	public static final int SIMPLE_INTEGER_VK=691;
	public static final int SINGLE_TABLE_MODE=692;
	public static final int SINGLE_VK=693;
	public static final int SKIP_VK=694;
	public static final int SMALLINT_VK=695;
	public static final int SOME_VK=697;
	public static final int SPECIFICATION_VK=698;
	public static final int SQLDATA_VK=764;
	public static final int SQLERROR_VK=765;
	public static final int SQL_SCRIPT=766;
	public static final int STANDALONE_VK=767;
	public static final int STANDARD_FUNCTION=768;
	public static final int STARTUP_VK=769;
	public static final int STATEMENTS=770;
	public static final int STATIC_RETURNING=771;
	public static final int STATIC_VK=772;
	public static final int STATISTICS_VK=773;
	public static final int STREAMING_CLAUSE=774;
	public static final int STRING_VK=775;
	public static final int SUBMULTISET_VK=776;
	public static final int SUBPARTITION_VK=777;
	public static final int SUBQUERY=778;
	public static final int SUBTYPE_DECLARE=779;
	public static final int SUCCESS_VK=780;
	public static final int SUSPEND_VK=781;
	public static final int TABLEVIEW_NAME=782;
	public static final int TABLE_ALIAS=783;
	public static final int TABLE_ELEMENT=784;
	public static final int TABLE_EXPRESSION=785;
	public static final int TABLE_REF=786;
	public static final int TABLE_REF_ELEMENT=787;
	public static final int TABLE_TYPE_DECLARE=788;
	public static final int TABLE_VAR_DECLARE=789;
	public static final int TABLE_VAR_NAME=790;
	public static final int THREE_DOTS=791;
	public static final int TIMESTAMP_LTZ_UNCONSTRAINED_VK=792;
	public static final int TIMESTAMP_TZ_UNCONSTRAINED_VK=793;
	public static final int TIMESTAMP_UNCONSTRAINED_VK=794;
	public static final int TIMESTAMP_VK=795;
	public static final int TIMEZONE_ABBR_VK=796;
	public static final int TIMEZONE_HOUR_VK=797;
	public static final int TIMEZONE_MINUTE_VK=798;
	public static final int TIMEZONE_REGION_VK=799;
	public static final int TIME_VK=800;
	public static final int TRAILING_VK=801;
	public static final int TRANSLATE_VK=802;
	public static final int TREAT_VK=803;
	public static final int TRIGGER_NAME=804;
	public static final int TRIM_VK=805;
	public static final int TRUNCATE_VK=806;
	public static final int TYPE_BODY_ELEMENTS=807;
	public static final int TYPE_NAME=808;
	public static final int TYPE_VK=809;
	public static final int UNARY_MINUS=810;
	public static final int UNARY_PLUS=811;
	public static final int UNBOUNDED_VK=812;
	public static final int UNDER_VK=813;
	public static final int UNLIMITED_VK=814;
	public static final int UNPIVOT_IN_ELEMENT=815;
	public static final int UNPIVOT_VK=816;
	public static final int UNTIL_VK=818;
	public static final int UPDATED_VK=819;
	public static final int UPSERT_VK=820;
	public static final int UROWID_VK=821;
	public static final int USING_INDEX=822;
	public static final int USING_MODE=823;
	public static final int VALIDATE_VK=824;
	public static final int VALUES_BOUND=825;
	public static final int VALUE_VK=826;
	public static final int VARCHAR2_VK=827;
	public static final int VARCHAR_VK=828;
	public static final int VARIABLE_DECLARE=829;
	public static final int VARIABLE_NAME=830;
	public static final int VARR_ARRAY_DEF=831;
	public static final int VECTOR_EXPR=832;
	public static final int VERSIONS_VK=833;
	public static final int VERSION_VK=834;
	public static final int VIEW_NAME=836;
	public static final int VIEW_TYPE_CONSTRAINTS=837;
	public static final int VIEW_TYPE_CONSTRAINT_ITEM_INLINE=838;
	public static final int WAIT_VK=839;
	public static final int WARNING_VK=840;
	public static final int WELLFORMED_VK=841;
	public static final int WHENEVER_VK=842;
	public static final int WHILE_LOOP=843;
	public static final int WITHIN_VK=844;
	public static final int WORK_VK=845;
	public static final int WRITE_VK=846;
	public static final int XMLAGG_VK=847;
	public static final int XMLATTRIBUTES_VK=848;
	public static final int XMLCAST_VK=849;
	public static final int XMLCOLATTVAL_VK=850;
	public static final int XMLELEMENT_VK=851;
	public static final int XMLEXISTS_VK=852;
	public static final int XMLFOREST_VK=853;
	public static final int XMLNAMESPACES_VK=854;
	public static final int XMLPARSE_VK=855;
	public static final int XMLPI_VK=856;
	public static final int XMLQUERY_VK=857;
	public static final int XMLROOT_VK=858;
	public static final int XMLSERIALIZE_VK=859;
	public static final int XMLTABLE_VK=860;
	public static final int XML_ALIAS=861;
	public static final int XML_COLUMN=862;
	public static final int XML_COLUMN_NAME=863;
	public static final int XML_ELEMENT=864;
	public static final int XML_VK=865;
	public static final int YEAR_VK=866;
	public static final int YES_VK=867;
	public static final int YMINTERVAL_UNCONSTRAINED_VK=868;

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators
	public PLSQLParser gPLSQLParser;
	public PLSQLParser gParent;


	public PLSQLParser_PLSQLKeys(TokenStream input, PLSQLParser gPLSQLParser) {
		this(input, new RecognizerSharedState(), gPLSQLParser);
	}
	public PLSQLParser_PLSQLKeys(TokenStream input, RecognizerSharedState state, PLSQLParser gPLSQLParser) {
		super(input, state);
		this.gPLSQLParser = gPLSQLParser;
		gParent = gPLSQLParser;
	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return PLSQLParser.tokenNames; }
	@Override public String getGrammarFileName() { return "PLSQLKeys.g"; }


	public static class create_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "create_key"
	// PLSQLKeys.g:366:1: create_key : SQL92_RESERVED_CREATE ;
	public final PLSQLParser_PLSQLKeys.create_key_return create_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.create_key_return retval = new PLSQLParser_PLSQLKeys.create_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CREATE1=null;

		Object SQL92_RESERVED_CREATE1_tree=null;

		try {
			// PLSQLKeys.g:367:5: ( SQL92_RESERVED_CREATE )
			// PLSQLKeys.g:367:10: SQL92_RESERVED_CREATE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CREATE1=(Token)match(input,SQL92_RESERVED_CREATE,FOLLOW_SQL92_RESERVED_CREATE_in_create_key2413); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CREATE1_tree = (Object)adaptor.create(SQL92_RESERVED_CREATE1);
			adaptor.addChild(root_0, SQL92_RESERVED_CREATE1_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "create_key"


	public static class replace_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "replace_key"
	// PLSQLKeys.g:370:1: replace_key :{...}? => REGULAR_ID -> REPLACE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.replace_key_return replace_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.replace_key_return retval = new PLSQLParser_PLSQLKeys.replace_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID2=null;

		Object REGULAR_ID2_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:371:5: ({...}? => REGULAR_ID -> REPLACE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:371:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("replace"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "replace_key", "input.LT(1).getText().equalsIgnoreCase(\"replace\")");
			}
			REGULAR_ID2=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_replace_key2440); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID2);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 371:76: -> REPLACE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REPLACE_VK, REGULAR_ID2));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "replace_key"


	public static class package_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "package_key"
	// PLSQLKeys.g:374:1: package_key :{...}? => REGULAR_ID -> PACKAGE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.package_key_return package_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.package_key_return retval = new PLSQLParser_PLSQLKeys.package_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID3=null;

		Object REGULAR_ID3_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:375:5: ({...}? => REGULAR_ID -> PACKAGE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:375:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("package"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "package_key", "input.LT(1).getText().equalsIgnoreCase(\"package\")");
			}
			REGULAR_ID3=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_package_key2468); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID3);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 375:76: -> PACKAGE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PACKAGE_VK, REGULAR_ID3));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "package_key"


	public static class body_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "body_key"
	// PLSQLKeys.g:378:1: body_key :{...}? REGULAR_ID -> BODY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.body_key_return body_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.body_key_return retval = new PLSQLParser_PLSQLKeys.body_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID4=null;

		Object REGULAR_ID4_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:379:5: ({...}? REGULAR_ID -> BODY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:379:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("body"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "body_key", "input.LT(1).getText().equalsIgnoreCase(\"body\")");
			}
			REGULAR_ID4=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_body_key2495); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID4);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 379:71: -> BODY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BODY_VK, REGULAR_ID4));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "body_key"


	public static class begin_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "begin_key"
	// PLSQLKeys.g:382:1: begin_key : SQL92_RESERVED_BEGIN ;
	public final PLSQLParser_PLSQLKeys.begin_key_return begin_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.begin_key_return retval = new PLSQLParser_PLSQLKeys.begin_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_BEGIN5=null;

		Object SQL92_RESERVED_BEGIN5_tree=null;

		try {
			// PLSQLKeys.g:383:5: ( SQL92_RESERVED_BEGIN )
			// PLSQLKeys.g:383:10: SQL92_RESERVED_BEGIN
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_BEGIN5=(Token)match(input,SQL92_RESERVED_BEGIN,FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key2520); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_BEGIN5_tree = (Object)adaptor.create(SQL92_RESERVED_BEGIN5);
			adaptor.addChild(root_0, SQL92_RESERVED_BEGIN5_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "begin_key"


	public static class exit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exit_key"
	// PLSQLKeys.g:386:1: exit_key :{...}? REGULAR_ID -> EXIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.exit_key_return exit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exit_key_return retval = new PLSQLParser_PLSQLKeys.exit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID6=null;

		Object REGULAR_ID6_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:386:9: ({...}? REGULAR_ID -> EXIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:386:14: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("exit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "exit_key", "input.LT(1).getText().equalsIgnoreCase(\"exit\")");
			}
			REGULAR_ID6=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_exit_key2537); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID6);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 386:75: -> EXIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXIT_VK, REGULAR_ID6));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exit_key"


	public static class declare_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "declare_key"
	// PLSQLKeys.g:389:1: declare_key : SQL92_RESERVED_DECLARE ;
	public final PLSQLParser_PLSQLKeys.declare_key_return declare_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.declare_key_return retval = new PLSQLParser_PLSQLKeys.declare_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DECLARE7=null;

		Object SQL92_RESERVED_DECLARE7_tree=null;

		try {
			// PLSQLKeys.g:390:5: ( SQL92_RESERVED_DECLARE )
			// PLSQLKeys.g:390:10: SQL92_RESERVED_DECLARE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DECLARE7=(Token)match(input,SQL92_RESERVED_DECLARE,FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key2562); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DECLARE7_tree = (Object)adaptor.create(SQL92_RESERVED_DECLARE7);
			adaptor.addChild(root_0, SQL92_RESERVED_DECLARE7_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "declare_key"


	public static class exception_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exception_key"
	// PLSQLKeys.g:393:1: exception_key : SQL92_RESERVED_EXCEPTION ;
	public final PLSQLParser_PLSQLKeys.exception_key_return exception_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exception_key_return retval = new PLSQLParser_PLSQLKeys.exception_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_EXCEPTION8=null;

		Object SQL92_RESERVED_EXCEPTION8_tree=null;

		try {
			// PLSQLKeys.g:394:5: ( SQL92_RESERVED_EXCEPTION )
			// PLSQLKeys.g:394:10: SQL92_RESERVED_EXCEPTION
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_EXCEPTION8=(Token)match(input,SQL92_RESERVED_EXCEPTION,FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key2582); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_EXCEPTION8_tree = (Object)adaptor.create(SQL92_RESERVED_EXCEPTION8);
			adaptor.addChild(root_0, SQL92_RESERVED_EXCEPTION8_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exception_key"


	public static class serveroutput_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "serveroutput_key"
	// PLSQLKeys.g:397:1: serveroutput_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.serveroutput_key_return serveroutput_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.serveroutput_key_return retval = new PLSQLParser_PLSQLKeys.serveroutput_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID9=null;

		Object REGULAR_ID9_tree=null;

		try {
			// PLSQLKeys.g:398:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:398:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("serveroutput"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "serveroutput_key", "input.LT(1).getText().equalsIgnoreCase(\"serveroutput\")");
			}
			REGULAR_ID9=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_serveroutput_key2604); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID9_tree = (Object)adaptor.create(REGULAR_ID9);
			adaptor.addChild(root_0, REGULAR_ID9_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "serveroutput_key"


	public static class off_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "off_key"
	// PLSQLKeys.g:401:1: off_key :{...}? REGULAR_ID -> OFF_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.off_key_return off_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.off_key_return retval = new PLSQLParser_PLSQLKeys.off_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID10=null;

		Object REGULAR_ID10_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:402:5: ({...}? REGULAR_ID -> OFF_VK[$REGULAR_ID] )
			// PLSQLKeys.g:402:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("off"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "off_key", "input.LT(1).getText().equalsIgnoreCase(\"off\")");
			}
			REGULAR_ID10=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_off_key2626); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID10);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 402:70: -> OFF_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OFF_VK, REGULAR_ID10));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "off_key"


	public static class constant_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "constant_key"
	// PLSQLKeys.g:405:1: constant_key :{...}? REGULAR_ID -> CONSTANT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.constant_key_return constant_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.constant_key_return retval = new PLSQLParser_PLSQLKeys.constant_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID11=null;

		Object REGULAR_ID11_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:406:5: ({...}? REGULAR_ID -> CONSTANT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:406:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("constant"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "constant_key", "input.LT(1).getText().equalsIgnoreCase(\"constant\")");
			}
			REGULAR_ID11=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_constant_key2653); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID11);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 406:75: -> CONSTANT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONSTANT_VK, REGULAR_ID11));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constant_key"


	public static class subtype_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subtype_key"
	// PLSQLKeys.g:409:1: subtype_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.subtype_key_return subtype_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.subtype_key_return retval = new PLSQLParser_PLSQLKeys.subtype_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID12=null;

		Object REGULAR_ID12_tree=null;

		try {
			// PLSQLKeys.g:410:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:410:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("subtype"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "subtype_key", "input.LT(1).getText().equalsIgnoreCase(\"subtype\")");
			}
			REGULAR_ID12=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_subtype_key2680); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID12_tree = (Object)adaptor.create(REGULAR_ID12);
			adaptor.addChild(root_0, REGULAR_ID12_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subtype_key"


	public static class cursor_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cursor_key"
	// PLSQLKeys.g:413:1: cursor_key : SQL92_RESERVED_CURSOR ;
	public final PLSQLParser_PLSQLKeys.cursor_key_return cursor_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cursor_key_return retval = new PLSQLParser_PLSQLKeys.cursor_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CURSOR13=null;

		Object SQL92_RESERVED_CURSOR13_tree=null;

		try {
			// PLSQLKeys.g:414:5: ( SQL92_RESERVED_CURSOR )
			// PLSQLKeys.g:414:10: SQL92_RESERVED_CURSOR
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CURSOR13=(Token)match(input,SQL92_RESERVED_CURSOR,FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key2700); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CURSOR13_tree = (Object)adaptor.create(SQL92_RESERVED_CURSOR13);
			adaptor.addChild(root_0, SQL92_RESERVED_CURSOR13_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cursor_key"


	public static class nextval_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nextval_key"
	// PLSQLKeys.g:417:1: nextval_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.nextval_key_return nextval_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nextval_key_return retval = new PLSQLParser_PLSQLKeys.nextval_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID14=null;

		Object REGULAR_ID14_tree=null;

		try {
			// PLSQLKeys.g:418:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:418:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("nextval"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nextval_key", "input.LT(1).getText().equalsIgnoreCase(\"nextval\")");
			}
			REGULAR_ID14=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nextval_key2723); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID14_tree = (Object)adaptor.create(REGULAR_ID14);
			adaptor.addChild(root_0, REGULAR_ID14_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nextval_key"


	public static class goto_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "goto_key"
	// PLSQLKeys.g:421:1: goto_key : SQL92_RESERVED_GOTO ;
	public final PLSQLParser_PLSQLKeys.goto_key_return goto_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.goto_key_return retval = new PLSQLParser_PLSQLKeys.goto_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_GOTO15=null;

		Object SQL92_RESERVED_GOTO15_tree=null;

		try {
			// PLSQLKeys.g:422:5: ( SQL92_RESERVED_GOTO )
			// PLSQLKeys.g:422:10: SQL92_RESERVED_GOTO
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_GOTO15=(Token)match(input,SQL92_RESERVED_GOTO,FOLLOW_SQL92_RESERVED_GOTO_in_goto_key2743); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_GOTO15_tree = (Object)adaptor.create(SQL92_RESERVED_GOTO15);
			adaptor.addChild(root_0, SQL92_RESERVED_GOTO15_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "goto_key"


	public static class execute_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "execute_key"
	// PLSQLKeys.g:425:1: execute_key :{...}? REGULAR_ID -> EXECUTE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.execute_key_return execute_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.execute_key_return retval = new PLSQLParser_PLSQLKeys.execute_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID16=null;

		Object REGULAR_ID16_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:426:5: ({...}? REGULAR_ID -> EXECUTE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:426:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("execute"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "execute_key", "input.LT(1).getText().equalsIgnoreCase(\"execute\")");
			}
			REGULAR_ID16=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_execute_key2765); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID16);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 426:74: -> EXECUTE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXECUTE_VK, REGULAR_ID16));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "execute_key"


	public static class immediate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "immediate_key"
	// PLSQLKeys.g:429:1: immediate_key :{...}? => REGULAR_ID -> IMMEDIATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.immediate_key_return immediate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.immediate_key_return retval = new PLSQLParser_PLSQLKeys.immediate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID17=null;

		Object REGULAR_ID17_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:430:5: ({...}? => REGULAR_ID -> IMMEDIATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:430:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("immediate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "immediate_key", "input.LT(1).getText().equalsIgnoreCase(\"immediate\")");
			}
			REGULAR_ID17=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_immediate_key2793); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID17);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 430:78: -> IMMEDIATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(IMMEDIATE_VK, REGULAR_ID17));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "immediate_key"


	public static class return_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "return_key"
	// PLSQLKeys.g:433:1: return_key :{...}? REGULAR_ID -> RETURN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.return_key_return return_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.return_key_return retval = new PLSQLParser_PLSQLKeys.return_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID18=null;

		Object REGULAR_ID18_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:434:5: ({...}? REGULAR_ID -> RETURN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:434:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("return"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "return_key", "input.LT(1).getText().equalsIgnoreCase(\"return\")");
			}
			REGULAR_ID18=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_return_key2820); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID18);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 434:73: -> RETURN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RETURN_VK, REGULAR_ID18));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "return_key"


	public static class procedure_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "procedure_key"
	// PLSQLKeys.g:437:1: procedure_key : SQL92_RESERVED_PROCEDURE ;
	public final PLSQLParser_PLSQLKeys.procedure_key_return procedure_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.procedure_key_return retval = new PLSQLParser_PLSQLKeys.procedure_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_PROCEDURE19=null;

		Object SQL92_RESERVED_PROCEDURE19_tree=null;

		try {
			// PLSQLKeys.g:438:5: ( SQL92_RESERVED_PROCEDURE )
			// PLSQLKeys.g:438:10: SQL92_RESERVED_PROCEDURE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_PROCEDURE19=(Token)match(input,SQL92_RESERVED_PROCEDURE,FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key2845); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_PROCEDURE19_tree = (Object)adaptor.create(SQL92_RESERVED_PROCEDURE19);
			adaptor.addChild(root_0, SQL92_RESERVED_PROCEDURE19_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "procedure_key"


	public static class function_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "function_key"
	// PLSQLKeys.g:441:1: function_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.function_key_return function_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.function_key_return retval = new PLSQLParser_PLSQLKeys.function_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID20=null;

		Object REGULAR_ID20_tree=null;

		try {
			// PLSQLKeys.g:442:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:442:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("function"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "function_key", "input.LT(1).getText().equalsIgnoreCase(\"function\")");
			}
			REGULAR_ID20=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_function_key2868); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID20_tree = (Object)adaptor.create(REGULAR_ID20);
			adaptor.addChild(root_0, REGULAR_ID20_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "function_key"


	public static class pragma_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pragma_key"
	// PLSQLKeys.g:445:1: pragma_key :{...}? REGULAR_ID -> PRAGMA_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.pragma_key_return pragma_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.pragma_key_return retval = new PLSQLParser_PLSQLKeys.pragma_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID21=null;

		Object REGULAR_ID21_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:446:5: ({...}? REGULAR_ID -> PRAGMA_VK[$REGULAR_ID] )
			// PLSQLKeys.g:446:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("pragma"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "pragma_key", "input.LT(1).getText().equalsIgnoreCase(\"pragma\")");
			}
			REGULAR_ID21=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_pragma_key2890); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID21);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 446:73: -> PRAGMA_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRAGMA_VK, REGULAR_ID21));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pragma_key"


	public static class exception_init_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exception_init_key"
	// PLSQLKeys.g:449:1: exception_init_key :{...}? REGULAR_ID -> EXCEPTION_INIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.exception_init_key_return exception_init_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exception_init_key_return retval = new PLSQLParser_PLSQLKeys.exception_init_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID22=null;

		Object REGULAR_ID22_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:450:5: ({...}? REGULAR_ID -> EXCEPTION_INIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:450:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("exception_init"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "exception_init_key", "input.LT(1).getText().equalsIgnoreCase(\"exception_init\")");
			}
			REGULAR_ID22=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_exception_init_key2917); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID22);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 450:81: -> EXCEPTION_INIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXCEPTION_INIT_VK, REGULAR_ID22));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exception_init_key"


	public static class type_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "type_key"
	// PLSQLKeys.g:453:1: type_key :{...}? => REGULAR_ID -> TYPE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.type_key_return type_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.type_key_return retval = new PLSQLParser_PLSQLKeys.type_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID23=null;

		Object REGULAR_ID23_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:454:5: ({...}? => REGULAR_ID -> TYPE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:454:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("type"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "type_key", "input.LT(1).getText().equalsIgnoreCase(\"type\")");
			}
			REGULAR_ID23=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_type_key2945); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID23);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 454:73: -> TYPE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TYPE_VK, REGULAR_ID23));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "type_key"


	public static class record_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "record_key"
	// PLSQLKeys.g:457:1: record_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.record_key_return record_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.record_key_return retval = new PLSQLParser_PLSQLKeys.record_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID24=null;

		Object REGULAR_ID24_tree=null;

		try {
			// PLSQLKeys.g:458:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:458:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("record"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "record_key", "input.LT(1).getText().equalsIgnoreCase(\"record\")");
			}
			REGULAR_ID24=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_record_key2973); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID24_tree = (Object)adaptor.create(REGULAR_ID24);
			adaptor.addChild(root_0, REGULAR_ID24_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "record_key"


	public static class indexed_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "indexed_key"
	// PLSQLKeys.g:461:1: indexed_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.indexed_key_return indexed_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.indexed_key_return retval = new PLSQLParser_PLSQLKeys.indexed_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID25=null;

		Object REGULAR_ID25_tree=null;

		try {
			// PLSQLKeys.g:462:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:462:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("indexed"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "indexed_key", "input.LT(1).getText().equalsIgnoreCase(\"indexed\")");
			}
			REGULAR_ID25=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_indexed_key2995); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID25_tree = (Object)adaptor.create(REGULAR_ID25);
			adaptor.addChild(root_0, REGULAR_ID25_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "indexed_key"


	public static class index_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "index_key"
	// PLSQLKeys.g:465:1: index_key : PLSQL_RESERVED_INDEX ;
	public final PLSQLParser_PLSQLKeys.index_key_return index_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.index_key_return retval = new PLSQLParser_PLSQLKeys.index_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_INDEX26=null;

		Object PLSQL_RESERVED_INDEX26_tree=null;

		try {
			// PLSQLKeys.g:466:5: ( PLSQL_RESERVED_INDEX )
			// PLSQLKeys.g:466:10: PLSQL_RESERVED_INDEX
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_INDEX26=(Token)match(input,PLSQL_RESERVED_INDEX,FOLLOW_PLSQL_RESERVED_INDEX_in_index_key3015); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_INDEX26_tree = (Object)adaptor.create(PLSQL_RESERVED_INDEX26);
			adaptor.addChild(root_0, PLSQL_RESERVED_INDEX26_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "index_key"


	public static class percent_notfound_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_notfound_key"
	// PLSQLKeys.g:469:1: percent_notfound_key :{...}? => PERCENT REGULAR_ID -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_notfound_key_return percent_notfound_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_notfound_key_return retval = new PLSQLParser_PLSQLKeys.percent_notfound_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT27=null;
		Token REGULAR_ID28=null;

		Object PERCENT27_tree=null;
		Object REGULAR_ID28_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:470:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:470:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("notfound"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_notfound_key", "input.LT(2).getText().equalsIgnoreCase(\"notfound\")");
			}
			PERCENT27=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_notfound_key3038); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT27);

			REGULAR_ID28=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_notfound_key3040); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID28);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 470:85: -> PERCENT_NOTFOUND_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_NOTFOUND_VK, REGULAR_ID28, (REGULAR_ID28!=null?REGULAR_ID28.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_notfound_key"


	public static class percent_found_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_found_key"
	// PLSQLKeys.g:473:1: percent_found_key :{...}? => PERCENT REGULAR_ID -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_found_key_return percent_found_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_found_key_return retval = new PLSQLParser_PLSQLKeys.percent_found_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT29=null;
		Token REGULAR_ID30=null;

		Object PERCENT29_tree=null;
		Object REGULAR_ID30_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:474:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:474:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("found"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_found_key", "input.LT(2).getText().equalsIgnoreCase(\"found\")");
			}
			PERCENT29=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_found_key3068); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT29);

			REGULAR_ID30=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_found_key3070); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID30);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 474:82: -> PERCENT_FOUND_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_FOUND_VK, REGULAR_ID30, (REGULAR_ID30!=null?REGULAR_ID30.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_found_key"


	public static class percent_isopen_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_isopen_key"
	// PLSQLKeys.g:477:1: percent_isopen_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_isopen_key_return percent_isopen_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_isopen_key_return retval = new PLSQLParser_PLSQLKeys.percent_isopen_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT31=null;
		Token REGULAR_ID32=null;

		Object PERCENT31_tree=null;
		Object REGULAR_ID32_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:478:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:478:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("isopen"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_isopen_key", "input.LT(2).getText().equalsIgnoreCase(\"isopen\")");
			}
			PERCENT31=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_isopen_key3098); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT31);

			REGULAR_ID32=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_isopen_key3100); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID32);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 478:83: -> PERCENT_ISOPEN_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_ISOPEN_VK, REGULAR_ID32, (REGULAR_ID32!=null?REGULAR_ID32.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_isopen_key"


	public static class percent_rowcount_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_rowcount_key"
	// PLSQLKeys.g:481:1: percent_rowcount_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_rowcount_key_return percent_rowcount_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_rowcount_key_return retval = new PLSQLParser_PLSQLKeys.percent_rowcount_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT33=null;
		Token REGULAR_ID34=null;

		Object PERCENT33_tree=null;
		Object REGULAR_ID34_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:482:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:482:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("rowcount"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_rowcount_key", "input.LT(2).getText().equalsIgnoreCase(\"rowcount\")");
			}
			PERCENT33=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_rowcount_key3128); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT33);

			REGULAR_ID34=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_rowcount_key3130); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID34);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 482:85: -> PERCENT_ROWCOUNT_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_ROWCOUNT_VK, REGULAR_ID34, (REGULAR_ID34!=null?REGULAR_ID34.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_rowcount_key"


	public static class percent_rowtype_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_rowtype_key"
	// PLSQLKeys.g:485:1: percent_rowtype_key :{...}? => PERCENT REGULAR_ID -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_rowtype_key_return percent_rowtype_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_rowtype_key_return retval = new PLSQLParser_PLSQLKeys.percent_rowtype_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT35=null;
		Token REGULAR_ID36=null;

		Object PERCENT35_tree=null;
		Object REGULAR_ID36_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:486:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:486:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("rowtype"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_rowtype_key", "input.LT(2).getText().equalsIgnoreCase(\"rowtype\")");
			}
			PERCENT35=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_rowtype_key3158); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT35);

			REGULAR_ID36=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_rowtype_key3160); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID36);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 486:84: -> PERCENT_ROWTYPE_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_ROWTYPE_VK, REGULAR_ID36, (REGULAR_ID36!=null?REGULAR_ID36.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_rowtype_key"


	public static class percent_type_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "percent_type_key"
	// PLSQLKeys.g:489:1: percent_type_key :{...}? => PERCENT REGULAR_ID -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text] ;
	public final PLSQLParser_PLSQLKeys.percent_type_key_return percent_type_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.percent_type_key_return retval = new PLSQLParser_PLSQLKeys.percent_type_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PERCENT37=null;
		Token REGULAR_ID38=null;

		Object PERCENT37_tree=null;
		Object REGULAR_ID38_tree=null;
		RewriteRuleTokenStream stream_PERCENT=new RewriteRuleTokenStream(adaptor,"token PERCENT");
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:490:5: ({...}? => PERCENT REGULAR_ID -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text] )
			// PLSQLKeys.g:490:10: {...}? => PERCENT REGULAR_ID
			{
			if ( !((input.LT(2).getText().equalsIgnoreCase("type"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "percent_type_key", "input.LT(2).getText().equalsIgnoreCase(\"type\")");
			}
			PERCENT37=(Token)match(input,PERCENT,FOLLOW_PERCENT_in_percent_type_key3189); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_PERCENT.add(PERCENT37);

			REGULAR_ID38=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_percent_type_key3191); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID38);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 490:81: -> PERCENT_TYPE_VK[$REGULAR_ID, $REGULAR_ID.text]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PERCENT_TYPE_VK, REGULAR_ID38, (REGULAR_ID38!=null?REGULAR_ID38.getText():null)));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "percent_type_key"


	public static class out_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "out_key"
	// PLSQLKeys.g:493:1: out_key :{...}? => REGULAR_ID -> OUT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.out_key_return out_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.out_key_return retval = new PLSQLParser_PLSQLKeys.out_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID39=null;

		Object REGULAR_ID39_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:494:5: ({...}? => REGULAR_ID -> OUT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:494:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("out"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "out_key", "input.LT(1).getText().equalsIgnoreCase(\"out\")");
			}
			REGULAR_ID39=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_out_key3219); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID39);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 494:72: -> OUT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OUT_VK, REGULAR_ID39));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "out_key"


	public static class inout_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "inout_key"
	// PLSQLKeys.g:497:1: inout_key :{...}? REGULAR_ID -> INOUT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.inout_key_return inout_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.inout_key_return retval = new PLSQLParser_PLSQLKeys.inout_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID40=null;

		Object REGULAR_ID40_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:498:5: ({...}? REGULAR_ID -> INOUT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:498:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("inout"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "inout_key", "input.LT(1).getText().equalsIgnoreCase(\"inout\")");
			}
			REGULAR_ID40=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_inout_key3246); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID40);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 498:72: -> INOUT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INOUT_VK, REGULAR_ID40));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "inout_key"


	public static class extend_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "extend_key"
	// PLSQLKeys.g:501:1: extend_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.extend_key_return extend_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.extend_key_return retval = new PLSQLParser_PLSQLKeys.extend_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID41=null;

		Object REGULAR_ID41_tree=null;

		try {
			// PLSQLKeys.g:502:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:502:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("extend"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "extend_key", "input.LT(1).getText().equalsIgnoreCase(\"extend\")");
			}
			REGULAR_ID41=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_extend_key3274); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID41_tree = (Object)adaptor.create(REGULAR_ID41);
			adaptor.addChild(root_0, REGULAR_ID41_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "extend_key"


	public static class raise_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "raise_key"
	// PLSQLKeys.g:505:1: raise_key :{...}? REGULAR_ID -> RAISE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.raise_key_return raise_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.raise_key_return retval = new PLSQLParser_PLSQLKeys.raise_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID42=null;

		Object REGULAR_ID42_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:506:5: ({...}? REGULAR_ID -> RAISE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:506:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("raise"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "raise_key", "input.LT(1).getText().equalsIgnoreCase(\"raise\")");
			}
			REGULAR_ID42=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_raise_key3296); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID42);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 506:72: -> RAISE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RAISE_VK, REGULAR_ID42));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "raise_key"


	public static class while_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "while_key"
	// PLSQLKeys.g:509:1: while_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.while_key_return while_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.while_key_return retval = new PLSQLParser_PLSQLKeys.while_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID43=null;

		Object REGULAR_ID43_tree=null;

		try {
			// PLSQLKeys.g:510:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:510:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("while"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "while_key", "input.LT(1).getText().equalsIgnoreCase(\"while\")");
			}
			REGULAR_ID43=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_while_key3323); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID43_tree = (Object)adaptor.create(REGULAR_ID43);
			adaptor.addChild(root_0, REGULAR_ID43_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "while_key"


	public static class loop_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "loop_key"
	// PLSQLKeys.g:513:1: loop_key :{...}? REGULAR_ID -> LOOP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.loop_key_return loop_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.loop_key_return retval = new PLSQLParser_PLSQLKeys.loop_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID44=null;

		Object REGULAR_ID44_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:514:5: ({...}? REGULAR_ID -> LOOP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:514:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("loop"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "loop_key", "input.LT(1).getText().equalsIgnoreCase(\"loop\")");
			}
			REGULAR_ID44=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_loop_key3345); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID44);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 514:71: -> LOOP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LOOP_VK, REGULAR_ID44));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "loop_key"


	public static class commit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "commit_key"
	// PLSQLKeys.g:517:1: commit_key :{...}? => REGULAR_ID -> COMMIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.commit_key_return commit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.commit_key_return retval = new PLSQLParser_PLSQLKeys.commit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID45=null;

		Object REGULAR_ID45_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:518:5: ({...}? => REGULAR_ID -> COMMIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:518:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("commit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "commit_key", "input.LT(1).getText().equalsIgnoreCase(\"commit\")");
			}
			REGULAR_ID45=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_commit_key3373); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID45);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 518:75: -> COMMIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMMIT_VK, REGULAR_ID45));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "commit_key"


	public static class work_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "work_key"
	// PLSQLKeys.g:521:1: work_key :{...}? REGULAR_ID -> WORK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.work_key_return work_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.work_key_return retval = new PLSQLParser_PLSQLKeys.work_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID46=null;

		Object REGULAR_ID46_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:521:9: ({...}? REGULAR_ID -> WORK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:521:14: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("work"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "work_key", "input.LT(1).getText().equalsIgnoreCase(\"work\")");
			}
			REGULAR_ID46=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_work_key3395); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID46);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 521:75: -> WORK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WORK_VK, REGULAR_ID46));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "work_key"


	public static class if_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "if_key"
	// PLSQLKeys.g:524:1: if_key : PLSQL_RESERVED_IF ;
	public final PLSQLParser_PLSQLKeys.if_key_return if_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.if_key_return retval = new PLSQLParser_PLSQLKeys.if_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_IF47=null;

		Object PLSQL_RESERVED_IF47_tree=null;

		try {
			// PLSQLKeys.g:525:5: ( PLSQL_RESERVED_IF )
			// PLSQLKeys.g:525:10: PLSQL_RESERVED_IF
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_IF47=(Token)match(input,PLSQL_RESERVED_IF,FOLLOW_PLSQL_RESERVED_IF_in_if_key3420); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_IF47_tree = (Object)adaptor.create(PLSQL_RESERVED_IF47);
			adaptor.addChild(root_0, PLSQL_RESERVED_IF47_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "if_key"


	public static class elsif_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "elsif_key"
	// PLSQLKeys.g:528:1: elsif_key : PLSQL_NON_RESERVED_ELSIF ;
	public final PLSQLParser_PLSQLKeys.elsif_key_return elsif_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.elsif_key_return retval = new PLSQLParser_PLSQLKeys.elsif_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_NON_RESERVED_ELSIF48=null;

		Object PLSQL_NON_RESERVED_ELSIF48_tree=null;

		try {
			// PLSQLKeys.g:529:5: ( PLSQL_NON_RESERVED_ELSIF )
			// PLSQLKeys.g:529:10: PLSQL_NON_RESERVED_ELSIF
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_NON_RESERVED_ELSIF48=(Token)match(input,PLSQL_NON_RESERVED_ELSIF,FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key3440); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_NON_RESERVED_ELSIF48_tree = (Object)adaptor.create(PLSQL_NON_RESERVED_ELSIF48);
			adaptor.addChild(root_0, PLSQL_NON_RESERVED_ELSIF48_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "elsif_key"


	public static class authid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "authid_key"
	// PLSQLKeys.g:532:1: authid_key :{...}? => REGULAR_ID -> AUTHID_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.authid_key_return authid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.authid_key_return retval = new PLSQLParser_PLSQLKeys.authid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID49=null;

		Object REGULAR_ID49_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:533:5: ({...}? => REGULAR_ID -> AUTHID_VK[$REGULAR_ID] )
			// PLSQLKeys.g:533:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("authid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "authid_key", "input.LT(1).getText().equalsIgnoreCase(\"authid\")");
			}
			REGULAR_ID49=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_authid_key3463); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID49);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 533:75: -> AUTHID_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AUTHID_VK, REGULAR_ID49));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "authid_key"


	public static class definer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "definer_key"
	// PLSQLKeys.g:536:1: definer_key :{...}? REGULAR_ID -> DEFINER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.definer_key_return definer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.definer_key_return retval = new PLSQLParser_PLSQLKeys.definer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID50=null;

		Object REGULAR_ID50_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:537:5: ({...}? REGULAR_ID -> DEFINER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:537:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("definer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "definer_key", "input.LT(1).getText().equalsIgnoreCase(\"definer\")");
			}
			REGULAR_ID50=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_definer_key3490); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID50);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 537:74: -> DEFINER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEFINER_VK, REGULAR_ID50));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "definer_key"


	public static class external_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "external_key"
	// PLSQLKeys.g:540:1: external_key :{...}? REGULAR_ID -> EXTERNAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.external_key_return external_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.external_key_return retval = new PLSQLParser_PLSQLKeys.external_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID51=null;

		Object REGULAR_ID51_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:541:5: ({...}? REGULAR_ID -> EXTERNAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:541:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("external"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "external_key", "input.LT(1).getText().equalsIgnoreCase(\"external\")");
			}
			REGULAR_ID51=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_external_key3517); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID51);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 541:75: -> EXTERNAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXTERNAL_VK, REGULAR_ID51));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "external_key"


	public static class language_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "language_key"
	// PLSQLKeys.g:544:1: language_key :{...}? REGULAR_ID -> LANGUAGE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.language_key_return language_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.language_key_return retval = new PLSQLParser_PLSQLKeys.language_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID52=null;

		Object REGULAR_ID52_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:545:5: ({...}? REGULAR_ID -> LANGUAGE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:545:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("language"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "language_key", "input.LT(1).getText().equalsIgnoreCase(\"language\")");
			}
			REGULAR_ID52=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_language_key3544); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID52);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 545:75: -> LANGUAGE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LANGUAGE_VK, REGULAR_ID52));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "language_key"


	public static class java_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "java_key"
	// PLSQLKeys.g:548:1: java_key :{...}? REGULAR_ID -> JAVA_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.java_key_return java_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.java_key_return retval = new PLSQLParser_PLSQLKeys.java_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID53=null;

		Object REGULAR_ID53_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:549:5: ({...}? REGULAR_ID -> JAVA_VK[$REGULAR_ID] )
			// PLSQLKeys.g:549:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("java"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "java_key", "input.LT(1).getText().equalsIgnoreCase(\"java\")");
			}
			REGULAR_ID53=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_java_key3571); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID53);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 549:71: -> JAVA_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(JAVA_VK, REGULAR_ID53));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "java_key"


	public static class name_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "name_key"
	// PLSQLKeys.g:552:1: name_key :{...}? => REGULAR_ID -> NAME_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.name_key_return name_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.name_key_return retval = new PLSQLParser_PLSQLKeys.name_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID54=null;

		Object REGULAR_ID54_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:553:5: ({...}? => REGULAR_ID -> NAME_VK[$REGULAR_ID] )
			// PLSQLKeys.g:553:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("name"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "name_key", "input.LT(1).getText().equalsIgnoreCase(\"name\")");
			}
			REGULAR_ID54=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_name_key3599); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID54);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 553:73: -> NAME_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NAME_VK, REGULAR_ID54));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "name_key"


	public static class deterministic_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "deterministic_key"
	// PLSQLKeys.g:556:1: deterministic_key :{...}? => REGULAR_ID -> DETERMINISTIC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.deterministic_key_return deterministic_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.deterministic_key_return retval = new PLSQLParser_PLSQLKeys.deterministic_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID55=null;

		Object REGULAR_ID55_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:557:5: ({...}? => REGULAR_ID -> DETERMINISTIC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:557:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("deterministic"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "deterministic_key", "input.LT(1).getText().equalsIgnoreCase(\"deterministic\")");
			}
			REGULAR_ID55=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_deterministic_key3627); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID55);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 557:82: -> DETERMINISTIC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DETERMINISTIC_VK, REGULAR_ID55));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "deterministic_key"


	public static class parallel_enable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parallel_enable_key"
	// PLSQLKeys.g:560:1: parallel_enable_key :{...}? => REGULAR_ID -> PARALLEL_ENABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.parallel_enable_key_return parallel_enable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.parallel_enable_key_return retval = new PLSQLParser_PLSQLKeys.parallel_enable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID56=null;

		Object REGULAR_ID56_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:561:5: ({...}? => REGULAR_ID -> PARALLEL_ENABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:561:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("parallel_enable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parallel_enable_key", "input.LT(1).getText().equalsIgnoreCase(\"parallel_enable\")");
			}
			REGULAR_ID56=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_parallel_enable_key3655); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID56);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 561:84: -> PARALLEL_ENABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PARALLEL_ENABLE_VK, REGULAR_ID56));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parallel_enable_key"


	public static class result_cache_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "result_cache_key"
	// PLSQLKeys.g:564:1: result_cache_key :{...}? => REGULAR_ID -> RESULT_CACHE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.result_cache_key_return result_cache_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.result_cache_key_return retval = new PLSQLParser_PLSQLKeys.result_cache_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID57=null;

		Object REGULAR_ID57_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:565:5: ({...}? => REGULAR_ID -> RESULT_CACHE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:565:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("result_cache"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "result_cache_key", "input.LT(1).getText().equalsIgnoreCase(\"result_cache\")");
			}
			REGULAR_ID57=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_result_cache_key3683); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID57);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 565:81: -> RESULT_CACHE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RESULT_CACHE_VK, REGULAR_ID57));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "result_cache_key"


	public static class pipelined_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pipelined_key"
	// PLSQLKeys.g:568:1: pipelined_key :{...}? => REGULAR_ID -> PIPELINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.pipelined_key_return pipelined_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.pipelined_key_return retval = new PLSQLParser_PLSQLKeys.pipelined_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID58=null;

		Object REGULAR_ID58_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:569:5: ({...}? => REGULAR_ID -> PIPELINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:569:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("pipelined"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "pipelined_key", "input.LT(1).getText().equalsIgnoreCase(\"pipelined\")");
			}
			REGULAR_ID58=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_pipelined_key3711); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID58);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 569:78: -> PIPELINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PIPELINED_VK, REGULAR_ID58));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pipelined_key"


	public static class aggregate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "aggregate_key"
	// PLSQLKeys.g:572:1: aggregate_key :{...}? REGULAR_ID -> AGGREGATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.aggregate_key_return aggregate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.aggregate_key_return retval = new PLSQLParser_PLSQLKeys.aggregate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID59=null;

		Object REGULAR_ID59_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:573:5: ({...}? REGULAR_ID -> AGGREGATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:573:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("aggregate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "aggregate_key", "input.LT(1).getText().equalsIgnoreCase(\"aggregate\")");
			}
			REGULAR_ID59=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_aggregate_key3738); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID59);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 573:76: -> AGGREGATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AGGREGATE_VK, REGULAR_ID59));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "aggregate_key"


	public static class alter_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "alter_key"
	// PLSQLKeys.g:576:1: alter_key : SQL92_RESERVED_ALTER ;
	public final PLSQLParser_PLSQLKeys.alter_key_return alter_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.alter_key_return retval = new PLSQLParser_PLSQLKeys.alter_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ALTER60=null;

		Object SQL92_RESERVED_ALTER60_tree=null;

		try {
			// PLSQLKeys.g:577:5: ( SQL92_RESERVED_ALTER )
			// PLSQLKeys.g:577:10: SQL92_RESERVED_ALTER
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ALTER60=(Token)match(input,SQL92_RESERVED_ALTER,FOLLOW_SQL92_RESERVED_ALTER_in_alter_key3763); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ALTER60_tree = (Object)adaptor.create(SQL92_RESERVED_ALTER60);
			adaptor.addChild(root_0, SQL92_RESERVED_ALTER60_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "alter_key"


	public static class compile_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "compile_key"
	// PLSQLKeys.g:580:1: compile_key :{...}? REGULAR_ID -> COMPILE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.compile_key_return compile_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.compile_key_return retval = new PLSQLParser_PLSQLKeys.compile_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID61=null;

		Object REGULAR_ID61_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:581:5: ({...}? REGULAR_ID -> COMPILE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:581:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("compile"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "compile_key", "input.LT(1).getText().equalsIgnoreCase(\"compile\")");
			}
			REGULAR_ID61=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_compile_key3785); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID61);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 581:74: -> COMPILE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMPILE_VK, REGULAR_ID61));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "compile_key"


	public static class debug_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "debug_key"
	// PLSQLKeys.g:584:1: debug_key :{...}? REGULAR_ID -> DEBUG_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.debug_key_return debug_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.debug_key_return retval = new PLSQLParser_PLSQLKeys.debug_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID62=null;

		Object REGULAR_ID62_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:585:5: ({...}? REGULAR_ID -> DEBUG_VK[$REGULAR_ID] )
			// PLSQLKeys.g:585:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("debug"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "debug_key", "input.LT(1).getText().equalsIgnoreCase(\"debug\")");
			}
			REGULAR_ID62=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_debug_key3813); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID62);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 585:72: -> DEBUG_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEBUG_VK, REGULAR_ID62));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "debug_key"


	public static class reuse_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "reuse_key"
	// PLSQLKeys.g:588:1: reuse_key :{...}? REGULAR_ID -> REUSE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.reuse_key_return reuse_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.reuse_key_return retval = new PLSQLParser_PLSQLKeys.reuse_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID63=null;

		Object REGULAR_ID63_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:589:5: ({...}? REGULAR_ID -> REUSE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:589:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("reuse"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "reuse_key", "input.LT(1).getText().equalsIgnoreCase(\"reuse\")");
			}
			REGULAR_ID63=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_reuse_key3840); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID63);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 589:72: -> REUSE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REUSE_VK, REGULAR_ID63));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "reuse_key"


	public static class settings_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "settings_key"
	// PLSQLKeys.g:592:1: settings_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.settings_key_return settings_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.settings_key_return retval = new PLSQLParser_PLSQLKeys.settings_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID64=null;

		Object REGULAR_ID64_tree=null;

		try {
			// PLSQLKeys.g:593:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:593:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("settings"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "settings_key", "input.LT(1).getText().equalsIgnoreCase(\"settings\")");
			}
			REGULAR_ID64=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_settings_key3867); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID64_tree = (Object)adaptor.create(REGULAR_ID64);
			adaptor.addChild(root_0, REGULAR_ID64_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "settings_key"


	public static class specification_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "specification_key"
	// PLSQLKeys.g:596:1: specification_key :{...}? REGULAR_ID -> SPECIFICATION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.specification_key_return specification_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.specification_key_return retval = new PLSQLParser_PLSQLKeys.specification_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID65=null;

		Object REGULAR_ID65_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:597:5: ({...}? REGULAR_ID -> SPECIFICATION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:597:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("specification"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "specification_key", "input.LT(1).getText().equalsIgnoreCase(\"specification\")");
			}
			REGULAR_ID65=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_specification_key3889); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID65);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 597:80: -> SPECIFICATION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SPECIFICATION_VK, REGULAR_ID65));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "specification_key"


	public static class drop_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "drop_key"
	// PLSQLKeys.g:600:1: drop_key : SQL92_RESERVED_DROP ;
	public final PLSQLParser_PLSQLKeys.drop_key_return drop_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.drop_key_return retval = new PLSQLParser_PLSQLKeys.drop_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DROP66=null;

		Object SQL92_RESERVED_DROP66_tree=null;

		try {
			// PLSQLKeys.g:601:5: ( SQL92_RESERVED_DROP )
			// PLSQLKeys.g:601:10: SQL92_RESERVED_DROP
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DROP66=(Token)match(input,SQL92_RESERVED_DROP,FOLLOW_SQL92_RESERVED_DROP_in_drop_key3914); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DROP66_tree = (Object)adaptor.create(SQL92_RESERVED_DROP66);
			adaptor.addChild(root_0, SQL92_RESERVED_DROP66_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "drop_key"


	public static class trigger_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "trigger_key"
	// PLSQLKeys.g:604:1: trigger_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.trigger_key_return trigger_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.trigger_key_return retval = new PLSQLParser_PLSQLKeys.trigger_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID67=null;

		Object REGULAR_ID67_tree=null;

		try {
			// PLSQLKeys.g:605:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:605:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("trigger"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "trigger_key", "input.LT(1).getText().equalsIgnoreCase(\"trigger\")");
			}
			REGULAR_ID67=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_trigger_key3937); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID67_tree = (Object)adaptor.create(REGULAR_ID67);
			adaptor.addChild(root_0, REGULAR_ID67_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trigger_key"


	public static class force_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "force_key"
	// PLSQLKeys.g:608:1: force_key :{...}? => REGULAR_ID -> FORCE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.force_key_return force_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.force_key_return retval = new PLSQLParser_PLSQLKeys.force_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID68=null;

		Object REGULAR_ID68_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:609:5: ({...}? => REGULAR_ID -> FORCE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:609:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("force"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "force_key", "input.LT(1).getText().equalsIgnoreCase(\"force\")");
			}
			REGULAR_ID68=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_force_key3960); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID68);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 609:74: -> FORCE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FORCE_VK, REGULAR_ID68));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "force_key"


	public static class validate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "validate_key"
	// PLSQLKeys.g:612:1: validate_key :{...}? REGULAR_ID -> VALIDATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.validate_key_return validate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.validate_key_return retval = new PLSQLParser_PLSQLKeys.validate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID69=null;

		Object REGULAR_ID69_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:613:5: ({...}? REGULAR_ID -> VALIDATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:613:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("validate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "validate_key", "input.LT(1).getText().equalsIgnoreCase(\"validate\")");
			}
			REGULAR_ID69=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_validate_key3987); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID69);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 613:75: -> VALIDATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VALIDATE_VK, REGULAR_ID69));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "validate_key"


	public static class ref_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ref_key"
	// PLSQLKeys.g:616:1: ref_key :{...}? => REGULAR_ID -> REF_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.ref_key_return ref_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ref_key_return retval = new PLSQLParser_PLSQLKeys.ref_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID70=null;

		Object REGULAR_ID70_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:617:5: ({...}? => REGULAR_ID -> REF_VK[$REGULAR_ID] )
			// PLSQLKeys.g:617:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("ref"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ref_key", "input.LT(1).getText().equalsIgnoreCase(\"ref\")");
			}
			REGULAR_ID70=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ref_key4015); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID70);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 617:72: -> REF_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REF_VK, REGULAR_ID70));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ref_key"


	public static class array_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "array_key"
	// PLSQLKeys.g:620:1: array_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.array_key_return array_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.array_key_return retval = new PLSQLParser_PLSQLKeys.array_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID71=null;

		Object REGULAR_ID71_tree=null;

		try {
			// PLSQLKeys.g:621:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:621:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("array"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "array_key", "input.LT(1).getText().equalsIgnoreCase(\"array\")");
			}
			REGULAR_ID71=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_array_key4043); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID71_tree = (Object)adaptor.create(REGULAR_ID71);
			adaptor.addChild(root_0, REGULAR_ID71_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "array_key"


	public static class varray_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "varray_key"
	// PLSQLKeys.g:624:1: varray_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.varray_key_return varray_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.varray_key_return retval = new PLSQLParser_PLSQLKeys.varray_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID72=null;

		Object REGULAR_ID72_tree=null;

		try {
			// PLSQLKeys.g:625:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:625:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("varray"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "varray_key", "input.LT(1).getText().equalsIgnoreCase(\"varray\")");
			}
			REGULAR_ID72=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_varray_key4066); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID72_tree = (Object)adaptor.create(REGULAR_ID72);
			adaptor.addChild(root_0, REGULAR_ID72_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "varray_key"


	public static class pls_integer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pls_integer_key"
	// PLSQLKeys.g:628:1: pls_integer_key :{...}? => REGULAR_ID -> PLS_INTEGER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.pls_integer_key_return pls_integer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.pls_integer_key_return retval = new PLSQLParser_PLSQLKeys.pls_integer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID73=null;

		Object REGULAR_ID73_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:629:5: ({...}? => REGULAR_ID -> PLS_INTEGER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:629:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("pls_integer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "pls_integer_key", "input.LT(1).getText().equalsIgnoreCase(\"pls_integer\")");
			}
			REGULAR_ID73=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_pls_integer_key4089); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID73);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 629:80: -> PLS_INTEGER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PLS_INTEGER_VK, REGULAR_ID73));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pls_integer_key"


	public static class serially_reusable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "serially_reusable_key"
	// PLSQLKeys.g:632:1: serially_reusable_key :{...}? => REGULAR_ID -> SERIALLY_REUSABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.serially_reusable_key_return serially_reusable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.serially_reusable_key_return retval = new PLSQLParser_PLSQLKeys.serially_reusable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID74=null;

		Object REGULAR_ID74_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:633:5: ({...}? => REGULAR_ID -> SERIALLY_REUSABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:633:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("serially_reusable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "serially_reusable_key", "input.LT(1).getText().equalsIgnoreCase(\"serially_reusable\")");
			}
			REGULAR_ID74=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_serially_reusable_key4117); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID74);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 633:86: -> SERIALLY_REUSABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SERIALLY_REUSABLE_VK, REGULAR_ID74));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "serially_reusable_key"


	public static class autonomous_transaction_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "autonomous_transaction_key"
	// PLSQLKeys.g:636:1: autonomous_transaction_key :{...}? => REGULAR_ID -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.autonomous_transaction_key_return autonomous_transaction_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.autonomous_transaction_key_return retval = new PLSQLParser_PLSQLKeys.autonomous_transaction_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID75=null;

		Object REGULAR_ID75_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:637:5: ({...}? => REGULAR_ID -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:637:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("autonomous_transaction"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "autonomous_transaction_key", "input.LT(1).getText().equalsIgnoreCase(\"autonomous_transaction\")");
			}
			REGULAR_ID75=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_autonomous_transaction_key4145); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID75);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 637:91: -> AUTONOMOUS_TRANSACTION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AUTONOMOUS_TRANSACTION_VK, REGULAR_ID75));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "autonomous_transaction_key"


	public static class inline_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "inline_key"
	// PLSQLKeys.g:640:1: inline_key :{...}? => REGULAR_ID -> INLINE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.inline_key_return inline_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.inline_key_return retval = new PLSQLParser_PLSQLKeys.inline_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID76=null;

		Object REGULAR_ID76_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:641:5: ({...}? => REGULAR_ID -> INLINE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:641:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("inline"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "inline_key", "input.LT(1).getText().equalsIgnoreCase(\"inline\")");
			}
			REGULAR_ID76=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_inline_key4173); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID76);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 641:75: -> INLINE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INLINE_VK, REGULAR_ID76));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "inline_key"


	public static class restrict_references_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "restrict_references_key"
	// PLSQLKeys.g:644:1: restrict_references_key :{...}? => REGULAR_ID -> RESTRICT_REFERENCES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.restrict_references_key_return restrict_references_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.restrict_references_key_return retval = new PLSQLParser_PLSQLKeys.restrict_references_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID77=null;

		Object REGULAR_ID77_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:645:5: ({...}? => REGULAR_ID -> RESTRICT_REFERENCES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:645:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("restrict_references"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "restrict_references_key", "input.LT(1).getText().equalsIgnoreCase(\"restrict_references\")");
			}
			REGULAR_ID77=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_restrict_references_key4201); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID77);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 645:88: -> RESTRICT_REFERENCES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RESTRICT_REFERENCES_VK, REGULAR_ID77));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "restrict_references_key"


	public static class exceptions_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exceptions_key"
	// PLSQLKeys.g:648:1: exceptions_key :{...}? => REGULAR_ID -> EXCEPTIONS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.exceptions_key_return exceptions_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exceptions_key_return retval = new PLSQLParser_PLSQLKeys.exceptions_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID78=null;

		Object REGULAR_ID78_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:649:5: ({...}? => REGULAR_ID -> EXCEPTIONS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:649:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("exceptions"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "exceptions_key", "input.LT(1).getText().equalsIgnoreCase(\"exceptions\")");
			}
			REGULAR_ID78=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_exceptions_key4229); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID78);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 649:79: -> EXCEPTIONS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXCEPTIONS_VK, REGULAR_ID78));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exceptions_key"


	public static class save_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "save_key"
	// PLSQLKeys.g:652:1: save_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.save_key_return save_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.save_key_return retval = new PLSQLParser_PLSQLKeys.save_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID79=null;

		Object REGULAR_ID79_tree=null;

		try {
			// PLSQLKeys.g:653:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:653:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("save"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "save_key", "input.LT(1).getText().equalsIgnoreCase(\"save\")");
			}
			REGULAR_ID79=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_save_key4258); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID79_tree = (Object)adaptor.create(REGULAR_ID79);
			adaptor.addChild(root_0, REGULAR_ID79_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "save_key"


	public static class forall_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "forall_key"
	// PLSQLKeys.g:656:1: forall_key :{...}? => REGULAR_ID -> FORALL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.forall_key_return forall_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.forall_key_return retval = new PLSQLParser_PLSQLKeys.forall_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID80=null;

		Object REGULAR_ID80_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:657:5: ({...}? => REGULAR_ID -> FORALL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:657:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("forall"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "forall_key", "input.LT(1).getText().equalsIgnoreCase(\"forall\")");
			}
			REGULAR_ID80=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_forall_key4281); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID80);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 657:75: -> FORALL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FORALL_VK, REGULAR_ID80));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "forall_key"


	public static class continue_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "continue_key"
	// PLSQLKeys.g:660:1: continue_key :{...}? => REGULAR_ID -> CONTINUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.continue_key_return continue_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.continue_key_return retval = new PLSQLParser_PLSQLKeys.continue_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID81=null;

		Object REGULAR_ID81_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:661:5: ({...}? => REGULAR_ID -> CONTINUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:661:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("continue"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "continue_key", "input.LT(1).getText().equalsIgnoreCase(\"continue\")");
			}
			REGULAR_ID81=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_continue_key4309); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID81);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 661:77: -> CONTINUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONTINUE_VK, REGULAR_ID81));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "continue_key"


	public static class indices_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "indices_key"
	// PLSQLKeys.g:664:1: indices_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.indices_key_return indices_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.indices_key_return retval = new PLSQLParser_PLSQLKeys.indices_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID82=null;

		Object REGULAR_ID82_tree=null;

		try {
			// PLSQLKeys.g:665:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:665:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("indices"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "indices_key", "input.LT(1).getText().equalsIgnoreCase(\"indices\")");
			}
			REGULAR_ID82=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_indices_key4337); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID82_tree = (Object)adaptor.create(REGULAR_ID82);
			adaptor.addChild(root_0, REGULAR_ID82_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "indices_key"


	public static class values_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "values_key"
	// PLSQLKeys.g:668:1: values_key : SQL92_RESERVED_VALUES ;
	public final PLSQLParser_PLSQLKeys.values_key_return values_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.values_key_return retval = new PLSQLParser_PLSQLKeys.values_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_VALUES83=null;

		Object SQL92_RESERVED_VALUES83_tree=null;

		try {
			// PLSQLKeys.g:669:5: ( SQL92_RESERVED_VALUES )
			// PLSQLKeys.g:669:10: SQL92_RESERVED_VALUES
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_VALUES83=(Token)match(input,SQL92_RESERVED_VALUES,FOLLOW_SQL92_RESERVED_VALUES_in_values_key4357); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_VALUES83_tree = (Object)adaptor.create(SQL92_RESERVED_VALUES83);
			adaptor.addChild(root_0, SQL92_RESERVED_VALUES83_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "values_key"


	public static class case_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "case_key"
	// PLSQLKeys.g:672:1: case_key : SQL92_RESERVED_CASE ;
	public final PLSQLParser_PLSQLKeys.case_key_return case_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.case_key_return retval = new PLSQLParser_PLSQLKeys.case_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CASE84=null;

		Object SQL92_RESERVED_CASE84_tree=null;

		try {
			// PLSQLKeys.g:673:5: ( SQL92_RESERVED_CASE )
			// PLSQLKeys.g:673:10: SQL92_RESERVED_CASE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CASE84=(Token)match(input,SQL92_RESERVED_CASE,FOLLOW_SQL92_RESERVED_CASE_in_case_key4377); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CASE84_tree = (Object)adaptor.create(SQL92_RESERVED_CASE84);
			adaptor.addChild(root_0, SQL92_RESERVED_CASE84_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "case_key"


	public static class bulk_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bulk_key"
	// PLSQLKeys.g:676:1: bulk_key :{...}? => REGULAR_ID -> BULK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.bulk_key_return bulk_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.bulk_key_return retval = new PLSQLParser_PLSQLKeys.bulk_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID85=null;

		Object REGULAR_ID85_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:677:5: ({...}? => REGULAR_ID -> BULK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:677:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("bulk"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "bulk_key", "input.LT(1).getText().equalsIgnoreCase(\"bulk\")");
			}
			REGULAR_ID85=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_bulk_key4400); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID85);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 677:73: -> BULK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BULK_VK, REGULAR_ID85));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bulk_key"


	public static class collect_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "collect_key"
	// PLSQLKeys.g:680:1: collect_key :{...}? => REGULAR_ID -> COLLECT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.collect_key_return collect_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.collect_key_return retval = new PLSQLParser_PLSQLKeys.collect_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID86=null;

		Object REGULAR_ID86_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:681:5: ({...}? => REGULAR_ID -> COLLECT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:681:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("collect"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "collect_key", "input.LT(1).getText().equalsIgnoreCase(\"collect\")");
			}
			REGULAR_ID86=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_collect_key4428); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID86);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 681:76: -> COLLECT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COLLECT_VK, REGULAR_ID86));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "collect_key"


	public static class committed_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "committed_key"
	// PLSQLKeys.g:684:1: committed_key :{...}? REGULAR_ID -> COMMITTED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.committed_key_return committed_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.committed_key_return retval = new PLSQLParser_PLSQLKeys.committed_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID87=null;

		Object REGULAR_ID87_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:685:5: ({...}? REGULAR_ID -> COMMITTED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:685:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("committed"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "committed_key", "input.LT(1).getText().equalsIgnoreCase(\"committed\")");
			}
			REGULAR_ID87=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_committed_key4455); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID87);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 685:76: -> COMMITTED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMMITTED_VK, REGULAR_ID87));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "committed_key"


	public static class use_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "use_key"
	// PLSQLKeys.g:688:1: use_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.use_key_return use_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.use_key_return retval = new PLSQLParser_PLSQLKeys.use_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID88=null;

		Object REGULAR_ID88_tree=null;

		try {
			// PLSQLKeys.g:689:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:689:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("use"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "use_key", "input.LT(1).getText().equalsIgnoreCase(\"use\")");
			}
			REGULAR_ID88=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_use_key4483); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID88_tree = (Object)adaptor.create(REGULAR_ID88);
			adaptor.addChild(root_0, REGULAR_ID88_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "use_key"


	public static class level_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "level_key"
	// PLSQLKeys.g:692:1: level_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.level_key_return level_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.level_key_return retval = new PLSQLParser_PLSQLKeys.level_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID89=null;

		Object REGULAR_ID89_tree=null;

		try {
			// PLSQLKeys.g:693:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:693:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("level"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "level_key", "input.LT(1).getText().equalsIgnoreCase(\"level\")");
			}
			REGULAR_ID89=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_level_key4505); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID89_tree = (Object)adaptor.create(REGULAR_ID89);
			adaptor.addChild(root_0, REGULAR_ID89_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "level_key"


	public static class isolation_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "isolation_key"
	// PLSQLKeys.g:696:1: isolation_key :{...}? => REGULAR_ID -> ISOLATION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.isolation_key_return isolation_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.isolation_key_return retval = new PLSQLParser_PLSQLKeys.isolation_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID90=null;

		Object REGULAR_ID90_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:697:5: ({...}? => REGULAR_ID -> ISOLATION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:697:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("isolation"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "isolation_key", "input.LT(1).getText().equalsIgnoreCase(\"isolation\")");
			}
			REGULAR_ID90=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_isolation_key4528); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID90);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 697:78: -> ISOLATION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ISOLATION_VK, REGULAR_ID90));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "isolation_key"


	public static class serializable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "serializable_key"
	// PLSQLKeys.g:700:1: serializable_key :{...}? REGULAR_ID -> SERIALIZABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.serializable_key_return serializable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.serializable_key_return retval = new PLSQLParser_PLSQLKeys.serializable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID91=null;

		Object REGULAR_ID91_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:701:5: ({...}? REGULAR_ID -> SERIALIZABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:701:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("serializable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "serializable_key", "input.LT(1).getText().equalsIgnoreCase(\"serializable\")");
			}
			REGULAR_ID91=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_serializable_key4555); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID91);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 701:79: -> SERIALIZABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SERIALIZABLE_VK, REGULAR_ID91));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "serializable_key"


	public static class segment_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "segment_key"
	// PLSQLKeys.g:704:1: segment_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.segment_key_return segment_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.segment_key_return retval = new PLSQLParser_PLSQLKeys.segment_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID92=null;

		Object REGULAR_ID92_tree=null;

		try {
			// PLSQLKeys.g:705:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:705:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("segment"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "segment_key", "input.LT(1).getText().equalsIgnoreCase(\"segment\")");
			}
			REGULAR_ID92=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_segment_key4582); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID92_tree = (Object)adaptor.create(REGULAR_ID92);
			adaptor.addChild(root_0, REGULAR_ID92_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "segment_key"


	public static class write_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "write_key"
	// PLSQLKeys.g:708:1: write_key :{...}? => REGULAR_ID -> WRITE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.write_key_return write_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.write_key_return retval = new PLSQLParser_PLSQLKeys.write_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID93=null;

		Object REGULAR_ID93_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:709:5: ({...}? => REGULAR_ID -> WRITE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:709:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("write"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "write_key", "input.LT(1).getText().equalsIgnoreCase(\"write\")");
			}
			REGULAR_ID93=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_write_key4605); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID93);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 709:74: -> WRITE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WRITE_VK, REGULAR_ID93));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "write_key"


	public static class wait_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wait_key"
	// PLSQLKeys.g:712:1: wait_key :{...}? => REGULAR_ID -> WAIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.wait_key_return wait_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.wait_key_return retval = new PLSQLParser_PLSQLKeys.wait_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID94=null;

		Object REGULAR_ID94_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:713:5: ({...}? => REGULAR_ID -> WAIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:713:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("wait"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wait_key", "input.LT(1).getText().equalsIgnoreCase(\"wait\")");
			}
			REGULAR_ID94=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_wait_key4633); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID94);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 713:73: -> WAIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WAIT_VK, REGULAR_ID94));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wait_key"


	public static class corrupt_xid_all_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "corrupt_xid_all_key"
	// PLSQLKeys.g:716:1: corrupt_xid_all_key :{...}? => REGULAR_ID -> CORRUPT_XID_ALL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.corrupt_xid_all_key_return corrupt_xid_all_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.corrupt_xid_all_key_return retval = new PLSQLParser_PLSQLKeys.corrupt_xid_all_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID95=null;

		Object REGULAR_ID95_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:717:5: ({...}? => REGULAR_ID -> CORRUPT_XID_ALL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:717:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("corrupt_xid_all"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "corrupt_xid_all_key", "input.LT(1).getText().equalsIgnoreCase(\"corrupt_xid_all\")");
			}
			REGULAR_ID95=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_corrupt_xid_all_key4661); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID95);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 717:84: -> CORRUPT_XID_ALL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CORRUPT_XID_ALL_VK, REGULAR_ID95));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "corrupt_xid_all_key"


	public static class corrupt_xid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "corrupt_xid_key"
	// PLSQLKeys.g:720:1: corrupt_xid_key :{...}? => REGULAR_ID -> CORRUPT_XID_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.corrupt_xid_key_return corrupt_xid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.corrupt_xid_key_return retval = new PLSQLParser_PLSQLKeys.corrupt_xid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID96=null;

		Object REGULAR_ID96_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:721:5: ({...}? => REGULAR_ID -> CORRUPT_XID_VK[$REGULAR_ID] )
			// PLSQLKeys.g:721:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("corrupt_xid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "corrupt_xid_key", "input.LT(1).getText().equalsIgnoreCase(\"corrupt_xid\")");
			}
			REGULAR_ID96=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_corrupt_xid_key4689); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID96);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 721:80: -> CORRUPT_XID_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CORRUPT_XID_VK, REGULAR_ID96));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "corrupt_xid_key"


	public static class batch_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "batch_key"
	// PLSQLKeys.g:724:1: batch_key :{...}? => REGULAR_ID -> BATCH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.batch_key_return batch_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.batch_key_return retval = new PLSQLParser_PLSQLKeys.batch_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID97=null;

		Object REGULAR_ID97_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:725:5: ({...}? => REGULAR_ID -> BATCH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:725:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("batch"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "batch_key", "input.LT(1).getText().equalsIgnoreCase(\"batch\")");
			}
			REGULAR_ID97=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_batch_key4717); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID97);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 725:74: -> BATCH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BATCH_VK, REGULAR_ID97));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "batch_key"


	public static class session_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "session_key"
	// PLSQLKeys.g:728:1: session_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.session_key_return session_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.session_key_return retval = new PLSQLParser_PLSQLKeys.session_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID98=null;

		Object REGULAR_ID98_tree=null;

		try {
			// PLSQLKeys.g:729:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:729:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("session"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "session_key", "input.LT(1).getText().equalsIgnoreCase(\"session\")");
			}
			REGULAR_ID98=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_session_key4745); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID98_tree = (Object)adaptor.create(REGULAR_ID98);
			adaptor.addChild(root_0, REGULAR_ID98_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "session_key"


	public static class role_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "role_key"
	// PLSQLKeys.g:732:1: role_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.role_key_return role_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.role_key_return retval = new PLSQLParser_PLSQLKeys.role_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID99=null;

		Object REGULAR_ID99_tree=null;

		try {
			// PLSQLKeys.g:733:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:733:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("role"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "role_key", "input.LT(1).getText().equalsIgnoreCase(\"role\")");
			}
			REGULAR_ID99=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_role_key4768); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID99_tree = (Object)adaptor.create(REGULAR_ID99);
			adaptor.addChild(root_0, REGULAR_ID99_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "role_key"


	public static class constraint_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "constraint_key"
	// PLSQLKeys.g:736:1: constraint_key :{...}? => REGULAR_ID -> CONSTRAINT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.constraint_key_return constraint_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.constraint_key_return retval = new PLSQLParser_PLSQLKeys.constraint_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID100=null;

		Object REGULAR_ID100_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:737:5: ({...}? => REGULAR_ID -> CONSTRAINT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:737:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("constraint"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "constraint_key", "input.LT(1).getText().equalsIgnoreCase(\"constraint\")");
			}
			REGULAR_ID100=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_constraint_key4791); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID100);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 737:79: -> CONSTRAINT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONSTRAINT_VK, REGULAR_ID100));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constraint_key"


	public static class constraints_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "constraints_key"
	// PLSQLKeys.g:740:1: constraints_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.constraints_key_return constraints_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.constraints_key_return retval = new PLSQLParser_PLSQLKeys.constraints_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID101=null;

		Object REGULAR_ID101_tree=null;

		try {
			// PLSQLKeys.g:741:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:741:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("constraints"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "constraints_key", "input.LT(1).getText().equalsIgnoreCase(\"constraints\")");
			}
			REGULAR_ID101=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_constraints_key4819); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID101_tree = (Object)adaptor.create(REGULAR_ID101);
			adaptor.addChild(root_0, REGULAR_ID101_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constraints_key"


	public static class call_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "call_key"
	// PLSQLKeys.g:744:1: call_key :{...}? => REGULAR_ID -> CALL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.call_key_return call_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.call_key_return retval = new PLSQLParser_PLSQLKeys.call_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID102=null;

		Object REGULAR_ID102_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:745:5: ({...}? => REGULAR_ID -> CALL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:745:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("call"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "call_key", "input.LT(1).getText().equalsIgnoreCase(\"call\")");
			}
			REGULAR_ID102=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_call_key4842); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID102);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 745:73: -> CALL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CALL_VK, REGULAR_ID102));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "call_key"


	public static class explain_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "explain_key"
	// PLSQLKeys.g:748:1: explain_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.explain_key_return explain_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.explain_key_return retval = new PLSQLParser_PLSQLKeys.explain_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID103=null;

		Object REGULAR_ID103_tree=null;

		try {
			// PLSQLKeys.g:749:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:749:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("explain"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "explain_key", "input.LT(1).getText().equalsIgnoreCase(\"explain\")");
			}
			REGULAR_ID103=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_explain_key4870); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID103_tree = (Object)adaptor.create(REGULAR_ID103);
			adaptor.addChild(root_0, REGULAR_ID103_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "explain_key"


	public static class merge_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "merge_key"
	// PLSQLKeys.g:752:1: merge_key :{...}? => REGULAR_ID -> MERGE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.merge_key_return merge_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.merge_key_return retval = new PLSQLParser_PLSQLKeys.merge_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID104=null;

		Object REGULAR_ID104_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:753:5: ({...}? => REGULAR_ID -> MERGE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:753:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("merge"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "merge_key", "input.LT(1).getText().equalsIgnoreCase(\"merge\")");
			}
			REGULAR_ID104=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_merge_key4893); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID104);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 753:74: -> MERGE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MERGE_VK, REGULAR_ID104));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "merge_key"


	public static class plan_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "plan_key"
	// PLSQLKeys.g:756:1: plan_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.plan_key_return plan_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.plan_key_return retval = new PLSQLParser_PLSQLKeys.plan_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID105=null;

		Object REGULAR_ID105_tree=null;

		try {
			// PLSQLKeys.g:757:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:757:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("plan"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "plan_key", "input.LT(1).getText().equalsIgnoreCase(\"plan\")");
			}
			REGULAR_ID105=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_plan_key4921); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID105_tree = (Object)adaptor.create(REGULAR_ID105);
			adaptor.addChild(root_0, REGULAR_ID105_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "plan_key"


	public static class system_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "system_key"
	// PLSQLKeys.g:760:1: system_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.system_key_return system_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.system_key_return retval = new PLSQLParser_PLSQLKeys.system_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID106=null;

		Object REGULAR_ID106_tree=null;

		try {
			// PLSQLKeys.g:761:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:761:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("system"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "system_key", "input.LT(1).getText().equalsIgnoreCase(\"system\")");
			}
			REGULAR_ID106=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_system_key4944); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID106_tree = (Object)adaptor.create(REGULAR_ID106);
			adaptor.addChild(root_0, REGULAR_ID106_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "system_key"


	public static class subpartition_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "subpartition_key"
	// PLSQLKeys.g:764:1: subpartition_key :{...}? => REGULAR_ID -> SUBPARTITION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.subpartition_key_return subpartition_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.subpartition_key_return retval = new PLSQLParser_PLSQLKeys.subpartition_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID107=null;

		Object REGULAR_ID107_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:765:5: ({...}? => REGULAR_ID -> SUBPARTITION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:765:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("subpartition"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "subpartition_key", "input.LT(1).getText().equalsIgnoreCase(\"subpartition\")");
			}
			REGULAR_ID107=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_subpartition_key4967); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID107);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 765:81: -> SUBPARTITION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SUBPARTITION_VK, REGULAR_ID107));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "subpartition_key"


	public static class partition_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "partition_key"
	// PLSQLKeys.g:768:1: partition_key :{...}? => REGULAR_ID -> PARTITION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.partition_key_return partition_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.partition_key_return retval = new PLSQLParser_PLSQLKeys.partition_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID108=null;

		Object REGULAR_ID108_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:769:5: ({...}? => REGULAR_ID -> PARTITION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:769:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("partition"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "partition_key", "input.LT(1).getText().equalsIgnoreCase(\"partition\")");
			}
			REGULAR_ID108=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_partition_key4995); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID108);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 769:78: -> PARTITION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PARTITION_VK, REGULAR_ID108));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partition_key"


	public static class matched_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "matched_key"
	// PLSQLKeys.g:772:1: matched_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.matched_key_return matched_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.matched_key_return retval = new PLSQLParser_PLSQLKeys.matched_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID109=null;

		Object REGULAR_ID109_tree=null;

		try {
			// PLSQLKeys.g:773:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:773:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("matched"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "matched_key", "input.LT(1).getText().equalsIgnoreCase(\"matched\")");
			}
			REGULAR_ID109=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_matched_key5023); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID109_tree = (Object)adaptor.create(REGULAR_ID109);
			adaptor.addChild(root_0, REGULAR_ID109_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "matched_key"


	public static class reject_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "reject_key"
	// PLSQLKeys.g:776:1: reject_key :{...}? => REGULAR_ID -> REJECT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.reject_key_return reject_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.reject_key_return retval = new PLSQLParser_PLSQLKeys.reject_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID110=null;

		Object REGULAR_ID110_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:777:5: ({...}? => REGULAR_ID -> REJECT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:777:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("reject"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "reject_key", "input.LT(1).getText().equalsIgnoreCase(\"reject\")");
			}
			REGULAR_ID110=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_reject_key5046); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID110);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 777:75: -> REJECT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REJECT_VK, REGULAR_ID110));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "reject_key"


	public static class log_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "log_key"
	// PLSQLKeys.g:780:1: log_key :{...}? => REGULAR_ID -> LOG_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.log_key_return log_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.log_key_return retval = new PLSQLParser_PLSQLKeys.log_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID111=null;

		Object REGULAR_ID111_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:781:5: ({...}? => REGULAR_ID -> LOG_VK[$REGULAR_ID] )
			// PLSQLKeys.g:781:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("log"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "log_key", "input.LT(1).getText().equalsIgnoreCase(\"log\")");
			}
			REGULAR_ID111=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_log_key5074); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID111);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 781:72: -> LOG_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LOG_VK, REGULAR_ID111));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "log_key"


	public static class unlimited_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unlimited_key"
	// PLSQLKeys.g:784:1: unlimited_key :{...}? => REGULAR_ID -> UNLIMITED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.unlimited_key_return unlimited_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.unlimited_key_return retval = new PLSQLParser_PLSQLKeys.unlimited_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID112=null;

		Object REGULAR_ID112_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:785:5: ({...}? => REGULAR_ID -> UNLIMITED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:785:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("unlimited"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "unlimited_key", "input.LT(1).getText().equalsIgnoreCase(\"unlimited\")");
			}
			REGULAR_ID112=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_unlimited_key5102); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID112);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 785:78: -> UNLIMITED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UNLIMITED_VK, REGULAR_ID112));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unlimited_key"


	public static class limit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "limit_key"
	// PLSQLKeys.g:788:1: limit_key :{...}? => REGULAR_ID -> LIMIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.limit_key_return limit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.limit_key_return retval = new PLSQLParser_PLSQLKeys.limit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID113=null;

		Object REGULAR_ID113_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:789:5: ({...}? => REGULAR_ID -> LIMIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:789:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("limit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "limit_key", "input.LT(1).getText().equalsIgnoreCase(\"limit\")");
			}
			REGULAR_ID113=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_limit_key5130); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID113);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 789:74: -> LIMIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LIMIT_VK, REGULAR_ID113));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "limit_key"


	public static class errors_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "errors_key"
	// PLSQLKeys.g:792:1: errors_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.errors_key_return errors_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.errors_key_return retval = new PLSQLParser_PLSQLKeys.errors_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID114=null;

		Object REGULAR_ID114_tree=null;

		try {
			// PLSQLKeys.g:793:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:793:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("errors"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "errors_key", "input.LT(1).getText().equalsIgnoreCase(\"errors\")");
			}
			REGULAR_ID114=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_errors_key5158); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID114_tree = (Object)adaptor.create(REGULAR_ID114);
			adaptor.addChild(root_0, REGULAR_ID114_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "errors_key"


	public static class timestamp_tz_unconstrained_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timestamp_tz_unconstrained_key"
	// PLSQLKeys.g:796:1: timestamp_tz_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timestamp_tz_unconstrained_key_return timestamp_tz_unconstrained_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timestamp_tz_unconstrained_key_return retval = new PLSQLParser_PLSQLKeys.timestamp_tz_unconstrained_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID115=null;

		Object REGULAR_ID115_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:797:5: ({...}? => REGULAR_ID -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:797:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timestamp_tz_unconstrained"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timestamp_tz_unconstrained_key", "input.LT(1).getText().equalsIgnoreCase(\"timestamp_tz_unconstrained\")");
			}
			REGULAR_ID115=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key5181); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID115);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 797:95: -> TIMESTAMP_TZ_UNCONSTRAINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMESTAMP_TZ_UNCONSTRAINED_VK, REGULAR_ID115));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timestamp_tz_unconstrained_key"


	public static class urowid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "urowid_key"
	// PLSQLKeys.g:800:1: urowid_key :{...}? => REGULAR_ID -> UROWID_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.urowid_key_return urowid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.urowid_key_return retval = new PLSQLParser_PLSQLKeys.urowid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID116=null;

		Object REGULAR_ID116_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:801:5: ({...}? => REGULAR_ID -> UROWID_VK[$REGULAR_ID] )
			// PLSQLKeys.g:801:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("urowid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "urowid_key", "input.LT(1).getText().equalsIgnoreCase(\"urowid\")");
			}
			REGULAR_ID116=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_urowid_key5209); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID116);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 801:75: -> UROWID_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UROWID_VK, REGULAR_ID116));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "urowid_key"


	public static class binary_float_min_subnormal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_min_subnormal_key"
	// PLSQLKeys.g:804:1: binary_float_min_subnormal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_min_subnormal_key_return binary_float_min_subnormal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_min_subnormal_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_min_subnormal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID117=null;

		Object REGULAR_ID117_tree=null;

		try {
			// PLSQLKeys.g:805:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:805:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_min_subnormal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_min_subnormal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_min_subnormal\")");
			}
			REGULAR_ID117=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key5237); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID117_tree = (Object)adaptor.create(REGULAR_ID117);
			adaptor.addChild(root_0, REGULAR_ID117_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_min_subnormal_key"


	public static class binary_double_min_normal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_min_normal_key"
	// PLSQLKeys.g:808:1: binary_double_min_normal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_min_normal_key_return binary_double_min_normal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_min_normal_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_min_normal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID118=null;

		Object REGULAR_ID118_tree=null;

		try {
			// PLSQLKeys.g:809:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:809:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_min_normal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_min_normal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_min_normal\")");
			}
			REGULAR_ID118=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_min_normal_key5260); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID118_tree = (Object)adaptor.create(REGULAR_ID118);
			adaptor.addChild(root_0, REGULAR_ID118_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_min_normal_key"


	public static class binary_float_max_normal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_max_normal_key"
	// PLSQLKeys.g:812:1: binary_float_max_normal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_max_normal_key_return binary_float_max_normal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_max_normal_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_max_normal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID119=null;

		Object REGULAR_ID119_tree=null;

		try {
			// PLSQLKeys.g:813:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:813:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_max_normal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_max_normal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_max_normal\")");
			}
			REGULAR_ID119=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_max_normal_key5283); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID119_tree = (Object)adaptor.create(REGULAR_ID119);
			adaptor.addChild(root_0, REGULAR_ID119_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_max_normal_key"


	public static class positiven_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "positiven_key"
	// PLSQLKeys.g:816:1: positiven_key :{...}? => REGULAR_ID -> POSITIVEN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.positiven_key_return positiven_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.positiven_key_return retval = new PLSQLParser_PLSQLKeys.positiven_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID120=null;

		Object REGULAR_ID120_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:817:5: ({...}? => REGULAR_ID -> POSITIVEN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:817:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("positiven"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "positiven_key", "input.LT(1).getText().equalsIgnoreCase(\"positiven\")");
			}
			REGULAR_ID120=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_positiven_key5306); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID120);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 817:78: -> POSITIVEN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(POSITIVEN_VK, REGULAR_ID120));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "positiven_key"


	public static class timezone_abbr_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timezone_abbr_key"
	// PLSQLKeys.g:820:1: timezone_abbr_key :{...}? => REGULAR_ID -> TIMEZONE_ABBR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timezone_abbr_key_return timezone_abbr_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timezone_abbr_key_return retval = new PLSQLParser_PLSQLKeys.timezone_abbr_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID121=null;

		Object REGULAR_ID121_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:821:5: ({...}? => REGULAR_ID -> TIMEZONE_ABBR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:821:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timezone_abbr"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timezone_abbr_key", "input.LT(1).getText().equalsIgnoreCase(\"timezone_abbr\")");
			}
			REGULAR_ID121=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timezone_abbr_key5334); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID121);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 821:82: -> TIMEZONE_ABBR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMEZONE_ABBR_VK, REGULAR_ID121));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timezone_abbr_key"


	public static class binary_double_min_subnormal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_min_subnormal_key"
	// PLSQLKeys.g:824:1: binary_double_min_subnormal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_min_subnormal_key_return binary_double_min_subnormal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_min_subnormal_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_min_subnormal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID122=null;

		Object REGULAR_ID122_tree=null;

		try {
			// PLSQLKeys.g:825:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:825:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_min_subnormal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_min_subnormal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_min_subnormal\")");
			}
			REGULAR_ID122=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key5362); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID122_tree = (Object)adaptor.create(REGULAR_ID122);
			adaptor.addChild(root_0, REGULAR_ID122_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_min_subnormal_key"


	public static class binary_float_max_subnormal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_max_subnormal_key"
	// PLSQLKeys.g:828:1: binary_float_max_subnormal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_max_subnormal_key_return binary_float_max_subnormal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_max_subnormal_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_max_subnormal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID123=null;

		Object REGULAR_ID123_tree=null;

		try {
			// PLSQLKeys.g:829:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:829:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_max_subnormal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_max_subnormal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_max_subnormal\")");
			}
			REGULAR_ID123=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key5385); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID123_tree = (Object)adaptor.create(REGULAR_ID123);
			adaptor.addChild(root_0, REGULAR_ID123_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_max_subnormal_key"


	public static class binary_double_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_key"
	// PLSQLKeys.g:832:1: binary_double_key :{...}? => REGULAR_ID -> BINARY_DOUBLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.binary_double_key_return binary_double_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID124=null;

		Object REGULAR_ID124_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:833:5: ({...}? => REGULAR_ID -> BINARY_DOUBLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:833:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double\")");
			}
			REGULAR_ID124=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_key5408); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID124);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 833:82: -> BINARY_DOUBLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BINARY_DOUBLE_VK, REGULAR_ID124));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_key"


	public static class bfile_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bfile_key"
	// PLSQLKeys.g:836:1: bfile_key :{...}? => REGULAR_ID -> BFILE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.bfile_key_return bfile_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.bfile_key_return retval = new PLSQLParser_PLSQLKeys.bfile_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID125=null;

		Object REGULAR_ID125_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:837:5: ({...}? => REGULAR_ID -> BFILE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:837:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("bfile"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "bfile_key", "input.LT(1).getText().equalsIgnoreCase(\"bfile\")");
			}
			REGULAR_ID125=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_bfile_key5436); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID125);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 837:74: -> BFILE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BFILE_VK, REGULAR_ID125));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bfile_key"


	public static class binary_double_infinity_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_infinity_key"
	// PLSQLKeys.g:840:1: binary_double_infinity_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_infinity_key_return binary_double_infinity_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_infinity_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_infinity_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID126=null;

		Object REGULAR_ID126_tree=null;

		try {
			// PLSQLKeys.g:841:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:841:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_infinity"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_infinity_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_infinity\")");
			}
			REGULAR_ID126=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_infinity_key5464); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID126_tree = (Object)adaptor.create(REGULAR_ID126);
			adaptor.addChild(root_0, REGULAR_ID126_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_infinity_key"


	public static class timezone_region_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timezone_region_key"
	// PLSQLKeys.g:844:1: timezone_region_key :{...}? => REGULAR_ID -> TIMEZONE_REGION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timezone_region_key_return timezone_region_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timezone_region_key_return retval = new PLSQLParser_PLSQLKeys.timezone_region_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID127=null;

		Object REGULAR_ID127_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:845:5: ({...}? => REGULAR_ID -> TIMEZONE_REGION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:845:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timezone_region"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timezone_region_key", "input.LT(1).getText().equalsIgnoreCase(\"timezone_region\")");
			}
			REGULAR_ID127=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timezone_region_key5487); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID127);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 845:84: -> TIMEZONE_REGION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMEZONE_REGION_VK, REGULAR_ID127));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timezone_region_key"


	public static class timestamp_ltz_unconstrained_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timestamp_ltz_unconstrained_key"
	// PLSQLKeys.g:848:1: timestamp_ltz_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timestamp_ltz_unconstrained_key_return timestamp_ltz_unconstrained_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timestamp_ltz_unconstrained_key_return retval = new PLSQLParser_PLSQLKeys.timestamp_ltz_unconstrained_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID128=null;

		Object REGULAR_ID128_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:849:5: ({...}? => REGULAR_ID -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:849:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timestamp_ltz_unconstrained"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timestamp_ltz_unconstrained_key", "input.LT(1).getText().equalsIgnoreCase(\"timestamp_ltz_unconstrained\")");
			}
			REGULAR_ID128=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key5515); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID128);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 849:96: -> TIMESTAMP_LTZ_UNCONSTRAINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMESTAMP_LTZ_UNCONSTRAINED_VK, REGULAR_ID128));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timestamp_ltz_unconstrained_key"


	public static class naturaln_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "naturaln_key"
	// PLSQLKeys.g:852:1: naturaln_key :{...}? => REGULAR_ID -> NATURALN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.naturaln_key_return naturaln_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.naturaln_key_return retval = new PLSQLParser_PLSQLKeys.naturaln_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID129=null;

		Object REGULAR_ID129_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:853:5: ({...}? => REGULAR_ID -> NATURALN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:853:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("naturaln"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "naturaln_key", "input.LT(1).getText().equalsIgnoreCase(\"naturaln\")");
			}
			REGULAR_ID129=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_naturaln_key5543); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID129);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 853:77: -> NATURALN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NATURALN_VK, REGULAR_ID129));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "naturaln_key"


	public static class simple_integer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "simple_integer_key"
	// PLSQLKeys.g:856:1: simple_integer_key :{...}? => REGULAR_ID -> SIMPLE_INTEGER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.simple_integer_key_return simple_integer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.simple_integer_key_return retval = new PLSQLParser_PLSQLKeys.simple_integer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID130=null;

		Object REGULAR_ID130_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:857:5: ({...}? => REGULAR_ID -> SIMPLE_INTEGER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:857:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("simple_integer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "simple_integer_key", "input.LT(1).getText().equalsIgnoreCase(\"simple_integer\")");
			}
			REGULAR_ID130=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_simple_integer_key5571); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID130);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 857:83: -> SIMPLE_INTEGER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SIMPLE_INTEGER_VK, REGULAR_ID130));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "simple_integer_key"


	public static class binary_double_max_subnormal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_max_subnormal_key"
	// PLSQLKeys.g:860:1: binary_double_max_subnormal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_max_subnormal_key_return binary_double_max_subnormal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_max_subnormal_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_max_subnormal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID131=null;

		Object REGULAR_ID131_tree=null;

		try {
			// PLSQLKeys.g:861:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:861:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_max_subnormal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_max_subnormal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_max_subnormal\")");
			}
			REGULAR_ID131=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key5599); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID131_tree = (Object)adaptor.create(REGULAR_ID131);
			adaptor.addChild(root_0, REGULAR_ID131_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_max_subnormal_key"


	public static class byte_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "byte_key"
	// PLSQLKeys.g:864:1: byte_key :{...}? => REGULAR_ID -> BYTE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.byte_key_return byte_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.byte_key_return retval = new PLSQLParser_PLSQLKeys.byte_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID132=null;

		Object REGULAR_ID132_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:865:5: ({...}? => REGULAR_ID -> BYTE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:865:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("byte"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "byte_key", "input.LT(1).getText().equalsIgnoreCase(\"byte\")");
			}
			REGULAR_ID132=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_byte_key5622); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID132);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 865:73: -> BYTE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BYTE_VK, REGULAR_ID132));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "byte_key"


	public static class binary_float_infinity_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_infinity_key"
	// PLSQLKeys.g:868:1: binary_float_infinity_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_infinity_key_return binary_float_infinity_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_infinity_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_infinity_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID133=null;

		Object REGULAR_ID133_tree=null;

		try {
			// PLSQLKeys.g:869:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:869:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_infinity"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_infinity_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_infinity\")");
			}
			REGULAR_ID133=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_infinity_key5650); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID133_tree = (Object)adaptor.create(REGULAR_ID133);
			adaptor.addChild(root_0, REGULAR_ID133_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_infinity_key"


	public static class binary_float_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_key"
	// PLSQLKeys.g:872:1: binary_float_key :{...}? => REGULAR_ID -> BINARY_FLOAT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.binary_float_key_return binary_float_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID134=null;

		Object REGULAR_ID134_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:873:5: ({...}? => REGULAR_ID -> BINARY_FLOAT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:873:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float\")");
			}
			REGULAR_ID134=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_key5673); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID134);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 873:81: -> BINARY_FLOAT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BINARY_FLOAT_VK, REGULAR_ID134));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_key"


	public static class range_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "range_key"
	// PLSQLKeys.g:876:1: range_key :{...}? => REGULAR_ID -> RANGE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.range_key_return range_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.range_key_return retval = new PLSQLParser_PLSQLKeys.range_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID135=null;

		Object REGULAR_ID135_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:877:5: ({...}? => REGULAR_ID -> RANGE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:877:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("range"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "range_key", "input.LT(1).getText().equalsIgnoreCase(\"range\")");
			}
			REGULAR_ID135=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_range_key5701); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID135);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 877:74: -> RANGE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RANGE_VK, REGULAR_ID135));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "range_key"


	public static class nclob_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nclob_key"
	// PLSQLKeys.g:880:1: nclob_key :{...}? => REGULAR_ID -> NCLOB_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nclob_key_return nclob_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nclob_key_return retval = new PLSQLParser_PLSQLKeys.nclob_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID136=null;

		Object REGULAR_ID136_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:881:5: ({...}? => REGULAR_ID -> NCLOB_VK[$REGULAR_ID] )
			// PLSQLKeys.g:881:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nclob"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nclob_key", "input.LT(1).getText().equalsIgnoreCase(\"nclob\")");
			}
			REGULAR_ID136=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nclob_key5729); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID136);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 881:74: -> NCLOB_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NCLOB_VK, REGULAR_ID136));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nclob_key"


	public static class clob_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "clob_key"
	// PLSQLKeys.g:884:1: clob_key :{...}? => REGULAR_ID -> CLOB_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.clob_key_return clob_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.clob_key_return retval = new PLSQLParser_PLSQLKeys.clob_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID137=null;

		Object REGULAR_ID137_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:885:5: ({...}? => REGULAR_ID -> CLOB_VK[$REGULAR_ID] )
			// PLSQLKeys.g:885:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("clob"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "clob_key", "input.LT(1).getText().equalsIgnoreCase(\"clob\")");
			}
			REGULAR_ID137=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_clob_key5757); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID137);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 885:73: -> CLOB_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CLOB_VK, REGULAR_ID137));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "clob_key"


	public static class dsinterval_unconstrained_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dsinterval_unconstrained_key"
	// PLSQLKeys.g:888:1: dsinterval_unconstrained_key :{...}? => REGULAR_ID -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.dsinterval_unconstrained_key_return dsinterval_unconstrained_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dsinterval_unconstrained_key_return retval = new PLSQLParser_PLSQLKeys.dsinterval_unconstrained_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID138=null;

		Object REGULAR_ID138_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:889:5: ({...}? => REGULAR_ID -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:889:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("dsinterval_unconstrained"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dsinterval_unconstrained_key", "input.LT(1).getText().equalsIgnoreCase(\"dsinterval_unconstrained\")");
			}
			REGULAR_ID138=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key5785); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID138);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 889:93: -> DSINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DSINTERVAL_UNCONSTRAINED_VK, REGULAR_ID138));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dsinterval_unconstrained_key"


	public static class yminterval_unconstrained_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "yminterval_unconstrained_key"
	// PLSQLKeys.g:892:1: yminterval_unconstrained_key :{...}? => REGULAR_ID -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.yminterval_unconstrained_key_return yminterval_unconstrained_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.yminterval_unconstrained_key_return retval = new PLSQLParser_PLSQLKeys.yminterval_unconstrained_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID139=null;

		Object REGULAR_ID139_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:893:5: ({...}? => REGULAR_ID -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:893:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("yminterval_unconstrained"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "yminterval_unconstrained_key", "input.LT(1).getText().equalsIgnoreCase(\"yminterval_unconstrained\")");
			}
			REGULAR_ID139=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key5813); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID139);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 893:93: -> YMINTERVAL_UNCONSTRAINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(YMINTERVAL_UNCONSTRAINED_VK, REGULAR_ID139));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "yminterval_unconstrained_key"


	public static class rowid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rowid_key"
	// PLSQLKeys.g:896:1: rowid_key :{...}? => REGULAR_ID -> ROWID_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rowid_key_return rowid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rowid_key_return retval = new PLSQLParser_PLSQLKeys.rowid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID140=null;

		Object REGULAR_ID140_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:897:5: ({...}? => REGULAR_ID -> ROWID_VK[$REGULAR_ID] )
			// PLSQLKeys.g:897:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rowid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rowid_key", "input.LT(1).getText().equalsIgnoreCase(\"rowid\")");
			}
			REGULAR_ID140=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rowid_key5841); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID140);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 897:74: -> ROWID_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ROWID_VK, REGULAR_ID140));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rowid_key"


	public static class binary_double_nan_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_nan_key"
	// PLSQLKeys.g:900:1: binary_double_nan_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_nan_key_return binary_double_nan_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_nan_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_nan_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID141=null;

		Object REGULAR_ID141_tree=null;

		try {
			// PLSQLKeys.g:901:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:901:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_nan"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_nan_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_nan\")");
			}
			REGULAR_ID141=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_nan_key5869); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID141_tree = (Object)adaptor.create(REGULAR_ID141);
			adaptor.addChild(root_0, REGULAR_ID141_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_nan_key"


	public static class timestamp_unconstrained_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timestamp_unconstrained_key"
	// PLSQLKeys.g:904:1: timestamp_unconstrained_key :{...}? => REGULAR_ID -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timestamp_unconstrained_key_return timestamp_unconstrained_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timestamp_unconstrained_key_return retval = new PLSQLParser_PLSQLKeys.timestamp_unconstrained_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID142=null;

		Object REGULAR_ID142_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:905:5: ({...}? => REGULAR_ID -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:905:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timestamp_unconstrained"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timestamp_unconstrained_key", "input.LT(1).getText().equalsIgnoreCase(\"timestamp_unconstrained\")");
			}
			REGULAR_ID142=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key5892); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID142);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 905:92: -> TIMESTAMP_UNCONSTRAINED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMESTAMP_UNCONSTRAINED_VK, REGULAR_ID142));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timestamp_unconstrained_key"


	public static class binary_float_min_normal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_min_normal_key"
	// PLSQLKeys.g:908:1: binary_float_min_normal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_min_normal_key_return binary_float_min_normal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_min_normal_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_min_normal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID143=null;

		Object REGULAR_ID143_tree=null;

		try {
			// PLSQLKeys.g:909:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:909:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_min_normal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_min_normal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_min_normal\")");
			}
			REGULAR_ID143=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_min_normal_key5920); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID143_tree = (Object)adaptor.create(REGULAR_ID143);
			adaptor.addChild(root_0, REGULAR_ID143_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_min_normal_key"


	public static class signtype_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "signtype_key"
	// PLSQLKeys.g:912:1: signtype_key :{...}? => REGULAR_ID -> SIGNTYPE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.signtype_key_return signtype_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.signtype_key_return retval = new PLSQLParser_PLSQLKeys.signtype_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID144=null;

		Object REGULAR_ID144_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:913:5: ({...}? => REGULAR_ID -> SIGNTYPE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:913:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("signtype"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "signtype_key", "input.LT(1).getText().equalsIgnoreCase(\"signtype\")");
			}
			REGULAR_ID144=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_signtype_key5943); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID144);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 913:77: -> SIGNTYPE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SIGNTYPE_VK, REGULAR_ID144));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "signtype_key"


	public static class blob_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "blob_key"
	// PLSQLKeys.g:916:1: blob_key :{...}? => REGULAR_ID -> BLOB_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.blob_key_return blob_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.blob_key_return retval = new PLSQLParser_PLSQLKeys.blob_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID145=null;

		Object REGULAR_ID145_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:917:5: ({...}? => REGULAR_ID -> BLOB_VK[$REGULAR_ID] )
			// PLSQLKeys.g:917:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("blob"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "blob_key", "input.LT(1).getText().equalsIgnoreCase(\"blob\")");
			}
			REGULAR_ID145=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_blob_key5971); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID145);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 917:73: -> BLOB_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BLOB_VK, REGULAR_ID145));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "blob_key"


	public static class nvarchar2_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nvarchar2_key"
	// PLSQLKeys.g:920:1: nvarchar2_key :{...}? => REGULAR_ID -> NVARCHAR2_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nvarchar2_key_return nvarchar2_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nvarchar2_key_return retval = new PLSQLParser_PLSQLKeys.nvarchar2_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID146=null;

		Object REGULAR_ID146_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:921:5: ({...}? => REGULAR_ID -> NVARCHAR2_VK[$REGULAR_ID] )
			// PLSQLKeys.g:921:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nvarchar2"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nvarchar2_key", "input.LT(1).getText().equalsIgnoreCase(\"nvarchar2\")");
			}
			REGULAR_ID146=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nvarchar2_key5999); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID146);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 921:78: -> NVARCHAR2_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NVARCHAR2_VK, REGULAR_ID146));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nvarchar2_key"


	public static class binary_double_max_normal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_double_max_normal_key"
	// PLSQLKeys.g:924:1: binary_double_max_normal_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_double_max_normal_key_return binary_double_max_normal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_double_max_normal_key_return retval = new PLSQLParser_PLSQLKeys.binary_double_max_normal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID147=null;

		Object REGULAR_ID147_tree=null;

		try {
			// PLSQLKeys.g:925:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:925:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_double_max_normal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_double_max_normal_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_double_max_normal\")");
			}
			REGULAR_ID147=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_double_max_normal_key6027); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID147_tree = (Object)adaptor.create(REGULAR_ID147);
			adaptor.addChild(root_0, REGULAR_ID147_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_double_max_normal_key"


	public static class binary_float_nan_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_float_nan_key"
	// PLSQLKeys.g:928:1: binary_float_nan_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.binary_float_nan_key_return binary_float_nan_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_float_nan_key_return retval = new PLSQLParser_PLSQLKeys.binary_float_nan_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID148=null;

		Object REGULAR_ID148_tree=null;

		try {
			// PLSQLKeys.g:929:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:929:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_float_nan"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_float_nan_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_float_nan\")");
			}
			REGULAR_ID148=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_float_nan_key6050); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID148_tree = (Object)adaptor.create(REGULAR_ID148);
			adaptor.addChild(root_0, REGULAR_ID148_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_float_nan_key"


	public static class string_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "string_key"
	// PLSQLKeys.g:932:1: string_key :{...}? => REGULAR_ID -> STRING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.string_key_return string_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.string_key_return retval = new PLSQLParser_PLSQLKeys.string_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID149=null;

		Object REGULAR_ID149_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:933:5: ({...}? => REGULAR_ID -> STRING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:933:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("string"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "string_key", "input.LT(1).getText().equalsIgnoreCase(\"string\")");
			}
			REGULAR_ID149=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_string_key6073); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID149);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 933:75: -> STRING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING_VK, REGULAR_ID149));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "string_key"


	public static class c_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "c_key"
	// PLSQLKeys.g:936:1: c_key :{...}? => REGULAR_ID -> C_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.c_key_return c_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.c_key_return retval = new PLSQLParser_PLSQLKeys.c_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID150=null;

		Object REGULAR_ID150_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:937:5: ({...}? => REGULAR_ID -> C_VK[$REGULAR_ID] )
			// PLSQLKeys.g:937:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("c"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "c_key", "input.LT(1).getText().equalsIgnoreCase(\"c\")");
			}
			REGULAR_ID150=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_c_key6101); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID150);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 937:70: -> C_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(C_VK, REGULAR_ID150));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "c_key"


	public static class library_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "library_key"
	// PLSQLKeys.g:940:1: library_key :{...}? => REGULAR_ID -> LIBRARY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.library_key_return library_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.library_key_return retval = new PLSQLParser_PLSQLKeys.library_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID151=null;

		Object REGULAR_ID151_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:941:5: ({...}? => REGULAR_ID -> LIBRARY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:941:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("library"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "library_key", "input.LT(1).getText().equalsIgnoreCase(\"library\")");
			}
			REGULAR_ID151=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_library_key6129); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID151);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 941:76: -> LIBRARY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LIBRARY_VK, REGULAR_ID151));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "library_key"


	public static class context_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "context_key"
	// PLSQLKeys.g:944:1: context_key :{...}? => REGULAR_ID -> CONTEXT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.context_key_return context_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.context_key_return retval = new PLSQLParser_PLSQLKeys.context_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID152=null;

		Object REGULAR_ID152_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:945:5: ({...}? => REGULAR_ID -> CONTEXT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:945:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("context"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "context_key", "input.LT(1).getText().equalsIgnoreCase(\"context\")");
			}
			REGULAR_ID152=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_context_key6157); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID152);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 945:76: -> CONTEXT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONTEXT_VK, REGULAR_ID152));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "context_key"


	public static class parameters_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parameters_key"
	// PLSQLKeys.g:948:1: parameters_key :{...}? => REGULAR_ID -> PARAMETERS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.parameters_key_return parameters_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.parameters_key_return retval = new PLSQLParser_PLSQLKeys.parameters_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID153=null;

		Object REGULAR_ID153_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:949:5: ({...}? => REGULAR_ID -> PARAMETERS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:949:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("parameters"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parameters_key", "input.LT(1).getText().equalsIgnoreCase(\"parameters\")");
			}
			REGULAR_ID153=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_parameters_key6185); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID153);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 949:79: -> PARAMETERS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PARAMETERS_VK, REGULAR_ID153));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parameters_key"


	public static class agent_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "agent_key"
	// PLSQLKeys.g:952:1: agent_key :{...}? => REGULAR_ID -> AGENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.agent_key_return agent_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.agent_key_return retval = new PLSQLParser_PLSQLKeys.agent_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID154=null;

		Object REGULAR_ID154_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:953:5: ({...}? => REGULAR_ID -> AGENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:953:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("agent"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "agent_key", "input.LT(1).getText().equalsIgnoreCase(\"agent\")");
			}
			REGULAR_ID154=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_agent_key6213); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID154);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 953:74: -> AGENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AGENT_VK, REGULAR_ID154));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "agent_key"


	public static class cluster_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cluster_key"
	// PLSQLKeys.g:956:1: cluster_key :{...}? => REGULAR_ID -> CLUSTER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cluster_key_return cluster_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cluster_key_return retval = new PLSQLParser_PLSQLKeys.cluster_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID155=null;

		Object REGULAR_ID155_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:957:5: ({...}? => REGULAR_ID -> CLUSTER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:957:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cluster"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cluster_key", "input.LT(1).getText().equalsIgnoreCase(\"cluster\")");
			}
			REGULAR_ID155=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cluster_key6241); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID155);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 957:76: -> CLUSTER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CLUSTER_VK, REGULAR_ID155));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cluster_key"


	public static class hash_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "hash_key"
	// PLSQLKeys.g:960:1: hash_key :{...}? => REGULAR_ID -> HASH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.hash_key_return hash_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.hash_key_return retval = new PLSQLParser_PLSQLKeys.hash_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID156=null;

		Object REGULAR_ID156_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:961:5: ({...}? => REGULAR_ID -> HASH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:961:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("hash"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "hash_key", "input.LT(1).getText().equalsIgnoreCase(\"hash\")");
			}
			REGULAR_ID156=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_hash_key6269); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID156);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 961:73: -> HASH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(HASH_VK, REGULAR_ID156));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "hash_key"


	public static class relies_on_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "relies_on_key"
	// PLSQLKeys.g:964:1: relies_on_key :{...}? => REGULAR_ID -> RELIES_ON_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.relies_on_key_return relies_on_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.relies_on_key_return retval = new PLSQLParser_PLSQLKeys.relies_on_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID157=null;

		Object REGULAR_ID157_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:965:5: ({...}? => REGULAR_ID -> RELIES_ON_VK[$REGULAR_ID] )
			// PLSQLKeys.g:965:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("relies_on"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "relies_on_key", "input.LT(1).getText().equalsIgnoreCase(\"relies_on\")");
			}
			REGULAR_ID157=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_relies_on_key6297); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID157);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 965:78: -> RELIES_ON_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RELIES_ON_VK, REGULAR_ID157));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "relies_on_key"


	public static class returning_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "returning_key"
	// PLSQLKeys.g:968:1: returning_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.returning_key_return returning_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.returning_key_return retval = new PLSQLParser_PLSQLKeys.returning_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID158=null;

		Object REGULAR_ID158_tree=null;

		try {
			// PLSQLKeys.g:969:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:969:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("returning"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "returning_key", "input.LT(1).getText().equalsIgnoreCase(\"returning\")");
			}
			REGULAR_ID158=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_returning_key6325); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID158_tree = (Object)adaptor.create(REGULAR_ID158);
			adaptor.addChild(root_0, REGULAR_ID158_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "returning_key"


	public static class statement_id_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statement_id_key"
	// PLSQLKeys.g:972:1: statement_id_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.statement_id_key_return statement_id_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.statement_id_key_return retval = new PLSQLParser_PLSQLKeys.statement_id_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID159=null;

		Object REGULAR_ID159_tree=null;

		try {
			// PLSQLKeys.g:973:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:973:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("statement_id"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "statement_id_key", "input.LT(1).getText().equalsIgnoreCase(\"statement_id\")");
			}
			REGULAR_ID159=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_statement_id_key6352); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID159_tree = (Object)adaptor.create(REGULAR_ID159);
			adaptor.addChild(root_0, REGULAR_ID159_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statement_id_key"


	public static class deferred_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "deferred_key"
	// PLSQLKeys.g:976:1: deferred_key :{...}? => REGULAR_ID -> DEFERRED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.deferred_key_return deferred_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.deferred_key_return retval = new PLSQLParser_PLSQLKeys.deferred_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID160=null;

		Object REGULAR_ID160_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:977:5: ({...}? => REGULAR_ID -> DEFERRED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:977:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("deferred"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "deferred_key", "input.LT(1).getText().equalsIgnoreCase(\"deferred\")");
			}
			REGULAR_ID160=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_deferred_key6375); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID160);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 977:77: -> DEFERRED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEFERRED_VK, REGULAR_ID160));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "deferred_key"


	public static class advise_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "advise_key"
	// PLSQLKeys.g:980:1: advise_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.advise_key_return advise_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.advise_key_return retval = new PLSQLParser_PLSQLKeys.advise_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID161=null;

		Object REGULAR_ID161_tree=null;

		try {
			// PLSQLKeys.g:981:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:981:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("advise"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "advise_key", "input.LT(1).getText().equalsIgnoreCase(\"advise\")");
			}
			REGULAR_ID161=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_advise_key6403); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID161_tree = (Object)adaptor.create(REGULAR_ID161);
			adaptor.addChild(root_0, REGULAR_ID161_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "advise_key"


	public static class resumable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "resumable_key"
	// PLSQLKeys.g:984:1: resumable_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.resumable_key_return resumable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.resumable_key_return retval = new PLSQLParser_PLSQLKeys.resumable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID162=null;

		Object REGULAR_ID162_tree=null;

		try {
			// PLSQLKeys.g:985:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:985:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("resumable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "resumable_key", "input.LT(1).getText().equalsIgnoreCase(\"resumable\")");
			}
			REGULAR_ID162=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_resumable_key6426); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID162_tree = (Object)adaptor.create(REGULAR_ID162);
			adaptor.addChild(root_0, REGULAR_ID162_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "resumable_key"


	public static class timeout_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timeout_key"
	// PLSQLKeys.g:988:1: timeout_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.timeout_key_return timeout_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timeout_key_return retval = new PLSQLParser_PLSQLKeys.timeout_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID163=null;

		Object REGULAR_ID163_tree=null;

		try {
			// PLSQLKeys.g:989:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:989:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("timeout"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timeout_key", "input.LT(1).getText().equalsIgnoreCase(\"timeout\")");
			}
			REGULAR_ID163=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timeout_key6449); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID163_tree = (Object)adaptor.create(REGULAR_ID163);
			adaptor.addChild(root_0, REGULAR_ID163_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timeout_key"


	public static class parallel_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parallel_key"
	// PLSQLKeys.g:992:1: parallel_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.parallel_key_return parallel_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.parallel_key_return retval = new PLSQLParser_PLSQLKeys.parallel_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID164=null;

		Object REGULAR_ID164_tree=null;

		try {
			// PLSQLKeys.g:993:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:993:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("parallel"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parallel_key", "input.LT(1).getText().equalsIgnoreCase(\"parallel\")");
			}
			REGULAR_ID164=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_parallel_key6472); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID164_tree = (Object)adaptor.create(REGULAR_ID164);
			adaptor.addChild(root_0, REGULAR_ID164_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parallel_key"


	public static class ddl_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ddl_key"
	// PLSQLKeys.g:996:1: ddl_key :{...}? => REGULAR_ID -> DDL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.ddl_key_return ddl_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ddl_key_return retval = new PLSQLParser_PLSQLKeys.ddl_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID165=null;

		Object REGULAR_ID165_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:997:5: ({...}? => REGULAR_ID -> DDL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:997:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("ddl"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ddl_key", "input.LT(1).getText().equalsIgnoreCase(\"ddl\")");
			}
			REGULAR_ID165=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ddl_key6495); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID165);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 997:72: -> DDL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DDL_VK, REGULAR_ID165));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ddl_key"


	public static class query_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "query_key"
	// PLSQLKeys.g:1000:1: query_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.query_key_return query_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.query_key_return retval = new PLSQLParser_PLSQLKeys.query_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID166=null;

		Object REGULAR_ID166_tree=null;

		try {
			// PLSQLKeys.g:1001:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1001:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("query"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "query_key", "input.LT(1).getText().equalsIgnoreCase(\"query\")");
			}
			REGULAR_ID166=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_query_key6523); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID166_tree = (Object)adaptor.create(REGULAR_ID166);
			adaptor.addChild(root_0, REGULAR_ID166_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "query_key"


	public static class dml_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dml_key"
	// PLSQLKeys.g:1004:1: dml_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.dml_key_return dml_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dml_key_return retval = new PLSQLParser_PLSQLKeys.dml_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID167=null;

		Object REGULAR_ID167_tree=null;

		try {
			// PLSQLKeys.g:1005:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1005:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("dml"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dml_key", "input.LT(1).getText().equalsIgnoreCase(\"dml\")");
			}
			REGULAR_ID167=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dml_key6546); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID167_tree = (Object)adaptor.create(REGULAR_ID167);
			adaptor.addChild(root_0, REGULAR_ID167_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dml_key"


	public static class guard_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "guard_key"
	// PLSQLKeys.g:1008:1: guard_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.guard_key_return guard_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.guard_key_return retval = new PLSQLParser_PLSQLKeys.guard_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID168=null;

		Object REGULAR_ID168_tree=null;

		try {
			// PLSQLKeys.g:1009:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1009:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("guard"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "guard_key", "input.LT(1).getText().equalsIgnoreCase(\"guard\")");
			}
			REGULAR_ID168=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_guard_key6569); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID168_tree = (Object)adaptor.create(REGULAR_ID168);
			adaptor.addChild(root_0, REGULAR_ID168_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "guard_key"


	public static class nothing_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nothing_key"
	// PLSQLKeys.g:1012:1: nothing_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.nothing_key_return nothing_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nothing_key_return retval = new PLSQLParser_PLSQLKeys.nothing_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID169=null;

		Object REGULAR_ID169_tree=null;

		try {
			// PLSQLKeys.g:1013:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1013:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("nothing"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nothing_key", "input.LT(1).getText().equalsIgnoreCase(\"nothing\")");
			}
			REGULAR_ID169=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nothing_key6592); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID169_tree = (Object)adaptor.create(REGULAR_ID169);
			adaptor.addChild(root_0, REGULAR_ID169_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nothing_key"


	public static class enable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "enable_key"
	// PLSQLKeys.g:1016:1: enable_key :{...}? => REGULAR_ID -> ENABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.enable_key_return enable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.enable_key_return retval = new PLSQLParser_PLSQLKeys.enable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID170=null;

		Object REGULAR_ID170_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1017:5: ({...}? => REGULAR_ID -> ENABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1017:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("enable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "enable_key", "input.LT(1).getText().equalsIgnoreCase(\"enable\")");
			}
			REGULAR_ID170=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_enable_key6615); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID170);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1017:75: -> ENABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ENABLE_VK, REGULAR_ID170));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "enable_key"


	public static class database_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "database_key"
	// PLSQLKeys.g:1020:1: database_key :{...}? => REGULAR_ID -> DATABASE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.database_key_return database_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.database_key_return retval = new PLSQLParser_PLSQLKeys.database_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID171=null;

		Object REGULAR_ID171_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1021:5: ({...}? => REGULAR_ID -> DATABASE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1021:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("database"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "database_key", "input.LT(1).getText().equalsIgnoreCase(\"database\")");
			}
			REGULAR_ID171=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_database_key6643); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID171);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1021:77: -> DATABASE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DATABASE_VK, REGULAR_ID171));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "database_key"


	public static class disable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "disable_key"
	// PLSQLKeys.g:1024:1: disable_key :{...}? => REGULAR_ID -> DISABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.disable_key_return disable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.disable_key_return retval = new PLSQLParser_PLSQLKeys.disable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID172=null;

		Object REGULAR_ID172_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1025:5: ({...}? => REGULAR_ID -> DISABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1025:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("disable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "disable_key", "input.LT(1).getText().equalsIgnoreCase(\"disable\")");
			}
			REGULAR_ID172=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_disable_key6671); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID172);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1025:76: -> DISABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DISABLE_VK, REGULAR_ID172));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "disable_key"


	public static class link_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "link_key"
	// PLSQLKeys.g:1028:1: link_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.link_key_return link_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.link_key_return retval = new PLSQLParser_PLSQLKeys.link_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID173=null;

		Object REGULAR_ID173_tree=null;

		try {
			// PLSQLKeys.g:1029:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1029:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("link"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "link_key", "input.LT(1).getText().equalsIgnoreCase(\"link\")");
			}
			REGULAR_ID173=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_link_key6699); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID173_tree = (Object)adaptor.create(REGULAR_ID173);
			adaptor.addChild(root_0, REGULAR_ID173_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "link_key"


	public static class identified_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "identified_key"
	// PLSQLKeys.g:1032:1: identified_key : PLSQL_RESERVED_IDENTIFIED ;
	public final PLSQLParser_PLSQLKeys.identified_key_return identified_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.identified_key_return retval = new PLSQLParser_PLSQLKeys.identified_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_IDENTIFIED174=null;

		Object PLSQL_RESERVED_IDENTIFIED174_tree=null;

		try {
			// PLSQLKeys.g:1033:5: ( PLSQL_RESERVED_IDENTIFIED )
			// PLSQLKeys.g:1033:10: PLSQL_RESERVED_IDENTIFIED
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_IDENTIFIED174=(Token)match(input,PLSQL_RESERVED_IDENTIFIED,FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key6719); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_IDENTIFIED174_tree = (Object)adaptor.create(PLSQL_RESERVED_IDENTIFIED174);
			adaptor.addChild(root_0, PLSQL_RESERVED_IDENTIFIED174_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "identified_key"


	public static class none_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "none_key"
	// PLSQLKeys.g:1036:1: none_key :{...}? => REGULAR_ID -> NONE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.none_key_return none_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.none_key_return retval = new PLSQLParser_PLSQLKeys.none_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID175=null;

		Object REGULAR_ID175_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1037:5: ({...}? => REGULAR_ID -> NONE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1037:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("none"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "none_key", "input.LT(1).getText().equalsIgnoreCase(\"none\")");
			}
			REGULAR_ID175=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_none_key6742); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID175);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1037:73: -> NONE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NONE_VK, REGULAR_ID175));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "none_key"


	public static class before_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "before_key"
	// PLSQLKeys.g:1040:1: before_key :{...}? => REGULAR_ID -> BEFORE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.before_key_return before_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.before_key_return retval = new PLSQLParser_PLSQLKeys.before_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID176=null;

		Object REGULAR_ID176_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1041:5: ({...}? => REGULAR_ID -> BEFORE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1041:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("before"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "before_key", "input.LT(1).getText().equalsIgnoreCase(\"before\")");
			}
			REGULAR_ID176=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_before_key6770); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID176);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1041:75: -> BEFORE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BEFORE_VK, REGULAR_ID176));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "before_key"


	public static class referencing_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "referencing_key"
	// PLSQLKeys.g:1044:1: referencing_key :{...}? => REGULAR_ID -> REFERENCING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.referencing_key_return referencing_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.referencing_key_return retval = new PLSQLParser_PLSQLKeys.referencing_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID177=null;

		Object REGULAR_ID177_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1045:5: ({...}? => REGULAR_ID -> REFERENCING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1045:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("referencing"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "referencing_key", "input.LT(1).getText().equalsIgnoreCase(\"referencing\")");
			}
			REGULAR_ID177=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_referencing_key6799); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID177);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1045:80: -> REFERENCING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REFERENCING_VK, REGULAR_ID177));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "referencing_key"


	public static class logon_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "logon_key"
	// PLSQLKeys.g:1048:1: logon_key :{...}? => REGULAR_ID -> LOGON_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.logon_key_return logon_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.logon_key_return retval = new PLSQLParser_PLSQLKeys.logon_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID178=null;

		Object REGULAR_ID178_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1049:5: ({...}? => REGULAR_ID -> LOGON_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1049:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("logon"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "logon_key", "input.LT(1).getText().equalsIgnoreCase(\"logon\")");
			}
			REGULAR_ID178=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_logon_key6827); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID178);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1049:74: -> LOGON_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LOGON_VK, REGULAR_ID178));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logon_key"


	public static class after_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "after_key"
	// PLSQLKeys.g:1052:1: after_key :{...}? => REGULAR_ID -> AFTER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.after_key_return after_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.after_key_return retval = new PLSQLParser_PLSQLKeys.after_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID179=null;

		Object REGULAR_ID179_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1053:5: ({...}? => REGULAR_ID -> AFTER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1053:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("after"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "after_key", "input.LT(1).getText().equalsIgnoreCase(\"after\")");
			}
			REGULAR_ID179=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_after_key6855); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID179);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1053:74: -> AFTER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AFTER_VK, REGULAR_ID179));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "after_key"


	public static class schema_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "schema_key"
	// PLSQLKeys.g:1056:1: schema_key :{...}? => REGULAR_ID -> SCHEMA_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.schema_key_return schema_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.schema_key_return retval = new PLSQLParser_PLSQLKeys.schema_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID180=null;

		Object REGULAR_ID180_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1057:5: ({...}? => REGULAR_ID -> SCHEMA_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1057:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("schema"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "schema_key", "input.LT(1).getText().equalsIgnoreCase(\"schema\")");
			}
			REGULAR_ID180=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_schema_key6883); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID180);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1057:75: -> SCHEMA_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SCHEMA_VK, REGULAR_ID180));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "schema_key"


	public static class grant_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "grant_key"
	// PLSQLKeys.g:1060:1: grant_key : SQL92_RESERVED_GRANT ;
	public final PLSQLParser_PLSQLKeys.grant_key_return grant_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.grant_key_return retval = new PLSQLParser_PLSQLKeys.grant_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_GRANT181=null;

		Object SQL92_RESERVED_GRANT181_tree=null;

		try {
			// PLSQLKeys.g:1061:5: ( SQL92_RESERVED_GRANT )
			// PLSQLKeys.g:1061:10: SQL92_RESERVED_GRANT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_GRANT181=(Token)match(input,SQL92_RESERVED_GRANT,FOLLOW_SQL92_RESERVED_GRANT_in_grant_key6908); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_GRANT181_tree = (Object)adaptor.create(SQL92_RESERVED_GRANT181);
			adaptor.addChild(root_0, SQL92_RESERVED_GRANT181_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "grant_key"


	public static class truncate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "truncate_key"
	// PLSQLKeys.g:1064:1: truncate_key :{...}? => REGULAR_ID -> TRUNCATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.truncate_key_return truncate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.truncate_key_return retval = new PLSQLParser_PLSQLKeys.truncate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID182=null;

		Object REGULAR_ID182_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1065:5: ({...}? => REGULAR_ID -> TRUNCATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1065:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("truncate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "truncate_key", "input.LT(1).getText().equalsIgnoreCase(\"truncate\")");
			}
			REGULAR_ID182=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_truncate_key6931); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID182);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1065:77: -> TRUNCATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TRUNCATE_VK, REGULAR_ID182));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "truncate_key"


	public static class startup_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "startup_key"
	// PLSQLKeys.g:1068:1: startup_key :{...}? => REGULAR_ID -> STARTUP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.startup_key_return startup_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.startup_key_return retval = new PLSQLParser_PLSQLKeys.startup_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID183=null;

		Object REGULAR_ID183_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1069:5: ({...}? => REGULAR_ID -> STARTUP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1069:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("startup"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "startup_key", "input.LT(1).getText().equalsIgnoreCase(\"startup\")");
			}
			REGULAR_ID183=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_startup_key6959); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID183);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1069:76: -> STARTUP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STARTUP_VK, REGULAR_ID183));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "startup_key"


	public static class statistics_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statistics_key"
	// PLSQLKeys.g:1072:1: statistics_key :{...}? => REGULAR_ID -> STATISTICS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.statistics_key_return statistics_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.statistics_key_return retval = new PLSQLParser_PLSQLKeys.statistics_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID184=null;

		Object REGULAR_ID184_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1073:5: ({...}? => REGULAR_ID -> STATISTICS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1073:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("statistics"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "statistics_key", "input.LT(1).getText().equalsIgnoreCase(\"statistics\")");
			}
			REGULAR_ID184=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_statistics_key6987); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID184);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1073:79: -> STATISTICS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STATISTICS_VK, REGULAR_ID184));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statistics_key"


	public static class noaudit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "noaudit_key"
	// PLSQLKeys.g:1076:1: noaudit_key :{...}? => REGULAR_ID -> NOAUDIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.noaudit_key_return noaudit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.noaudit_key_return retval = new PLSQLParser_PLSQLKeys.noaudit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID185=null;

		Object REGULAR_ID185_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1077:5: ({...}? => REGULAR_ID -> NOAUDIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1077:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("noaudit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "noaudit_key", "input.LT(1).getText().equalsIgnoreCase(\"noaudit\")");
			}
			REGULAR_ID185=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_noaudit_key7015); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID185);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1077:76: -> NOAUDIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOAUDIT_VK, REGULAR_ID185));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "noaudit_key"


	public static class suspend_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "suspend_key"
	// PLSQLKeys.g:1080:1: suspend_key :{...}? => REGULAR_ID -> SUSPEND_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.suspend_key_return suspend_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.suspend_key_return retval = new PLSQLParser_PLSQLKeys.suspend_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID186=null;

		Object REGULAR_ID186_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1081:5: ({...}? => REGULAR_ID -> SUSPEND_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1081:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("suspend"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "suspend_key", "input.LT(1).getText().equalsIgnoreCase(\"suspend\")");
			}
			REGULAR_ID186=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_suspend_key7043); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID186);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1081:76: -> SUSPEND_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SUSPEND_VK, REGULAR_ID186));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "suspend_key"


	public static class audit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "audit_key"
	// PLSQLKeys.g:1084:1: audit_key :{...}? => REGULAR_ID -> AUDIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.audit_key_return audit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.audit_key_return retval = new PLSQLParser_PLSQLKeys.audit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID187=null;

		Object REGULAR_ID187_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1085:5: ({...}? => REGULAR_ID -> AUDIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1085:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("audit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "audit_key", "input.LT(1).getText().equalsIgnoreCase(\"audit\")");
			}
			REGULAR_ID187=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_audit_key7071); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID187);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1085:74: -> AUDIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AUDIT_VK, REGULAR_ID187));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "audit_key"


	public static class disassociate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "disassociate_key"
	// PLSQLKeys.g:1088:1: disassociate_key :{...}? => REGULAR_ID -> DISASSOCIATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.disassociate_key_return disassociate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.disassociate_key_return retval = new PLSQLParser_PLSQLKeys.disassociate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID188=null;

		Object REGULAR_ID188_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1089:5: ({...}? => REGULAR_ID -> DISASSOCIATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1089:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("disassociate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "disassociate_key", "input.LT(1).getText().equalsIgnoreCase(\"disassociate\")");
			}
			REGULAR_ID188=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_disassociate_key7099); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID188);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1089:81: -> DISASSOCIATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DISASSOCIATE_VK, REGULAR_ID188));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "disassociate_key"


	public static class shutdown_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "shutdown_key"
	// PLSQLKeys.g:1092:1: shutdown_key :{...}? => REGULAR_ID -> SHUTDOWN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.shutdown_key_return shutdown_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.shutdown_key_return retval = new PLSQLParser_PLSQLKeys.shutdown_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID189=null;

		Object REGULAR_ID189_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1093:5: ({...}? => REGULAR_ID -> SHUTDOWN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1093:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("shutdown"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "shutdown_key", "input.LT(1).getText().equalsIgnoreCase(\"shutdown\")");
			}
			REGULAR_ID189=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_shutdown_key7128); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID189);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1093:77: -> SHUTDOWN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SHUTDOWN_VK, REGULAR_ID189));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "shutdown_key"


	public static class compound_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "compound_key"
	// PLSQLKeys.g:1096:1: compound_key :{...}? => REGULAR_ID -> COMPOUND_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.compound_key_return compound_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.compound_key_return retval = new PLSQLParser_PLSQLKeys.compound_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID190=null;

		Object REGULAR_ID190_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1097:5: ({...}? => REGULAR_ID -> COMPOUND_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1097:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("compound"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "compound_key", "input.LT(1).getText().equalsIgnoreCase(\"compound\")");
			}
			REGULAR_ID190=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_compound_key7156); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID190);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1097:77: -> COMPOUND_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMPOUND_VK, REGULAR_ID190));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "compound_key"


	public static class servererror_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "servererror_key"
	// PLSQLKeys.g:1100:1: servererror_key :{...}? => REGULAR_ID -> SERVERERROR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.servererror_key_return servererror_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.servererror_key_return retval = new PLSQLParser_PLSQLKeys.servererror_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID191=null;

		Object REGULAR_ID191_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1101:5: ({...}? => REGULAR_ID -> SERVERERROR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1101:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("servererror"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "servererror_key", "input.LT(1).getText().equalsIgnoreCase(\"servererror\")");
			}
			REGULAR_ID191=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_servererror_key7184); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID191);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1101:80: -> SERVERERROR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SERVERERROR_VK, REGULAR_ID191));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "servererror_key"


	public static class parent_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "parent_key"
	// PLSQLKeys.g:1104:1: parent_key :{...}? => REGULAR_ID -> PARENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.parent_key_return parent_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.parent_key_return retval = new PLSQLParser_PLSQLKeys.parent_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID192=null;

		Object REGULAR_ID192_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1105:5: ({...}? => REGULAR_ID -> PARENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1105:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("parent"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parent_key", "input.LT(1).getText().equalsIgnoreCase(\"parent\")");
			}
			REGULAR_ID192=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_parent_key7212); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID192);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1105:75: -> PARENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PARENT_VK, REGULAR_ID192));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "parent_key"


	public static class follows_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "follows_key"
	// PLSQLKeys.g:1108:1: follows_key :{...}? => REGULAR_ID -> FOLLOWS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.follows_key_return follows_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.follows_key_return retval = new PLSQLParser_PLSQLKeys.follows_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID193=null;

		Object REGULAR_ID193_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1109:5: ({...}? => REGULAR_ID -> FOLLOWS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1109:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("follows"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "follows_key", "input.LT(1).getText().equalsIgnoreCase(\"follows\")");
			}
			REGULAR_ID193=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_follows_key7240); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID193);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1109:76: -> FOLLOWS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FOLLOWS_VK, REGULAR_ID193));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "follows_key"


	public static class nested_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nested_key"
	// PLSQLKeys.g:1112:1: nested_key :{...}? => REGULAR_ID -> NESTED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nested_key_return nested_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nested_key_return retval = new PLSQLParser_PLSQLKeys.nested_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID194=null;

		Object REGULAR_ID194_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1113:5: ({...}? => REGULAR_ID -> NESTED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1113:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nested"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nested_key", "input.LT(1).getText().equalsIgnoreCase(\"nested\")");
			}
			REGULAR_ID194=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nested_key7268); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID194);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1113:75: -> NESTED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NESTED_VK, REGULAR_ID194));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nested_key"


	public static class old_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "old_key"
	// PLSQLKeys.g:1116:1: old_key :{...}? => REGULAR_ID -> OLD_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.old_key_return old_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.old_key_return retval = new PLSQLParser_PLSQLKeys.old_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID195=null;

		Object REGULAR_ID195_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1117:5: ({...}? => REGULAR_ID -> OLD_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1117:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("old"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "old_key", "input.LT(1).getText().equalsIgnoreCase(\"old\")");
			}
			REGULAR_ID195=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_old_key7296); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID195);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1117:72: -> OLD_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OLD_VK, REGULAR_ID195));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "old_key"


	public static class statement_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statement_key"
	// PLSQLKeys.g:1120:1: statement_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.statement_key_return statement_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.statement_key_return retval = new PLSQLParser_PLSQLKeys.statement_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID196=null;

		Object REGULAR_ID196_tree=null;

		try {
			// PLSQLKeys.g:1121:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1121:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("statement"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "statement_key", "input.LT(1).getText().equalsIgnoreCase(\"statement\")");
			}
			REGULAR_ID196=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_statement_key7324); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID196_tree = (Object)adaptor.create(REGULAR_ID196);
			adaptor.addChild(root_0, REGULAR_ID196_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "statement_key"


	public static class db_role_change_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "db_role_change_key"
	// PLSQLKeys.g:1124:1: db_role_change_key :{...}? => REGULAR_ID -> DB_ROLE_CHANGE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.db_role_change_key_return db_role_change_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.db_role_change_key_return retval = new PLSQLParser_PLSQLKeys.db_role_change_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID197=null;

		Object REGULAR_ID197_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1125:5: ({...}? => REGULAR_ID -> DB_ROLE_CHANGE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1125:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("db_role_change"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "db_role_change_key", "input.LT(1).getText().equalsIgnoreCase(\"db_role_change\")");
			}
			REGULAR_ID197=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_db_role_change_key7347); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID197);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1125:83: -> DB_ROLE_CHANGE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DB_ROLE_CHANGE_VK, REGULAR_ID197));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "db_role_change_key"


	public static class each_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "each_key"
	// PLSQLKeys.g:1128:1: each_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.each_key_return each_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.each_key_return retval = new PLSQLParser_PLSQLKeys.each_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID198=null;

		Object REGULAR_ID198_tree=null;

		try {
			// PLSQLKeys.g:1129:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1129:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("each"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "each_key", "input.LT(1).getText().equalsIgnoreCase(\"each\")");
			}
			REGULAR_ID198=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_each_key7375); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID198_tree = (Object)adaptor.create(REGULAR_ID198);
			adaptor.addChild(root_0, REGULAR_ID198_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "each_key"


	public static class logoff_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "logoff_key"
	// PLSQLKeys.g:1132:1: logoff_key :{...}? => REGULAR_ID -> LOGOFF_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.logoff_key_return logoff_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.logoff_key_return retval = new PLSQLParser_PLSQLKeys.logoff_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID199=null;

		Object REGULAR_ID199_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1133:5: ({...}? => REGULAR_ID -> LOGOFF_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1133:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("logoff"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "logoff_key", "input.LT(1).getText().equalsIgnoreCase(\"logoff\")");
			}
			REGULAR_ID199=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_logoff_key7398); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID199);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1133:75: -> LOGOFF_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LOGOFF_VK, REGULAR_ID199));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "logoff_key"


	public static class analyze_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "analyze_key"
	// PLSQLKeys.g:1136:1: analyze_key :{...}? => REGULAR_ID -> ANALYZE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.analyze_key_return analyze_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.analyze_key_return retval = new PLSQLParser_PLSQLKeys.analyze_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID200=null;

		Object REGULAR_ID200_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1137:5: ({...}? => REGULAR_ID -> ANALYZE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1137:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("analyze"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "analyze_key", "input.LT(1).getText().equalsIgnoreCase(\"analyze\")");
			}
			REGULAR_ID200=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_analyze_key7426); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID200);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1137:76: -> ANALYZE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ANALYZE_VK, REGULAR_ID200));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "analyze_key"


	public static class instead_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "instead_key"
	// PLSQLKeys.g:1140:1: instead_key :{...}? => REGULAR_ID -> INSTEAD_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.instead_key_return instead_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.instead_key_return retval = new PLSQLParser_PLSQLKeys.instead_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID201=null;

		Object REGULAR_ID201_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1141:5: ({...}? => REGULAR_ID -> INSTEAD_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1141:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("instead"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "instead_key", "input.LT(1).getText().equalsIgnoreCase(\"instead\")");
			}
			REGULAR_ID201=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_instead_key7454); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID201);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1141:76: -> INSTEAD_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INSTEAD_VK, REGULAR_ID201));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "instead_key"


	public static class associate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "associate_key"
	// PLSQLKeys.g:1144:1: associate_key :{...}? => REGULAR_ID -> ASSOCIATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.associate_key_return associate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.associate_key_return retval = new PLSQLParser_PLSQLKeys.associate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID202=null;

		Object REGULAR_ID202_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1145:5: ({...}? => REGULAR_ID -> ASSOCIATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1145:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("associate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "associate_key", "input.LT(1).getText().equalsIgnoreCase(\"associate\")");
			}
			REGULAR_ID202=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_associate_key7482); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID202);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1145:78: -> ASSOCIATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ASSOCIATE_VK, REGULAR_ID202));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "associate_key"


	public static class new_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "new_key"
	// PLSQLKeys.g:1148:1: new_key :{...}? => REGULAR_ID -> NEW_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.new_key_return new_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.new_key_return retval = new PLSQLParser_PLSQLKeys.new_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID203=null;

		Object REGULAR_ID203_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1149:5: ({...}? => REGULAR_ID -> NEW_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1149:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("new"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "new_key", "input.LT(1).getText().equalsIgnoreCase(\"new\")");
			}
			REGULAR_ID203=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_new_key7510); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID203);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1149:72: -> NEW_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NEW_VK, REGULAR_ID203));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "new_key"


	public static class revoke_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "revoke_key"
	// PLSQLKeys.g:1152:1: revoke_key : SQL92_RESERVED_REVOKE ;
	public final PLSQLParser_PLSQLKeys.revoke_key_return revoke_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.revoke_key_return retval = new PLSQLParser_PLSQLKeys.revoke_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_REVOKE204=null;

		Object SQL92_RESERVED_REVOKE204_tree=null;

		try {
			// PLSQLKeys.g:1153:5: ( SQL92_RESERVED_REVOKE )
			// PLSQLKeys.g:1153:10: SQL92_RESERVED_REVOKE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_REVOKE204=(Token)match(input,SQL92_RESERVED_REVOKE,FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key7535); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_REVOKE204_tree = (Object)adaptor.create(SQL92_RESERVED_REVOKE204);
			adaptor.addChild(root_0, SQL92_RESERVED_REVOKE204_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "revoke_key"


	public static class rename_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rename_key"
	// PLSQLKeys.g:1156:1: rename_key :{...}? => REGULAR_ID -> RENAME_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rename_key_return rename_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rename_key_return retval = new PLSQLParser_PLSQLKeys.rename_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID205=null;

		Object REGULAR_ID205_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1157:5: ({...}? => REGULAR_ID -> RENAME_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1157:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rename"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rename_key", "input.LT(1).getText().equalsIgnoreCase(\"rename\")");
			}
			REGULAR_ID205=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rename_key7558); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID205);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1157:75: -> RENAME_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RENAME_VK, REGULAR_ID205));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rename_key"


	public static class customdatum_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "customdatum_key"
	// PLSQLKeys.g:1160:1: customdatum_key :{...}? => REGULAR_ID -> CUSTOMDATUM_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.customdatum_key_return customdatum_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.customdatum_key_return retval = new PLSQLParser_PLSQLKeys.customdatum_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID206=null;

		Object REGULAR_ID206_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1161:5: ({...}? => REGULAR_ID -> CUSTOMDATUM_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1161:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("customdatum"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "customdatum_key", "input.LT(1).getText().equalsIgnoreCase(\"customdatum\")");
			}
			REGULAR_ID206=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_customdatum_key7587); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID206);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1161:80: -> CUSTOMDATUM_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CUSTOMDATUM_VK, REGULAR_ID206));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "customdatum_key"


	public static class oradata_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "oradata_key"
	// PLSQLKeys.g:1164:1: oradata_key :{...}? => REGULAR_ID -> ORADATA_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.oradata_key_return oradata_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.oradata_key_return retval = new PLSQLParser_PLSQLKeys.oradata_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID207=null;

		Object REGULAR_ID207_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1165:5: ({...}? => REGULAR_ID -> ORADATA_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1165:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("oradata"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "oradata_key", "input.LT(1).getText().equalsIgnoreCase(\"oradata\")");
			}
			REGULAR_ID207=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_oradata_key7615); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID207);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1165:76: -> ORADATA_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ORADATA_VK, REGULAR_ID207));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "oradata_key"


	public static class constructor_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "constructor_key"
	// PLSQLKeys.g:1168:1: constructor_key :{...}? => REGULAR_ID -> CONSTRUCTOR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.constructor_key_return constructor_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.constructor_key_return retval = new PLSQLParser_PLSQLKeys.constructor_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID208=null;

		Object REGULAR_ID208_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1169:5: ({...}? => REGULAR_ID -> CONSTRUCTOR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1169:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("constructor"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "constructor_key", "input.LT(1).getText().equalsIgnoreCase(\"constructor\")");
			}
			REGULAR_ID208=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_constructor_key7643); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID208);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1169:80: -> CONSTRUCTOR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONSTRUCTOR_VK, REGULAR_ID208));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "constructor_key"


	public static class sqldata_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sqldata_key"
	// PLSQLKeys.g:1172:1: sqldata_key :{...}? => REGULAR_ID -> SQLDATA_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sqldata_key_return sqldata_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sqldata_key_return retval = new PLSQLParser_PLSQLKeys.sqldata_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID209=null;

		Object REGULAR_ID209_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1173:5: ({...}? => REGULAR_ID -> SQLDATA_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1173:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sqldata"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sqldata_key", "input.LT(1).getText().equalsIgnoreCase(\"sqldata\")");
			}
			REGULAR_ID209=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sqldata_key7671); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID209);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1173:76: -> SQLDATA_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SQLDATA_VK, REGULAR_ID209));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sqldata_key"


	public static class member_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "member_key"
	// PLSQLKeys.g:1176:1: member_key :{...}? => REGULAR_ID -> MEMBER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.member_key_return member_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.member_key_return retval = new PLSQLParser_PLSQLKeys.member_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID210=null;

		Object REGULAR_ID210_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1177:5: ({...}? => REGULAR_ID -> MEMBER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1177:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("member"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "member_key", "input.LT(1).getText().equalsIgnoreCase(\"member\")");
			}
			REGULAR_ID210=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_member_key7699); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID210);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1177:75: -> MEMBER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MEMBER_VK, REGULAR_ID210));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "member_key"


	public static class self_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "self_key"
	// PLSQLKeys.g:1180:1: self_key :{...}? => REGULAR_ID -> SELF_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.self_key_return self_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.self_key_return retval = new PLSQLParser_PLSQLKeys.self_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID211=null;

		Object REGULAR_ID211_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1181:5: ({...}? => REGULAR_ID -> SELF_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1181:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("self"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "self_key", "input.LT(1).getText().equalsIgnoreCase(\"self\")");
			}
			REGULAR_ID211=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_self_key7727); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID211);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1181:73: -> SELF_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SELF_VK, REGULAR_ID211));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "self_key"


	public static class object_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "object_key"
	// PLSQLKeys.g:1184:1: object_key :{...}? => REGULAR_ID -> OBJECT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.object_key_return object_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.object_key_return retval = new PLSQLParser_PLSQLKeys.object_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID212=null;

		Object REGULAR_ID212_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1185:5: ({...}? => REGULAR_ID -> OBJECT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1185:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("object"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "object_key", "input.LT(1).getText().equalsIgnoreCase(\"object\")");
			}
			REGULAR_ID212=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_object_key7755); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID212);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1185:75: -> OBJECT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OBJECT_VK, REGULAR_ID212));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "object_key"


	public static class variable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "variable_key"
	// PLSQLKeys.g:1188:1: variable_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.variable_key_return variable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.variable_key_return retval = new PLSQLParser_PLSQLKeys.variable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID213=null;

		Object REGULAR_ID213_tree=null;

		try {
			// PLSQLKeys.g:1189:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1189:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("variable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "variable_key", "input.LT(1).getText().equalsIgnoreCase(\"variable\")");
			}
			REGULAR_ID213=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_variable_key7783); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID213_tree = (Object)adaptor.create(REGULAR_ID213);
			adaptor.addChild(root_0, REGULAR_ID213_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variable_key"


	public static class instantiable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "instantiable_key"
	// PLSQLKeys.g:1192:1: instantiable_key :{...}? => REGULAR_ID -> INSTANTIABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.instantiable_key_return instantiable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.instantiable_key_return retval = new PLSQLParser_PLSQLKeys.instantiable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID214=null;

		Object REGULAR_ID214_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1193:5: ({...}? => REGULAR_ID -> INSTANTIABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1193:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("instantiable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "instantiable_key", "input.LT(1).getText().equalsIgnoreCase(\"instantiable\")");
			}
			REGULAR_ID214=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_instantiable_key7806); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID214);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1193:81: -> INSTANTIABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INSTANTIABLE_VK, REGULAR_ID214));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "instantiable_key"


	public static class final_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "final_key"
	// PLSQLKeys.g:1196:1: final_key :{...}? => REGULAR_ID -> FINAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.final_key_return final_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.final_key_return retval = new PLSQLParser_PLSQLKeys.final_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID215=null;

		Object REGULAR_ID215_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1197:5: ({...}? => REGULAR_ID -> FINAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1197:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("final"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "final_key", "input.LT(1).getText().equalsIgnoreCase(\"final\")");
			}
			REGULAR_ID215=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_final_key7834); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID215);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1197:74: -> FINAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FINAL_VK, REGULAR_ID215));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "final_key"


	public static class static_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "static_key"
	// PLSQLKeys.g:1200:1: static_key :{...}? => REGULAR_ID -> STATIC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.static_key_return static_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.static_key_return retval = new PLSQLParser_PLSQLKeys.static_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID216=null;

		Object REGULAR_ID216_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1201:5: ({...}? => REGULAR_ID -> STATIC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1201:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("static"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "static_key", "input.LT(1).getText().equalsIgnoreCase(\"static\")");
			}
			REGULAR_ID216=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_static_key7862); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID216);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1201:75: -> STATIC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STATIC_VK, REGULAR_ID216));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "static_key"


	public static class oid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "oid_key"
	// PLSQLKeys.g:1204:1: oid_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.oid_key_return oid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.oid_key_return retval = new PLSQLParser_PLSQLKeys.oid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID217=null;

		Object REGULAR_ID217_tree=null;

		try {
			// PLSQLKeys.g:1205:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1205:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("oid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "oid_key", "input.LT(1).getText().equalsIgnoreCase(\"oid\")");
			}
			REGULAR_ID217=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_oid_key7890); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID217_tree = (Object)adaptor.create(REGULAR_ID217);
			adaptor.addChild(root_0, REGULAR_ID217_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "oid_key"


	public static class result_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "result_key"
	// PLSQLKeys.g:1208:1: result_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.result_key_return result_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.result_key_return retval = new PLSQLParser_PLSQLKeys.result_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID218=null;

		Object REGULAR_ID218_tree=null;

		try {
			// PLSQLKeys.g:1209:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1209:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("result"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "result_key", "input.LT(1).getText().equalsIgnoreCase(\"result\")");
			}
			REGULAR_ID218=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_result_key7913); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID218_tree = (Object)adaptor.create(REGULAR_ID218);
			adaptor.addChild(root_0, REGULAR_ID218_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "result_key"


	public static class under_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "under_key"
	// PLSQLKeys.g:1212:1: under_key :{...}? => REGULAR_ID -> UNDER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.under_key_return under_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.under_key_return retval = new PLSQLParser_PLSQLKeys.under_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID219=null;

		Object REGULAR_ID219_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1213:5: ({...}? => REGULAR_ID -> UNDER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1213:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("under"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "under_key", "input.LT(1).getText().equalsIgnoreCase(\"under\")");
			}
			REGULAR_ID219=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_under_key7936); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID219);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1213:74: -> UNDER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UNDER_VK, REGULAR_ID219));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "under_key"


	public static class map_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "map_key"
	// PLSQLKeys.g:1216:1: map_key :{...}? => REGULAR_ID -> MAP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.map_key_return map_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.map_key_return retval = new PLSQLParser_PLSQLKeys.map_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID220=null;

		Object REGULAR_ID220_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1217:5: ({...}? => REGULAR_ID -> MAP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1217:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("map"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "map_key", "input.LT(1).getText().equalsIgnoreCase(\"map\")");
			}
			REGULAR_ID220=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_map_key7964); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID220);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1217:72: -> MAP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MAP_VK, REGULAR_ID220));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "map_key"


	public static class overriding_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "overriding_key"
	// PLSQLKeys.g:1220:1: overriding_key :{...}? => REGULAR_ID -> OVERRIDING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.overriding_key_return overriding_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.overriding_key_return retval = new PLSQLParser_PLSQLKeys.overriding_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID221=null;

		Object REGULAR_ID221_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1221:5: ({...}? => REGULAR_ID -> OVERRIDING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1221:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("overriding"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "overriding_key", "input.LT(1).getText().equalsIgnoreCase(\"overriding\")");
			}
			REGULAR_ID221=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_overriding_key7992); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID221);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1221:79: -> OVERRIDING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OVERRIDING_VK, REGULAR_ID221));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "overriding_key"


	public static class add_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "add_key"
	// PLSQLKeys.g:1224:1: add_key :{...}? => REGULAR_ID -> ADD_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.add_key_return add_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.add_key_return retval = new PLSQLParser_PLSQLKeys.add_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID222=null;

		Object REGULAR_ID222_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1225:5: ({...}? => REGULAR_ID -> ADD_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1225:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("add"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "add_key", "input.LT(1).getText().equalsIgnoreCase(\"add\")");
			}
			REGULAR_ID222=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_add_key8020); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID222);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1225:72: -> ADD_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ADD_VK, REGULAR_ID222));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "add_key"


	public static class modify_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "modify_key"
	// PLSQLKeys.g:1228:1: modify_key :{...}? => REGULAR_ID -> MODIFY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.modify_key_return modify_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.modify_key_return retval = new PLSQLParser_PLSQLKeys.modify_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID223=null;

		Object REGULAR_ID223_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1229:5: ({...}? => REGULAR_ID -> MODIFY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1229:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("modify"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "modify_key", "input.LT(1).getText().equalsIgnoreCase(\"modify\")");
			}
			REGULAR_ID223=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_modify_key8048); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID223);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1229:75: -> MODIFY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MODIFY_VK, REGULAR_ID223));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "modify_key"


	public static class including_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "including_key"
	// PLSQLKeys.g:1232:1: including_key :{...}? => REGULAR_ID -> INCLUDING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.including_key_return including_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.including_key_return retval = new PLSQLParser_PLSQLKeys.including_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID224=null;

		Object REGULAR_ID224_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1233:5: ({...}? => REGULAR_ID -> INCLUDING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1233:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("including"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "including_key", "input.LT(1).getText().equalsIgnoreCase(\"including\")");
			}
			REGULAR_ID224=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_including_key8076); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID224);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1233:78: -> INCLUDING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INCLUDING_VK, REGULAR_ID224));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "including_key"


	public static class substitutable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "substitutable_key"
	// PLSQLKeys.g:1236:1: substitutable_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.substitutable_key_return substitutable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.substitutable_key_return retval = new PLSQLParser_PLSQLKeys.substitutable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID225=null;

		Object REGULAR_ID225_tree=null;

		try {
			// PLSQLKeys.g:1237:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1237:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("substitutable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "substitutable_key", "input.LT(1).getText().equalsIgnoreCase(\"substitutable\")");
			}
			REGULAR_ID225=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_substitutable_key8104); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID225_tree = (Object)adaptor.create(REGULAR_ID225);
			adaptor.addChild(root_0, REGULAR_ID225_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "substitutable_key"


	public static class attribute_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "attribute_key"
	// PLSQLKeys.g:1240:1: attribute_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.attribute_key_return attribute_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.attribute_key_return retval = new PLSQLParser_PLSQLKeys.attribute_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID226=null;

		Object REGULAR_ID226_tree=null;

		try {
			// PLSQLKeys.g:1241:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1241:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("attribute"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "attribute_key", "input.LT(1).getText().equalsIgnoreCase(\"attribute\")");
			}
			REGULAR_ID226=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_attribute_key8127); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID226_tree = (Object)adaptor.create(REGULAR_ID226);
			adaptor.addChild(root_0, REGULAR_ID226_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "attribute_key"


	public static class cascade_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cascade_key"
	// PLSQLKeys.g:1244:1: cascade_key :{...}? => REGULAR_ID -> CASCADE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cascade_key_return cascade_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cascade_key_return retval = new PLSQLParser_PLSQLKeys.cascade_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID227=null;

		Object REGULAR_ID227_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1245:5: ({...}? => REGULAR_ID -> CASCADE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1245:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cascade"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cascade_key", "input.LT(1).getText().equalsIgnoreCase(\"cascade\")");
			}
			REGULAR_ID227=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cascade_key8150); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID227);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1245:76: -> CASCADE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CASCADE_VK, REGULAR_ID227));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cascade_key"


	public static class data_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "data_key"
	// PLSQLKeys.g:1248:1: data_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.data_key_return data_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.data_key_return retval = new PLSQLParser_PLSQLKeys.data_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID228=null;

		Object REGULAR_ID228_tree=null;

		try {
			// PLSQLKeys.g:1249:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1249:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("data"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "data_key", "input.LT(1).getText().equalsIgnoreCase(\"data\")");
			}
			REGULAR_ID228=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_data_key8179); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID228_tree = (Object)adaptor.create(REGULAR_ID228);
			adaptor.addChild(root_0, REGULAR_ID228_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "data_key"


	public static class invalidate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "invalidate_key"
	// PLSQLKeys.g:1252:1: invalidate_key :{...}? => REGULAR_ID -> INVALIDATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.invalidate_key_return invalidate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.invalidate_key_return retval = new PLSQLParser_PLSQLKeys.invalidate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID229=null;

		Object REGULAR_ID229_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1253:5: ({...}? => REGULAR_ID -> INVALIDATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1253:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("invalidate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "invalidate_key", "input.LT(1).getText().equalsIgnoreCase(\"invalidate\")");
			}
			REGULAR_ID229=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_invalidate_key8202); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID229);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1253:79: -> INVALIDATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INVALIDATE_VK, REGULAR_ID229));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "invalidate_key"


	public static class element_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "element_key"
	// PLSQLKeys.g:1256:1: element_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.element_key_return element_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.element_key_return retval = new PLSQLParser_PLSQLKeys.element_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID230=null;

		Object REGULAR_ID230_tree=null;

		try {
			// PLSQLKeys.g:1257:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1257:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("element"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "element_key", "input.LT(1).getText().equalsIgnoreCase(\"element\")");
			}
			REGULAR_ID230=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_element_key8230); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID230_tree = (Object)adaptor.create(REGULAR_ID230);
			adaptor.addChild(root_0, REGULAR_ID230_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "element_key"


	public static class first_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "first_key"
	// PLSQLKeys.g:1260:1: first_key :{...}? => REGULAR_ID -> FIRST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.first_key_return first_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.first_key_return retval = new PLSQLParser_PLSQLKeys.first_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID231=null;

		Object REGULAR_ID231_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1261:5: ({...}? => REGULAR_ID -> FIRST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1261:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("first"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "first_key", "input.LT(1).getText().equalsIgnoreCase(\"first\")");
			}
			REGULAR_ID231=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_first_key8253); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID231);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1261:74: -> FIRST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FIRST_VK, REGULAR_ID231));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "first_key"


	public static class check_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "check_key"
	// PLSQLKeys.g:1264:1: check_key : SQL92_RESERVED_CHECK ;
	public final PLSQLParser_PLSQLKeys.check_key_return check_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.check_key_return retval = new PLSQLParser_PLSQLKeys.check_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CHECK232=null;

		Object SQL92_RESERVED_CHECK232_tree=null;

		try {
			// PLSQLKeys.g:1265:5: ( SQL92_RESERVED_CHECK )
			// PLSQLKeys.g:1265:10: SQL92_RESERVED_CHECK
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CHECK232=(Token)match(input,SQL92_RESERVED_CHECK,FOLLOW_SQL92_RESERVED_CHECK_in_check_key8278); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CHECK232_tree = (Object)adaptor.create(SQL92_RESERVED_CHECK232);
			adaptor.addChild(root_0, SQL92_RESERVED_CHECK232_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "check_key"


	public static class option_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "option_key"
	// PLSQLKeys.g:1268:1: option_key : SQL92_RESERVED_OPTION ;
	public final PLSQLParser_PLSQLKeys.option_key_return option_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.option_key_return retval = new PLSQLParser_PLSQLKeys.option_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_OPTION233=null;

		Object SQL92_RESERVED_OPTION233_tree=null;

		try {
			// PLSQLKeys.g:1269:5: ( SQL92_RESERVED_OPTION )
			// PLSQLKeys.g:1269:10: SQL92_RESERVED_OPTION
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_OPTION233=(Token)match(input,SQL92_RESERVED_OPTION,FOLLOW_SQL92_RESERVED_OPTION_in_option_key8298); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_OPTION233_tree = (Object)adaptor.create(SQL92_RESERVED_OPTION233);
			adaptor.addChild(root_0, SQL92_RESERVED_OPTION233_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "option_key"


	public static class nocycle_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nocycle_key"
	// PLSQLKeys.g:1272:1: nocycle_key :{...}? => REGULAR_ID -> NOCYCLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nocycle_key_return nocycle_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nocycle_key_return retval = new PLSQLParser_PLSQLKeys.nocycle_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID234=null;

		Object REGULAR_ID234_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1273:5: ({...}? => REGULAR_ID -> NOCYCLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1273:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nocycle"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nocycle_key", "input.LT(1).getText().equalsIgnoreCase(\"nocycle\")");
			}
			REGULAR_ID234=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nocycle_key8321); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID234);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1273:76: -> NOCYCLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOCYCLE_VK, REGULAR_ID234));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nocycle_key"


	public static class locked_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "locked_key"
	// PLSQLKeys.g:1276:1: locked_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.locked_key_return locked_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.locked_key_return retval = new PLSQLParser_PLSQLKeys.locked_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID235=null;

		Object REGULAR_ID235_tree=null;

		try {
			// PLSQLKeys.g:1277:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1277:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("locked"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "locked_key", "input.LT(1).getText().equalsIgnoreCase(\"locked\")");
			}
			REGULAR_ID235=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_locked_key8349); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID235_tree = (Object)adaptor.create(REGULAR_ID235);
			adaptor.addChild(root_0, REGULAR_ID235_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "locked_key"


	public static class block_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "block_key"
	// PLSQLKeys.g:1280:1: block_key :{...}? => REGULAR_ID -> BLOCK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.block_key_return block_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.block_key_return retval = new PLSQLParser_PLSQLKeys.block_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID236=null;

		Object REGULAR_ID236_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1281:5: ({...}? => REGULAR_ID -> BLOCK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1281:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("block"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "block_key", "input.LT(1).getText().equalsIgnoreCase(\"block\")");
			}
			REGULAR_ID236=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_block_key8372); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID236);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1281:74: -> BLOCK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BLOCK_VK, REGULAR_ID236));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "block_key"


	public static class xml_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xml_key"
	// PLSQLKeys.g:1284:1: xml_key :{...}? => REGULAR_ID -> XML_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xml_key_return xml_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xml_key_return retval = new PLSQLParser_PLSQLKeys.xml_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID237=null;

		Object REGULAR_ID237_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1285:5: ({...}? => REGULAR_ID -> XML_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1285:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xml"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xml_key", "input.LT(1).getText().equalsIgnoreCase(\"xml\")");
			}
			REGULAR_ID237=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xml_key8400); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID237);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1285:72: -> XML_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XML_VK, REGULAR_ID237));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xml_key"


	public static class pivot_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pivot_key"
	// PLSQLKeys.g:1288:1: pivot_key :{...}? => REGULAR_ID -> PIVOT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.pivot_key_return pivot_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.pivot_key_return retval = new PLSQLParser_PLSQLKeys.pivot_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID238=null;

		Object REGULAR_ID238_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1289:5: ({...}? => REGULAR_ID -> PIVOT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1289:10: {...}? => REGULAR_ID
			{
			if ( !(((input.LT(1).getText().equalsIgnoreCase("pivot")))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "pivot_key", "(input.LT(1).getText().equalsIgnoreCase(\"pivot\"))");
			}
			REGULAR_ID238=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_pivot_key8428); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID238);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1289:76: -> PIVOT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PIVOT_VK, REGULAR_ID238));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pivot_key"


	public static class prior_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "prior_key"
	// PLSQLKeys.g:1292:1: prior_key : SQL92_RESERVED_PRIOR ;
	public final PLSQLParser_PLSQLKeys.prior_key_return prior_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.prior_key_return retval = new PLSQLParser_PLSQLKeys.prior_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_PRIOR239=null;

		Object SQL92_RESERVED_PRIOR239_tree=null;

		try {
			// PLSQLKeys.g:1293:5: ( SQL92_RESERVED_PRIOR )
			// PLSQLKeys.g:1293:10: SQL92_RESERVED_PRIOR
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_PRIOR239=(Token)match(input,SQL92_RESERVED_PRIOR,FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key8453); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_PRIOR239_tree = (Object)adaptor.create(SQL92_RESERVED_PRIOR239);
			adaptor.addChild(root_0, SQL92_RESERVED_PRIOR239_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "prior_key"


	public static class sequential_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sequential_key"
	// PLSQLKeys.g:1296:1: sequential_key :{...}? => REGULAR_ID -> SEQUENTIAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sequential_key_return sequential_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sequential_key_return retval = new PLSQLParser_PLSQLKeys.sequential_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID240=null;

		Object REGULAR_ID240_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1297:5: ({...}? => REGULAR_ID -> SEQUENTIAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1297:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sequential"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sequential_key", "input.LT(1).getText().equalsIgnoreCase(\"sequential\")");
			}
			REGULAR_ID240=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sequential_key8476); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID240);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1297:79: -> SEQUENTIAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SEQUENTIAL_VK, REGULAR_ID240));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sequential_key"


	public static class single_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "single_key"
	// PLSQLKeys.g:1300:1: single_key :{...}? => REGULAR_ID -> SINGLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.single_key_return single_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.single_key_return retval = new PLSQLParser_PLSQLKeys.single_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID241=null;

		Object REGULAR_ID241_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1301:5: ({...}? => REGULAR_ID -> SINGLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1301:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("single"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "single_key", "input.LT(1).getText().equalsIgnoreCase(\"single\")");
			}
			REGULAR_ID241=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_single_key8504); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID241);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1301:75: -> SINGLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SINGLE_VK, REGULAR_ID241));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "single_key"


	public static class skip_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "skip_key"
	// PLSQLKeys.g:1304:1: skip_key :{...}? => REGULAR_ID -> SKIP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.skip_key_return skip_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.skip_key_return retval = new PLSQLParser_PLSQLKeys.skip_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID242=null;

		Object REGULAR_ID242_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1305:5: ({...}? => REGULAR_ID -> SKIP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1305:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("skip"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "skip_key", "input.LT(1).getText().equalsIgnoreCase(\"skip\")");
			}
			REGULAR_ID242=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_skip_key8532); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID242);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1305:73: -> SKIP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SKIP_VK, REGULAR_ID242));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "skip_key"


	public static class model_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "model_key"
	// PLSQLKeys.g:1308:1: model_key : PLSQL_NON_RESERVED_MODEL ;
	public final PLSQLParser_PLSQLKeys.model_key_return model_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.model_key_return retval = new PLSQLParser_PLSQLKeys.model_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_NON_RESERVED_MODEL243=null;

		Object PLSQL_NON_RESERVED_MODEL243_tree=null;

		try {
			// PLSQLKeys.g:1309:5: ( PLSQL_NON_RESERVED_MODEL )
			// PLSQLKeys.g:1310:9: PLSQL_NON_RESERVED_MODEL
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_NON_RESERVED_MODEL243=(Token)match(input,PLSQL_NON_RESERVED_MODEL,FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key8566); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_NON_RESERVED_MODEL243_tree = (Object)adaptor.create(PLSQL_NON_RESERVED_MODEL243);
			adaptor.addChild(root_0, PLSQL_NON_RESERVED_MODEL243_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "model_key"


	public static class updated_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "updated_key"
	// PLSQLKeys.g:1313:1: updated_key :{...}? => REGULAR_ID -> UPDATED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.updated_key_return updated_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.updated_key_return retval = new PLSQLParser_PLSQLKeys.updated_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID244=null;

		Object REGULAR_ID244_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1314:5: ({...}? => REGULAR_ID -> UPDATED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1314:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("updated"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "updated_key", "input.LT(1).getText().equalsIgnoreCase(\"updated\")");
			}
			REGULAR_ID244=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_updated_key8589); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID244);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1314:76: -> UPDATED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UPDATED_VK, REGULAR_ID244));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "updated_key"


	public static class increment_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "increment_key"
	// PLSQLKeys.g:1317:1: increment_key :{...}? => REGULAR_ID -> INCREMENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.increment_key_return increment_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.increment_key_return retval = new PLSQLParser_PLSQLKeys.increment_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID245=null;

		Object REGULAR_ID245_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1318:5: ({...}? => REGULAR_ID -> INCREMENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1318:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("increment"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "increment_key", "input.LT(1).getText().equalsIgnoreCase(\"increment\")");
			}
			REGULAR_ID245=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_increment_key8617); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID245);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1318:78: -> INCREMENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INCREMENT_VK, REGULAR_ID245));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "increment_key"


	public static class exclude_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exclude_key"
	// PLSQLKeys.g:1321:1: exclude_key :{...}? => REGULAR_ID -> EXCLUDE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.exclude_key_return exclude_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exclude_key_return retval = new PLSQLParser_PLSQLKeys.exclude_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID246=null;

		Object REGULAR_ID246_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1322:5: ({...}? => REGULAR_ID -> EXCLUDE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1322:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("exclude"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "exclude_key", "input.LT(1).getText().equalsIgnoreCase(\"exclude\")");
			}
			REGULAR_ID246=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_exclude_key8645); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID246);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1322:76: -> EXCLUDE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXCLUDE_VK, REGULAR_ID246));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exclude_key"


	public static class reference_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "reference_key"
	// PLSQLKeys.g:1325:1: reference_key :{...}? => REGULAR_ID -> REFERENCE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.reference_key_return reference_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.reference_key_return retval = new PLSQLParser_PLSQLKeys.reference_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID247=null;

		Object REGULAR_ID247_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1326:5: ({...}? => REGULAR_ID -> REFERENCE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1326:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("reference"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "reference_key", "input.LT(1).getText().equalsIgnoreCase(\"reference\")");
			}
			REGULAR_ID247=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_reference_key8673); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID247);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1326:78: -> REFERENCE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REFERENCE_VK, REGULAR_ID247));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "reference_key"


	public static class sets_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sets_key"
	// PLSQLKeys.g:1329:1: sets_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.sets_key_return sets_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sets_key_return retval = new PLSQLParser_PLSQLKeys.sets_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID248=null;

		Object REGULAR_ID248_tree=null;

		try {
			// PLSQLKeys.g:1330:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1330:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("sets"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sets_key", "input.LT(1).getText().equalsIgnoreCase(\"sets\")");
			}
			REGULAR_ID248=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sets_key8701); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID248_tree = (Object)adaptor.create(REGULAR_ID248);
			adaptor.addChild(root_0, REGULAR_ID248_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sets_key"


	public static class until_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "until_key"
	// PLSQLKeys.g:1333:1: until_key :{...}? => REGULAR_ID -> UNTIL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.until_key_return until_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.until_key_return retval = new PLSQLParser_PLSQLKeys.until_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID249=null;

		Object REGULAR_ID249_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1334:5: ({...}? => REGULAR_ID -> UNTIL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1334:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("until"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "until_key", "input.LT(1).getText().equalsIgnoreCase(\"until\")");
			}
			REGULAR_ID249=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_until_key8724); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID249);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1334:74: -> UNTIL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UNTIL_VK, REGULAR_ID249));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "until_key"


	public static class seed_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "seed_key"
	// PLSQLKeys.g:1337:1: seed_key :{...}? => REGULAR_ID -> SEED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.seed_key_return seed_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.seed_key_return retval = new PLSQLParser_PLSQLKeys.seed_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID250=null;

		Object REGULAR_ID250_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1338:5: ({...}? => REGULAR_ID -> SEED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1338:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("seed"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "seed_key", "input.LT(1).getText().equalsIgnoreCase(\"seed\")");
			}
			REGULAR_ID250=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_seed_key8752); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID250);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1338:73: -> SEED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SEED_VK, REGULAR_ID250));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "seed_key"


	public static class maxvalue_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "maxvalue_key"
	// PLSQLKeys.g:1341:1: maxvalue_key :{...}? => REGULAR_ID -> MAXVALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.maxvalue_key_return maxvalue_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.maxvalue_key_return retval = new PLSQLParser_PLSQLKeys.maxvalue_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID251=null;

		Object REGULAR_ID251_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1342:5: ({...}? => REGULAR_ID -> MAXVALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1342:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("maxvalue"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "maxvalue_key", "input.LT(1).getText().equalsIgnoreCase(\"maxvalue\")");
			}
			REGULAR_ID251=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_maxvalue_key8780); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID251);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1342:77: -> MAXVALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MAXVALUE_VK, REGULAR_ID251));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "maxvalue_key"


	public static class siblings_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "siblings_key"
	// PLSQLKeys.g:1345:1: siblings_key :{...}? => REGULAR_ID -> SIBLINGS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.siblings_key_return siblings_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.siblings_key_return retval = new PLSQLParser_PLSQLKeys.siblings_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID252=null;

		Object REGULAR_ID252_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1346:5: ({...}? => REGULAR_ID -> SIBLINGS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1346:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("siblings"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "siblings_key", "input.LT(1).getText().equalsIgnoreCase(\"siblings\")");
			}
			REGULAR_ID252=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_siblings_key8808); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID252);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1346:77: -> SIBLINGS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SIBLINGS_VK, REGULAR_ID252));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "siblings_key"


	public static class cube_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cube_key"
	// PLSQLKeys.g:1349:1: cube_key :{...}? => REGULAR_ID -> CUBE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cube_key_return cube_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cube_key_return retval = new PLSQLParser_PLSQLKeys.cube_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID253=null;

		Object REGULAR_ID253_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1350:5: ({...}? => REGULAR_ID -> CUBE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1350:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cube"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cube_key", "input.LT(1).getText().equalsIgnoreCase(\"cube\")");
			}
			REGULAR_ID253=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cube_key8836); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID253);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1350:73: -> CUBE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CUBE_VK, REGULAR_ID253));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cube_key"


	public static class nulls_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nulls_key"
	// PLSQLKeys.g:1353:1: nulls_key :{...}? => REGULAR_ID -> NULLS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nulls_key_return nulls_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nulls_key_return retval = new PLSQLParser_PLSQLKeys.nulls_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID254=null;

		Object REGULAR_ID254_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1354:5: ({...}? => REGULAR_ID -> NULLS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1354:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nulls"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nulls_key", "input.LT(1).getText().equalsIgnoreCase(\"nulls\")");
			}
			REGULAR_ID254=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nulls_key8864); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID254);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1354:74: -> NULLS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NULLS_VK, REGULAR_ID254));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nulls_key"


	public static class dimension_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dimension_key"
	// PLSQLKeys.g:1357:1: dimension_key :{...}? => REGULAR_ID -> DIMENSION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.dimension_key_return dimension_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dimension_key_return retval = new PLSQLParser_PLSQLKeys.dimension_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID255=null;

		Object REGULAR_ID255_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1358:5: ({...}? => REGULAR_ID -> DIMENSION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1358:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("dimension"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dimension_key", "input.LT(1).getText().equalsIgnoreCase(\"dimension\")");
			}
			REGULAR_ID255=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dimension_key8892); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID255);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1358:78: -> DIMENSION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DIMENSION_VK, REGULAR_ID255));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dimension_key"


	public static class scn_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "scn_key"
	// PLSQLKeys.g:1361:1: scn_key :{...}? => REGULAR_ID -> SCN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.scn_key_return scn_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.scn_key_return retval = new PLSQLParser_PLSQLKeys.scn_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID256=null;

		Object REGULAR_ID256_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1362:5: ({...}? => REGULAR_ID -> SCN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1362:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("scn"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "scn_key", "input.LT(1).getText().equalsIgnoreCase(\"scn\")");
			}
			REGULAR_ID256=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_scn_key8920); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID256);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1362:72: -> SCN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SCN_VK, REGULAR_ID256));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "scn_key"


	public static class snapshot_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "snapshot_key"
	// PLSQLKeys.g:1365:1: snapshot_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.snapshot_key_return snapshot_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.snapshot_key_return retval = new PLSQLParser_PLSQLKeys.snapshot_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID257=null;

		Object REGULAR_ID257_tree=null;

		try {
			// PLSQLKeys.g:1366:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1366:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("snapshot"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "snapshot_key", "input.LT(1).getText().equalsIgnoreCase(\"snapshot\")");
			}
			REGULAR_ID257=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_snapshot_key8948); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID257_tree = (Object)adaptor.create(REGULAR_ID257);
			adaptor.addChild(root_0, REGULAR_ID257_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "snapshot_key"


	public static class decrement_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "decrement_key"
	// PLSQLKeys.g:1369:1: decrement_key :{...}? => REGULAR_ID -> DECREMENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.decrement_key_return decrement_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.decrement_key_return retval = new PLSQLParser_PLSQLKeys.decrement_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID258=null;

		Object REGULAR_ID258_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1370:5: ({...}? => REGULAR_ID -> DECREMENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1370:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("decrement"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "decrement_key", "input.LT(1).getText().equalsIgnoreCase(\"decrement\")");
			}
			REGULAR_ID258=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_decrement_key8971); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID258);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1370:78: -> DECREMENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DECREMENT_VK, REGULAR_ID258));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "decrement_key"


	public static class unpivot_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unpivot_key"
	// PLSQLKeys.g:1373:1: unpivot_key :{...}? => REGULAR_ID -> UNPIVOT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.unpivot_key_return unpivot_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.unpivot_key_return retval = new PLSQLParser_PLSQLKeys.unpivot_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID259=null;

		Object REGULAR_ID259_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1374:5: ({...}? => REGULAR_ID -> UNPIVOT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1374:10: {...}? => REGULAR_ID
			{
			if ( !(((input.LT(1).getText().equalsIgnoreCase("unpivot")))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "unpivot_key", "(input.LT(1).getText().equalsIgnoreCase(\"unpivot\"))");
			}
			REGULAR_ID259=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_unpivot_key8999); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID259);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1374:78: -> UNPIVOT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UNPIVOT_VK, REGULAR_ID259));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unpivot_key"


	public static class keep_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "keep_key"
	// PLSQLKeys.g:1377:1: keep_key :{...}? => REGULAR_ID -> KEEP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.keep_key_return keep_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.keep_key_return retval = new PLSQLParser_PLSQLKeys.keep_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID260=null;

		Object REGULAR_ID260_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1378:5: ({...}? => REGULAR_ID -> KEEP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1378:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("keep"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "keep_key", "input.LT(1).getText().equalsIgnoreCase(\"keep\")");
			}
			REGULAR_ID260=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_keep_key9027); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID260);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1378:73: -> KEEP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(KEEP_VK, REGULAR_ID260));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "keep_key"


	public static class measures_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "measures_key"
	// PLSQLKeys.g:1381:1: measures_key :{...}? => REGULAR_ID -> MEASURES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.measures_key_return measures_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.measures_key_return retval = new PLSQLParser_PLSQLKeys.measures_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID261=null;

		Object REGULAR_ID261_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1382:5: ({...}? => REGULAR_ID -> MEASURES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1382:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("measures"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "measures_key", "input.LT(1).getText().equalsIgnoreCase(\"measures\")");
			}
			REGULAR_ID261=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_measures_key9055); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID261);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1382:77: -> MEASURES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MEASURES_VK, REGULAR_ID261));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "measures_key"


	public static class rows_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rows_key"
	// PLSQLKeys.g:1385:1: rows_key :{...}? => REGULAR_ID -> ROWS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rows_key_return rows_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rows_key_return retval = new PLSQLParser_PLSQLKeys.rows_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID262=null;

		Object REGULAR_ID262_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1386:5: ({...}? => REGULAR_ID -> ROWS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1386:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rows"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rows_key", "input.LT(1).getText().equalsIgnoreCase(\"rows\")");
			}
			REGULAR_ID262=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rows_key9083); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID262);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1386:73: -> ROWS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ROWS_VK, REGULAR_ID262));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rows_key"


	public static class sample_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sample_key"
	// PLSQLKeys.g:1389:1: sample_key :{...}? => REGULAR_ID -> SAMPLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sample_key_return sample_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sample_key_return retval = new PLSQLParser_PLSQLKeys.sample_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID263=null;

		Object REGULAR_ID263_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1390:5: ({...}? => REGULAR_ID -> SAMPLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1390:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sample"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sample_key", "input.LT(1).getText().equalsIgnoreCase(\"sample\")");
			}
			REGULAR_ID263=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sample_key9111); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID263);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1390:75: -> SAMPLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SAMPLE_VK, REGULAR_ID263));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sample_key"


	public static class upsert_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "upsert_key"
	// PLSQLKeys.g:1393:1: upsert_key :{...}? => REGULAR_ID -> UPSERT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.upsert_key_return upsert_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.upsert_key_return retval = new PLSQLParser_PLSQLKeys.upsert_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID264=null;

		Object REGULAR_ID264_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1394:5: ({...}? => REGULAR_ID -> UPSERT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1394:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("upsert"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "upsert_key", "input.LT(1).getText().equalsIgnoreCase(\"upsert\")");
			}
			REGULAR_ID264=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_upsert_key9139); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID264);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1394:75: -> UPSERT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UPSERT_VK, REGULAR_ID264));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "upsert_key"


	public static class versions_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "versions_key"
	// PLSQLKeys.g:1397:1: versions_key :{...}? => REGULAR_ID -> VERSIONS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.versions_key_return versions_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.versions_key_return retval = new PLSQLParser_PLSQLKeys.versions_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID265=null;

		Object REGULAR_ID265_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1398:5: ({...}? => REGULAR_ID -> VERSIONS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1398:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("versions"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "versions_key", "input.LT(1).getText().equalsIgnoreCase(\"versions\")");
			}
			REGULAR_ID265=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_versions_key9167); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID265);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1398:77: -> VERSIONS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VERSIONS_VK, REGULAR_ID265));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "versions_key"


	public static class rules_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rules_key"
	// PLSQLKeys.g:1401:1: rules_key :{...}? => REGULAR_ID -> RULES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rules_key_return rules_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rules_key_return retval = new PLSQLParser_PLSQLKeys.rules_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID266=null;

		Object REGULAR_ID266_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1402:5: ({...}? => REGULAR_ID -> RULES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1402:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rules"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rules_key", "input.LT(1).getText().equalsIgnoreCase(\"rules\")");
			}
			REGULAR_ID266=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rules_key9195); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID266);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1402:74: -> RULES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RULES_VK, REGULAR_ID266));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rules_key"


	public static class iterate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "iterate_key"
	// PLSQLKeys.g:1405:1: iterate_key :{...}? => REGULAR_ID -> ITERATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.iterate_key_return iterate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.iterate_key_return retval = new PLSQLParser_PLSQLKeys.iterate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID267=null;

		Object REGULAR_ID267_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1406:5: ({...}? => REGULAR_ID -> ITERATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1406:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("iterate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "iterate_key", "input.LT(1).getText().equalsIgnoreCase(\"iterate\")");
			}
			REGULAR_ID267=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_iterate_key9223); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID267);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1406:76: -> ITERATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ITERATE_VK, REGULAR_ID267));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "iterate_key"


	public static class minvalue_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "minvalue_key"
	// PLSQLKeys.g:1409:1: minvalue_key :{...}? => REGULAR_ID -> MINVALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.minvalue_key_return minvalue_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.minvalue_key_return retval = new PLSQLParser_PLSQLKeys.minvalue_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID268=null;

		Object REGULAR_ID268_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1410:5: ({...}? => REGULAR_ID -> MINVALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1410:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("minvalue"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "minvalue_key", "input.LT(1).getText().equalsIgnoreCase(\"minvalue\")");
			}
			REGULAR_ID268=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_minvalue_key9251); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID268);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1410:77: -> MINVALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MINVALUE_VK, REGULAR_ID268));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "minvalue_key"


	public static class rollup_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rollup_key"
	// PLSQLKeys.g:1413:1: rollup_key :{...}? => REGULAR_ID -> ROLLUP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rollup_key_return rollup_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rollup_key_return retval = new PLSQLParser_PLSQLKeys.rollup_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID269=null;

		Object REGULAR_ID269_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1414:5: ({...}? => REGULAR_ID -> ROLLUP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1414:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rollup"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rollup_key", "input.LT(1).getText().equalsIgnoreCase(\"rollup\")");
			}
			REGULAR_ID269=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rollup_key9279); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID269);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1414:75: -> ROLLUP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ROLLUP_VK, REGULAR_ID269));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rollup_key"


	public static class nav_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nav_key"
	// PLSQLKeys.g:1417:1: nav_key :{...}? => REGULAR_ID -> NAV_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nav_key_return nav_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nav_key_return retval = new PLSQLParser_PLSQLKeys.nav_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID270=null;

		Object REGULAR_ID270_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1418:5: ({...}? => REGULAR_ID -> NAV_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1418:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nav"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nav_key", "input.LT(1).getText().equalsIgnoreCase(\"nav\")");
			}
			REGULAR_ID270=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nav_key9307); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID270);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1418:72: -> NAV_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NAV_VK, REGULAR_ID270));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nav_key"


	public static class automatic_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "automatic_key"
	// PLSQLKeys.g:1421:1: automatic_key :{...}? => REGULAR_ID -> AUTOMATIC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.automatic_key_return automatic_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.automatic_key_return retval = new PLSQLParser_PLSQLKeys.automatic_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID271=null;

		Object REGULAR_ID271_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1422:5: ({...}? => REGULAR_ID -> AUTOMATIC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1422:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("automatic"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "automatic_key", "input.LT(1).getText().equalsIgnoreCase(\"automatic\")");
			}
			REGULAR_ID271=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_automatic_key9335); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID271);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1422:78: -> AUTOMATIC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AUTOMATIC_VK, REGULAR_ID271));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "automatic_key"


	public static class last_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "last_key"
	// PLSQLKeys.g:1425:1: last_key :{...}? => REGULAR_ID -> LAST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.last_key_return last_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.last_key_return retval = new PLSQLParser_PLSQLKeys.last_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID272=null;

		Object REGULAR_ID272_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1426:5: ({...}? => REGULAR_ID -> LAST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1426:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("last"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "last_key", "input.LT(1).getText().equalsIgnoreCase(\"last\")");
			}
			REGULAR_ID272=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_last_key9363); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID272);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1426:73: -> LAST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LAST_VK, REGULAR_ID272));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "last_key"


	public static class main_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "main_key"
	// PLSQLKeys.g:1429:1: main_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.main_key_return main_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.main_key_return retval = new PLSQLParser_PLSQLKeys.main_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID273=null;

		Object REGULAR_ID273_tree=null;

		try {
			// PLSQLKeys.g:1430:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1430:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("main"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "main_key", "input.LT(1).getText().equalsIgnoreCase(\"main\")");
			}
			REGULAR_ID273=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_main_key9391); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID273_tree = (Object)adaptor.create(REGULAR_ID273);
			adaptor.addChild(root_0, REGULAR_ID273_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "main_key"


	public static class grouping_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "grouping_key"
	// PLSQLKeys.g:1433:1: grouping_key :{...}? => REGULAR_ID -> GROUPING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.grouping_key_return grouping_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.grouping_key_return retval = new PLSQLParser_PLSQLKeys.grouping_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID274=null;

		Object REGULAR_ID274_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1434:5: ({...}? => REGULAR_ID -> GROUPING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1434:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("grouping"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "grouping_key", "input.LT(1).getText().equalsIgnoreCase(\"grouping\")");
			}
			REGULAR_ID274=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_grouping_key9414); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID274);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1434:77: -> GROUPING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(GROUPING_VK, REGULAR_ID274));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "grouping_key"


	public static class include_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "include_key"
	// PLSQLKeys.g:1437:1: include_key :{...}? => REGULAR_ID -> INCLUDE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.include_key_return include_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.include_key_return retval = new PLSQLParser_PLSQLKeys.include_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID275=null;

		Object REGULAR_ID275_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1438:5: ({...}? => REGULAR_ID -> INCLUDE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1438:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("include"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "include_key", "input.LT(1).getText().equalsIgnoreCase(\"include\")");
			}
			REGULAR_ID275=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_include_key9442); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID275);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1438:76: -> INCLUDE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INCLUDE_VK, REGULAR_ID275));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "include_key"


	public static class ignore_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ignore_key"
	// PLSQLKeys.g:1441:1: ignore_key :{...}? => REGULAR_ID -> IGNORE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.ignore_key_return ignore_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ignore_key_return retval = new PLSQLParser_PLSQLKeys.ignore_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID276=null;

		Object REGULAR_ID276_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1442:5: ({...}? => REGULAR_ID -> IGNORE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1442:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("ignore"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ignore_key", "input.LT(1).getText().equalsIgnoreCase(\"ignore\")");
			}
			REGULAR_ID276=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ignore_key9470); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID276);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1442:75: -> IGNORE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(IGNORE_VK, REGULAR_ID276));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ignore_key"


	public static class respect_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "respect_key"
	// PLSQLKeys.g:1445:1: respect_key :{...}? => REGULAR_ID -> RESPECT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.respect_key_return respect_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.respect_key_return retval = new PLSQLParser_PLSQLKeys.respect_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID277=null;

		Object REGULAR_ID277_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1446:5: ({...}? => REGULAR_ID -> RESPECT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1446:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("respect"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "respect_key", "input.LT(1).getText().equalsIgnoreCase(\"respect\")");
			}
			REGULAR_ID277=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_respect_key9498); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID277);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1446:76: -> RESPECT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RESPECT_VK, REGULAR_ID277));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "respect_key"


	public static class unique_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unique_key"
	// PLSQLKeys.g:1449:1: unique_key : SQL92_RESERVED_UNIQUE ;
	public final PLSQLParser_PLSQLKeys.unique_key_return unique_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.unique_key_return retval = new PLSQLParser_PLSQLKeys.unique_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_UNIQUE278=null;

		Object SQL92_RESERVED_UNIQUE278_tree=null;

		try {
			// PLSQLKeys.g:1450:5: ( SQL92_RESERVED_UNIQUE )
			// PLSQLKeys.g:1450:10: SQL92_RESERVED_UNIQUE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_UNIQUE278=(Token)match(input,SQL92_RESERVED_UNIQUE,FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key9522); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_UNIQUE278_tree = (Object)adaptor.create(SQL92_RESERVED_UNIQUE278);
			adaptor.addChild(root_0, SQL92_RESERVED_UNIQUE278_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unique_key"


	public static class submultiset_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "submultiset_key"
	// PLSQLKeys.g:1453:1: submultiset_key :{...}? => REGULAR_ID -> SUBMULTISET_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.submultiset_key_return submultiset_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.submultiset_key_return retval = new PLSQLParser_PLSQLKeys.submultiset_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID279=null;

		Object REGULAR_ID279_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1454:5: ({...}? => REGULAR_ID -> SUBMULTISET_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1454:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("submultiset"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "submultiset_key", "input.LT(1).getText().equalsIgnoreCase(\"submultiset\")");
			}
			REGULAR_ID279=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_submultiset_key9545); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID279);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1454:80: -> SUBMULTISET_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SUBMULTISET_VK, REGULAR_ID279));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "submultiset_key"


	public static class at_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "at_key"
	// PLSQLKeys.g:1457:1: at_key :{...}? => REGULAR_ID -> AT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.at_key_return at_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.at_key_return retval = new PLSQLParser_PLSQLKeys.at_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID280=null;

		Object REGULAR_ID280_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1458:5: ({...}? => REGULAR_ID -> AT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1458:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("at"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "at_key", "input.LT(1).getText().equalsIgnoreCase(\"at\")");
			}
			REGULAR_ID280=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_at_key9573); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID280);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1458:71: -> AT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AT_VK, REGULAR_ID280));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "at_key"


	public static class a_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "a_key"
	// PLSQLKeys.g:1461:1: a_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.a_key_return a_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.a_key_return retval = new PLSQLParser_PLSQLKeys.a_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID281=null;

		Object REGULAR_ID281_tree=null;

		try {
			// PLSQLKeys.g:1462:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1462:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("a"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "a_key", "input.LT(1).getText().equalsIgnoreCase(\"a\")");
			}
			REGULAR_ID281=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_a_key9601); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID281_tree = (Object)adaptor.create(REGULAR_ID281);
			adaptor.addChild(root_0, REGULAR_ID281_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "a_key"


	public static class empty_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "empty_key"
	// PLSQLKeys.g:1465:1: empty_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.empty_key_return empty_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.empty_key_return retval = new PLSQLParser_PLSQLKeys.empty_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID282=null;

		Object REGULAR_ID282_tree=null;

		try {
			// PLSQLKeys.g:1466:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1466:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("empty"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "empty_key", "input.LT(1).getText().equalsIgnoreCase(\"empty\")");
			}
			REGULAR_ID282=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_empty_key9624); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID282_tree = (Object)adaptor.create(REGULAR_ID282);
			adaptor.addChild(root_0, REGULAR_ID282_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "empty_key"


	public static class likec_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "likec_key"
	// PLSQLKeys.g:1469:1: likec_key :{...}? => REGULAR_ID -> LIKEC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.likec_key_return likec_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.likec_key_return retval = new PLSQLParser_PLSQLKeys.likec_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID283=null;

		Object REGULAR_ID283_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1470:5: ({...}? => REGULAR_ID -> LIKEC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1470:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("likec"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "likec_key", "input.LT(1).getText().equalsIgnoreCase(\"likec\")");
			}
			REGULAR_ID283=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_likec_key9647); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID283);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1470:74: -> LIKEC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LIKEC_VK, REGULAR_ID283));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "likec_key"


	public static class nan_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nan_key"
	// PLSQLKeys.g:1473:1: nan_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.nan_key_return nan_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nan_key_return retval = new PLSQLParser_PLSQLKeys.nan_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID284=null;

		Object REGULAR_ID284_tree=null;

		try {
			// PLSQLKeys.g:1474:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1474:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("nan"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nan_key", "input.LT(1).getText().equalsIgnoreCase(\"nan\")");
			}
			REGULAR_ID284=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nan_key9675); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID284_tree = (Object)adaptor.create(REGULAR_ID284);
			adaptor.addChild(root_0, REGULAR_ID284_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nan_key"


	public static class infinite_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "infinite_key"
	// PLSQLKeys.g:1477:1: infinite_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.infinite_key_return infinite_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.infinite_key_return retval = new PLSQLParser_PLSQLKeys.infinite_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID285=null;

		Object REGULAR_ID285_tree=null;

		try {
			// PLSQLKeys.g:1478:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1478:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("infinite"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "infinite_key", "input.LT(1).getText().equalsIgnoreCase(\"infinite\")");
			}
			REGULAR_ID285=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_infinite_key9698); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID285_tree = (Object)adaptor.create(REGULAR_ID285);
			adaptor.addChild(root_0, REGULAR_ID285_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "infinite_key"


	public static class like2_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "like2_key"
	// PLSQLKeys.g:1481:1: like2_key :{...}? => REGULAR_ID -> LIKE2_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.like2_key_return like2_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.like2_key_return retval = new PLSQLParser_PLSQLKeys.like2_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID286=null;

		Object REGULAR_ID286_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1482:5: ({...}? => REGULAR_ID -> LIKE2_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1482:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("like2"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "like2_key", "input.LT(1).getText().equalsIgnoreCase(\"like2\")");
			}
			REGULAR_ID286=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_like2_key9721); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID286);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1482:74: -> LIKE2_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LIKE2_VK, REGULAR_ID286));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "like2_key"


	public static class like4_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "like4_key"
	// PLSQLKeys.g:1485:1: like4_key :{...}? => REGULAR_ID -> LIKE4_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.like4_key_return like4_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.like4_key_return retval = new PLSQLParser_PLSQLKeys.like4_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID287=null;

		Object REGULAR_ID287_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1486:5: ({...}? => REGULAR_ID -> LIKE4_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1486:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("like4"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "like4_key", "input.LT(1).getText().equalsIgnoreCase(\"like4\")");
			}
			REGULAR_ID287=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_like4_key9749); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID287);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1486:74: -> LIKE4_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LIKE4_VK, REGULAR_ID287));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "like4_key"


	public static class present_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "present_key"
	// PLSQLKeys.g:1489:1: present_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.present_key_return present_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.present_key_return retval = new PLSQLParser_PLSQLKeys.present_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID288=null;

		Object REGULAR_ID288_tree=null;

		try {
			// PLSQLKeys.g:1490:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1490:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("present"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "present_key", "input.LT(1).getText().equalsIgnoreCase(\"present\")");
			}
			REGULAR_ID288=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_present_key9777); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID288_tree = (Object)adaptor.create(REGULAR_ID288);
			adaptor.addChild(root_0, REGULAR_ID288_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "present_key"


	public static class dbtimezone_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dbtimezone_key"
	// PLSQLKeys.g:1493:1: dbtimezone_key :{...}? => REGULAR_ID -> DBTIMEZONE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.dbtimezone_key_return dbtimezone_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dbtimezone_key_return retval = new PLSQLParser_PLSQLKeys.dbtimezone_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID289=null;

		Object REGULAR_ID289_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1494:5: ({...}? => REGULAR_ID -> DBTIMEZONE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1494:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("dbtimezone"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dbtimezone_key", "input.LT(1).getText().equalsIgnoreCase(\"dbtimezone\")");
			}
			REGULAR_ID289=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dbtimezone_key9800); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID289);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1494:79: -> DBTIMEZONE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DBTIMEZONE_VK, REGULAR_ID289));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dbtimezone_key"


	public static class sessiontimezone_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sessiontimezone_key"
	// PLSQLKeys.g:1497:1: sessiontimezone_key :{...}? => REGULAR_ID -> SESSIONTIMEZONE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sessiontimezone_key_return sessiontimezone_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sessiontimezone_key_return retval = new PLSQLParser_PLSQLKeys.sessiontimezone_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID290=null;

		Object REGULAR_ID290_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1498:5: ({...}? => REGULAR_ID -> SESSIONTIMEZONE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1498:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sessiontimezone"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sessiontimezone_key", "input.LT(1).getText().equalsIgnoreCase(\"sessiontimezone\")");
			}
			REGULAR_ID290=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sessiontimezone_key9828); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID290);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1498:84: -> SESSIONTIMEZONE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SESSIONTIMEZONE_VK, REGULAR_ID290));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sessiontimezone_key"


	public static class nchar_cs_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nchar_cs_key"
	// PLSQLKeys.g:1501:1: nchar_cs_key :{...}? => REGULAR_ID -> NCHAR_CS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nchar_cs_key_return nchar_cs_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nchar_cs_key_return retval = new PLSQLParser_PLSQLKeys.nchar_cs_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID291=null;

		Object REGULAR_ID291_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1502:5: ({...}? => REGULAR_ID -> NCHAR_CS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1502:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nchar_cs"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nchar_cs_key", "input.LT(1).getText().equalsIgnoreCase(\"nchar_cs\")");
			}
			REGULAR_ID291=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nchar_cs_key9856); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID291);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1502:77: -> NCHAR_CS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NCHAR_CS_VK, REGULAR_ID291));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nchar_cs_key"


	public static class decompose_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "decompose_key"
	// PLSQLKeys.g:1505:1: decompose_key :{...}? => REGULAR_ID -> DECOMPOSE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.decompose_key_return decompose_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.decompose_key_return retval = new PLSQLParser_PLSQLKeys.decompose_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID292=null;

		Object REGULAR_ID292_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1506:5: ({...}? => REGULAR_ID -> DECOMPOSE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1506:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("decompose"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "decompose_key", "input.LT(1).getText().equalsIgnoreCase(\"decompose\")");
			}
			REGULAR_ID292=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_decompose_key9884); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID292);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1506:78: -> DECOMPOSE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DECOMPOSE_VK, REGULAR_ID292));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "decompose_key"


	public static class following_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "following_key"
	// PLSQLKeys.g:1509:1: following_key :{...}? => REGULAR_ID -> FOLLOWING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.following_key_return following_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.following_key_return retval = new PLSQLParser_PLSQLKeys.following_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID293=null;

		Object REGULAR_ID293_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1510:5: ({...}? => REGULAR_ID -> FOLLOWING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1510:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("following"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "following_key", "input.LT(1).getText().equalsIgnoreCase(\"following\")");
			}
			REGULAR_ID293=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_following_key9912); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID293);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1510:78: -> FOLLOWING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FOLLOWING_VK, REGULAR_ID293));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "following_key"


	public static class first_value_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "first_value_key"
	// PLSQLKeys.g:1513:1: first_value_key :{...}? => REGULAR_ID -> FIRST_VALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.first_value_key_return first_value_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.first_value_key_return retval = new PLSQLParser_PLSQLKeys.first_value_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID294=null;

		Object REGULAR_ID294_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1514:5: ({...}? => REGULAR_ID -> FIRST_VALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1514:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("first_value"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "first_value_key", "input.LT(1).getText().equalsIgnoreCase(\"first_value\")");
			}
			REGULAR_ID294=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_first_value_key9940); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID294);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1514:80: -> FIRST_VALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FIRST_VALUE_VK, REGULAR_ID294));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "first_value_key"


	public static class preceding_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "preceding_key"
	// PLSQLKeys.g:1517:1: preceding_key :{...}? => REGULAR_ID -> PRECEDING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.preceding_key_return preceding_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.preceding_key_return retval = new PLSQLParser_PLSQLKeys.preceding_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID295=null;

		Object REGULAR_ID295_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1518:5: ({...}? => REGULAR_ID -> PRECEDING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1518:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("preceding"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "preceding_key", "input.LT(1).getText().equalsIgnoreCase(\"preceding\")");
			}
			REGULAR_ID295=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_preceding_key9968); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID295);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1518:78: -> PRECEDING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRECEDING_VK, REGULAR_ID295));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "preceding_key"


	public static class within_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "within_key"
	// PLSQLKeys.g:1521:1: within_key :{...}? => REGULAR_ID -> WITHIN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.within_key_return within_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.within_key_return retval = new PLSQLParser_PLSQLKeys.within_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID296=null;

		Object REGULAR_ID296_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1522:5: ({...}? => REGULAR_ID -> WITHIN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1522:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("within"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "within_key", "input.LT(1).getText().equalsIgnoreCase(\"within\")");
			}
			REGULAR_ID296=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_within_key9996); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID296);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1522:75: -> WITHIN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WITHIN_VK, REGULAR_ID296));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "within_key"


	public static class canonical_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "canonical_key"
	// PLSQLKeys.g:1525:1: canonical_key :{...}? => REGULAR_ID -> CANONICAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.canonical_key_return canonical_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.canonical_key_return retval = new PLSQLParser_PLSQLKeys.canonical_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID297=null;

		Object REGULAR_ID297_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1526:5: ({...}? => REGULAR_ID -> CANONICAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1526:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("canonical"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "canonical_key", "input.LT(1).getText().equalsIgnoreCase(\"canonical\")");
			}
			REGULAR_ID297=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_canonical_key10024); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID297);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1526:78: -> CANONICAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CANONICAL_VK, REGULAR_ID297));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "canonical_key"


	public static class compatibility_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "compatibility_key"
	// PLSQLKeys.g:1529:1: compatibility_key :{...}? => REGULAR_ID -> COMPATIBILITY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.compatibility_key_return compatibility_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.compatibility_key_return retval = new PLSQLParser_PLSQLKeys.compatibility_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID298=null;

		Object REGULAR_ID298_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1530:5: ({...}? => REGULAR_ID -> COMPATIBILITY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1530:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("compatibility"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "compatibility_key", "input.LT(1).getText().equalsIgnoreCase(\"compatibility\")");
			}
			REGULAR_ID298=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_compatibility_key10052); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID298);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1530:82: -> COMPATIBILITY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMPATIBILITY_VK, REGULAR_ID298));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "compatibility_key"


	public static class over_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "over_key"
	// PLSQLKeys.g:1533:1: over_key :{...}? => REGULAR_ID -> OVER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.over_key_return over_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.over_key_return retval = new PLSQLParser_PLSQLKeys.over_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID299=null;

		Object REGULAR_ID299_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1534:5: ({...}? => REGULAR_ID -> OVER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1534:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("over"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "over_key", "input.LT(1).getText().equalsIgnoreCase(\"over\")");
			}
			REGULAR_ID299=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_over_key10080); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID299);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1534:73: -> OVER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OVER_VK, REGULAR_ID299));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "over_key"


	public static class multiset_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "multiset_key"
	// PLSQLKeys.g:1537:1: multiset_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.multiset_key_return multiset_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.multiset_key_return retval = new PLSQLParser_PLSQLKeys.multiset_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID300=null;

		Object REGULAR_ID300_tree=null;

		try {
			// PLSQLKeys.g:1538:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1538:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("multiset"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "multiset_key", "input.LT(1).getText().equalsIgnoreCase(\"multiset\")");
			}
			REGULAR_ID300=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_multiset_key10108); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID300_tree = (Object)adaptor.create(REGULAR_ID300);
			adaptor.addChild(root_0, REGULAR_ID300_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "multiset_key"


	public static class connect_by_root_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "connect_by_root_key"
	// PLSQLKeys.g:1541:1: connect_by_root_key : PLSQL_NON_RESERVED_CONNECT_BY_ROOT ;
	public final PLSQLParser_PLSQLKeys.connect_by_root_key_return connect_by_root_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.connect_by_root_key_return retval = new PLSQLParser_PLSQLKeys.connect_by_root_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_NON_RESERVED_CONNECT_BY_ROOT301=null;

		Object PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree=null;

		try {
			// PLSQLKeys.g:1542:5: ( PLSQL_NON_RESERVED_CONNECT_BY_ROOT )
			// PLSQLKeys.g:1542:10: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_NON_RESERVED_CONNECT_BY_ROOT301=(Token)match(input,PLSQL_NON_RESERVED_CONNECT_BY_ROOT,FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key10128); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree = (Object)adaptor.create(PLSQL_NON_RESERVED_CONNECT_BY_ROOT301);
			adaptor.addChild(root_0, PLSQL_NON_RESERVED_CONNECT_BY_ROOT301_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "connect_by_root_key"


	public static class last_value_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "last_value_key"
	// PLSQLKeys.g:1545:1: last_value_key :{...}? => REGULAR_ID -> LAST_VALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.last_value_key_return last_value_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.last_value_key_return retval = new PLSQLParser_PLSQLKeys.last_value_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID302=null;

		Object REGULAR_ID302_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1546:5: ({...}? => REGULAR_ID -> LAST_VALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1546:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("last_value"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "last_value_key", "input.LT(1).getText().equalsIgnoreCase(\"last_value\")");
			}
			REGULAR_ID302=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_last_value_key10151); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID302);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1546:79: -> LAST_VALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LAST_VALUE_VK, REGULAR_ID302));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "last_value_key"


	public static class current_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "current_key"
	// PLSQLKeys.g:1549:1: current_key : SQL92_RESERVED_CURRENT ;
	public final PLSQLParser_PLSQLKeys.current_key_return current_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.current_key_return retval = new PLSQLParser_PLSQLKeys.current_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CURRENT303=null;

		Object SQL92_RESERVED_CURRENT303_tree=null;

		try {
			// PLSQLKeys.g:1550:5: ( SQL92_RESERVED_CURRENT )
			// PLSQLKeys.g:1550:10: SQL92_RESERVED_CURRENT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CURRENT303=(Token)match(input,SQL92_RESERVED_CURRENT,FOLLOW_SQL92_RESERVED_CURRENT_in_current_key10176); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CURRENT303_tree = (Object)adaptor.create(SQL92_RESERVED_CURRENT303);
			adaptor.addChild(root_0, SQL92_RESERVED_CURRENT303_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "current_key"


	public static class unbounded_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unbounded_key"
	// PLSQLKeys.g:1553:1: unbounded_key :{...}? => REGULAR_ID -> UNBOUNDED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.unbounded_key_return unbounded_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.unbounded_key_return retval = new PLSQLParser_PLSQLKeys.unbounded_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID304=null;

		Object REGULAR_ID304_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1554:5: ({...}? => REGULAR_ID -> UNBOUNDED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1554:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("unbounded"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "unbounded_key", "input.LT(1).getText().equalsIgnoreCase(\"unbounded\")");
			}
			REGULAR_ID304=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_unbounded_key10199); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID304);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1554:78: -> UNBOUNDED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(UNBOUNDED_VK, REGULAR_ID304));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unbounded_key"


	public static class dense_rank_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dense_rank_key"
	// PLSQLKeys.g:1557:1: dense_rank_key :{...}? => REGULAR_ID -> DENSE_RANK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.dense_rank_key_return dense_rank_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dense_rank_key_return retval = new PLSQLParser_PLSQLKeys.dense_rank_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID305=null;

		Object REGULAR_ID305_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1558:5: ({...}? => REGULAR_ID -> DENSE_RANK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1558:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("dense_rank"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dense_rank_key", "input.LT(1).getText().equalsIgnoreCase(\"dense_rank\")");
			}
			REGULAR_ID305=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dense_rank_key10227); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID305);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1558:79: -> DENSE_RANK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DENSE_RANK_VK, REGULAR_ID305));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dense_rank_key"


	public static class cost_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cost_key"
	// PLSQLKeys.g:1561:1: cost_key :{...}? => REGULAR_ID -> COST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cost_key_return cost_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cost_key_return retval = new PLSQLParser_PLSQLKeys.cost_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID306=null;

		Object REGULAR_ID306_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1562:5: ({...}? => REGULAR_ID -> COST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1562:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cost"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cost_key", "input.LT(1).getText().equalsIgnoreCase(\"cost\")");
			}
			REGULAR_ID306=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cost_key10255); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID306);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1562:73: -> COST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COST_VK, REGULAR_ID306));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cost_key"


	public static class char_cs_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "char_cs_key"
	// PLSQLKeys.g:1565:1: char_cs_key :{...}? => REGULAR_ID -> CHAR_CS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.char_cs_key_return char_cs_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.char_cs_key_return retval = new PLSQLParser_PLSQLKeys.char_cs_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID307=null;

		Object REGULAR_ID307_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1566:5: ({...}? => REGULAR_ID -> CHAR_CS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1566:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("char_cs"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "char_cs_key", "input.LT(1).getText().equalsIgnoreCase(\"char_cs\")");
			}
			REGULAR_ID307=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_char_cs_key10283); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID307);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1566:76: -> CHAR_CS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CHAR_CS_VK, REGULAR_ID307));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "char_cs_key"


	public static class auto_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "auto_key"
	// PLSQLKeys.g:1569:1: auto_key :{...}? => REGULAR_ID -> AUTO_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.auto_key_return auto_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.auto_key_return retval = new PLSQLParser_PLSQLKeys.auto_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID308=null;

		Object REGULAR_ID308_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1570:5: ({...}? => REGULAR_ID -> AUTO_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1570:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("auto"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "auto_key", "input.LT(1).getText().equalsIgnoreCase(\"auto\")");
			}
			REGULAR_ID308=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_auto_key10311); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID308);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1570:73: -> AUTO_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(AUTO_VK, REGULAR_ID308));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "auto_key"


	public static class treat_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "treat_key"
	// PLSQLKeys.g:1573:1: treat_key :{...}? => REGULAR_ID -> TREAT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.treat_key_return treat_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.treat_key_return retval = new PLSQLParser_PLSQLKeys.treat_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID309=null;

		Object REGULAR_ID309_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1574:5: ({...}? => REGULAR_ID -> TREAT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1574:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("treat"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "treat_key", "input.LT(1).getText().equalsIgnoreCase(\"treat\")");
			}
			REGULAR_ID309=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_treat_key10339); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID309);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1574:74: -> TREAT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TREAT_VK, REGULAR_ID309));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "treat_key"


	public static class content_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "content_key"
	// PLSQLKeys.g:1577:1: content_key :{...}? => REGULAR_ID -> CONTENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.content_key_return content_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.content_key_return retval = new PLSQLParser_PLSQLKeys.content_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID310=null;

		Object REGULAR_ID310_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1578:5: ({...}? => REGULAR_ID -> CONTENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1578:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("content"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "content_key", "input.LT(1).getText().equalsIgnoreCase(\"content\")");
			}
			REGULAR_ID310=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_content_key10367); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID310);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1578:76: -> CONTENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONTENT_VK, REGULAR_ID310));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "content_key"


	public static class xmlparse_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlparse_key"
	// PLSQLKeys.g:1581:1: xmlparse_key :{...}? => REGULAR_ID -> XMLPARSE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlparse_key_return xmlparse_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlparse_key_return retval = new PLSQLParser_PLSQLKeys.xmlparse_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID311=null;

		Object REGULAR_ID311_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1582:5: ({...}? => REGULAR_ID -> XMLPARSE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1582:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlparse"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlparse_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlparse\")");
			}
			REGULAR_ID311=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlparse_key10395); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID311);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1582:77: -> XMLPARSE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLPARSE_VK, REGULAR_ID311));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlparse_key"


	public static class xmlelement_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlelement_key"
	// PLSQLKeys.g:1585:1: xmlelement_key :{...}? => REGULAR_ID -> XMLELEMENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlelement_key_return xmlelement_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlelement_key_return retval = new PLSQLParser_PLSQLKeys.xmlelement_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID312=null;

		Object REGULAR_ID312_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1586:5: ({...}? => REGULAR_ID -> XMLELEMENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1586:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlelement"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlelement_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlelement\")");
			}
			REGULAR_ID312=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlelement_key10423); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID312);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1586:79: -> XMLELEMENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLELEMENT_VK, REGULAR_ID312));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlelement_key"


	public static class entityescaping_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "entityescaping_key"
	// PLSQLKeys.g:1589:1: entityescaping_key :{...}? => REGULAR_ID -> ENTITYESCAPING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.entityescaping_key_return entityescaping_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.entityescaping_key_return retval = new PLSQLParser_PLSQLKeys.entityescaping_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID313=null;

		Object REGULAR_ID313_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1590:5: ({...}? => REGULAR_ID -> ENTITYESCAPING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1590:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("entityescaping"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "entityescaping_key", "input.LT(1).getText().equalsIgnoreCase(\"entityescaping\")");
			}
			REGULAR_ID313=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_entityescaping_key10451); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID313);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1590:83: -> ENTITYESCAPING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ENTITYESCAPING_VK, REGULAR_ID313));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "entityescaping_key"


	public static class standalone_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "standalone_key"
	// PLSQLKeys.g:1593:1: standalone_key :{...}? => REGULAR_ID -> STANDALONE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.standalone_key_return standalone_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.standalone_key_return retval = new PLSQLParser_PLSQLKeys.standalone_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID314=null;

		Object REGULAR_ID314_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1594:5: ({...}? => REGULAR_ID -> STANDALONE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1594:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("standalone"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "standalone_key", "input.LT(1).getText().equalsIgnoreCase(\"standalone\")");
			}
			REGULAR_ID314=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_standalone_key10479); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID314);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1594:79: -> STANDALONE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STANDALONE_VK, REGULAR_ID314));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "standalone_key"


	public static class wellformed_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "wellformed_key"
	// PLSQLKeys.g:1597:1: wellformed_key :{...}? => REGULAR_ID -> WELLFORMED_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.wellformed_key_return wellformed_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.wellformed_key_return retval = new PLSQLParser_PLSQLKeys.wellformed_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID315=null;

		Object REGULAR_ID315_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1598:5: ({...}? => REGULAR_ID -> WELLFORMED_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1598:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("wellformed"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "wellformed_key", "input.LT(1).getText().equalsIgnoreCase(\"wellformed\")");
			}
			REGULAR_ID315=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_wellformed_key10507); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID315);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1598:79: -> WELLFORMED_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WELLFORMED_VK, REGULAR_ID315));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "wellformed_key"


	public static class xmlexists_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlexists_key"
	// PLSQLKeys.g:1601:1: xmlexists_key :{...}? => REGULAR_ID -> XMLEXISTS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlexists_key_return xmlexists_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlexists_key_return retval = new PLSQLParser_PLSQLKeys.xmlexists_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID316=null;

		Object REGULAR_ID316_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1602:5: ({...}? => REGULAR_ID -> XMLEXISTS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1602:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlexists"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlexists_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlexists\")");
			}
			REGULAR_ID316=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlexists_key10535); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID316);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1602:78: -> XMLEXISTS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLEXISTS_VK, REGULAR_ID316));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlexists_key"


	public static class version_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "version_key"
	// PLSQLKeys.g:1605:1: version_key :{...}? => REGULAR_ID -> VERSION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.version_key_return version_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.version_key_return retval = new PLSQLParser_PLSQLKeys.version_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID317=null;

		Object REGULAR_ID317_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1606:5: ({...}? => REGULAR_ID -> VERSION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1606:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("version"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "version_key", "input.LT(1).getText().equalsIgnoreCase(\"version\")");
			}
			REGULAR_ID317=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_version_key10563); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID317);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1606:76: -> VERSION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VERSION_VK, REGULAR_ID317));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "version_key"


	public static class xmlcast_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlcast_key"
	// PLSQLKeys.g:1609:1: xmlcast_key :{...}? => REGULAR_ID -> XMLCAST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlcast_key_return xmlcast_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlcast_key_return retval = new PLSQLParser_PLSQLKeys.xmlcast_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID318=null;

		Object REGULAR_ID318_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1610:5: ({...}? => REGULAR_ID -> XMLCAST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1610:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlcast"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlcast_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlcast\")");
			}
			REGULAR_ID318=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlcast_key10591); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID318);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1610:76: -> XMLCAST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLCAST_VK, REGULAR_ID318));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlcast_key"


	public static class yes_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "yes_key"
	// PLSQLKeys.g:1613:1: yes_key :{...}? => REGULAR_ID -> YES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.yes_key_return yes_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.yes_key_return retval = new PLSQLParser_PLSQLKeys.yes_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID319=null;

		Object REGULAR_ID319_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1614:5: ({...}? => REGULAR_ID -> YES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1614:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("yes"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "yes_key", "input.LT(1).getText().equalsIgnoreCase(\"yes\")");
			}
			REGULAR_ID319=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_yes_key10619); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID319);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1614:72: -> YES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(YES_VK, REGULAR_ID319));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "yes_key"


	public static class no_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "no_key"
	// PLSQLKeys.g:1617:1: no_key :{...}? => REGULAR_ID -> NO_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.no_key_return no_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.no_key_return retval = new PLSQLParser_PLSQLKeys.no_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID320=null;

		Object REGULAR_ID320_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1618:5: ({...}? => REGULAR_ID -> NO_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1618:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("no"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "no_key", "input.LT(1).getText().equalsIgnoreCase(\"no\")");
			}
			REGULAR_ID320=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_no_key10647); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID320);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1618:71: -> NO_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NO_VK, REGULAR_ID320));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "no_key"


	public static class evalname_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "evalname_key"
	// PLSQLKeys.g:1621:1: evalname_key :{...}? => REGULAR_ID -> EVALNAME_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.evalname_key_return evalname_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.evalname_key_return retval = new PLSQLParser_PLSQLKeys.evalname_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID321=null;

		Object REGULAR_ID321_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1622:5: ({...}? => REGULAR_ID -> EVALNAME_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1622:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("evalname"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "evalname_key", "input.LT(1).getText().equalsIgnoreCase(\"evalname\")");
			}
			REGULAR_ID321=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_evalname_key10675); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID321);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1622:77: -> EVALNAME_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EVALNAME_VK, REGULAR_ID321));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "evalname_key"


	public static class xmlpi_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlpi_key"
	// PLSQLKeys.g:1625:1: xmlpi_key :{...}? => REGULAR_ID -> XMLPI_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlpi_key_return xmlpi_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlpi_key_return retval = new PLSQLParser_PLSQLKeys.xmlpi_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID322=null;

		Object REGULAR_ID322_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1626:5: ({...}? => REGULAR_ID -> XMLPI_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1626:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlpi"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlpi_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlpi\")");
			}
			REGULAR_ID322=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlpi_key10703); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID322);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1626:74: -> XMLPI_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLPI_VK, REGULAR_ID322));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlpi_key"


	public static class xmlcolattval_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlcolattval_key"
	// PLSQLKeys.g:1629:1: xmlcolattval_key :{...}? => REGULAR_ID -> XMLCOLATTVAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlcolattval_key_return xmlcolattval_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlcolattval_key_return retval = new PLSQLParser_PLSQLKeys.xmlcolattval_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID323=null;

		Object REGULAR_ID323_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1630:5: ({...}? => REGULAR_ID -> XMLCOLATTVAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1630:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlcolattval"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlcolattval_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlcolattval\")");
			}
			REGULAR_ID323=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlcolattval_key10731); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID323);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1630:81: -> XMLCOLATTVAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLCOLATTVAL_VK, REGULAR_ID323));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlcolattval_key"


	public static class document_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "document_key"
	// PLSQLKeys.g:1633:1: document_key :{...}? => REGULAR_ID -> DOCUMENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.document_key_return document_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.document_key_return retval = new PLSQLParser_PLSQLKeys.document_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID324=null;

		Object REGULAR_ID324_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1634:5: ({...}? => REGULAR_ID -> DOCUMENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1634:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("document"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "document_key", "input.LT(1).getText().equalsIgnoreCase(\"document\")");
			}
			REGULAR_ID324=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_document_key10759); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID324);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1634:77: -> DOCUMENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DOCUMENT_VK, REGULAR_ID324));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "document_key"


	public static class xmlforest_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlforest_key"
	// PLSQLKeys.g:1637:1: xmlforest_key :{...}? => REGULAR_ID -> XMLFOREST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlforest_key_return xmlforest_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlforest_key_return retval = new PLSQLParser_PLSQLKeys.xmlforest_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID325=null;

		Object REGULAR_ID325_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1638:5: ({...}? => REGULAR_ID -> XMLFOREST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1638:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlforest"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlforest_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlforest\")");
			}
			REGULAR_ID325=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlforest_key10787); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID325);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1638:78: -> XMLFOREST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLFOREST_VK, REGULAR_ID325));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlforest_key"


	public static class passing_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "passing_key"
	// PLSQLKeys.g:1641:1: passing_key :{...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.passing_key_return passing_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.passing_key_return retval = new PLSQLParser_PLSQLKeys.passing_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID326=null;

		Object REGULAR_ID326_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1642:5: ({...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1642:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("passing"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "passing_key", "input.LT(1).getText().equalsIgnoreCase(\"passing\")");
			}
			REGULAR_ID326=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_passing_key10815); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID326);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1642:76: -> PASSING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PASSING_VK, REGULAR_ID326));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "passing_key"


	public static class columns_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "columns_key"
	// PLSQLKeys.g:1645:1: columns_key :{...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.columns_key_return columns_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.columns_key_return retval = new PLSQLParser_PLSQLKeys.columns_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID327=null;

		Object REGULAR_ID327_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1646:5: ({...}? => REGULAR_ID -> PASSING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1646:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("columns"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "columns_key", "input.LT(1).getText().equalsIgnoreCase(\"columns\")");
			}
			REGULAR_ID327=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_columns_key10843); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID327);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1646:76: -> PASSING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PASSING_VK, REGULAR_ID327));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "columns_key"


	public static class indent_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "indent_key"
	// PLSQLKeys.g:1649:1: indent_key :{...}? => REGULAR_ID -> INDENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.indent_key_return indent_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.indent_key_return retval = new PLSQLParser_PLSQLKeys.indent_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID328=null;

		Object REGULAR_ID328_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1650:5: ({...}? => REGULAR_ID -> INDENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1650:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("indent"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "indent_key", "input.LT(1).getText().equalsIgnoreCase(\"indent\")");
			}
			REGULAR_ID328=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_indent_key10872); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID328);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1650:75: -> INDENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INDENT_VK, REGULAR_ID328));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "indent_key"


	public static class hide_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "hide_key"
	// PLSQLKeys.g:1653:1: hide_key :{...}? => REGULAR_ID -> HIDE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.hide_key_return hide_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.hide_key_return retval = new PLSQLParser_PLSQLKeys.hide_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID329=null;

		Object REGULAR_ID329_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1654:5: ({...}? => REGULAR_ID -> HIDE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1654:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("hide"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "hide_key", "input.LT(1).getText().equalsIgnoreCase(\"hide\")");
			}
			REGULAR_ID329=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_hide_key10900); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID329);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1654:73: -> HIDE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(HIDE_VK, REGULAR_ID329));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "hide_key"


	public static class xmlagg_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlagg_key"
	// PLSQLKeys.g:1657:1: xmlagg_key :{...}? => REGULAR_ID -> XMLAGG_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlagg_key_return xmlagg_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlagg_key_return retval = new PLSQLParser_PLSQLKeys.xmlagg_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID330=null;

		Object REGULAR_ID330_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1658:5: ({...}? => REGULAR_ID -> XMLAGG_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1658:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlagg"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlagg_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlagg\")");
			}
			REGULAR_ID330=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlagg_key10928); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID330);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1658:75: -> XMLAGG_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLAGG_VK, REGULAR_ID330));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlagg_key"


	public static class path_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "path_key"
	// PLSQLKeys.g:1661:1: path_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.path_key_return path_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.path_key_return retval = new PLSQLParser_PLSQLKeys.path_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID331=null;

		Object REGULAR_ID331_tree=null;

		try {
			// PLSQLKeys.g:1662:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1662:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("path"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "path_key", "input.LT(1).getText().equalsIgnoreCase(\"path\")");
			}
			REGULAR_ID331=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_path_key10956); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID331_tree = (Object)adaptor.create(REGULAR_ID331);
			adaptor.addChild(root_0, REGULAR_ID331_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "path_key"


	public static class xmlnamespaces_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlnamespaces_key"
	// PLSQLKeys.g:1665:1: xmlnamespaces_key :{...}? => REGULAR_ID -> XMLNAMESPACES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlnamespaces_key_return xmlnamespaces_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlnamespaces_key_return retval = new PLSQLParser_PLSQLKeys.xmlnamespaces_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID332=null;

		Object REGULAR_ID332_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1666:5: ({...}? => REGULAR_ID -> XMLNAMESPACES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1666:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlnamespaces"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlnamespaces_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlnamespaces\")");
			}
			REGULAR_ID332=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlnamespaces_key10979); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID332);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1666:82: -> XMLNAMESPACES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLNAMESPACES_VK, REGULAR_ID332));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlnamespaces_key"


	public static class size_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "size_key"
	// PLSQLKeys.g:1669:1: size_key : SQL92_RESERVED_SIZE ;
	public final PLSQLParser_PLSQLKeys.size_key_return size_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.size_key_return retval = new PLSQLParser_PLSQLKeys.size_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_SIZE333=null;

		Object SQL92_RESERVED_SIZE333_tree=null;

		try {
			// PLSQLKeys.g:1670:5: ( SQL92_RESERVED_SIZE )
			// PLSQLKeys.g:1670:10: SQL92_RESERVED_SIZE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_SIZE333=(Token)match(input,SQL92_RESERVED_SIZE,FOLLOW_SQL92_RESERVED_SIZE_in_size_key11004); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_SIZE333_tree = (Object)adaptor.create(SQL92_RESERVED_SIZE333);
			adaptor.addChild(root_0, SQL92_RESERVED_SIZE333_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "size_key"


	public static class noschemacheck_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "noschemacheck_key"
	// PLSQLKeys.g:1673:1: noschemacheck_key :{...}? => REGULAR_ID -> NOSCHEMACHECK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.noschemacheck_key_return noschemacheck_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.noschemacheck_key_return retval = new PLSQLParser_PLSQLKeys.noschemacheck_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID334=null;

		Object REGULAR_ID334_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1674:5: ({...}? => REGULAR_ID -> NOSCHEMACHECK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1674:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("noschemacheck"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "noschemacheck_key", "input.LT(1).getText().equalsIgnoreCase(\"noschemacheck\")");
			}
			REGULAR_ID334=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_noschemacheck_key11027); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID334);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1674:82: -> NOSCHEMACHECK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOSCHEMACHECK_VK, REGULAR_ID334));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "noschemacheck_key"


	public static class noentityescaping_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "noentityescaping_key"
	// PLSQLKeys.g:1677:1: noentityescaping_key :{...}? => REGULAR_ID -> NOENTITYESCAPING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.noentityescaping_key_return noentityescaping_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.noentityescaping_key_return retval = new PLSQLParser_PLSQLKeys.noentityescaping_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID335=null;

		Object REGULAR_ID335_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1678:5: ({...}? => REGULAR_ID -> NOENTITYESCAPING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1678:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("noentityescaping"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "noentityescaping_key", "input.LT(1).getText().equalsIgnoreCase(\"noentityescaping\")");
			}
			REGULAR_ID335=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_noentityescaping_key11055); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID335);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1678:85: -> NOENTITYESCAPING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOENTITYESCAPING_VK, REGULAR_ID335));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "noentityescaping_key"


	public static class xmlquery_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlquery_key"
	// PLSQLKeys.g:1681:1: xmlquery_key :{...}? => REGULAR_ID -> XMLQUERY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlquery_key_return xmlquery_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlquery_key_return retval = new PLSQLParser_PLSQLKeys.xmlquery_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID336=null;

		Object REGULAR_ID336_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1682:5: ({...}? => REGULAR_ID -> XMLQUERY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1682:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlquery"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlquery_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlquery\")");
			}
			REGULAR_ID336=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlquery_key11083); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID336);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1682:77: -> XMLQUERY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLQUERY_VK, REGULAR_ID336));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlquery_key"


	public static class xmltable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmltable_key"
	// PLSQLKeys.g:1685:1: xmltable_key :{...}? => REGULAR_ID -> XMLTABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmltable_key_return xmltable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmltable_key_return retval = new PLSQLParser_PLSQLKeys.xmltable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID337=null;

		Object REGULAR_ID337_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1686:5: ({...}? => REGULAR_ID -> XMLTABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1686:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmltable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmltable_key", "input.LT(1).getText().equalsIgnoreCase(\"xmltable\")");
			}
			REGULAR_ID337=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmltable_key11111); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID337);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1686:77: -> XMLTABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLTABLE_VK, REGULAR_ID337));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmltable_key"


	public static class xmlroot_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlroot_key"
	// PLSQLKeys.g:1689:1: xmlroot_key :{...}? => REGULAR_ID -> XMLROOT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlroot_key_return xmlroot_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlroot_key_return retval = new PLSQLParser_PLSQLKeys.xmlroot_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID338=null;

		Object REGULAR_ID338_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1690:5: ({...}? => REGULAR_ID -> XMLROOT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1690:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlroot"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlroot_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlroot\")");
			}
			REGULAR_ID338=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlroot_key11139); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID338);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1690:76: -> XMLROOT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLROOT_VK, REGULAR_ID338));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlroot_key"


	public static class schemacheck_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "schemacheck_key"
	// PLSQLKeys.g:1693:1: schemacheck_key :{...}? => REGULAR_ID -> SCHEMACHECK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.schemacheck_key_return schemacheck_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.schemacheck_key_return retval = new PLSQLParser_PLSQLKeys.schemacheck_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID339=null;

		Object REGULAR_ID339_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1694:5: ({...}? => REGULAR_ID -> SCHEMACHECK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1694:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("schemacheck"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "schemacheck_key", "input.LT(1).getText().equalsIgnoreCase(\"schemacheck\")");
			}
			REGULAR_ID339=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_schemacheck_key11167); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID339);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1694:80: -> SCHEMACHECK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SCHEMACHECK_VK, REGULAR_ID339));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "schemacheck_key"


	public static class xmlattributes_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlattributes_key"
	// PLSQLKeys.g:1697:1: xmlattributes_key :{...}? => REGULAR_ID -> XMLATTRIBUTES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlattributes_key_return xmlattributes_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlattributes_key_return retval = new PLSQLParser_PLSQLKeys.xmlattributes_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID340=null;

		Object REGULAR_ID340_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1698:5: ({...}? => REGULAR_ID -> XMLATTRIBUTES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1698:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlattributes"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlattributes_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlattributes\")");
			}
			REGULAR_ID340=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlattributes_key11195); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID340);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1698:82: -> XMLATTRIBUTES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLATTRIBUTES_VK, REGULAR_ID340));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlattributes_key"


	public static class encoding_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "encoding_key"
	// PLSQLKeys.g:1701:1: encoding_key :{...}? => REGULAR_ID -> ENCODING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.encoding_key_return encoding_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.encoding_key_return retval = new PLSQLParser_PLSQLKeys.encoding_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID341=null;

		Object REGULAR_ID341_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1702:5: ({...}? => REGULAR_ID -> ENCODING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1702:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("encoding"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "encoding_key", "input.LT(1).getText().equalsIgnoreCase(\"encoding\")");
			}
			REGULAR_ID341=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_encoding_key11223); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID341);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1702:77: -> ENCODING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ENCODING_VK, REGULAR_ID341));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "encoding_key"


	public static class show_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "show_key"
	// PLSQLKeys.g:1705:1: show_key :{...}? => REGULAR_ID -> SHOW_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.show_key_return show_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.show_key_return retval = new PLSQLParser_PLSQLKeys.show_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID342=null;

		Object REGULAR_ID342_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1706:5: ({...}? => REGULAR_ID -> SHOW_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1706:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("show"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "show_key", "input.LT(1).getText().equalsIgnoreCase(\"show\")");
			}
			REGULAR_ID342=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_show_key11251); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID342);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1706:73: -> SHOW_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SHOW_VK, REGULAR_ID342));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "show_key"


	public static class xmlserialize_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "xmlserialize_key"
	// PLSQLKeys.g:1709:1: xmlserialize_key :{...}? => REGULAR_ID -> XMLSERIALIZE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.xmlserialize_key_return xmlserialize_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.xmlserialize_key_return retval = new PLSQLParser_PLSQLKeys.xmlserialize_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID343=null;

		Object REGULAR_ID343_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1710:5: ({...}? => REGULAR_ID -> XMLSERIALIZE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1710:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("xmlserialize"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xmlserialize_key", "input.LT(1).getText().equalsIgnoreCase(\"xmlserialize\")");
			}
			REGULAR_ID343=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_xmlserialize_key11279); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID343);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1710:81: -> XMLSERIALIZE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(XMLSERIALIZE_VK, REGULAR_ID343));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "xmlserialize_key"


	public static class ordinality_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ordinality_key"
	// PLSQLKeys.g:1713:1: ordinality_key :{...}? => REGULAR_ID -> ORDINALITY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.ordinality_key_return ordinality_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ordinality_key_return retval = new PLSQLParser_PLSQLKeys.ordinality_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID344=null;

		Object REGULAR_ID344_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1714:5: ({...}? => REGULAR_ID -> ORDINALITY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1714:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("ordinality"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ordinality_key", "input.LT(1).getText().equalsIgnoreCase(\"ordinality\")");
			}
			REGULAR_ID344=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ordinality_key11307); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID344);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1714:79: -> ORDINALITY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ORDINALITY_VK, REGULAR_ID344));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ordinality_key"


	public static class defaults_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "defaults_key"
	// PLSQLKeys.g:1717:1: defaults_key :{...}? => REGULAR_ID -> DEFAULTS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.defaults_key_return defaults_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.defaults_key_return retval = new PLSQLParser_PLSQLKeys.defaults_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID345=null;

		Object REGULAR_ID345_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1718:5: ({...}? => REGULAR_ID -> DEFAULTS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1718:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("defaults"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "defaults_key", "input.LT(1).getText().equalsIgnoreCase(\"defaults\")");
			}
			REGULAR_ID345=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_defaults_key11335); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID345);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1718:77: -> DEFAULTS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEFAULTS_VK, REGULAR_ID345));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "defaults_key"


	public static class sqlerror_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sqlerror_key"
	// PLSQLKeys.g:1721:1: sqlerror_key :{...}? REGULAR_ID -> SQLERROR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sqlerror_key_return sqlerror_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sqlerror_key_return retval = new PLSQLParser_PLSQLKeys.sqlerror_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID346=null;

		Object REGULAR_ID346_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1722:5: ({...}? REGULAR_ID -> SQLERROR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1722:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sqlerror"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sqlerror_key", "input.LT(1).getText().equalsIgnoreCase(\"sqlerror\")");
			}
			REGULAR_ID346=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sqlerror_key11362); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID346);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1722:75: -> SQLERROR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SQLERROR_VK, REGULAR_ID346));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sqlerror_key"


	public static class oserror_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "oserror_key"
	// PLSQLKeys.g:1725:1: oserror_key :{...}? REGULAR_ID -> OSERROR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.oserror_key_return oserror_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.oserror_key_return retval = new PLSQLParser_PLSQLKeys.oserror_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID347=null;

		Object REGULAR_ID347_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1726:5: ({...}? REGULAR_ID -> OSERROR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1726:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("oserror"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "oserror_key", "input.LT(1).getText().equalsIgnoreCase(\"oserror\")");
			}
			REGULAR_ID347=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_oserror_key11390); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID347);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1726:74: -> OSERROR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OSERROR_VK, REGULAR_ID347));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "oserror_key"


	public static class success_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "success_key"
	// PLSQLKeys.g:1729:1: success_key :{...}? REGULAR_ID -> SUCCESS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.success_key_return success_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.success_key_return retval = new PLSQLParser_PLSQLKeys.success_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID348=null;

		Object REGULAR_ID348_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1730:5: ({...}? REGULAR_ID -> SUCCESS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1730:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("success"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "success_key", "input.LT(1).getText().equalsIgnoreCase(\"success\")");
			}
			REGULAR_ID348=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_success_key11417); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID348);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1730:74: -> SUCCESS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SUCCESS_VK, REGULAR_ID348));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "success_key"


	public static class warning_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "warning_key"
	// PLSQLKeys.g:1733:1: warning_key :{...}? REGULAR_ID -> WARNING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.warning_key_return warning_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.warning_key_return retval = new PLSQLParser_PLSQLKeys.warning_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID349=null;

		Object REGULAR_ID349_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1734:5: ({...}? REGULAR_ID -> WARNING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1734:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("warning"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "warning_key", "input.LT(1).getText().equalsIgnoreCase(\"warning\")");
			}
			REGULAR_ID349=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_warning_key11444); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID349);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1734:74: -> WARNING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WARNING_VK, REGULAR_ID349));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "warning_key"


	public static class failure_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "failure_key"
	// PLSQLKeys.g:1737:1: failure_key :{...}? REGULAR_ID -> FAILURE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.failure_key_return failure_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.failure_key_return retval = new PLSQLParser_PLSQLKeys.failure_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID350=null;

		Object REGULAR_ID350_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1738:5: ({...}? REGULAR_ID -> FAILURE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1738:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("failure"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "failure_key", "input.LT(1).getText().equalsIgnoreCase(\"failure\")");
			}
			REGULAR_ID350=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_failure_key11471); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID350);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1738:74: -> FAILURE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FAILURE_VK, REGULAR_ID350));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "failure_key"


	public static class insert_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "insert_key"
	// PLSQLKeys.g:1741:1: insert_key : SQL92_RESERVED_INSERT ;
	public final PLSQLParser_PLSQLKeys.insert_key_return insert_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.insert_key_return retval = new PLSQLParser_PLSQLKeys.insert_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_INSERT351=null;

		Object SQL92_RESERVED_INSERT351_tree=null;

		try {
			// PLSQLKeys.g:1742:5: ( SQL92_RESERVED_INSERT )
			// PLSQLKeys.g:1742:10: SQL92_RESERVED_INSERT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_INSERT351=(Token)match(input,SQL92_RESERVED_INSERT,FOLLOW_SQL92_RESERVED_INSERT_in_insert_key11496); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_INSERT351_tree = (Object)adaptor.create(SQL92_RESERVED_INSERT351);
			adaptor.addChild(root_0, SQL92_RESERVED_INSERT351_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "insert_key"


	public static class order_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "order_key"
	// PLSQLKeys.g:1745:1: order_key : SQL92_RESERVED_ORDER ;
	public final PLSQLParser_PLSQLKeys.order_key_return order_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.order_key_return retval = new PLSQLParser_PLSQLKeys.order_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ORDER352=null;

		Object SQL92_RESERVED_ORDER352_tree=null;

		try {
			// PLSQLKeys.g:1746:5: ( SQL92_RESERVED_ORDER )
			// PLSQLKeys.g:1746:10: SQL92_RESERVED_ORDER
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ORDER352=(Token)match(input,SQL92_RESERVED_ORDER,FOLLOW_SQL92_RESERVED_ORDER_in_order_key11516); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ORDER352_tree = (Object)adaptor.create(SQL92_RESERVED_ORDER352);
			adaptor.addChild(root_0, SQL92_RESERVED_ORDER352_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "order_key"


	public static class minus_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "minus_key"
	// PLSQLKeys.g:1749:1: minus_key : PLSQL_RESERVED_MINUS ;
	public final PLSQLParser_PLSQLKeys.minus_key_return minus_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.minus_key_return retval = new PLSQLParser_PLSQLKeys.minus_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_MINUS353=null;

		Object PLSQL_RESERVED_MINUS353_tree=null;

		try {
			// PLSQLKeys.g:1750:5: ( PLSQL_RESERVED_MINUS )
			// PLSQLKeys.g:1750:10: PLSQL_RESERVED_MINUS
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_MINUS353=(Token)match(input,PLSQL_RESERVED_MINUS,FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key11536); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_MINUS353_tree = (Object)adaptor.create(PLSQL_RESERVED_MINUS353);
			adaptor.addChild(root_0, PLSQL_RESERVED_MINUS353_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "minus_key"


	public static class row_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "row_key"
	// PLSQLKeys.g:1753:1: row_key :{...}? REGULAR_ID -> ROW_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.row_key_return row_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.row_key_return retval = new PLSQLParser_PLSQLKeys.row_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID354=null;

		Object REGULAR_ID354_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1754:5: ({...}? REGULAR_ID -> ROW_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1754:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("row"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "row_key", "input.LT(1).getText().equalsIgnoreCase(\"row\")");
			}
			REGULAR_ID354=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_row_key11558); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID354);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1754:70: -> ROW_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ROW_VK, REGULAR_ID354));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "row_key"


	public static class raw_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "raw_key"
	// PLSQLKeys.g:1757:1: raw_key :{...}? => REGULAR_ID -> RAW_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.raw_key_return raw_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.raw_key_return retval = new PLSQLParser_PLSQLKeys.raw_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID355=null;

		Object REGULAR_ID355_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1758:5: ({...}? => REGULAR_ID -> RAW_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1758:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("raw"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "raw_key", "input.LT(1).getText().equalsIgnoreCase(\"raw\")");
			}
			REGULAR_ID355=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_raw_key11586); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID355);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1758:72: -> RAW_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RAW_VK, REGULAR_ID355));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "raw_key"


	public static class power_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "power_key"
	// PLSQLKeys.g:1761:1: power_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.power_key_return power_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.power_key_return retval = new PLSQLParser_PLSQLKeys.power_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID356=null;

		Object REGULAR_ID356_tree=null;

		try {
			// PLSQLKeys.g:1762:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1762:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("power"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "power_key", "input.LT(1).getText().equalsIgnoreCase(\"power\")");
			}
			REGULAR_ID356=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_power_key11613); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID356_tree = (Object)adaptor.create(REGULAR_ID356);
			adaptor.addChild(root_0, REGULAR_ID356_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "power_key"


	public static class lock_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lock_key"
	// PLSQLKeys.g:1765:1: lock_key : PLSQL_RESERVED_LOCK ;
	public final PLSQLParser_PLSQLKeys.lock_key_return lock_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.lock_key_return retval = new PLSQLParser_PLSQLKeys.lock_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_LOCK357=null;

		Object PLSQL_RESERVED_LOCK357_tree=null;

		try {
			// PLSQLKeys.g:1766:5: ( PLSQL_RESERVED_LOCK )
			// PLSQLKeys.g:1766:10: PLSQL_RESERVED_LOCK
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_LOCK357=(Token)match(input,PLSQL_RESERVED_LOCK,FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key11633); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_LOCK357_tree = (Object)adaptor.create(PLSQL_RESERVED_LOCK357);
			adaptor.addChild(root_0, PLSQL_RESERVED_LOCK357_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lock_key"


	public static class exists_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exists_key"
	// PLSQLKeys.g:1769:1: exists_key : SQL92_RESERVED_EXISTS ;
	public final PLSQLParser_PLSQLKeys.exists_key_return exists_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exists_key_return retval = new PLSQLParser_PLSQLKeys.exists_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_EXISTS358=null;

		Object SQL92_RESERVED_EXISTS358_tree=null;

		try {
			// PLSQLKeys.g:1770:5: ( SQL92_RESERVED_EXISTS )
			// PLSQLKeys.g:1770:10: SQL92_RESERVED_EXISTS
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_EXISTS358=(Token)match(input,SQL92_RESERVED_EXISTS,FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key11653); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_EXISTS358_tree = (Object)adaptor.create(SQL92_RESERVED_EXISTS358);
			adaptor.addChild(root_0, SQL92_RESERVED_EXISTS358_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exists_key"


	public static class having_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "having_key"
	// PLSQLKeys.g:1773:1: having_key : SQL92_RESERVED_HAVING ;
	public final PLSQLParser_PLSQLKeys.having_key_return having_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.having_key_return retval = new PLSQLParser_PLSQLKeys.having_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_HAVING359=null;

		Object SQL92_RESERVED_HAVING359_tree=null;

		try {
			// PLSQLKeys.g:1774:5: ( SQL92_RESERVED_HAVING )
			// PLSQLKeys.g:1774:10: SQL92_RESERVED_HAVING
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_HAVING359=(Token)match(input,SQL92_RESERVED_HAVING,FOLLOW_SQL92_RESERVED_HAVING_in_having_key11673); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_HAVING359_tree = (Object)adaptor.create(SQL92_RESERVED_HAVING359);
			adaptor.addChild(root_0, SQL92_RESERVED_HAVING359_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "having_key"


	public static class any_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "any_key"
	// PLSQLKeys.g:1777:1: any_key : SQL92_RESERVED_ANY ;
	public final PLSQLParser_PLSQLKeys.any_key_return any_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.any_key_return retval = new PLSQLParser_PLSQLKeys.any_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ANY360=null;

		Object SQL92_RESERVED_ANY360_tree=null;

		try {
			// PLSQLKeys.g:1778:5: ( SQL92_RESERVED_ANY )
			// PLSQLKeys.g:1778:10: SQL92_RESERVED_ANY
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ANY360=(Token)match(input,SQL92_RESERVED_ANY,FOLLOW_SQL92_RESERVED_ANY_in_any_key11693); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ANY360_tree = (Object)adaptor.create(SQL92_RESERVED_ANY360);
			adaptor.addChild(root_0, SQL92_RESERVED_ANY360_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "any_key"


	public static class with_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "with_key"
	// PLSQLKeys.g:1781:1: with_key : SQL92_RESERVED_WITH ;
	public final PLSQLParser_PLSQLKeys.with_key_return with_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.with_key_return retval = new PLSQLParser_PLSQLKeys.with_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_WITH361=null;

		Object SQL92_RESERVED_WITH361_tree=null;

		try {
			// PLSQLKeys.g:1782:5: ( SQL92_RESERVED_WITH )
			// PLSQLKeys.g:1782:10: SQL92_RESERVED_WITH
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_WITH361=(Token)match(input,SQL92_RESERVED_WITH,FOLLOW_SQL92_RESERVED_WITH_in_with_key11713); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_WITH361_tree = (Object)adaptor.create(SQL92_RESERVED_WITH361);
			adaptor.addChild(root_0, SQL92_RESERVED_WITH361_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "with_key"


	public static class transaction_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "transaction_key"
	// PLSQLKeys.g:1785:1: transaction_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.transaction_key_return transaction_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.transaction_key_return retval = new PLSQLParser_PLSQLKeys.transaction_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID362=null;

		Object REGULAR_ID362_tree=null;

		try {
			// PLSQLKeys.g:1786:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:1786:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("transaction"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "transaction_key", "input.LT(1).getText().equalsIgnoreCase(\"transaction\")");
			}
			REGULAR_ID362=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_transaction_key11736); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID362_tree = (Object)adaptor.create(REGULAR_ID362);
			adaptor.addChild(root_0, REGULAR_ID362_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "transaction_key"


	public static class rawtohex_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rawtohex_key"
	// PLSQLKeys.g:1789:1: rawtohex_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.rawtohex_key_return rawtohex_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rawtohex_key_return retval = new PLSQLParser_PLSQLKeys.rawtohex_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID363=null;

		Object REGULAR_ID363_tree=null;

		try {
			// PLSQLKeys.g:1790:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1790:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("rawtohex"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rawtohex_key", "input.LT(1).getText().equalsIgnoreCase(\"rawtohex\")");
			}
			REGULAR_ID363=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rawtohex_key11758); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID363_tree = (Object)adaptor.create(REGULAR_ID363);
			adaptor.addChild(root_0, REGULAR_ID363_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rawtohex_key"


	public static class number_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "number_key"
	// PLSQLKeys.g:1793:1: number_key :{...}? => REGULAR_ID -> NUMBER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.number_key_return number_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.number_key_return retval = new PLSQLParser_PLSQLKeys.number_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID364=null;

		Object REGULAR_ID364_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1794:5: ({...}? => REGULAR_ID -> NUMBER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1794:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("number"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "number_key", "input.LT(1).getText().equalsIgnoreCase(\"number\")");
			}
			REGULAR_ID364=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_number_key11781); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID364);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1794:75: -> NUMBER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NUMBER_VK, REGULAR_ID364));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "number_key"


	public static class nocopy_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nocopy_key"
	// PLSQLKeys.g:1797:1: nocopy_key :{...}? => REGULAR_ID -> NOCOPY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nocopy_key_return nocopy_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nocopy_key_return retval = new PLSQLParser_PLSQLKeys.nocopy_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID365=null;

		Object REGULAR_ID365_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1798:5: ({...}? => REGULAR_ID -> NOCOPY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1798:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nocopy"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nocopy_key", "input.LT(1).getText().equalsIgnoreCase(\"nocopy\")");
			}
			REGULAR_ID365=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nocopy_key11809); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID365);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1798:75: -> NOCOPY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOCOPY_VK, REGULAR_ID365));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nocopy_key"


	public static class to_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "to_key"
	// PLSQLKeys.g:1801:1: to_key : SQL92_RESERVED_TO ;
	public final PLSQLParser_PLSQLKeys.to_key_return to_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.to_key_return retval = new PLSQLParser_PLSQLKeys.to_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_TO366=null;

		Object SQL92_RESERVED_TO366_tree=null;

		try {
			// PLSQLKeys.g:1802:5: ( SQL92_RESERVED_TO )
			// PLSQLKeys.g:1802:10: SQL92_RESERVED_TO
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_TO366=(Token)match(input,SQL92_RESERVED_TO,FOLLOW_SQL92_RESERVED_TO_in_to_key11834); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_TO366_tree = (Object)adaptor.create(SQL92_RESERVED_TO366);
			adaptor.addChild(root_0, SQL92_RESERVED_TO366_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "to_key"


	public static class abs_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "abs_key"
	// PLSQLKeys.g:1805:1: abs_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.abs_key_return abs_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.abs_key_return retval = new PLSQLParser_PLSQLKeys.abs_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID367=null;

		Object REGULAR_ID367_tree=null;

		try {
			// PLSQLKeys.g:1806:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1806:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("abs"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "abs_key", "input.LT(1).getText().equalsIgnoreCase(\"abs\")");
			}
			REGULAR_ID367=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_abs_key11856); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID367_tree = (Object)adaptor.create(REGULAR_ID367);
			adaptor.addChild(root_0, REGULAR_ID367_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "abs_key"


	public static class rollback_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rollback_key"
	// PLSQLKeys.g:1809:1: rollback_key :{...}? => REGULAR_ID -> ROLLBACK_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rollback_key_return rollback_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rollback_key_return retval = new PLSQLParser_PLSQLKeys.rollback_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID368=null;

		Object REGULAR_ID368_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1810:5: ({...}? => REGULAR_ID -> ROLLBACK_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1810:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rollback"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rollback_key", "input.LT(1).getText().equalsIgnoreCase(\"rollback\")");
			}
			REGULAR_ID368=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rollback_key11879); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID368);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1810:77: -> ROLLBACK_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ROLLBACK_VK, REGULAR_ID368));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rollback_key"


	public static class share_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "share_key"
	// PLSQLKeys.g:1813:1: share_key : PLSQL_RESERVED_SHARE ;
	public final PLSQLParser_PLSQLKeys.share_key_return share_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.share_key_return retval = new PLSQLParser_PLSQLKeys.share_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_SHARE369=null;

		Object PLSQL_RESERVED_SHARE369_tree=null;

		try {
			// PLSQLKeys.g:1814:5: ( PLSQL_RESERVED_SHARE )
			// PLSQLKeys.g:1814:10: PLSQL_RESERVED_SHARE
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_SHARE369=(Token)match(input,PLSQL_RESERVED_SHARE,FOLLOW_PLSQL_RESERVED_SHARE_in_share_key11904); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_SHARE369_tree = (Object)adaptor.create(PLSQL_RESERVED_SHARE369);
			adaptor.addChild(root_0, PLSQL_RESERVED_SHARE369_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "share_key"


	public static class greatest_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "greatest_key"
	// PLSQLKeys.g:1817:1: greatest_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.greatest_key_return greatest_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.greatest_key_return retval = new PLSQLParser_PLSQLKeys.greatest_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID370=null;

		Object REGULAR_ID370_tree=null;

		try {
			// PLSQLKeys.g:1818:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1818:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("greatest"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "greatest_key", "input.LT(1).getText().equalsIgnoreCase(\"greatest\")");
			}
			REGULAR_ID370=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_greatest_key11926); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID370_tree = (Object)adaptor.create(REGULAR_ID370);
			adaptor.addChild(root_0, REGULAR_ID370_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "greatest_key"


	public static class vsize_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "vsize_key"
	// PLSQLKeys.g:1821:1: vsize_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.vsize_key_return vsize_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.vsize_key_return retval = new PLSQLParser_PLSQLKeys.vsize_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID371=null;

		Object REGULAR_ID371_tree=null;

		try {
			// PLSQLKeys.g:1822:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1822:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("vsize"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "vsize_key", "input.LT(1).getText().equalsIgnoreCase(\"vsize\")");
			}
			REGULAR_ID371=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_vsize_key11948); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID371_tree = (Object)adaptor.create(REGULAR_ID371);
			adaptor.addChild(root_0, REGULAR_ID371_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "vsize_key"


	public static class exclusive_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exclusive_key"
	// PLSQLKeys.g:1825:1: exclusive_key : PLSQL_RESERVED_EXCLUSIVE ;
	public final PLSQLParser_PLSQLKeys.exclusive_key_return exclusive_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.exclusive_key_return retval = new PLSQLParser_PLSQLKeys.exclusive_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_EXCLUSIVE372=null;

		Object PLSQL_RESERVED_EXCLUSIVE372_tree=null;

		try {
			// PLSQLKeys.g:1826:5: ( PLSQL_RESERVED_EXCLUSIVE )
			// PLSQLKeys.g:1826:10: PLSQL_RESERVED_EXCLUSIVE
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_EXCLUSIVE372=(Token)match(input,PLSQL_RESERVED_EXCLUSIVE,FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key11968); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_EXCLUSIVE372_tree = (Object)adaptor.create(PLSQL_RESERVED_EXCLUSIVE372);
			adaptor.addChild(root_0, PLSQL_RESERVED_EXCLUSIVE372_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "exclusive_key"


	public static class varchar2_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "varchar2_key"
	// PLSQLKeys.g:1829:1: varchar2_key :{...}? => REGULAR_ID -> VARCHAR2_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.varchar2_key_return varchar2_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.varchar2_key_return retval = new PLSQLParser_PLSQLKeys.varchar2_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID373=null;

		Object REGULAR_ID373_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1830:5: ({...}? => REGULAR_ID -> VARCHAR2_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1830:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("varchar2"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "varchar2_key", "input.LT(1).getText().equalsIgnoreCase(\"varchar2\")");
			}
			REGULAR_ID373=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_varchar2_key11991); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID373);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1830:77: -> VARCHAR2_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VARCHAR2_VK, REGULAR_ID373));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "varchar2_key"


	public static class rowidtochar_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rowidtochar_key"
	// PLSQLKeys.g:1833:1: rowidtochar_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.rowidtochar_key_return rowidtochar_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rowidtochar_key_return retval = new PLSQLParser_PLSQLKeys.rowidtochar_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID374=null;

		Object REGULAR_ID374_tree=null;

		try {
			// PLSQLKeys.g:1834:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1834:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("rowidtochar"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rowidtochar_key", "input.LT(1).getText().equalsIgnoreCase(\"rowidtochar\")");
			}
			REGULAR_ID374=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rowidtochar_key12018); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID374_tree = (Object)adaptor.create(REGULAR_ID374);
			adaptor.addChild(root_0, REGULAR_ID374_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rowidtochar_key"


	public static class open_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "open_key"
	// PLSQLKeys.g:1837:1: open_key :{...}? => REGULAR_ID -> OPEN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.open_key_return open_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.open_key_return retval = new PLSQLParser_PLSQLKeys.open_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID375=null;

		Object REGULAR_ID375_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1838:5: ({...}? => REGULAR_ID -> OPEN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1838:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("open"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "open_key", "input.LT(1).getText().equalsIgnoreCase(\"open\")");
			}
			REGULAR_ID375=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_open_key12041); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID375);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1838:73: -> OPEN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(OPEN_VK, REGULAR_ID375));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "open_key"


	public static class comment_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "comment_key"
	// PLSQLKeys.g:1841:1: comment_key :{...}? => REGULAR_ID -> COMMENT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.comment_key_return comment_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.comment_key_return retval = new PLSQLParser_PLSQLKeys.comment_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID376=null;

		Object REGULAR_ID376_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1842:5: ({...}? => REGULAR_ID -> COMMENT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1842:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("comment"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "comment_key", "input.LT(1).getText().equalsIgnoreCase(\"comment\")");
			}
			REGULAR_ID376=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_comment_key12069); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID376);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1842:76: -> COMMENT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COMMENT_VK, REGULAR_ID376));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "comment_key"


	public static class sqrt_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sqrt_key"
	// PLSQLKeys.g:1845:1: sqrt_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.sqrt_key_return sqrt_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sqrt_key_return retval = new PLSQLParser_PLSQLKeys.sqrt_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID377=null;

		Object REGULAR_ID377_tree=null;

		try {
			// PLSQLKeys.g:1846:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1846:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("sqrt"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sqrt_key", "input.LT(1).getText().equalsIgnoreCase(\"sqrt\")");
			}
			REGULAR_ID377=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sqrt_key12096); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID377_tree = (Object)adaptor.create(REGULAR_ID377);
			adaptor.addChild(root_0, REGULAR_ID377_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sqrt_key"


	public static class instr_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "instr_key"
	// PLSQLKeys.g:1849:1: instr_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.instr_key_return instr_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.instr_key_return retval = new PLSQLParser_PLSQLKeys.instr_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID378=null;

		Object REGULAR_ID378_tree=null;

		try {
			// PLSQLKeys.g:1850:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1850:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("instr"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "instr_key", "input.LT(1).getText().equalsIgnoreCase(\"instr\")");
			}
			REGULAR_ID378=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_instr_key12118); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID378_tree = (Object)adaptor.create(REGULAR_ID378);
			adaptor.addChild(root_0, REGULAR_ID378_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "instr_key"


	public static class nowait_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nowait_key"
	// PLSQLKeys.g:1853:1: nowait_key : PLSQL_RESERVED_NOWAIT ;
	public final PLSQLParser_PLSQLKeys.nowait_key_return nowait_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nowait_key_return retval = new PLSQLParser_PLSQLKeys.nowait_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_NOWAIT379=null;

		Object PLSQL_RESERVED_NOWAIT379_tree=null;

		try {
			// PLSQLKeys.g:1854:5: ( PLSQL_RESERVED_NOWAIT )
			// PLSQLKeys.g:1854:10: PLSQL_RESERVED_NOWAIT
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_NOWAIT379=(Token)match(input,PLSQL_RESERVED_NOWAIT,FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key12138); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_NOWAIT379_tree = (Object)adaptor.create(PLSQL_RESERVED_NOWAIT379);
			adaptor.addChild(root_0, PLSQL_RESERVED_NOWAIT379_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nowait_key"


	public static class lpad_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lpad_key"
	// PLSQLKeys.g:1857:1: lpad_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.lpad_key_return lpad_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.lpad_key_return retval = new PLSQLParser_PLSQLKeys.lpad_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID380=null;

		Object REGULAR_ID380_tree=null;

		try {
			// PLSQLKeys.g:1858:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1858:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("lpad"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "lpad_key", "input.LT(1).getText().equalsIgnoreCase(\"lpad\")");
			}
			REGULAR_ID380=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_lpad_key12160); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID380_tree = (Object)adaptor.create(REGULAR_ID380);
			adaptor.addChild(root_0, REGULAR_ID380_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lpad_key"


	public static class boolean_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "boolean_key"
	// PLSQLKeys.g:1861:1: boolean_key :{...}? => REGULAR_ID -> BOOLEAN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.boolean_key_return boolean_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.boolean_key_return retval = new PLSQLParser_PLSQLKeys.boolean_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID381=null;

		Object REGULAR_ID381_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1862:5: ({...}? => REGULAR_ID -> BOOLEAN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1862:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("boolean"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "boolean_key", "input.LT(1).getText().equalsIgnoreCase(\"boolean\")");
			}
			REGULAR_ID381=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_boolean_key12183); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID381);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1862:76: -> BOOLEAN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BOOLEAN_VK, REGULAR_ID381));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "boolean_key"


	public static class rpad_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rpad_key"
	// PLSQLKeys.g:1865:1: rpad_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.rpad_key_return rpad_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rpad_key_return retval = new PLSQLParser_PLSQLKeys.rpad_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID382=null;

		Object REGULAR_ID382_tree=null;

		try {
			// PLSQLKeys.g:1866:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1866:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("rpad"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rpad_key", "input.LT(1).getText().equalsIgnoreCase(\"rpad\")");
			}
			REGULAR_ID382=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rpad_key12210); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID382_tree = (Object)adaptor.create(REGULAR_ID382);
			adaptor.addChild(root_0, REGULAR_ID382_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rpad_key"


	public static class savepoint_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "savepoint_key"
	// PLSQLKeys.g:1869:1: savepoint_key :{...}? => REGULAR_ID -> SAVEPOINT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.savepoint_key_return savepoint_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.savepoint_key_return retval = new PLSQLParser_PLSQLKeys.savepoint_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID383=null;

		Object REGULAR_ID383_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1870:5: ({...}? => REGULAR_ID -> SAVEPOINT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1870:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("savepoint"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "savepoint_key", "input.LT(1).getText().equalsIgnoreCase(\"savepoint\")");
			}
			REGULAR_ID383=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_savepoint_key12233); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID383);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1870:78: -> SAVEPOINT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SAVEPOINT_VK, REGULAR_ID383));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "savepoint_key"


	public static class decode_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "decode_key"
	// PLSQLKeys.g:1873:1: decode_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.decode_key_return decode_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.decode_key_return retval = new PLSQLParser_PLSQLKeys.decode_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID384=null;

		Object REGULAR_ID384_tree=null;

		try {
			// PLSQLKeys.g:1874:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1874:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("decode"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "decode_key", "input.LT(1).getText().equalsIgnoreCase(\"decode\")");
			}
			REGULAR_ID384=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_decode_key12260); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID384_tree = (Object)adaptor.create(REGULAR_ID384);
			adaptor.addChild(root_0, REGULAR_ID384_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "decode_key"


	public static class reverse_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "reverse_key"
	// PLSQLKeys.g:1877:1: reverse_key :{...}? REGULAR_ID -> REVERSE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.reverse_key_return reverse_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.reverse_key_return retval = new PLSQLParser_PLSQLKeys.reverse_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID385=null;

		Object REGULAR_ID385_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1878:5: ({...}? REGULAR_ID -> REVERSE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1878:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("reverse"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "reverse_key", "input.LT(1).getText().equalsIgnoreCase(\"reverse\")");
			}
			REGULAR_ID385=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_reverse_key12282); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID385);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1878:74: -> REVERSE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REVERSE_VK, REGULAR_ID385));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "reverse_key"


	public static class least_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "least_key"
	// PLSQLKeys.g:1881:1: least_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.least_key_return least_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.least_key_return retval = new PLSQLParser_PLSQLKeys.least_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID386=null;

		Object REGULAR_ID386_tree=null;

		try {
			// PLSQLKeys.g:1882:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1882:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("least"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "least_key", "input.LT(1).getText().equalsIgnoreCase(\"least\")");
			}
			REGULAR_ID386=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_least_key12309); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID386_tree = (Object)adaptor.create(REGULAR_ID386);
			adaptor.addChild(root_0, REGULAR_ID386_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "least_key"


	public static class nvl_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nvl_key"
	// PLSQLKeys.g:1885:1: nvl_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.nvl_key_return nvl_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nvl_key_return retval = new PLSQLParser_PLSQLKeys.nvl_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID387=null;

		Object REGULAR_ID387_tree=null;

		try {
			// PLSQLKeys.g:1886:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1886:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("nvl"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nvl_key", "input.LT(1).getText().equalsIgnoreCase(\"nvl\")");
			}
			REGULAR_ID387=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nvl_key12331); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID387_tree = (Object)adaptor.create(REGULAR_ID387);
			adaptor.addChild(root_0, REGULAR_ID387_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nvl_key"


	public static class variance_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "variance_key"
	// PLSQLKeys.g:1889:1: variance_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.variance_key_return variance_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.variance_key_return retval = new PLSQLParser_PLSQLKeys.variance_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID388=null;

		Object REGULAR_ID388_tree=null;

		try {
			// PLSQLKeys.g:1890:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1890:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("variance"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "variance_key", "input.LT(1).getText().equalsIgnoreCase(\"variance\")");
			}
			REGULAR_ID388=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_variance_key12353); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID388_tree = (Object)adaptor.create(REGULAR_ID388);
			adaptor.addChild(root_0, REGULAR_ID388_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "variance_key"


	public static class start_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "start_key"
	// PLSQLKeys.g:1893:1: start_key : PLSQL_RESERVED_START ;
	public final PLSQLParser_PLSQLKeys.start_key_return start_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.start_key_return retval = new PLSQLParser_PLSQLKeys.start_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_START389=null;

		Object PLSQL_RESERVED_START389_tree=null;

		try {
			// PLSQLKeys.g:1894:5: ( PLSQL_RESERVED_START )
			// PLSQLKeys.g:1894:10: PLSQL_RESERVED_START
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_START389=(Token)match(input,PLSQL_RESERVED_START,FOLLOW_PLSQL_RESERVED_START_in_start_key12373); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_START389_tree = (Object)adaptor.create(PLSQL_RESERVED_START389);
			adaptor.addChild(root_0, PLSQL_RESERVED_START389_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "start_key"


	public static class desc_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "desc_key"
	// PLSQLKeys.g:1897:1: desc_key : SQL92_RESERVED_DESC ;
	public final PLSQLParser_PLSQLKeys.desc_key_return desc_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.desc_key_return retval = new PLSQLParser_PLSQLKeys.desc_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DESC390=null;

		Object SQL92_RESERVED_DESC390_tree=null;

		try {
			// PLSQLKeys.g:1898:5: ( SQL92_RESERVED_DESC )
			// PLSQLKeys.g:1898:10: SQL92_RESERVED_DESC
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DESC390=(Token)match(input,SQL92_RESERVED_DESC,FOLLOW_SQL92_RESERVED_DESC_in_desc_key12393); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DESC390_tree = (Object)adaptor.create(SQL92_RESERVED_DESC390);
			adaptor.addChild(root_0, SQL92_RESERVED_DESC390_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "desc_key"


	public static class concat_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "concat_key"
	// PLSQLKeys.g:1901:1: concat_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.concat_key_return concat_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.concat_key_return retval = new PLSQLParser_PLSQLKeys.concat_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID391=null;

		Object REGULAR_ID391_tree=null;

		try {
			// PLSQLKeys.g:1902:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1902:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("concat"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "concat_key", "input.LT(1).getText().equalsIgnoreCase(\"concat\")");
			}
			REGULAR_ID391=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_concat_key12415); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID391_tree = (Object)adaptor.create(REGULAR_ID391);
			adaptor.addChild(root_0, REGULAR_ID391_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "concat_key"


	public static class dump_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dump_key"
	// PLSQLKeys.g:1905:1: dump_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.dump_key_return dump_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dump_key_return retval = new PLSQLParser_PLSQLKeys.dump_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID392=null;

		Object REGULAR_ID392_tree=null;

		try {
			// PLSQLKeys.g:1906:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1906:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("dump"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dump_key", "input.LT(1).getText().equalsIgnoreCase(\"dump\")");
			}
			REGULAR_ID392=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dump_key12437); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID392_tree = (Object)adaptor.create(REGULAR_ID392);
			adaptor.addChild(root_0, REGULAR_ID392_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dump_key"


	public static class soundex_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "soundex_key"
	// PLSQLKeys.g:1909:1: soundex_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.soundex_key_return soundex_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.soundex_key_return retval = new PLSQLParser_PLSQLKeys.soundex_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID393=null;

		Object REGULAR_ID393_tree=null;

		try {
			// PLSQLKeys.g:1910:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1910:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("soundex"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "soundex_key", "input.LT(1).getText().equalsIgnoreCase(\"soundex\")");
			}
			REGULAR_ID393=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_soundex_key12459); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID393_tree = (Object)adaptor.create(REGULAR_ID393);
			adaptor.addChild(root_0, REGULAR_ID393_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "soundex_key"


	public static class positive_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "positive_key"
	// PLSQLKeys.g:1913:1: positive_key :{...}? => REGULAR_ID -> POSITIVE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.positive_key_return positive_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.positive_key_return retval = new PLSQLParser_PLSQLKeys.positive_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID394=null;

		Object REGULAR_ID394_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1914:5: ({...}? => REGULAR_ID -> POSITIVE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1914:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("positive"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "positive_key", "input.LT(1).getText().equalsIgnoreCase(\"positive\")");
			}
			REGULAR_ID394=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_positive_key12482); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID394);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1914:77: -> POSITIVE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(POSITIVE_VK, REGULAR_ID394));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "positive_key"


	public static class union_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "union_key"
	// PLSQLKeys.g:1917:1: union_key : SQL92_RESERVED_UNION ;
	public final PLSQLParser_PLSQLKeys.union_key_return union_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.union_key_return retval = new PLSQLParser_PLSQLKeys.union_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_UNION395=null;

		Object SQL92_RESERVED_UNION395_tree=null;

		try {
			// PLSQLKeys.g:1918:5: ( SQL92_RESERVED_UNION )
			// PLSQLKeys.g:1918:10: SQL92_RESERVED_UNION
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_UNION395=(Token)match(input,SQL92_RESERVED_UNION,FOLLOW_SQL92_RESERVED_UNION_in_union_key12507); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_UNION395_tree = (Object)adaptor.create(SQL92_RESERVED_UNION395);
			adaptor.addChild(root_0, SQL92_RESERVED_UNION395_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "union_key"


	public static class ascii_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ascii_key"
	// PLSQLKeys.g:1921:1: ascii_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.ascii_key_return ascii_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ascii_key_return retval = new PLSQLParser_PLSQLKeys.ascii_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID396=null;

		Object REGULAR_ID396_tree=null;

		try {
			// PLSQLKeys.g:1922:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1922:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("ascii"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ascii_key", "input.LT(1).getText().equalsIgnoreCase(\"ascii\")");
			}
			REGULAR_ID396=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ascii_key12529); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID396_tree = (Object)adaptor.create(REGULAR_ID396);
			adaptor.addChild(root_0, REGULAR_ID396_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ascii_key"


	public static class connect_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "connect_key"
	// PLSQLKeys.g:1925:1: connect_key : SQL92_RESERVED_CONNECT ;
	public final PLSQLParser_PLSQLKeys.connect_key_return connect_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.connect_key_return retval = new PLSQLParser_PLSQLKeys.connect_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_CONNECT397=null;

		Object SQL92_RESERVED_CONNECT397_tree=null;

		try {
			// PLSQLKeys.g:1926:5: ( SQL92_RESERVED_CONNECT )
			// PLSQLKeys.g:1926:10: SQL92_RESERVED_CONNECT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_CONNECT397=(Token)match(input,SQL92_RESERVED_CONNECT,FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key12549); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_CONNECT397_tree = (Object)adaptor.create(SQL92_RESERVED_CONNECT397);
			adaptor.addChild(root_0, SQL92_RESERVED_CONNECT397_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "connect_key"


	public static class asc_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "asc_key"
	// PLSQLKeys.g:1929:1: asc_key : SQL92_RESERVED_ASC ;
	public final PLSQLParser_PLSQLKeys.asc_key_return asc_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.asc_key_return retval = new PLSQLParser_PLSQLKeys.asc_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ASC398=null;

		Object SQL92_RESERVED_ASC398_tree=null;

		try {
			// PLSQLKeys.g:1930:5: ( SQL92_RESERVED_ASC )
			// PLSQLKeys.g:1930:10: SQL92_RESERVED_ASC
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ASC398=(Token)match(input,SQL92_RESERVED_ASC,FOLLOW_SQL92_RESERVED_ASC_in_asc_key12569); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ASC398_tree = (Object)adaptor.create(SQL92_RESERVED_ASC398);
			adaptor.addChild(root_0, SQL92_RESERVED_ASC398_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "asc_key"


	public static class hextoraw_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "hextoraw_key"
	// PLSQLKeys.g:1933:1: hextoraw_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.hextoraw_key_return hextoraw_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.hextoraw_key_return retval = new PLSQLParser_PLSQLKeys.hextoraw_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID399=null;

		Object REGULAR_ID399_tree=null;

		try {
			// PLSQLKeys.g:1934:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1934:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("hextoraw"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "hextoraw_key", "input.LT(1).getText().equalsIgnoreCase(\"hextoraw\")");
			}
			REGULAR_ID399=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_hextoraw_key12591); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID399_tree = (Object)adaptor.create(REGULAR_ID399);
			adaptor.addChild(root_0, REGULAR_ID399_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "hextoraw_key"


	public static class to_date_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "to_date_key"
	// PLSQLKeys.g:1937:1: to_date_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.to_date_key_return to_date_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.to_date_key_return retval = new PLSQLParser_PLSQLKeys.to_date_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID400=null;

		Object REGULAR_ID400_tree=null;

		try {
			// PLSQLKeys.g:1938:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1938:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("to_date"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "to_date_key", "input.LT(1).getText().equalsIgnoreCase(\"to_date\")");
			}
			REGULAR_ID400=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_to_date_key12613); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID400_tree = (Object)adaptor.create(REGULAR_ID400);
			adaptor.addChild(root_0, REGULAR_ID400_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "to_date_key"


	public static class floor_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "floor_key"
	// PLSQLKeys.g:1941:1: floor_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.floor_key_return floor_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.floor_key_return retval = new PLSQLParser_PLSQLKeys.floor_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID401=null;

		Object REGULAR_ID401_tree=null;

		try {
			// PLSQLKeys.g:1942:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1942:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("floor"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "floor_key", "input.LT(1).getText().equalsIgnoreCase(\"floor\")");
			}
			REGULAR_ID401=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_floor_key12635); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID401_tree = (Object)adaptor.create(REGULAR_ID401);
			adaptor.addChild(root_0, REGULAR_ID401_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "floor_key"


	public static class sign_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sign_key"
	// PLSQLKeys.g:1945:1: sign_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.sign_key_return sign_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sign_key_return retval = new PLSQLParser_PLSQLKeys.sign_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID402=null;

		Object REGULAR_ID402_tree=null;

		try {
			// PLSQLKeys.g:1946:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1946:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("sign"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sign_key", "input.LT(1).getText().equalsIgnoreCase(\"sign\")");
			}
			REGULAR_ID402=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sign_key12657); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID402_tree = (Object)adaptor.create(REGULAR_ID402);
			adaptor.addChild(root_0, REGULAR_ID402_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sign_key"


	public static class update_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "update_key"
	// PLSQLKeys.g:1949:1: update_key : SQL92_RESERVED_UPDATE ;
	public final PLSQLParser_PLSQLKeys.update_key_return update_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.update_key_return retval = new PLSQLParser_PLSQLKeys.update_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_UPDATE403=null;

		Object SQL92_RESERVED_UPDATE403_tree=null;

		try {
			// PLSQLKeys.g:1950:5: ( SQL92_RESERVED_UPDATE )
			// PLSQLKeys.g:1950:10: SQL92_RESERVED_UPDATE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_UPDATE403=(Token)match(input,SQL92_RESERVED_UPDATE,FOLLOW_SQL92_RESERVED_UPDATE_in_update_key12677); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_UPDATE403_tree = (Object)adaptor.create(SQL92_RESERVED_UPDATE403);
			adaptor.addChild(root_0, SQL92_RESERVED_UPDATE403_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "update_key"


	public static class trunc_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "trunc_key"
	// PLSQLKeys.g:1953:1: trunc_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.trunc_key_return trunc_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.trunc_key_return retval = new PLSQLParser_PLSQLKeys.trunc_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID404=null;

		Object REGULAR_ID404_tree=null;

		try {
			// PLSQLKeys.g:1954:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1954:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("trunc"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "trunc_key", "input.LT(1).getText().equalsIgnoreCase(\"trunc\")");
			}
			REGULAR_ID404=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_trunc_key12699); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID404_tree = (Object)adaptor.create(REGULAR_ID404);
			adaptor.addChild(root_0, REGULAR_ID404_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trunc_key"


	public static class rtrim_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rtrim_key"
	// PLSQLKeys.g:1957:1: rtrim_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.rtrim_key_return rtrim_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rtrim_key_return retval = new PLSQLParser_PLSQLKeys.rtrim_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID405=null;

		Object REGULAR_ID405_tree=null;

		try {
			// PLSQLKeys.g:1958:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1958:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("rtrim"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rtrim_key", "input.LT(1).getText().equalsIgnoreCase(\"rtrim\")");
			}
			REGULAR_ID405=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rtrim_key12721); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID405_tree = (Object)adaptor.create(REGULAR_ID405);
			adaptor.addChild(root_0, REGULAR_ID405_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rtrim_key"


	public static class close_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "close_key"
	// PLSQLKeys.g:1961:1: close_key :{...}? => REGULAR_ID -> CLOSE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.close_key_return close_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.close_key_return retval = new PLSQLParser_PLSQLKeys.close_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID406=null;

		Object REGULAR_ID406_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1962:5: ({...}? => REGULAR_ID -> CLOSE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1962:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("close"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "close_key", "input.LT(1).getText().equalsIgnoreCase(\"close\")");
			}
			REGULAR_ID406=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_close_key12744); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID406);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1962:74: -> CLOSE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CLOSE_VK, REGULAR_ID406));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "close_key"


	public static class to_char_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "to_char_key"
	// PLSQLKeys.g:1965:1: to_char_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.to_char_key_return to_char_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.to_char_key_return retval = new PLSQLParser_PLSQLKeys.to_char_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID407=null;

		Object REGULAR_ID407_tree=null;

		try {
			// PLSQLKeys.g:1966:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1966:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("to_char"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "to_char_key", "input.LT(1).getText().equalsIgnoreCase(\"to_char\")");
			}
			REGULAR_ID407=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_to_char_key12771); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID407_tree = (Object)adaptor.create(REGULAR_ID407);
			adaptor.addChild(root_0, REGULAR_ID407_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "to_char_key"


	public static class ltrim_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ltrim_key"
	// PLSQLKeys.g:1969:1: ltrim_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.ltrim_key_return ltrim_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ltrim_key_return retval = new PLSQLParser_PLSQLKeys.ltrim_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID408=null;

		Object REGULAR_ID408_tree=null;

		try {
			// PLSQLKeys.g:1970:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1970:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("ltrim"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ltrim_key", "input.LT(1).getText().equalsIgnoreCase(\"ltrim\")");
			}
			REGULAR_ID408=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ltrim_key12793); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID408_tree = (Object)adaptor.create(REGULAR_ID408);
			adaptor.addChild(root_0, REGULAR_ID408_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ltrim_key"


	public static class mode_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "mode_key"
	// PLSQLKeys.g:1973:1: mode_key : PLSQL_RESERVED_MODE ;
	public final PLSQLParser_PLSQLKeys.mode_key_return mode_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.mode_key_return retval = new PLSQLParser_PLSQLKeys.mode_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_RESERVED_MODE409=null;

		Object PLSQL_RESERVED_MODE409_tree=null;

		try {
			// PLSQLKeys.g:1974:5: ( PLSQL_RESERVED_MODE )
			// PLSQLKeys.g:1974:10: PLSQL_RESERVED_MODE
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_RESERVED_MODE409=(Token)match(input,PLSQL_RESERVED_MODE,FOLLOW_PLSQL_RESERVED_MODE_in_mode_key12813); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_RESERVED_MODE409_tree = (Object)adaptor.create(PLSQL_RESERVED_MODE409);
			adaptor.addChild(root_0, PLSQL_RESERVED_MODE409_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mode_key"


	public static class uid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "uid_key"
	// PLSQLKeys.g:1977:1: uid_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.uid_key_return uid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.uid_key_return retval = new PLSQLParser_PLSQLKeys.uid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID410=null;

		Object REGULAR_ID410_tree=null;

		try {
			// PLSQLKeys.g:1978:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1978:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("uid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "uid_key", "input.LT(1).getText().equalsIgnoreCase(\"uid\")");
			}
			REGULAR_ID410=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_uid_key12835); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID410_tree = (Object)adaptor.create(REGULAR_ID410);
			adaptor.addChild(root_0, REGULAR_ID410_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "uid_key"


	public static class chr_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "chr_key"
	// PLSQLKeys.g:1981:1: chr_key :{...}? REGULAR_ID -> CHR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.chr_key_return chr_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.chr_key_return retval = new PLSQLParser_PLSQLKeys.chr_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID411=null;

		Object REGULAR_ID411_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1982:5: ({...}? REGULAR_ID -> CHR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1982:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("chr"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "chr_key", "input.LT(1).getText().equalsIgnoreCase(\"chr\")");
			}
			REGULAR_ID411=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_chr_key12857); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID411);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1982:70: -> CHR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CHR_VK, REGULAR_ID411));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "chr_key"


	public static class intersect_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "intersect_key"
	// PLSQLKeys.g:1985:1: intersect_key : SQL92_RESERVED_INTERSECT ;
	public final PLSQLParser_PLSQLKeys.intersect_key_return intersect_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.intersect_key_return retval = new PLSQLParser_PLSQLKeys.intersect_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_INTERSECT412=null;

		Object SQL92_RESERVED_INTERSECT412_tree=null;

		try {
			// PLSQLKeys.g:1986:5: ( SQL92_RESERVED_INTERSECT )
			// PLSQLKeys.g:1986:10: SQL92_RESERVED_INTERSECT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_INTERSECT412=(Token)match(input,SQL92_RESERVED_INTERSECT,FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key12882); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_INTERSECT412_tree = (Object)adaptor.create(SQL92_RESERVED_INTERSECT412);
			adaptor.addChild(root_0, SQL92_RESERVED_INTERSECT412_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "intersect_key"


	public static class chartorowid_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "chartorowid_key"
	// PLSQLKeys.g:1989:1: chartorowid_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.chartorowid_key_return chartorowid_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.chartorowid_key_return retval = new PLSQLParser_PLSQLKeys.chartorowid_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID413=null;

		Object REGULAR_ID413_tree=null;

		try {
			// PLSQLKeys.g:1990:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1990:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("chartorowid"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "chartorowid_key", "input.LT(1).getText().equalsIgnoreCase(\"chartorowid\")");
			}
			REGULAR_ID413=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_chartorowid_key12904); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID413_tree = (Object)adaptor.create(REGULAR_ID413);
			adaptor.addChild(root_0, REGULAR_ID413_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "chartorowid_key"


	public static class mlslabel_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "mlslabel_key"
	// PLSQLKeys.g:1993:1: mlslabel_key :{...}? => REGULAR_ID -> MLSLABEL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.mlslabel_key_return mlslabel_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.mlslabel_key_return retval = new PLSQLParser_PLSQLKeys.mlslabel_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID414=null;

		Object REGULAR_ID414_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:1994:5: ({...}? => REGULAR_ID -> MLSLABEL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:1994:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("mlslabel"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "mlslabel_key", "input.LT(1).getText().equalsIgnoreCase(\"mlslabel\")");
			}
			REGULAR_ID414=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_mlslabel_key12927); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID414);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 1994:77: -> MLSLABEL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MLSLABEL_VK, REGULAR_ID414));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mlslabel_key"


	public static class userenv_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "userenv_key"
	// PLSQLKeys.g:1997:1: userenv_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.userenv_key_return userenv_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.userenv_key_return retval = new PLSQLParser_PLSQLKeys.userenv_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID415=null;

		Object REGULAR_ID415_tree=null;

		try {
			// PLSQLKeys.g:1998:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:1998:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("userenv"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "userenv_key", "input.LT(1).getText().equalsIgnoreCase(\"userenv\")");
			}
			REGULAR_ID415=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_userenv_key12954); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID415_tree = (Object)adaptor.create(REGULAR_ID415);
			adaptor.addChild(root_0, REGULAR_ID415_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "userenv_key"


	public static class stddev_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "stddev_key"
	// PLSQLKeys.g:2001:1: stddev_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.stddev_key_return stddev_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.stddev_key_return retval = new PLSQLParser_PLSQLKeys.stddev_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID416=null;

		Object REGULAR_ID416_tree=null;

		try {
			// PLSQLKeys.g:2002:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2002:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("stddev"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "stddev_key", "input.LT(1).getText().equalsIgnoreCase(\"stddev\")");
			}
			REGULAR_ID416=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_stddev_key12976); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID416_tree = (Object)adaptor.create(REGULAR_ID416);
			adaptor.addChild(root_0, REGULAR_ID416_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "stddev_key"


	public static class length_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "length_key"
	// PLSQLKeys.g:2005:1: length_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.length_key_return length_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.length_key_return retval = new PLSQLParser_PLSQLKeys.length_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID417=null;

		Object REGULAR_ID417_tree=null;

		try {
			// PLSQLKeys.g:2006:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2006:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("length"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "length_key", "input.LT(1).getText().equalsIgnoreCase(\"length\")");
			}
			REGULAR_ID417=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_length_key12998); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID417_tree = (Object)adaptor.create(REGULAR_ID417);
			adaptor.addChild(root_0, REGULAR_ID417_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "length_key"


	public static class fetch_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "fetch_key"
	// PLSQLKeys.g:2009:1: fetch_key : SQL92_RESERVED_FETCH ;
	public final PLSQLParser_PLSQLKeys.fetch_key_return fetch_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.fetch_key_return retval = new PLSQLParser_PLSQLKeys.fetch_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_FETCH418=null;

		Object SQL92_RESERVED_FETCH418_tree=null;

		try {
			// PLSQLKeys.g:2010:5: ( SQL92_RESERVED_FETCH )
			// PLSQLKeys.g:2010:10: SQL92_RESERVED_FETCH
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_FETCH418=(Token)match(input,SQL92_RESERVED_FETCH,FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key13018); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_FETCH418_tree = (Object)adaptor.create(SQL92_RESERVED_FETCH418);
			adaptor.addChild(root_0, SQL92_RESERVED_FETCH418_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "fetch_key"


	public static class group_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "group_key"
	// PLSQLKeys.g:2013:1: group_key : SQL92_RESERVED_GROUP ;
	public final PLSQLParser_PLSQLKeys.group_key_return group_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.group_key_return retval = new PLSQLParser_PLSQLKeys.group_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_GROUP419=null;

		Object SQL92_RESERVED_GROUP419_tree=null;

		try {
			// PLSQLKeys.g:2014:5: ( SQL92_RESERVED_GROUP )
			// PLSQLKeys.g:2014:10: SQL92_RESERVED_GROUP
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_GROUP419=(Token)match(input,SQL92_RESERVED_GROUP,FOLLOW_SQL92_RESERVED_GROUP_in_group_key13038); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_GROUP419_tree = (Object)adaptor.create(SQL92_RESERVED_GROUP419);
			adaptor.addChild(root_0, SQL92_RESERVED_GROUP419_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "group_key"


	public static class sysdate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sysdate_key"
	// PLSQLKeys.g:2017:1: sysdate_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.sysdate_key_return sysdate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sysdate_key_return retval = new PLSQLParser_PLSQLKeys.sysdate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID420=null;

		Object REGULAR_ID420_tree=null;

		try {
			// PLSQLKeys.g:2018:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2018:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("sysdate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sysdate_key", "input.LT(1).getText().equalsIgnoreCase(\"sysdate\")");
			}
			REGULAR_ID420=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sysdate_key13060); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID420_tree = (Object)adaptor.create(REGULAR_ID420);
			adaptor.addChild(root_0, REGULAR_ID420_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sysdate_key"


	public static class binary_integer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "binary_integer_key"
	// PLSQLKeys.g:2021:1: binary_integer_key :{...}? => REGULAR_ID -> BINARY_INTEGER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.binary_integer_key_return binary_integer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.binary_integer_key_return retval = new PLSQLParser_PLSQLKeys.binary_integer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID421=null;

		Object REGULAR_ID421_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2022:5: ({...}? => REGULAR_ID -> BINARY_INTEGER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2022:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("binary_integer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "binary_integer_key", "input.LT(1).getText().equalsIgnoreCase(\"binary_integer\")");
			}
			REGULAR_ID421=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_binary_integer_key13083); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID421);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2022:83: -> BINARY_INTEGER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BINARY_INTEGER_VK, REGULAR_ID421));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "binary_integer_key"


	public static class to_number_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "to_number_key"
	// PLSQLKeys.g:2025:1: to_number_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.to_number_key_return to_number_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.to_number_key_return retval = new PLSQLParser_PLSQLKeys.to_number_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID422=null;

		Object REGULAR_ID422_tree=null;

		try {
			// PLSQLKeys.g:2026:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2026:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("to_number"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "to_number_key", "input.LT(1).getText().equalsIgnoreCase(\"to_number\")");
			}
			REGULAR_ID422=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_to_number_key13110); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID422_tree = (Object)adaptor.create(REGULAR_ID422);
			adaptor.addChild(root_0, REGULAR_ID422_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "to_number_key"


	public static class substr_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "substr_key"
	// PLSQLKeys.g:2029:1: substr_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.substr_key_return substr_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.substr_key_return retval = new PLSQLParser_PLSQLKeys.substr_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID423=null;

		Object REGULAR_ID423_tree=null;

		try {
			// PLSQLKeys.g:2030:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2030:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("substr"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "substr_key", "input.LT(1).getText().equalsIgnoreCase(\"substr\")");
			}
			REGULAR_ID423=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_substr_key13132); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID423_tree = (Object)adaptor.create(REGULAR_ID423);
			adaptor.addChild(root_0, REGULAR_ID423_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "substr_key"


	public static class ceil_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "ceil_key"
	// PLSQLKeys.g:2033:1: ceil_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.ceil_key_return ceil_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.ceil_key_return retval = new PLSQLParser_PLSQLKeys.ceil_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID424=null;

		Object REGULAR_ID424_tree=null;

		try {
			// PLSQLKeys.g:2034:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2034:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("ceil"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "ceil_key", "input.LT(1).getText().equalsIgnoreCase(\"ceil\")");
			}
			REGULAR_ID424=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_ceil_key13154); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID424_tree = (Object)adaptor.create(REGULAR_ID424);
			adaptor.addChild(root_0, REGULAR_ID424_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "ceil_key"


	public static class initcap_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "initcap_key"
	// PLSQLKeys.g:2037:1: initcap_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.initcap_key_return initcap_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.initcap_key_return retval = new PLSQLParser_PLSQLKeys.initcap_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID425=null;

		Object REGULAR_ID425_tree=null;

		try {
			// PLSQLKeys.g:2038:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2038:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("initcap"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "initcap_key", "input.LT(1).getText().equalsIgnoreCase(\"initcap\")");
			}
			REGULAR_ID425=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_initcap_key13176); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID425_tree = (Object)adaptor.create(REGULAR_ID425);
			adaptor.addChild(root_0, REGULAR_ID425_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "initcap_key"


	public static class round_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "round_key"
	// PLSQLKeys.g:2041:1: round_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.round_key_return round_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.round_key_return retval = new PLSQLParser_PLSQLKeys.round_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID426=null;

		Object REGULAR_ID426_tree=null;

		try {
			// PLSQLKeys.g:2042:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2042:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("round"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "round_key", "input.LT(1).getText().equalsIgnoreCase(\"round\")");
			}
			REGULAR_ID426=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_round_key13198); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID426_tree = (Object)adaptor.create(REGULAR_ID426);
			adaptor.addChild(root_0, REGULAR_ID426_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "round_key"


	public static class long_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "long_key"
	// PLSQLKeys.g:2045:1: long_key :{...}? => REGULAR_ID -> LONG_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.long_key_return long_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.long_key_return retval = new PLSQLParser_PLSQLKeys.long_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID427=null;

		Object REGULAR_ID427_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2046:5: ({...}? => REGULAR_ID -> LONG_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2046:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("long"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "long_key", "input.LT(1).getText().equalsIgnoreCase(\"long\")");
			}
			REGULAR_ID427=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_long_key13221); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID427);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2046:73: -> LONG_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LONG_VK, REGULAR_ID427));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "long_key"


	public static class read_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "read_key"
	// PLSQLKeys.g:2049:1: read_key :{...}? => REGULAR_ID -> READ_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.read_key_return read_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.read_key_return retval = new PLSQLParser_PLSQLKeys.read_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID428=null;

		Object REGULAR_ID428_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2050:5: ({...}? => REGULAR_ID -> READ_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2050:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("read"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "read_key", "input.LT(1).getText().equalsIgnoreCase(\"read\")");
			}
			REGULAR_ID428=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_read_key13249); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID428);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2050:73: -> READ_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(READ_VK, REGULAR_ID428));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "read_key"


	public static class only_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "only_key"
	// PLSQLKeys.g:2053:1: only_key :{...}? REGULAR_ID -> ONLY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.only_key_return only_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.only_key_return retval = new PLSQLParser_PLSQLKeys.only_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID429=null;

		Object REGULAR_ID429_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2054:5: ({...}? REGULAR_ID -> ONLY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2054:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("only"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "only_key", "input.LT(1).getText().equalsIgnoreCase(\"only\")");
			}
			REGULAR_ID429=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_only_key13276); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID429);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2054:71: -> ONLY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(ONLY_VK, REGULAR_ID429));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "only_key"


	public static class set_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "set_key"
	// PLSQLKeys.g:2057:1: set_key :{...}? => REGULAR_ID -> SET_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.set_key_return set_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.set_key_return retval = new PLSQLParser_PLSQLKeys.set_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID430=null;

		Object REGULAR_ID430_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2058:5: ({...}? => REGULAR_ID -> SET_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2058:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("set"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "set_key", "input.LT(1).getText().equalsIgnoreCase(\"set\")");
			}
			REGULAR_ID430=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_set_key13304); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID430);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2058:72: -> SET_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SET_VK, REGULAR_ID430));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "set_key"


	public static class nullif_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nullif_key"
	// PLSQLKeys.g:2061:1: nullif_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.nullif_key_return nullif_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nullif_key_return retval = new PLSQLParser_PLSQLKeys.nullif_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID431=null;

		Object REGULAR_ID431_tree=null;

		try {
			// PLSQLKeys.g:2062:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2062:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("nullif"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nullif_key", "input.LT(1).getText().equalsIgnoreCase(\"nullif\")");
			}
			REGULAR_ID431=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nullif_key13331); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID431_tree = (Object)adaptor.create(REGULAR_ID431);
			adaptor.addChild(root_0, REGULAR_ID431_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nullif_key"


	public static class coalesce_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "coalesce_key"
	// PLSQLKeys.g:2065:1: coalesce_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.coalesce_key_return coalesce_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.coalesce_key_return retval = new PLSQLParser_PLSQLKeys.coalesce_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID432=null;

		Object REGULAR_ID432_tree=null;

		try {
			// PLSQLKeys.g:2066:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2066:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("coalesce"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "coalesce_key", "input.LT(1).getText().equalsIgnoreCase(\"coalesce\")");
			}
			REGULAR_ID432=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_coalesce_key13353); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID432_tree = (Object)adaptor.create(REGULAR_ID432);
			adaptor.addChild(root_0, REGULAR_ID432_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "coalesce_key"


	public static class count_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "count_key"
	// PLSQLKeys.g:2069:1: count_key :{...}? REGULAR_ID -> COUNT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.count_key_return count_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.count_key_return retval = new PLSQLParser_PLSQLKeys.count_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID433=null;

		Object REGULAR_ID433_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2070:5: ({...}? REGULAR_ID -> COUNT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2070:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("count"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "count_key", "input.LT(1).getText().equalsIgnoreCase(\"count\")");
			}
			REGULAR_ID433=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_count_key13375); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID433);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2070:72: -> COUNT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(COUNT_VK, REGULAR_ID433));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "count_key"


	public static class avg_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "avg_key"
	// PLSQLKeys.g:2073:1: avg_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.avg_key_return avg_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.avg_key_return retval = new PLSQLParser_PLSQLKeys.avg_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID434=null;

		Object REGULAR_ID434_tree=null;

		try {
			// PLSQLKeys.g:2073:12: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2073:17: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("avg"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "avg_key", "input.LT(1).getText().equalsIgnoreCase(\"avg\")");
			}
			REGULAR_ID434=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_avg_key13401); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID434_tree = (Object)adaptor.create(REGULAR_ID434);
			adaptor.addChild(root_0, REGULAR_ID434_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "avg_key"


	public static class max_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "max_key"
	// PLSQLKeys.g:2076:1: max_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.max_key_return max_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.max_key_return retval = new PLSQLParser_PLSQLKeys.max_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID435=null;

		Object REGULAR_ID435_tree=null;

		try {
			// PLSQLKeys.g:2076:12: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2076:17: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("max"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "max_key", "input.LT(1).getText().equalsIgnoreCase(\"max\")");
			}
			REGULAR_ID435=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_max_key13422); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID435_tree = (Object)adaptor.create(REGULAR_ID435);
			adaptor.addChild(root_0, REGULAR_ID435_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "max_key"


	public static class min_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "min_key"
	// PLSQLKeys.g:2079:1: min_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.min_key_return min_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.min_key_return retval = new PLSQLParser_PLSQLKeys.min_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID436=null;

		Object REGULAR_ID436_tree=null;

		try {
			// PLSQLKeys.g:2079:12: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2079:17: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("min"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "min_key", "input.LT(1).getText().equalsIgnoreCase(\"min\")");
			}
			REGULAR_ID436=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_min_key13443); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID436_tree = (Object)adaptor.create(REGULAR_ID436);
			adaptor.addChild(root_0, REGULAR_ID436_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "min_key"


	public static class sum_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sum_key"
	// PLSQLKeys.g:2082:1: sum_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.sum_key_return sum_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sum_key_return retval = new PLSQLParser_PLSQLKeys.sum_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID437=null;

		Object REGULAR_ID437_tree=null;

		try {
			// PLSQLKeys.g:2082:12: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2082:17: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("sum"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sum_key", "input.LT(1).getText().equalsIgnoreCase(\"sum\")");
			}
			REGULAR_ID437=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sum_key13464); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID437_tree = (Object)adaptor.create(REGULAR_ID437);
			adaptor.addChild(root_0, REGULAR_ID437_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sum_key"


	public static class unknown_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "unknown_key"
	// PLSQLKeys.g:2085:1: unknown_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.unknown_key_return unknown_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.unknown_key_return retval = new PLSQLParser_PLSQLKeys.unknown_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID438=null;

		Object REGULAR_ID438_tree=null;

		try {
			// PLSQLKeys.g:2086:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2086:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("unknown"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "unknown_key", "input.LT(1).getText().equalsIgnoreCase(\"unknown\")");
			}
			REGULAR_ID438=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_unknown_key13486); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID438_tree = (Object)adaptor.create(REGULAR_ID438);
			adaptor.addChild(root_0, REGULAR_ID438_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "unknown_key"


	public static class escape_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "escape_key"
	// PLSQLKeys.g:2089:1: escape_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.escape_key_return escape_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.escape_key_return retval = new PLSQLParser_PLSQLKeys.escape_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID439=null;

		Object REGULAR_ID439_tree=null;

		try {
			// PLSQLKeys.g:2090:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2090:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("escape"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "escape_key", "input.LT(1).getText().equalsIgnoreCase(\"escape\")");
			}
			REGULAR_ID439=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_escape_key13508); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID439_tree = (Object)adaptor.create(REGULAR_ID439);
			adaptor.addChild(root_0, REGULAR_ID439_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "escape_key"


	public static class some_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "some_key"
	// PLSQLKeys.g:2093:1: some_key :{...}? REGULAR_ID -> SOME_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.some_key_return some_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.some_key_return retval = new PLSQLParser_PLSQLKeys.some_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID440=null;

		Object REGULAR_ID440_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2094:5: ({...}? REGULAR_ID -> SOME_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2094:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("some"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "some_key", "input.LT(1).getText().equalsIgnoreCase(\"some\")");
			}
			REGULAR_ID440=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_some_key13530); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID440);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2094:71: -> SOME_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SOME_VK, REGULAR_ID440));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "some_key"


	public static class match_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "match_key"
	// PLSQLKeys.g:2097:1: match_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.match_key_return match_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.match_key_return retval = new PLSQLParser_PLSQLKeys.match_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID441=null;

		Object REGULAR_ID441_tree=null;

		try {
			// PLSQLKeys.g:2098:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2098:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("match"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "match_key", "input.LT(1).getText().equalsIgnoreCase(\"match\")");
			}
			REGULAR_ID441=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_match_key13557); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID441_tree = (Object)adaptor.create(REGULAR_ID441);
			adaptor.addChild(root_0, REGULAR_ID441_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "match_key"


	public static class cast_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cast_key"
	// PLSQLKeys.g:2101:1: cast_key :{...}? REGULAR_ID -> CAST_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cast_key_return cast_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cast_key_return retval = new PLSQLParser_PLSQLKeys.cast_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID442=null;

		Object REGULAR_ID442_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2102:5: ({...}? REGULAR_ID -> CAST_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2102:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cast"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cast_key", "input.LT(1).getText().equalsIgnoreCase(\"cast\")");
			}
			REGULAR_ID442=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cast_key13579); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID442);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2102:71: -> CAST_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CAST_VK, REGULAR_ID442));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cast_key"


	public static class full_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "full_key"
	// PLSQLKeys.g:2105:1: full_key :{...}? => REGULAR_ID -> FULL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.full_key_return full_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.full_key_return retval = new PLSQLParser_PLSQLKeys.full_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID443=null;

		Object REGULAR_ID443_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2105:9: ({...}? => REGULAR_ID -> FULL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2105:14: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("full"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "full_key", "input.LT(1).getText().equalsIgnoreCase(\"full\")");
			}
			REGULAR_ID443=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_full_key13602); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID443);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2105:77: -> FULL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FULL_VK, REGULAR_ID443));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "full_key"


	public static class partial_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "partial_key"
	// PLSQLKeys.g:2108:1: partial_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.partial_key_return partial_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.partial_key_return retval = new PLSQLParser_PLSQLKeys.partial_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID444=null;

		Object REGULAR_ID444_tree=null;

		try {
			// PLSQLKeys.g:2109:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2109:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("partial"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "partial_key", "input.LT(1).getText().equalsIgnoreCase(\"partial\")");
			}
			REGULAR_ID444=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_partial_key13629); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID444_tree = (Object)adaptor.create(REGULAR_ID444);
			adaptor.addChild(root_0, REGULAR_ID444_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "partial_key"


	public static class character_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "character_key"
	// PLSQLKeys.g:2112:1: character_key :{...}? => REGULAR_ID -> CHARACTER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.character_key_return character_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.character_key_return retval = new PLSQLParser_PLSQLKeys.character_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID445=null;

		Object REGULAR_ID445_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2113:5: ({...}? => REGULAR_ID -> CHARACTER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2113:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("character"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "character_key", "input.LT(1).getText().equalsIgnoreCase(\"character\")");
			}
			REGULAR_ID445=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_character_key13652); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID445);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2113:78: -> CHARACTER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CHARACTER_VK, REGULAR_ID445));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "character_key"


	public static class except_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "except_key"
	// PLSQLKeys.g:2116:1: except_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.except_key_return except_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.except_key_return retval = new PLSQLParser_PLSQLKeys.except_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID446=null;

		Object REGULAR_ID446_tree=null;

		try {
			// PLSQLKeys.g:2117:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2117:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("except"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "except_key", "input.LT(1).getText().equalsIgnoreCase(\"except\")");
			}
			REGULAR_ID446=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_except_key13679); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID446_tree = (Object)adaptor.create(REGULAR_ID446);
			adaptor.addChild(root_0, REGULAR_ID446_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "except_key"


	public static class char_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "char_key"
	// PLSQLKeys.g:2120:1: char_key :{...}? => REGULAR_ID -> CHAR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.char_key_return char_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.char_key_return retval = new PLSQLParser_PLSQLKeys.char_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID447=null;

		Object REGULAR_ID447_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2120:9: ({...}? => REGULAR_ID -> CHAR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2120:14: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("char"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "char_key", "input.LT(1).getText().equalsIgnoreCase(\"char\")");
			}
			REGULAR_ID447=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_char_key13697); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID447);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2120:77: -> CHAR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CHAR_VK, REGULAR_ID447));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "char_key"


	public static class varying_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "varying_key"
	// PLSQLKeys.g:2123:1: varying_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.varying_key_return varying_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.varying_key_return retval = new PLSQLParser_PLSQLKeys.varying_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID448=null;

		Object REGULAR_ID448_tree=null;

		try {
			// PLSQLKeys.g:2124:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:2124:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("varying"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "varying_key", "input.LT(1).getText().equalsIgnoreCase(\"varying\")");
			}
			REGULAR_ID448=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_varying_key13725); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID448_tree = (Object)adaptor.create(REGULAR_ID448);
			adaptor.addChild(root_0, REGULAR_ID448_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "varying_key"


	public static class varchar_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "varchar_key"
	// PLSQLKeys.g:2127:1: varchar_key :{...}? => REGULAR_ID -> VARCHAR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.varchar_key_return varchar_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.varchar_key_return retval = new PLSQLParser_PLSQLKeys.varchar_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID449=null;

		Object REGULAR_ID449_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2128:5: ({...}? => REGULAR_ID -> VARCHAR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2128:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("varchar"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "varchar_key", "input.LT(1).getText().equalsIgnoreCase(\"varchar\")");
			}
			REGULAR_ID449=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_varchar_key13748); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID449);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2128:76: -> VARCHAR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VARCHAR_VK, REGULAR_ID449));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "varchar_key"


	public static class national_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "national_key"
	// PLSQLKeys.g:2131:1: national_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.national_key_return national_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.national_key_return retval = new PLSQLParser_PLSQLKeys.national_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID450=null;

		Object REGULAR_ID450_tree=null;

		try {
			// PLSQLKeys.g:2132:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2132:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("national"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "national_key", "input.LT(1).getText().equalsIgnoreCase(\"national\")");
			}
			REGULAR_ID450=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_national_key13775); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID450_tree = (Object)adaptor.create(REGULAR_ID450);
			adaptor.addChild(root_0, REGULAR_ID450_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "national_key"


	public static class nchar_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nchar_key"
	// PLSQLKeys.g:2135:1: nchar_key :{...}? REGULAR_ID -> NCHAR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nchar_key_return nchar_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nchar_key_return retval = new PLSQLParser_PLSQLKeys.nchar_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID451=null;

		Object REGULAR_ID451_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2136:5: ({...}? REGULAR_ID -> NCHAR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2136:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nchar"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nchar_key", "input.LT(1).getText().equalsIgnoreCase(\"nchar\")");
			}
			REGULAR_ID451=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nchar_key13797); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID451);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2136:72: -> NCHAR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NCHAR_VK, REGULAR_ID451));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nchar_key"


	public static class bit_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bit_key"
	// PLSQLKeys.g:2139:1: bit_key :{...}? REGULAR_ID -> BIT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.bit_key_return bit_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.bit_key_return retval = new PLSQLParser_PLSQLKeys.bit_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID452=null;

		Object REGULAR_ID452_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2139:12: ({...}? REGULAR_ID -> BIT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2139:17: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("bit"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "bit_key", "input.LT(1).getText().equalsIgnoreCase(\"bit\")");
			}
			REGULAR_ID452=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_bit_key13823); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID452);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2139:77: -> BIT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BIT_VK, REGULAR_ID452));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bit_key"


	public static class float_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "float_key"
	// PLSQLKeys.g:2142:1: float_key :{...}? REGULAR_ID -> FLOAT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.float_key_return float_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.float_key_return retval = new PLSQLParser_PLSQLKeys.float_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID453=null;

		Object REGULAR_ID453_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2143:5: ({...}? REGULAR_ID -> FLOAT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2143:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("float"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "float_key", "input.LT(1).getText().equalsIgnoreCase(\"float\")");
			}
			REGULAR_ID453=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_float_key13850); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID453);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2143:72: -> FLOAT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FLOAT_VK, REGULAR_ID453));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "float_key"


	public static class real_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "real_key"
	// PLSQLKeys.g:2146:1: real_key :{...}? => REGULAR_ID -> REAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.real_key_return real_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.real_key_return retval = new PLSQLParser_PLSQLKeys.real_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID454=null;

		Object REGULAR_ID454_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2146:9: ({...}? => REGULAR_ID -> REAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2146:14: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("real"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "real_key", "input.LT(1).getText().equalsIgnoreCase(\"real\")");
			}
			REGULAR_ID454=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_real_key13877); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID454);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2146:77: -> REAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REAL_VK, REGULAR_ID454));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "real_key"


	public static class double_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "double_key"
	// PLSQLKeys.g:2149:1: double_key :{...}? => REGULAR_ID -> DOUBLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.double_key_return double_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.double_key_return retval = new PLSQLParser_PLSQLKeys.double_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID455=null;

		Object REGULAR_ID455_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2150:5: ({...}? => REGULAR_ID -> DOUBLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2150:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("double"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "double_key", "input.LT(1).getText().equalsIgnoreCase(\"double\")");
			}
			REGULAR_ID455=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_double_key13905); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID455);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2150:75: -> DOUBLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DOUBLE_VK, REGULAR_ID455));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "double_key"


	public static class precision_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "precision_key"
	// PLSQLKeys.g:2153:1: precision_key :{...}? REGULAR_ID -> PRECISION_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.precision_key_return precision_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.precision_key_return retval = new PLSQLParser_PLSQLKeys.precision_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID456=null;

		Object REGULAR_ID456_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2154:5: ({...}? REGULAR_ID -> PRECISION_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2154:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("precision"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "precision_key", "input.LT(1).getText().equalsIgnoreCase(\"precision\")");
			}
			REGULAR_ID456=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_precision_key13932); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID456);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2154:76: -> PRECISION_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRECISION_VK, REGULAR_ID456));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "precision_key"


	public static class interval_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "interval_key"
	// PLSQLKeys.g:2157:1: interval_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.interval_key_return interval_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.interval_key_return retval = new PLSQLParser_PLSQLKeys.interval_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID457=null;

		Object REGULAR_ID457_tree=null;

		try {
			// PLSQLKeys.g:2158:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:2158:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("interval"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "interval_key", "input.LT(1).getText().equalsIgnoreCase(\"interval\")");
			}
			REGULAR_ID457=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_interval_key13960); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID457_tree = (Object)adaptor.create(REGULAR_ID457);
			adaptor.addChild(root_0, REGULAR_ID457_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "interval_key"


	public static class time_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "time_key"
	// PLSQLKeys.g:2161:1: time_key :{...}? REGULAR_ID -> TIME_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.time_key_return time_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.time_key_return retval = new PLSQLParser_PLSQLKeys.time_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID458=null;

		Object REGULAR_ID458_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2162:5: ({...}? REGULAR_ID -> TIME_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2162:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("time"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "time_key", "input.LT(1).getText().equalsIgnoreCase(\"time\")");
			}
			REGULAR_ID458=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_time_key13982); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID458);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2162:71: -> TIME_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIME_VK, REGULAR_ID458));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "time_key"


	public static class zone_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "zone_key"
	// PLSQLKeys.g:2165:1: zone_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.zone_key_return zone_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.zone_key_return retval = new PLSQLParser_PLSQLKeys.zone_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID459=null;

		Object REGULAR_ID459_tree=null;

		try {
			// PLSQLKeys.g:2165:9: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2165:14: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("zone"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "zone_key", "input.LT(1).getText().equalsIgnoreCase(\"zone\")");
			}
			REGULAR_ID459=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_zone_key14005); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID459_tree = (Object)adaptor.create(REGULAR_ID459);
			adaptor.addChild(root_0, REGULAR_ID459_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "zone_key"


	public static class timestamp_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timestamp_key"
	// PLSQLKeys.g:2168:1: timestamp_key :{...}? REGULAR_ID -> TIMESTAMP_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timestamp_key_return timestamp_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timestamp_key_return retval = new PLSQLParser_PLSQLKeys.timestamp_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID460=null;

		Object REGULAR_ID460_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2169:5: ({...}? REGULAR_ID -> TIMESTAMP_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2169:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timestamp"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timestamp_key", "input.LT(1).getText().equalsIgnoreCase(\"timestamp\")");
			}
			REGULAR_ID460=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timestamp_key14027); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID460);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2169:76: -> TIMESTAMP_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMESTAMP_VK, REGULAR_ID460));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timestamp_key"


	public static class date_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "date_key"
	// PLSQLKeys.g:2172:1: date_key : SQL92_RESERVED_DATE ;
	public final PLSQLParser_PLSQLKeys.date_key_return date_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.date_key_return retval = new PLSQLParser_PLSQLKeys.date_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DATE461=null;

		Object SQL92_RESERVED_DATE461_tree=null;

		try {
			// PLSQLKeys.g:2173:5: ( SQL92_RESERVED_DATE )
			// PLSQLKeys.g:2173:10: SQL92_RESERVED_DATE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DATE461=(Token)match(input,SQL92_RESERVED_DATE,FOLLOW_SQL92_RESERVED_DATE_in_date_key14052); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DATE461_tree = (Object)adaptor.create(SQL92_RESERVED_DATE461);
			adaptor.addChild(root_0, SQL92_RESERVED_DATE461_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "date_key"


	public static class numeric_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "numeric_key"
	// PLSQLKeys.g:2176:1: numeric_key :{...}? => REGULAR_ID -> NUMERIC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.numeric_key_return numeric_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.numeric_key_return retval = new PLSQLParser_PLSQLKeys.numeric_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID462=null;

		Object REGULAR_ID462_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2177:5: ({...}? => REGULAR_ID -> NUMERIC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2177:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("numeric"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "numeric_key", "input.LT(1).getText().equalsIgnoreCase(\"numeric\")");
			}
			REGULAR_ID462=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_numeric_key14075); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID462);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2177:76: -> NUMERIC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NUMERIC_VK, REGULAR_ID462));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "numeric_key"


	public static class decimal_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "decimal_key"
	// PLSQLKeys.g:2180:1: decimal_key :{...}? => REGULAR_ID -> DECIMAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.decimal_key_return decimal_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.decimal_key_return retval = new PLSQLParser_PLSQLKeys.decimal_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID463=null;

		Object REGULAR_ID463_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2181:5: ({...}? => REGULAR_ID -> DECIMAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2181:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("decimal"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "decimal_key", "input.LT(1).getText().equalsIgnoreCase(\"decimal\")");
			}
			REGULAR_ID463=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_decimal_key14103); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID463);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2181:76: -> DECIMAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DECIMAL_VK, REGULAR_ID463));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "decimal_key"


	public static class dec_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "dec_key"
	// PLSQLKeys.g:2184:1: dec_key :{...}? => REGULAR_ID -> DEC_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.dec_key_return dec_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.dec_key_return retval = new PLSQLParser_PLSQLKeys.dec_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID464=null;

		Object REGULAR_ID464_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2184:12: ({...}? => REGULAR_ID -> DEC_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2184:17: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("dec"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dec_key", "input.LT(1).getText().equalsIgnoreCase(\"dec\")");
			}
			REGULAR_ID464=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_dec_key14130); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID464);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2184:79: -> DEC_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEC_VK, REGULAR_ID464));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "dec_key"


	public static class integer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "integer_key"
	// PLSQLKeys.g:2187:1: integer_key :{...}? => REGULAR_ID -> INTEGER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.integer_key_return integer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.integer_key_return retval = new PLSQLParser_PLSQLKeys.integer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID465=null;

		Object REGULAR_ID465_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2188:5: ({...}? => REGULAR_ID -> INTEGER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2188:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("integer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "integer_key", "input.LT(1).getText().equalsIgnoreCase(\"integer\")");
			}
			REGULAR_ID465=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_integer_key14158); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID465);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2188:76: -> INTEGER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INTEGER_VK, REGULAR_ID465));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "integer_key"


	public static class int_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "int_key"
	// PLSQLKeys.g:2191:1: int_key :{...}? => REGULAR_ID -> INT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.int_key_return int_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.int_key_return retval = new PLSQLParser_PLSQLKeys.int_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID466=null;

		Object REGULAR_ID466_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2191:12: ({...}? => REGULAR_ID -> INT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2191:17: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("int"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "int_key", "input.LT(1).getText().equalsIgnoreCase(\"int\")");
			}
			REGULAR_ID466=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_int_key14185); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID466);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2191:79: -> INT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INT_VK, REGULAR_ID466));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "int_key"


	public static class smallint_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "smallint_key"
	// PLSQLKeys.g:2194:1: smallint_key :{...}? => REGULAR_ID -> SMALLINT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.smallint_key_return smallint_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.smallint_key_return retval = new PLSQLParser_PLSQLKeys.smallint_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID467=null;

		Object REGULAR_ID467_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2195:5: ({...}? => REGULAR_ID -> SMALLINT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2195:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("smallint"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "smallint_key", "input.LT(1).getText().equalsIgnoreCase(\"smallint\")");
			}
			REGULAR_ID467=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_smallint_key14213); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID467);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2195:77: -> SMALLINT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SMALLINT_VK, REGULAR_ID467));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "smallint_key"


	public static class corresponding_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "corresponding_key"
	// PLSQLKeys.g:2198:1: corresponding_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.corresponding_key_return corresponding_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.corresponding_key_return retval = new PLSQLParser_PLSQLKeys.corresponding_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID468=null;

		Object REGULAR_ID468_tree=null;

		try {
			// PLSQLKeys.g:2199:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2199:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("corresponding"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "corresponding_key", "input.LT(1).getText().equalsIgnoreCase(\"corresponding\")");
			}
			REGULAR_ID468=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_corresponding_key14240); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID468_tree = (Object)adaptor.create(REGULAR_ID468);
			adaptor.addChild(root_0, REGULAR_ID468_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "corresponding_key"


	public static class cross_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cross_key"
	// PLSQLKeys.g:2202:1: cross_key :{...}? => REGULAR_ID -> CROSS_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cross_key_return cross_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cross_key_return retval = new PLSQLParser_PLSQLKeys.cross_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID469=null;

		Object REGULAR_ID469_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2203:5: ({...}? => REGULAR_ID -> CROSS_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2203:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cross"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cross_key", "input.LT(1).getText().equalsIgnoreCase(\"cross\")");
			}
			REGULAR_ID469=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cross_key14263); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID469);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2203:74: -> CROSS_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CROSS_VK, REGULAR_ID469));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cross_key"


	public static class join_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "join_key"
	// PLSQLKeys.g:2206:1: join_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.join_key_return join_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.join_key_return retval = new PLSQLParser_PLSQLKeys.join_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID470=null;

		Object REGULAR_ID470_tree=null;

		try {
			// PLSQLKeys.g:2207:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:2207:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("join"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "join_key", "input.LT(1).getText().equalsIgnoreCase(\"join\")");
			}
			REGULAR_ID470=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_join_key14291); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID470_tree = (Object)adaptor.create(REGULAR_ID470);
			adaptor.addChild(root_0, REGULAR_ID470_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "join_key"


	public static class left_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "left_key"
	// PLSQLKeys.g:2210:1: left_key :{...}? => REGULAR_ID -> LEFT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.left_key_return left_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.left_key_return retval = new PLSQLParser_PLSQLKeys.left_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID471=null;

		Object REGULAR_ID471_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2211:5: ({...}? => REGULAR_ID -> LEFT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2211:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("left"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "left_key", "input.LT(1).getText().equalsIgnoreCase(\"left\")");
			}
			REGULAR_ID471=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_left_key14314); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID471);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2211:73: -> LEFT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LEFT_VK, REGULAR_ID471));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "left_key"


	public static class right_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "right_key"
	// PLSQLKeys.g:2214:1: right_key :{...}? => REGULAR_ID -> RIGHT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.right_key_return right_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.right_key_return retval = new PLSQLParser_PLSQLKeys.right_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID472=null;

		Object REGULAR_ID472_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2215:5: ({...}? => REGULAR_ID -> RIGHT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2215:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("right"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "right_key", "input.LT(1).getText().equalsIgnoreCase(\"right\")");
			}
			REGULAR_ID472=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_right_key14342); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID472);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2215:74: -> RIGHT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RIGHT_VK, REGULAR_ID472));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "right_key"


	public static class inner_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "inner_key"
	// PLSQLKeys.g:2218:1: inner_key :{...}? => REGULAR_ID -> INNER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.inner_key_return inner_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.inner_key_return retval = new PLSQLParser_PLSQLKeys.inner_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID473=null;

		Object REGULAR_ID473_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2219:5: ({...}? => REGULAR_ID -> INNER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2219:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("inner"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "inner_key", "input.LT(1).getText().equalsIgnoreCase(\"inner\")");
			}
			REGULAR_ID473=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_inner_key14370); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID473);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2219:74: -> INNER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INNER_VK, REGULAR_ID473));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "inner_key"


	public static class natural_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "natural_key"
	// PLSQLKeys.g:2222:1: natural_key :{...}? => REGULAR_ID -> NATURAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.natural_key_return natural_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.natural_key_return retval = new PLSQLParser_PLSQLKeys.natural_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID474=null;

		Object REGULAR_ID474_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2223:5: ({...}? => REGULAR_ID -> NATURAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2223:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("natural"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "natural_key", "input.LT(1).getText().equalsIgnoreCase(\"natural\")");
			}
			REGULAR_ID474=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_natural_key14398); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID474);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2223:76: -> NATURAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NATURAL_VK, REGULAR_ID474));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "natural_key"


	public static class outer_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "outer_key"
	// PLSQLKeys.g:2226:1: outer_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.outer_key_return outer_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.outer_key_return retval = new PLSQLParser_PLSQLKeys.outer_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID475=null;

		Object REGULAR_ID475_tree=null;

		try {
			// PLSQLKeys.g:2227:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:2227:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("outer"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "outer_key", "input.LT(1).getText().equalsIgnoreCase(\"outer\")");
			}
			REGULAR_ID475=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_outer_key14426); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID475_tree = (Object)adaptor.create(REGULAR_ID475);
			adaptor.addChild(root_0, REGULAR_ID475_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "outer_key"


	public static class using_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "using_key"
	// PLSQLKeys.g:2230:1: using_key : PLSQL_NON_RESERVED_USING ;
	public final PLSQLParser_PLSQLKeys.using_key_return using_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.using_key_return retval = new PLSQLParser_PLSQLKeys.using_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token PLSQL_NON_RESERVED_USING476=null;

		Object PLSQL_NON_RESERVED_USING476_tree=null;

		try {
			// PLSQLKeys.g:2231:5: ( PLSQL_NON_RESERVED_USING )
			// PLSQLKeys.g:2231:10: PLSQL_NON_RESERVED_USING
			{
			root_0 = (Object)adaptor.nil();


			PLSQL_NON_RESERVED_USING476=(Token)match(input,PLSQL_NON_RESERVED_USING,FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key14446); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			PLSQL_NON_RESERVED_USING476_tree = (Object)adaptor.create(PLSQL_NON_RESERVED_USING476);
			adaptor.addChild(root_0, PLSQL_NON_RESERVED_USING476_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "using_key"


	public static class indicator_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "indicator_key"
	// PLSQLKeys.g:2234:1: indicator_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.indicator_key_return indicator_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.indicator_key_return retval = new PLSQLParser_PLSQLKeys.indicator_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID477=null;

		Object REGULAR_ID477_tree=null;

		try {
			// PLSQLKeys.g:2235:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2235:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("indicator"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "indicator_key", "input.LT(1).getText().equalsIgnoreCase(\"indicator\")");
			}
			REGULAR_ID477=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_indicator_key14468); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID477_tree = (Object)adaptor.create(REGULAR_ID477);
			adaptor.addChild(root_0, REGULAR_ID477_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "indicator_key"


	public static class user_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "user_key"
	// PLSQLKeys.g:2238:1: user_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.user_key_return user_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.user_key_return retval = new PLSQLParser_PLSQLKeys.user_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID478=null;

		Object REGULAR_ID478_tree=null;

		try {
			// PLSQLKeys.g:2239:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2239:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("user"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "user_key", "input.LT(1).getText().equalsIgnoreCase(\"user\")");
			}
			REGULAR_ID478=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_user_key14490); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID478_tree = (Object)adaptor.create(REGULAR_ID478);
			adaptor.addChild(root_0, REGULAR_ID478_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "user_key"


	public static class current_user_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "current_user_key"
	// PLSQLKeys.g:2242:1: current_user_key :{...}? REGULAR_ID -> CURRENT_USER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.current_user_key_return current_user_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.current_user_key_return retval = new PLSQLParser_PLSQLKeys.current_user_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID479=null;

		Object REGULAR_ID479_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2243:5: ({...}? REGULAR_ID -> CURRENT_USER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2243:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("current_user"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "current_user_key", "input.LT(1).getText().equalsIgnoreCase(\"current_user\")");
			}
			REGULAR_ID479=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_current_user_key14512); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID479);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2243:79: -> CURRENT_USER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CURRENT_USER_VK, REGULAR_ID479));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "current_user_key"


	public static class session_user_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "session_user_key"
	// PLSQLKeys.g:2246:1: session_user_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.session_user_key_return session_user_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.session_user_key_return retval = new PLSQLParser_PLSQLKeys.session_user_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID480=null;

		Object REGULAR_ID480_tree=null;

		try {
			// PLSQLKeys.g:2247:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2247:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("session_user"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "session_user_key", "input.LT(1).getText().equalsIgnoreCase(\"session_user\")");
			}
			REGULAR_ID480=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_session_user_key14539); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID480_tree = (Object)adaptor.create(REGULAR_ID480);
			adaptor.addChild(root_0, REGULAR_ID480_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "session_user_key"


	public static class system_user_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "system_user_key"
	// PLSQLKeys.g:2250:1: system_user_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.system_user_key_return system_user_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.system_user_key_return retval = new PLSQLParser_PLSQLKeys.system_user_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID481=null;

		Object REGULAR_ID481_tree=null;

		try {
			// PLSQLKeys.g:2251:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2251:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("system_user"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "system_user_key", "input.LT(1).getText().equalsIgnoreCase(\"system_user\")");
			}
			REGULAR_ID481=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_system_user_key14561); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID481_tree = (Object)adaptor.create(REGULAR_ID481);
			adaptor.addChild(root_0, REGULAR_ID481_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "system_user_key"


	public static class value_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "value_key"
	// PLSQLKeys.g:2254:1: value_key :{...}? REGULAR_ID -> VALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.value_key_return value_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.value_key_return retval = new PLSQLParser_PLSQLKeys.value_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID482=null;

		Object REGULAR_ID482_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2255:5: ({...}? REGULAR_ID -> VALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2255:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("value"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "value_key", "input.LT(1).getText().equalsIgnoreCase(\"value\")");
			}
			REGULAR_ID482=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_value_key14583); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID482);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2255:72: -> VALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(VALUE_VK, REGULAR_ID482));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "value_key"


	public static class substring_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "substring_key"
	// PLSQLKeys.g:2258:1: substring_key :{...}? => REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.substring_key_return substring_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.substring_key_return retval = new PLSQLParser_PLSQLKeys.substring_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID483=null;

		Object REGULAR_ID483_tree=null;

		try {
			// PLSQLKeys.g:2259:5: ({...}? => REGULAR_ID )
			// PLSQLKeys.g:2259:10: {...}? => REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("substring"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "substring_key", "input.LT(1).getText().equalsIgnoreCase(\"substring\")");
			}
			REGULAR_ID483=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_substring_key14611); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID483_tree = (Object)adaptor.create(REGULAR_ID483);
			adaptor.addChild(root_0, REGULAR_ID483_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "substring_key"


	public static class upper_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "upper_key"
	// PLSQLKeys.g:2262:1: upper_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.upper_key_return upper_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.upper_key_return retval = new PLSQLParser_PLSQLKeys.upper_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID484=null;

		Object REGULAR_ID484_tree=null;

		try {
			// PLSQLKeys.g:2263:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2263:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("upper"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "upper_key", "input.LT(1).getText().equalsIgnoreCase(\"upper\")");
			}
			REGULAR_ID484=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_upper_key14633); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID484_tree = (Object)adaptor.create(REGULAR_ID484);
			adaptor.addChild(root_0, REGULAR_ID484_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "upper_key"


	public static class lower_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "lower_key"
	// PLSQLKeys.g:2266:1: lower_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.lower_key_return lower_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.lower_key_return retval = new PLSQLParser_PLSQLKeys.lower_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID485=null;

		Object REGULAR_ID485_tree=null;

		try {
			// PLSQLKeys.g:2267:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2267:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("lower"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "lower_key", "input.LT(1).getText().equalsIgnoreCase(\"lower\")");
			}
			REGULAR_ID485=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_lower_key14655); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID485_tree = (Object)adaptor.create(REGULAR_ID485);
			adaptor.addChild(root_0, REGULAR_ID485_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "lower_key"


	public static class convert_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "convert_key"
	// PLSQLKeys.g:2270:1: convert_key :{...}? REGULAR_ID -> CONVERT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.convert_key_return convert_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.convert_key_return retval = new PLSQLParser_PLSQLKeys.convert_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID486=null;

		Object REGULAR_ID486_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2271:5: ({...}? REGULAR_ID -> CONVERT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2271:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("convert"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "convert_key", "input.LT(1).getText().equalsIgnoreCase(\"convert\")");
			}
			REGULAR_ID486=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_convert_key14677); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID486);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2271:74: -> CONVERT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CONVERT_VK, REGULAR_ID486));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "convert_key"


	public static class translate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "translate_key"
	// PLSQLKeys.g:2274:1: translate_key :{...}? REGULAR_ID -> TRANSLATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.translate_key_return translate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.translate_key_return retval = new PLSQLParser_PLSQLKeys.translate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID487=null;

		Object REGULAR_ID487_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2275:5: ({...}? REGULAR_ID -> TRANSLATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2275:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("translate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "translate_key", "input.LT(1).getText().equalsIgnoreCase(\"translate\")");
			}
			REGULAR_ID487=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_translate_key14704); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID487);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2275:76: -> TRANSLATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TRANSLATE_VK, REGULAR_ID487));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "translate_key"


	public static class trim_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "trim_key"
	// PLSQLKeys.g:2278:1: trim_key :{...}? REGULAR_ID -> TRIM_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.trim_key_return trim_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.trim_key_return retval = new PLSQLParser_PLSQLKeys.trim_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID488=null;

		Object REGULAR_ID488_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2279:5: ({...}? REGULAR_ID -> TRIM_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2279:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("trim"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "trim_key", "input.LT(1).getText().equalsIgnoreCase(\"trim\")");
			}
			REGULAR_ID488=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_trim_key14731); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID488);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2279:71: -> TRIM_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TRIM_VK, REGULAR_ID488));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trim_key"


	public static class leading_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "leading_key"
	// PLSQLKeys.g:2282:1: leading_key :{...}? REGULAR_ID -> LEADING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.leading_key_return leading_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.leading_key_return retval = new PLSQLParser_PLSQLKeys.leading_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID489=null;

		Object REGULAR_ID489_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2283:5: ({...}? REGULAR_ID -> LEADING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2283:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("leading"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "leading_key", "input.LT(1).getText().equalsIgnoreCase(\"leading\")");
			}
			REGULAR_ID489=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_leading_key14758); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID489);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2283:74: -> LEADING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LEADING_VK, REGULAR_ID489));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "leading_key"


	public static class trailing_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "trailing_key"
	// PLSQLKeys.g:2286:1: trailing_key :{...}? REGULAR_ID -> TRAILING_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.trailing_key_return trailing_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.trailing_key_return retval = new PLSQLParser_PLSQLKeys.trailing_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID490=null;

		Object REGULAR_ID490_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2287:5: ({...}? REGULAR_ID -> TRAILING_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2287:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("trailing"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "trailing_key", "input.LT(1).getText().equalsIgnoreCase(\"trailing\")");
			}
			REGULAR_ID490=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_trailing_key14785); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID490);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2287:75: -> TRAILING_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TRAILING_VK, REGULAR_ID490));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "trailing_key"


	public static class both_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "both_key"
	// PLSQLKeys.g:2290:1: both_key :{...}? REGULAR_ID -> BOTH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.both_key_return both_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.both_key_return retval = new PLSQLParser_PLSQLKeys.both_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID491=null;

		Object REGULAR_ID491_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2291:5: ({...}? REGULAR_ID -> BOTH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2291:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("both"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "both_key", "input.LT(1).getText().equalsIgnoreCase(\"both\")");
			}
			REGULAR_ID491=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_both_key14812); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID491);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2291:71: -> BOTH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BOTH_VK, REGULAR_ID491));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "both_key"


	public static class collate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "collate_key"
	// PLSQLKeys.g:2294:1: collate_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.collate_key_return collate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.collate_key_return retval = new PLSQLParser_PLSQLKeys.collate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID492=null;

		Object REGULAR_ID492_tree=null;

		try {
			// PLSQLKeys.g:2295:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2295:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("collate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "collate_key", "input.LT(1).getText().equalsIgnoreCase(\"collate\")");
			}
			REGULAR_ID492=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_collate_key14839); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID492_tree = (Object)adaptor.create(REGULAR_ID492);
			adaptor.addChild(root_0, REGULAR_ID492_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "collate_key"


	public static class position_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "position_key"
	// PLSQLKeys.g:2298:1: position_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.position_key_return position_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.position_key_return retval = new PLSQLParser_PLSQLKeys.position_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID493=null;

		Object REGULAR_ID493_tree=null;

		try {
			// PLSQLKeys.g:2299:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2299:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("position"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "position_key", "input.LT(1).getText().equalsIgnoreCase(\"position\")");
			}
			REGULAR_ID493=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_position_key14861); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID493_tree = (Object)adaptor.create(REGULAR_ID493);
			adaptor.addChild(root_0, REGULAR_ID493_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "position_key"


	public static class extract_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "extract_key"
	// PLSQLKeys.g:2302:1: extract_key :{...}? REGULAR_ID -> EXTRACT_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.extract_key_return extract_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.extract_key_return retval = new PLSQLParser_PLSQLKeys.extract_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID494=null;

		Object REGULAR_ID494_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2303:5: ({...}? REGULAR_ID -> EXTRACT_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2303:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("extract"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "extract_key", "input.LT(1).getText().equalsIgnoreCase(\"extract\")");
			}
			REGULAR_ID494=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_extract_key14883); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID494);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2303:74: -> EXTRACT_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(EXTRACT_VK, REGULAR_ID494));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "extract_key"


	public static class second_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "second_key"
	// PLSQLKeys.g:2306:1: second_key :{...}? REGULAR_ID -> SECOND_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.second_key_return second_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.second_key_return retval = new PLSQLParser_PLSQLKeys.second_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID495=null;

		Object REGULAR_ID495_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2307:5: ({...}? REGULAR_ID -> SECOND_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2307:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("second"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "second_key", "input.LT(1).getText().equalsIgnoreCase(\"second\")");
			}
			REGULAR_ID495=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_second_key14910); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID495);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2307:73: -> SECOND_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SECOND_VK, REGULAR_ID495));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "second_key"


	public static class timezone_hour_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timezone_hour_key"
	// PLSQLKeys.g:2310:1: timezone_hour_key :{...}? REGULAR_ID -> TIMEZONE_HOUR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timezone_hour_key_return timezone_hour_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timezone_hour_key_return retval = new PLSQLParser_PLSQLKeys.timezone_hour_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID496=null;

		Object REGULAR_ID496_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2311:5: ({...}? REGULAR_ID -> TIMEZONE_HOUR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2311:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timezone_hour"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timezone_hour_key", "input.LT(1).getText().equalsIgnoreCase(\"timezone_hour\")");
			}
			REGULAR_ID496=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timezone_hour_key14937); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID496);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2311:80: -> TIMEZONE_HOUR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMEZONE_HOUR_VK, REGULAR_ID496));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timezone_hour_key"


	public static class timezone_minute_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "timezone_minute_key"
	// PLSQLKeys.g:2314:1: timezone_minute_key :{...}? REGULAR_ID -> TIMEZONE_MINUTE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.timezone_minute_key_return timezone_minute_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.timezone_minute_key_return retval = new PLSQLParser_PLSQLKeys.timezone_minute_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID497=null;

		Object REGULAR_ID497_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2315:5: ({...}? REGULAR_ID -> TIMEZONE_MINUTE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2315:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("timezone_minute"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "timezone_minute_key", "input.LT(1).getText().equalsIgnoreCase(\"timezone_minute\")");
			}
			REGULAR_ID497=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_timezone_minute_key14964); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID497);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2315:82: -> TIMEZONE_MINUTE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(TIMEZONE_MINUTE_VK, REGULAR_ID497));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "timezone_minute_key"


	public static class char_length_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "char_length_key"
	// PLSQLKeys.g:2318:1: char_length_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.char_length_key_return char_length_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.char_length_key_return retval = new PLSQLParser_PLSQLKeys.char_length_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID498=null;

		Object REGULAR_ID498_tree=null;

		try {
			// PLSQLKeys.g:2319:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2319:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("char_length"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "char_length_key", "input.LT(1).getText().equalsIgnoreCase(\"char_length\")");
			}
			REGULAR_ID498=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_char_length_key14991); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID498_tree = (Object)adaptor.create(REGULAR_ID498);
			adaptor.addChild(root_0, REGULAR_ID498_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "char_length_key"


	public static class octet_length_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "octet_length_key"
	// PLSQLKeys.g:2322:1: octet_length_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.octet_length_key_return octet_length_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.octet_length_key_return retval = new PLSQLParser_PLSQLKeys.octet_length_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID499=null;

		Object REGULAR_ID499_tree=null;

		try {
			// PLSQLKeys.g:2323:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2323:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("octet_length"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "octet_length_key", "input.LT(1).getText().equalsIgnoreCase(\"octet_length\")");
			}
			REGULAR_ID499=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_octet_length_key15013); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID499_tree = (Object)adaptor.create(REGULAR_ID499);
			adaptor.addChild(root_0, REGULAR_ID499_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "octet_length_key"


	public static class character_length_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "character_length_key"
	// PLSQLKeys.g:2326:1: character_length_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.character_length_key_return character_length_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.character_length_key_return retval = new PLSQLParser_PLSQLKeys.character_length_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID500=null;

		Object REGULAR_ID500_tree=null;

		try {
			// PLSQLKeys.g:2327:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2327:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("character_length"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "character_length_key", "input.LT(1).getText().equalsIgnoreCase(\"character_length\")");
			}
			REGULAR_ID500=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_character_length_key15035); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID500_tree = (Object)adaptor.create(REGULAR_ID500);
			adaptor.addChild(root_0, REGULAR_ID500_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "character_length_key"


	public static class bit_length_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bit_length_key"
	// PLSQLKeys.g:2330:1: bit_length_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.bit_length_key_return bit_length_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.bit_length_key_return retval = new PLSQLParser_PLSQLKeys.bit_length_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID501=null;

		Object REGULAR_ID501_tree=null;

		try {
			// PLSQLKeys.g:2331:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2331:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("bit_length"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "bit_length_key", "input.LT(1).getText().equalsIgnoreCase(\"bit_length\")");
			}
			REGULAR_ID501=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_bit_length_key15057); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID501_tree = (Object)adaptor.create(REGULAR_ID501);
			adaptor.addChild(root_0, REGULAR_ID501_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "bit_length_key"


	public static class local_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "local_key"
	// PLSQLKeys.g:2334:1: local_key :{...}? REGULAR_ID -> LOCAL_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.local_key_return local_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.local_key_return retval = new PLSQLParser_PLSQLKeys.local_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID502=null;

		Object REGULAR_ID502_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2335:5: ({...}? REGULAR_ID -> LOCAL_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2335:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("local"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "local_key", "input.LT(1).getText().equalsIgnoreCase(\"local\")");
			}
			REGULAR_ID502=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_local_key15079); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID502);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2335:72: -> LOCAL_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(LOCAL_VK, REGULAR_ID502));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "local_key"


	public static class current_timestamp_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "current_timestamp_key"
	// PLSQLKeys.g:2338:1: current_timestamp_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.current_timestamp_key_return current_timestamp_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.current_timestamp_key_return retval = new PLSQLParser_PLSQLKeys.current_timestamp_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID503=null;

		Object REGULAR_ID503_tree=null;

		try {
			// PLSQLKeys.g:2339:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2339:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("current_timestamp"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "current_timestamp_key", "input.LT(1).getText().equalsIgnoreCase(\"current_timestamp\")");
			}
			REGULAR_ID503=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_current_timestamp_key15106); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID503_tree = (Object)adaptor.create(REGULAR_ID503);
			adaptor.addChild(root_0, REGULAR_ID503_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "current_timestamp_key"


	public static class current_date_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "current_date_key"
	// PLSQLKeys.g:2342:1: current_date_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.current_date_key_return current_date_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.current_date_key_return retval = new PLSQLParser_PLSQLKeys.current_date_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID504=null;

		Object REGULAR_ID504_tree=null;

		try {
			// PLSQLKeys.g:2343:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2343:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("current_date"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "current_date_key", "input.LT(1).getText().equalsIgnoreCase(\"current_date\")");
			}
			REGULAR_ID504=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_current_date_key15128); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID504_tree = (Object)adaptor.create(REGULAR_ID504);
			adaptor.addChild(root_0, REGULAR_ID504_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "current_date_key"


	public static class current_time_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "current_time_key"
	// PLSQLKeys.g:2346:1: current_time_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.current_time_key_return current_time_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.current_time_key_return retval = new PLSQLParser_PLSQLKeys.current_time_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID505=null;

		Object REGULAR_ID505_tree=null;

		try {
			// PLSQLKeys.g:2347:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2347:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("current_time"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "current_time_key", "input.LT(1).getText().equalsIgnoreCase(\"current_time\")");
			}
			REGULAR_ID505=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_current_time_key15150); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID505_tree = (Object)adaptor.create(REGULAR_ID505);
			adaptor.addChild(root_0, REGULAR_ID505_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "current_time_key"


	public static class module_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "module_key"
	// PLSQLKeys.g:2350:1: module_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.module_key_return module_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.module_key_return retval = new PLSQLParser_PLSQLKeys.module_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID506=null;

		Object REGULAR_ID506_tree=null;

		try {
			// PLSQLKeys.g:2351:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2351:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("module"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "module_key", "input.LT(1).getText().equalsIgnoreCase(\"module\")");
			}
			REGULAR_ID506=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_module_key15172); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID506_tree = (Object)adaptor.create(REGULAR_ID506);
			adaptor.addChild(root_0, REGULAR_ID506_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "module_key"


	public static class global_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "global_key"
	// PLSQLKeys.g:2354:1: global_key :{...}? REGULAR_ID ;
	public final PLSQLParser_PLSQLKeys.global_key_return global_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.global_key_return retval = new PLSQLParser_PLSQLKeys.global_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID507=null;

		Object REGULAR_ID507_tree=null;

		try {
			// PLSQLKeys.g:2355:5: ({...}? REGULAR_ID )
			// PLSQLKeys.g:2355:10: {...}? REGULAR_ID
			{
			root_0 = (Object)adaptor.nil();


			if ( !((input.LT(1).getText().equalsIgnoreCase("global"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "global_key", "input.LT(1).getText().equalsIgnoreCase(\"global\")");
			}
			REGULAR_ID507=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_global_key15194); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			REGULAR_ID507_tree = (Object)adaptor.create(REGULAR_ID507);
			adaptor.addChild(root_0, REGULAR_ID507_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "global_key"


	public static class year_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "year_key"
	// PLSQLKeys.g:2358:1: year_key :{...}? => REGULAR_ID -> YEAR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.year_key_return year_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.year_key_return retval = new PLSQLParser_PLSQLKeys.year_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID508=null;

		Object REGULAR_ID508_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2359:5: ({...}? => REGULAR_ID -> YEAR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2359:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("year"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "year_key", "input.LT(1).getText().equalsIgnoreCase(\"year\")");
			}
			REGULAR_ID508=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_year_key15217); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID508);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2359:73: -> YEAR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(YEAR_VK, REGULAR_ID508));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "year_key"


	public static class month_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "month_key"
	// PLSQLKeys.g:2362:1: month_key :{...}? REGULAR_ID -> MONTH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.month_key_return month_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.month_key_return retval = new PLSQLParser_PLSQLKeys.month_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID509=null;

		Object REGULAR_ID509_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2363:5: ({...}? REGULAR_ID -> MONTH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2363:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("month"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "month_key", "input.LT(1).getText().equalsIgnoreCase(\"month\")");
			}
			REGULAR_ID509=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_month_key15244); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID509);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2363:72: -> MONTH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MONTH_VK, REGULAR_ID509));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "month_key"


	public static class day_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "day_key"
	// PLSQLKeys.g:2366:1: day_key :{...}? => REGULAR_ID -> DAY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.day_key_return day_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.day_key_return retval = new PLSQLParser_PLSQLKeys.day_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID510=null;

		Object REGULAR_ID510_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2367:5: ({...}? => REGULAR_ID -> DAY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2367:10: {...}? => REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("day"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "day_key", "input.LT(1).getText().equalsIgnoreCase(\"day\")");
			}
			REGULAR_ID510=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_day_key15272); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID510);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2367:72: -> DAY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DAY_VK, REGULAR_ID510));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "day_key"


	public static class hour_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "hour_key"
	// PLSQLKeys.g:2370:1: hour_key :{...}? REGULAR_ID -> HOUR_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.hour_key_return hour_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.hour_key_return retval = new PLSQLParser_PLSQLKeys.hour_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID511=null;

		Object REGULAR_ID511_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2370:9: ({...}? REGULAR_ID -> HOUR_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2370:14: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("hour"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "hour_key", "input.LT(1).getText().equalsIgnoreCase(\"hour\")");
			}
			REGULAR_ID511=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_hour_key15294); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID511);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2370:75: -> HOUR_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(HOUR_VK, REGULAR_ID511));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "hour_key"


	public static class minute_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "minute_key"
	// PLSQLKeys.g:2373:1: minute_key :{...}? REGULAR_ID -> MINUTE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.minute_key_return minute_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.minute_key_return retval = new PLSQLParser_PLSQLKeys.minute_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID512=null;

		Object REGULAR_ID512_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2374:5: ({...}? REGULAR_ID -> MINUTE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2374:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("minute"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "minute_key", "input.LT(1).getText().equalsIgnoreCase(\"minute\")");
			}
			REGULAR_ID512=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_minute_key15321); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID512);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2374:73: -> MINUTE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MINUTE_VK, REGULAR_ID512));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "minute_key"


	public static class whenever_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "whenever_key"
	// PLSQLKeys.g:2377:1: whenever_key :{...}? REGULAR_ID -> WHENEVER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.whenever_key_return whenever_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.whenever_key_return retval = new PLSQLParser_PLSQLKeys.whenever_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID513=null;

		Object REGULAR_ID513_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2378:5: ({...}? REGULAR_ID -> WHENEVER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2378:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("whenever"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "whenever_key", "input.LT(1).getText().equalsIgnoreCase(\"whenever\")");
			}
			REGULAR_ID513=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_whenever_key15348); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID513);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2378:75: -> WHENEVER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(WHENEVER_VK, REGULAR_ID513));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "whenever_key"


	public static class is_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "is_key"
	// PLSQLKeys.g:2381:1: is_key : SQL92_RESERVED_IS ;
	public final PLSQLParser_PLSQLKeys.is_key_return is_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.is_key_return retval = new PLSQLParser_PLSQLKeys.is_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_IS514=null;

		Object SQL92_RESERVED_IS514_tree=null;

		try {
			// PLSQLKeys.g:2382:5: ( SQL92_RESERVED_IS )
			// PLSQLKeys.g:2382:10: SQL92_RESERVED_IS
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_IS514=(Token)match(input,SQL92_RESERVED_IS,FOLLOW_SQL92_RESERVED_IS_in_is_key15373); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_IS514_tree = (Object)adaptor.create(SQL92_RESERVED_IS514);
			adaptor.addChild(root_0, SQL92_RESERVED_IS514_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "is_key"


	public static class else_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "else_key"
	// PLSQLKeys.g:2385:1: else_key : SQL92_RESERVED_ELSE ;
	public final PLSQLParser_PLSQLKeys.else_key_return else_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.else_key_return retval = new PLSQLParser_PLSQLKeys.else_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ELSE515=null;

		Object SQL92_RESERVED_ELSE515_tree=null;

		try {
			// PLSQLKeys.g:2386:5: ( SQL92_RESERVED_ELSE )
			// PLSQLKeys.g:2386:10: SQL92_RESERVED_ELSE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ELSE515=(Token)match(input,SQL92_RESERVED_ELSE,FOLLOW_SQL92_RESERVED_ELSE_in_else_key15393); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ELSE515_tree = (Object)adaptor.create(SQL92_RESERVED_ELSE515);
			adaptor.addChild(root_0, SQL92_RESERVED_ELSE515_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "else_key"


	public static class table_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "table_key"
	// PLSQLKeys.g:2389:1: table_key : SQL92_RESERVED_TABLE ;
	public final PLSQLParser_PLSQLKeys.table_key_return table_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.table_key_return retval = new PLSQLParser_PLSQLKeys.table_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_TABLE516=null;

		Object SQL92_RESERVED_TABLE516_tree=null;

		try {
			// PLSQLKeys.g:2390:5: ( SQL92_RESERVED_TABLE )
			// PLSQLKeys.g:2390:10: SQL92_RESERVED_TABLE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_TABLE516=(Token)match(input,SQL92_RESERVED_TABLE,FOLLOW_SQL92_RESERVED_TABLE_in_table_key15413); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_TABLE516_tree = (Object)adaptor.create(SQL92_RESERVED_TABLE516);
			adaptor.addChild(root_0, SQL92_RESERVED_TABLE516_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "table_key"


	public static class the_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "the_key"
	// PLSQLKeys.g:2393:1: the_key : SQL92_RESERVED_THE ;
	public final PLSQLParser_PLSQLKeys.the_key_return the_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.the_key_return retval = new PLSQLParser_PLSQLKeys.the_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_THE517=null;

		Object SQL92_RESERVED_THE517_tree=null;

		try {
			// PLSQLKeys.g:2394:5: ( SQL92_RESERVED_THE )
			// PLSQLKeys.g:2394:10: SQL92_RESERVED_THE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_THE517=(Token)match(input,SQL92_RESERVED_THE,FOLLOW_SQL92_RESERVED_THE_in_the_key15433); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_THE517_tree = (Object)adaptor.create(SQL92_RESERVED_THE517);
			adaptor.addChild(root_0, SQL92_RESERVED_THE517_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "the_key"


	public static class then_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "then_key"
	// PLSQLKeys.g:2397:1: then_key : SQL92_RESERVED_THEN ;
	public final PLSQLParser_PLSQLKeys.then_key_return then_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.then_key_return retval = new PLSQLParser_PLSQLKeys.then_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_THEN518=null;

		Object SQL92_RESERVED_THEN518_tree=null;

		try {
			// PLSQLKeys.g:2398:5: ( SQL92_RESERVED_THEN )
			// PLSQLKeys.g:2398:10: SQL92_RESERVED_THEN
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_THEN518=(Token)match(input,SQL92_RESERVED_THEN,FOLLOW_SQL92_RESERVED_THEN_in_then_key15453); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_THEN518_tree = (Object)adaptor.create(SQL92_RESERVED_THEN518);
			adaptor.addChild(root_0, SQL92_RESERVED_THEN518_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "then_key"


	public static class end_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "end_key"
	// PLSQLKeys.g:2401:1: end_key : SQL92_RESERVED_END ;
	public final PLSQLParser_PLSQLKeys.end_key_return end_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.end_key_return retval = new PLSQLParser_PLSQLKeys.end_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_END519=null;

		Object SQL92_RESERVED_END519_tree=null;

		try {
			// PLSQLKeys.g:2402:5: ( SQL92_RESERVED_END )
			// PLSQLKeys.g:2402:10: SQL92_RESERVED_END
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_END519=(Token)match(input,SQL92_RESERVED_END,FOLLOW_SQL92_RESERVED_END_in_end_key15473); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_END519_tree = (Object)adaptor.create(SQL92_RESERVED_END519);
			adaptor.addChild(root_0, SQL92_RESERVED_END519_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "end_key"


	public static class all_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "all_key"
	// PLSQLKeys.g:2405:1: all_key : SQL92_RESERVED_ALL ;
	public final PLSQLParser_PLSQLKeys.all_key_return all_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.all_key_return retval = new PLSQLParser_PLSQLKeys.all_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ALL520=null;

		Object SQL92_RESERVED_ALL520_tree=null;

		try {
			// PLSQLKeys.g:2406:5: ( SQL92_RESERVED_ALL )
			// PLSQLKeys.g:2406:10: SQL92_RESERVED_ALL
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ALL520=(Token)match(input,SQL92_RESERVED_ALL,FOLLOW_SQL92_RESERVED_ALL_in_all_key15493); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ALL520_tree = (Object)adaptor.create(SQL92_RESERVED_ALL520);
			adaptor.addChild(root_0, SQL92_RESERVED_ALL520_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "all_key"


	public static class on_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "on_key"
	// PLSQLKeys.g:2409:1: on_key : SQL92_RESERVED_ON ;
	public final PLSQLParser_PLSQLKeys.on_key_return on_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.on_key_return retval = new PLSQLParser_PLSQLKeys.on_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_ON521=null;

		Object SQL92_RESERVED_ON521_tree=null;

		try {
			// PLSQLKeys.g:2410:5: ( SQL92_RESERVED_ON )
			// PLSQLKeys.g:2410:10: SQL92_RESERVED_ON
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_ON521=(Token)match(input,SQL92_RESERVED_ON,FOLLOW_SQL92_RESERVED_ON_in_on_key15513); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_ON521_tree = (Object)adaptor.create(SQL92_RESERVED_ON521);
			adaptor.addChild(root_0, SQL92_RESERVED_ON521_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "on_key"


	public static class or_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "or_key"
	// PLSQLKeys.g:2413:1: or_key : SQL92_RESERVED_OR ;
	public final PLSQLParser_PLSQLKeys.or_key_return or_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.or_key_return retval = new PLSQLParser_PLSQLKeys.or_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_OR522=null;

		Object SQL92_RESERVED_OR522_tree=null;

		try {
			// PLSQLKeys.g:2414:5: ( SQL92_RESERVED_OR )
			// PLSQLKeys.g:2414:10: SQL92_RESERVED_OR
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_OR522=(Token)match(input,SQL92_RESERVED_OR,FOLLOW_SQL92_RESERVED_OR_in_or_key15533); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_OR522_tree = (Object)adaptor.create(SQL92_RESERVED_OR522);
			adaptor.addChild(root_0, SQL92_RESERVED_OR522_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "or_key"


	public static class and_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "and_key"
	// PLSQLKeys.g:2417:1: and_key : SQL92_RESERVED_AND ;
	public final PLSQLParser_PLSQLKeys.and_key_return and_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.and_key_return retval = new PLSQLParser_PLSQLKeys.and_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_AND523=null;

		Object SQL92_RESERVED_AND523_tree=null;

		try {
			// PLSQLKeys.g:2418:5: ( SQL92_RESERVED_AND )
			// PLSQLKeys.g:2418:10: SQL92_RESERVED_AND
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_AND523=(Token)match(input,SQL92_RESERVED_AND,FOLLOW_SQL92_RESERVED_AND_in_and_key15553); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_AND523_tree = (Object)adaptor.create(SQL92_RESERVED_AND523);
			adaptor.addChild(root_0, SQL92_RESERVED_AND523_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "and_key"


	public static class not_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "not_key"
	// PLSQLKeys.g:2421:1: not_key : SQL92_RESERVED_NOT ;
	public final PLSQLParser_PLSQLKeys.not_key_return not_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.not_key_return retval = new PLSQLParser_PLSQLKeys.not_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_NOT524=null;

		Object SQL92_RESERVED_NOT524_tree=null;

		try {
			// PLSQLKeys.g:2422:5: ( SQL92_RESERVED_NOT )
			// PLSQLKeys.g:2422:10: SQL92_RESERVED_NOT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_NOT524=(Token)match(input,SQL92_RESERVED_NOT,FOLLOW_SQL92_RESERVED_NOT_in_not_key15573); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_NOT524_tree = (Object)adaptor.create(SQL92_RESERVED_NOT524);
			adaptor.addChild(root_0, SQL92_RESERVED_NOT524_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "not_key"


	public static class true_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "true_key"
	// PLSQLKeys.g:2425:1: true_key : SQL92_RESERVED_TRUE ;
	public final PLSQLParser_PLSQLKeys.true_key_return true_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.true_key_return retval = new PLSQLParser_PLSQLKeys.true_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_TRUE525=null;

		Object SQL92_RESERVED_TRUE525_tree=null;

		try {
			// PLSQLKeys.g:2426:5: ( SQL92_RESERVED_TRUE )
			// PLSQLKeys.g:2426:10: SQL92_RESERVED_TRUE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_TRUE525=(Token)match(input,SQL92_RESERVED_TRUE,FOLLOW_SQL92_RESERVED_TRUE_in_true_key15593); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_TRUE525_tree = (Object)adaptor.create(SQL92_RESERVED_TRUE525);
			adaptor.addChild(root_0, SQL92_RESERVED_TRUE525_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "true_key"


	public static class false_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "false_key"
	// PLSQLKeys.g:2429:1: false_key : SQL92_RESERVED_FALSE ;
	public final PLSQLParser_PLSQLKeys.false_key_return false_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.false_key_return retval = new PLSQLParser_PLSQLKeys.false_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_FALSE526=null;

		Object SQL92_RESERVED_FALSE526_tree=null;

		try {
			// PLSQLKeys.g:2430:5: ( SQL92_RESERVED_FALSE )
			// PLSQLKeys.g:2430:10: SQL92_RESERVED_FALSE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_FALSE526=(Token)match(input,SQL92_RESERVED_FALSE,FOLLOW_SQL92_RESERVED_FALSE_in_false_key15613); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_FALSE526_tree = (Object)adaptor.create(SQL92_RESERVED_FALSE526);
			adaptor.addChild(root_0, SQL92_RESERVED_FALSE526_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "false_key"


	public static class default_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "default_key"
	// PLSQLKeys.g:2433:1: default_key : SQL92_RESERVED_DEFAULT ;
	public final PLSQLParser_PLSQLKeys.default_key_return default_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.default_key_return retval = new PLSQLParser_PLSQLKeys.default_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DEFAULT527=null;

		Object SQL92_RESERVED_DEFAULT527_tree=null;

		try {
			// PLSQLKeys.g:2434:5: ( SQL92_RESERVED_DEFAULT )
			// PLSQLKeys.g:2434:10: SQL92_RESERVED_DEFAULT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DEFAULT527=(Token)match(input,SQL92_RESERVED_DEFAULT,FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key15633); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DEFAULT527_tree = (Object)adaptor.create(SQL92_RESERVED_DEFAULT527);
			adaptor.addChild(root_0, SQL92_RESERVED_DEFAULT527_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "default_key"


	public static class distinct_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "distinct_key"
	// PLSQLKeys.g:2437:1: distinct_key : SQL92_RESERVED_DISTINCT ;
	public final PLSQLParser_PLSQLKeys.distinct_key_return distinct_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.distinct_key_return retval = new PLSQLParser_PLSQLKeys.distinct_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DISTINCT528=null;

		Object SQL92_RESERVED_DISTINCT528_tree=null;

		try {
			// PLSQLKeys.g:2438:5: ( SQL92_RESERVED_DISTINCT )
			// PLSQLKeys.g:2438:10: SQL92_RESERVED_DISTINCT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DISTINCT528=(Token)match(input,SQL92_RESERVED_DISTINCT,FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key15653); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DISTINCT528_tree = (Object)adaptor.create(SQL92_RESERVED_DISTINCT528);
			adaptor.addChild(root_0, SQL92_RESERVED_DISTINCT528_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "distinct_key"


	public static class into_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "into_key"
	// PLSQLKeys.g:2441:1: into_key : SQL92_RESERVED_INTO ;
	public final PLSQLParser_PLSQLKeys.into_key_return into_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.into_key_return retval = new PLSQLParser_PLSQLKeys.into_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_INTO529=null;

		Object SQL92_RESERVED_INTO529_tree=null;

		try {
			// PLSQLKeys.g:2442:5: ( SQL92_RESERVED_INTO )
			// PLSQLKeys.g:2442:10: SQL92_RESERVED_INTO
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_INTO529=(Token)match(input,SQL92_RESERVED_INTO,FOLLOW_SQL92_RESERVED_INTO_in_into_key15673); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_INTO529_tree = (Object)adaptor.create(SQL92_RESERVED_INTO529);
			adaptor.addChild(root_0, SQL92_RESERVED_INTO529_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "into_key"


	public static class by_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "by_key"
	// PLSQLKeys.g:2445:1: by_key : SQL92_RESERVED_BY ;
	public final PLSQLParser_PLSQLKeys.by_key_return by_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.by_key_return retval = new PLSQLParser_PLSQLKeys.by_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_BY530=null;

		Object SQL92_RESERVED_BY530_tree=null;

		try {
			// PLSQLKeys.g:2446:5: ( SQL92_RESERVED_BY )
			// PLSQLKeys.g:2446:10: SQL92_RESERVED_BY
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_BY530=(Token)match(input,SQL92_RESERVED_BY,FOLLOW_SQL92_RESERVED_BY_in_by_key15693); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_BY530_tree = (Object)adaptor.create(SQL92_RESERVED_BY530);
			adaptor.addChild(root_0, SQL92_RESERVED_BY530_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "by_key"


	public static class as_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "as_key"
	// PLSQLKeys.g:2449:1: as_key : SQL92_RESERVED_AS ;
	public final PLSQLParser_PLSQLKeys.as_key_return as_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.as_key_return retval = new PLSQLParser_PLSQLKeys.as_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_AS531=null;

		Object SQL92_RESERVED_AS531_tree=null;

		try {
			// PLSQLKeys.g:2450:5: ( SQL92_RESERVED_AS )
			// PLSQLKeys.g:2450:10: SQL92_RESERVED_AS
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_AS531=(Token)match(input,SQL92_RESERVED_AS,FOLLOW_SQL92_RESERVED_AS_in_as_key15713); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_AS531_tree = (Object)adaptor.create(SQL92_RESERVED_AS531);
			adaptor.addChild(root_0, SQL92_RESERVED_AS531_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "as_key"


	public static class in_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "in_key"
	// PLSQLKeys.g:2453:1: in_key : SQL92_RESERVED_IN ;
	public final PLSQLParser_PLSQLKeys.in_key_return in_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.in_key_return retval = new PLSQLParser_PLSQLKeys.in_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_IN532=null;

		Object SQL92_RESERVED_IN532_tree=null;

		try {
			// PLSQLKeys.g:2454:5: ( SQL92_RESERVED_IN )
			// PLSQLKeys.g:2454:10: SQL92_RESERVED_IN
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_IN532=(Token)match(input,SQL92_RESERVED_IN,FOLLOW_SQL92_RESERVED_IN_in_in_key15733); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_IN532_tree = (Object)adaptor.create(SQL92_RESERVED_IN532);
			adaptor.addChild(root_0, SQL92_RESERVED_IN532_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "in_key"


	public static class of_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "of_key"
	// PLSQLKeys.g:2457:1: of_key : SQL92_RESERVED_OF ;
	public final PLSQLParser_PLSQLKeys.of_key_return of_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.of_key_return retval = new PLSQLParser_PLSQLKeys.of_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_OF533=null;

		Object SQL92_RESERVED_OF533_tree=null;

		try {
			// PLSQLKeys.g:2458:5: ( SQL92_RESERVED_OF )
			// PLSQLKeys.g:2458:10: SQL92_RESERVED_OF
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_OF533=(Token)match(input,SQL92_RESERVED_OF,FOLLOW_SQL92_RESERVED_OF_in_of_key15753); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_OF533_tree = (Object)adaptor.create(SQL92_RESERVED_OF533);
			adaptor.addChild(root_0, SQL92_RESERVED_OF533_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "of_key"


	public static class null_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "null_key"
	// PLSQLKeys.g:2461:1: null_key : SQL92_RESERVED_NULL ;
	public final PLSQLParser_PLSQLKeys.null_key_return null_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.null_key_return retval = new PLSQLParser_PLSQLKeys.null_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_NULL534=null;

		Object SQL92_RESERVED_NULL534_tree=null;

		try {
			// PLSQLKeys.g:2462:5: ( SQL92_RESERVED_NULL )
			// PLSQLKeys.g:2462:10: SQL92_RESERVED_NULL
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_NULL534=(Token)match(input,SQL92_RESERVED_NULL,FOLLOW_SQL92_RESERVED_NULL_in_null_key15773); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_NULL534_tree = (Object)adaptor.create(SQL92_RESERVED_NULL534);
			adaptor.addChild(root_0, SQL92_RESERVED_NULL534_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "null_key"


	public static class for_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "for_key"
	// PLSQLKeys.g:2465:1: for_key : SQL92_RESERVED_FOR ;
	public final PLSQLParser_PLSQLKeys.for_key_return for_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.for_key_return retval = new PLSQLParser_PLSQLKeys.for_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_FOR535=null;

		Object SQL92_RESERVED_FOR535_tree=null;

		try {
			// PLSQLKeys.g:2466:5: ( SQL92_RESERVED_FOR )
			// PLSQLKeys.g:2466:10: SQL92_RESERVED_FOR
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_FOR535=(Token)match(input,SQL92_RESERVED_FOR,FOLLOW_SQL92_RESERVED_FOR_in_for_key15793); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_FOR535_tree = (Object)adaptor.create(SQL92_RESERVED_FOR535);
			adaptor.addChild(root_0, SQL92_RESERVED_FOR535_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "for_key"


	public static class select_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "select_key"
	// PLSQLKeys.g:2469:1: select_key : SQL92_RESERVED_SELECT ;
	public final PLSQLParser_PLSQLKeys.select_key_return select_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.select_key_return retval = new PLSQLParser_PLSQLKeys.select_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_SELECT536=null;

		Object SQL92_RESERVED_SELECT536_tree=null;

		try {
			// PLSQLKeys.g:2470:5: ( SQL92_RESERVED_SELECT )
			// PLSQLKeys.g:2470:10: SQL92_RESERVED_SELECT
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_SELECT536=(Token)match(input,SQL92_RESERVED_SELECT,FOLLOW_SQL92_RESERVED_SELECT_in_select_key15813); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_SELECT536_tree = (Object)adaptor.create(SQL92_RESERVED_SELECT536);
			adaptor.addChild(root_0, SQL92_RESERVED_SELECT536_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "select_key"


	public static class when_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "when_key"
	// PLSQLKeys.g:2473:1: when_key : SQL92_RESERVED_WHEN ;
	public final PLSQLParser_PLSQLKeys.when_key_return when_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.when_key_return retval = new PLSQLParser_PLSQLKeys.when_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_WHEN537=null;

		Object SQL92_RESERVED_WHEN537_tree=null;

		try {
			// PLSQLKeys.g:2474:5: ( SQL92_RESERVED_WHEN )
			// PLSQLKeys.g:2474:10: SQL92_RESERVED_WHEN
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_WHEN537=(Token)match(input,SQL92_RESERVED_WHEN,FOLLOW_SQL92_RESERVED_WHEN_in_when_key15833); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_WHEN537_tree = (Object)adaptor.create(SQL92_RESERVED_WHEN537);
			adaptor.addChild(root_0, SQL92_RESERVED_WHEN537_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "when_key"


	public static class delete_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "delete_key"
	// PLSQLKeys.g:2477:1: delete_key : SQL92_RESERVED_DELETE ;
	public final PLSQLParser_PLSQLKeys.delete_key_return delete_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.delete_key_return retval = new PLSQLParser_PLSQLKeys.delete_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_DELETE538=null;

		Object SQL92_RESERVED_DELETE538_tree=null;

		try {
			// PLSQLKeys.g:2478:5: ( SQL92_RESERVED_DELETE )
			// PLSQLKeys.g:2478:10: SQL92_RESERVED_DELETE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_DELETE538=(Token)match(input,SQL92_RESERVED_DELETE,FOLLOW_SQL92_RESERVED_DELETE_in_delete_key15853); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_DELETE538_tree = (Object)adaptor.create(SQL92_RESERVED_DELETE538);
			adaptor.addChild(root_0, SQL92_RESERVED_DELETE538_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "delete_key"


	public static class between_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "between_key"
	// PLSQLKeys.g:2481:1: between_key : SQL92_RESERVED_BETWEEN ;
	public final PLSQLParser_PLSQLKeys.between_key_return between_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.between_key_return retval = new PLSQLParser_PLSQLKeys.between_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_BETWEEN539=null;

		Object SQL92_RESERVED_BETWEEN539_tree=null;

		try {
			// PLSQLKeys.g:2482:5: ( SQL92_RESERVED_BETWEEN )
			// PLSQLKeys.g:2482:10: SQL92_RESERVED_BETWEEN
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_BETWEEN539=(Token)match(input,SQL92_RESERVED_BETWEEN,FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key15873); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_BETWEEN539_tree = (Object)adaptor.create(SQL92_RESERVED_BETWEEN539);
			adaptor.addChild(root_0, SQL92_RESERVED_BETWEEN539_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "between_key"


	public static class like_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "like_key"
	// PLSQLKeys.g:2485:1: like_key : SQL92_RESERVED_LIKE ;
	public final PLSQLParser_PLSQLKeys.like_key_return like_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.like_key_return retval = new PLSQLParser_PLSQLKeys.like_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_LIKE540=null;

		Object SQL92_RESERVED_LIKE540_tree=null;

		try {
			// PLSQLKeys.g:2486:5: ( SQL92_RESERVED_LIKE )
			// PLSQLKeys.g:2486:10: SQL92_RESERVED_LIKE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_LIKE540=(Token)match(input,SQL92_RESERVED_LIKE,FOLLOW_SQL92_RESERVED_LIKE_in_like_key15893); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_LIKE540_tree = (Object)adaptor.create(SQL92_RESERVED_LIKE540);
			adaptor.addChild(root_0, SQL92_RESERVED_LIKE540_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "like_key"


	public static class from_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "from_key"
	// PLSQLKeys.g:2489:1: from_key : SQL92_RESERVED_FROM ;
	public final PLSQLParser_PLSQLKeys.from_key_return from_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.from_key_return retval = new PLSQLParser_PLSQLKeys.from_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_FROM541=null;

		Object SQL92_RESERVED_FROM541_tree=null;

		try {
			// PLSQLKeys.g:2490:5: ( SQL92_RESERVED_FROM )
			// PLSQLKeys.g:2490:10: SQL92_RESERVED_FROM
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_FROM541=(Token)match(input,SQL92_RESERVED_FROM,FOLLOW_SQL92_RESERVED_FROM_in_from_key15913); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_FROM541_tree = (Object)adaptor.create(SQL92_RESERVED_FROM541);
			adaptor.addChild(root_0, SQL92_RESERVED_FROM541_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "from_key"


	public static class where_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "where_key"
	// PLSQLKeys.g:2493:1: where_key : SQL92_RESERVED_WHERE ;
	public final PLSQLParser_PLSQLKeys.where_key_return where_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.where_key_return retval = new PLSQLParser_PLSQLKeys.where_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_WHERE542=null;

		Object SQL92_RESERVED_WHERE542_tree=null;

		try {
			// PLSQLKeys.g:2494:5: ( SQL92_RESERVED_WHERE )
			// PLSQLKeys.g:2494:10: SQL92_RESERVED_WHERE
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_WHERE542=(Token)match(input,SQL92_RESERVED_WHERE,FOLLOW_SQL92_RESERVED_WHERE_in_where_key15933); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_WHERE542_tree = (Object)adaptor.create(SQL92_RESERVED_WHERE542);
			adaptor.addChild(root_0, SQL92_RESERVED_WHERE542_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "where_key"


	public static class view_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "view_key"
	// PLSQLKeys.g:2497:1: view_key : SQL92_RESERVED_VIEW ;
	public final PLSQLParser_PLSQLKeys.view_key_return view_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.view_key_return retval = new PLSQLParser_PLSQLKeys.view_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token SQL92_RESERVED_VIEW543=null;

		Object SQL92_RESERVED_VIEW543_tree=null;

		try {
			// PLSQLKeys.g:2498:5: ( SQL92_RESERVED_VIEW )
			// PLSQLKeys.g:2498:9: SQL92_RESERVED_VIEW
			{
			root_0 = (Object)adaptor.nil();


			SQL92_RESERVED_VIEW543=(Token)match(input,SQL92_RESERVED_VIEW,FOLLOW_SQL92_RESERVED_VIEW_in_view_key15952); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			SQL92_RESERVED_VIEW543_tree = (Object)adaptor.create(SQL92_RESERVED_VIEW543);
			adaptor.addChild(root_0, SQL92_RESERVED_VIEW543_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "view_key"


	public static class sequence_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "sequence_key"
	// PLSQLKeys.g:2501:1: sequence_key :{...}? REGULAR_ID -> SEQUENCE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.sequence_key_return sequence_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.sequence_key_return retval = new PLSQLParser_PLSQLKeys.sequence_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID544=null;

		Object REGULAR_ID544_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2502:5: ({...}? REGULAR_ID -> SEQUENCE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2502:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("sequence"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "sequence_key", "input.LT(1).getText().equalsIgnoreCase(\"sequence\")");
			}
			REGULAR_ID544=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_sequence_key15973); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID544);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2502:74: -> SEQUENCE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SEQUENCE_VK, REGULAR_ID544));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "sequence_key"


	public static class noorder_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "noorder_key"
	// PLSQLKeys.g:2505:1: noorder_key :{...}? REGULAR_ID -> NOORDER_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.noorder_key_return noorder_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.noorder_key_return retval = new PLSQLParser_PLSQLKeys.noorder_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID545=null;

		Object REGULAR_ID545_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2506:5: ({...}? REGULAR_ID -> NOORDER_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2506:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("noorder"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "noorder_key", "input.LT(1).getText().equalsIgnoreCase(\"noorder\")");
			}
			REGULAR_ID545=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_noorder_key15999); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID545);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2506:73: -> NOORDER_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOORDER_VK, REGULAR_ID545));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "noorder_key"


	public static class cycle_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cycle_key"
	// PLSQLKeys.g:2509:1: cycle_key :{...}? REGULAR_ID -> CYCLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cycle_key_return cycle_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cycle_key_return retval = new PLSQLParser_PLSQLKeys.cycle_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID546=null;

		Object REGULAR_ID546_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2510:5: ({...}? REGULAR_ID -> CYCLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2510:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cycle"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cycle_key", "input.LT(1).getText().equalsIgnoreCase(\"cycle\")");
			}
			REGULAR_ID546=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cycle_key16025); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID546);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2510:71: -> CYCLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CYCLE_VK, REGULAR_ID546));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cycle_key"


	public static class cache_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "cache_key"
	// PLSQLKeys.g:2513:1: cache_key :{...}? REGULAR_ID -> CACHE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.cache_key_return cache_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.cache_key_return retval = new PLSQLParser_PLSQLKeys.cache_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID547=null;

		Object REGULAR_ID547_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2514:5: ({...}? REGULAR_ID -> CACHE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2514:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("cache"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "cache_key", "input.LT(1).getText().equalsIgnoreCase(\"cache\")");
			}
			REGULAR_ID547=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_cache_key16051); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID547);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2514:71: -> CACHE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(CACHE_VK, REGULAR_ID547));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "cache_key"


	public static class nocache_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nocache_key"
	// PLSQLKeys.g:2517:1: nocache_key :{...}? REGULAR_ID -> NOCACHE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nocache_key_return nocache_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nocache_key_return retval = new PLSQLParser_PLSQLKeys.nocache_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID548=null;

		Object REGULAR_ID548_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2518:5: ({...}? REGULAR_ID -> NOCACHE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2518:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nocache"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nocache_key", "input.LT(1).getText().equalsIgnoreCase(\"nocache\")");
			}
			REGULAR_ID548=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nocache_key16077); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID548);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2518:73: -> NOCACHE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOCACHE_VK, REGULAR_ID548));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nocache_key"


	public static class nomaxvalue_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nomaxvalue_key"
	// PLSQLKeys.g:2521:1: nomaxvalue_key :{...}? REGULAR_ID -> NOMAXVALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nomaxvalue_key_return nomaxvalue_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nomaxvalue_key_return retval = new PLSQLParser_PLSQLKeys.nomaxvalue_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID549=null;

		Object REGULAR_ID549_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2522:5: ({...}? REGULAR_ID -> NOMAXVALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2522:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nomaxvalue"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nomaxvalue_key", "input.LT(1).getText().equalsIgnoreCase(\"nomaxvalue\")");
			}
			REGULAR_ID549=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nomaxvalue_key16103); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID549);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2522:76: -> NOMAXVALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOMAXVALUE_VK, REGULAR_ID549));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nomaxvalue_key"


	public static class nominvalue_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "nominvalue_key"
	// PLSQLKeys.g:2525:1: nominvalue_key :{...}? REGULAR_ID -> NOMINVALUE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.nominvalue_key_return nominvalue_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.nominvalue_key_return retval = new PLSQLParser_PLSQLKeys.nominvalue_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID550=null;

		Object REGULAR_ID550_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2526:5: ({...}? REGULAR_ID -> NOMINVALUE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2526:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("nominvalue"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "nominvalue_key", "input.LT(1).getText().equalsIgnoreCase(\"nominvalue\")");
			}
			REGULAR_ID550=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_nominvalue_key16129); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID550);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2526:76: -> NOMINVALUE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOMINVALUE_VK, REGULAR_ID550));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "nominvalue_key"


	public static class search_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "search_key"
	// PLSQLKeys.g:2529:1: search_key :{...}? REGULAR_ID -> SEARCH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.search_key_return search_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.search_key_return retval = new PLSQLParser_PLSQLKeys.search_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID551=null;

		Object REGULAR_ID551_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2530:5: ({...}? REGULAR_ID -> SEARCH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2530:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("search"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "search_key", "input.LT(1).getText().equalsIgnoreCase(\"search\")");
			}
			REGULAR_ID551=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_search_key16155); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID551);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2530:72: -> SEARCH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(SEARCH_VK, REGULAR_ID551));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "search_key"


	public static class depth_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "depth_key"
	// PLSQLKeys.g:2533:1: depth_key :{...}? REGULAR_ID -> DEPTH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.depth_key_return depth_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.depth_key_return retval = new PLSQLParser_PLSQLKeys.depth_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID552=null;

		Object REGULAR_ID552_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2534:5: ({...}? REGULAR_ID -> DEPTH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2534:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("depth"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "depth_key", "input.LT(1).getText().equalsIgnoreCase(\"depth\")");
			}
			REGULAR_ID552=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_depth_key16181); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID552);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2534:71: -> DEPTH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEPTH_VK, REGULAR_ID552));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "depth_key"


	public static class breadth_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "breadth_key"
	// PLSQLKeys.g:2537:1: breadth_key :{...}? REGULAR_ID -> BREADTH_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.breadth_key_return breadth_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.breadth_key_return retval = new PLSQLParser_PLSQLKeys.breadth_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID553=null;

		Object REGULAR_ID553_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2538:5: ({...}? REGULAR_ID -> BREADTH_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2538:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("breadth"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "breadth_key", "input.LT(1).getText().equalsIgnoreCase(\"breadth\")");
			}
			REGULAR_ID553=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_breadth_key16207); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID553);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2538:73: -> BREADTH_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(BREADTH_VK, REGULAR_ID553));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "breadth_key"


	public static class mod_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "mod_key"
	// PLSQLKeys.g:2541:1: mod_key :{...}? REGULAR_ID -> MOD_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.mod_key_return mod_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.mod_key_return retval = new PLSQLParser_PLSQLKeys.mod_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID554=null;

		Object REGULAR_ID554_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2542:5: ({...}? REGULAR_ID -> MOD_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2542:10: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("mod"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "mod_key", "input.LT(1).getText().equalsIgnoreCase(\"mod\")");
			}
			REGULAR_ID554=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_mod_key16234); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID554);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2542:70: -> MOD_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(MOD_VK, REGULAR_ID554));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "mod_key"


	public static class div_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "div_key"
	// PLSQLKeys.g:2545:1: div_key :{...}? REGULAR_ID -> DIV_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.div_key_return div_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.div_key_return retval = new PLSQLParser_PLSQLKeys.div_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID555=null;

		Object REGULAR_ID555_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2546:5: ({...}? REGULAR_ID -> DIV_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2546:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("div"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "div_key", "input.LT(1).getText().equalsIgnoreCase(\"div\")");
			}
			REGULAR_ID555=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_div_key16260); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID555);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2546:69: -> DIV_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DIV_VK, REGULAR_ID555));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "div_key"


	public static class pipe_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "pipe_key"
	// PLSQLKeys.g:2549:1: pipe_key :{...}? REGULAR_ID -> PIPE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.pipe_key_return pipe_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.pipe_key_return retval = new PLSQLParser_PLSQLKeys.pipe_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID556=null;

		Object REGULAR_ID556_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2550:5: ({...}? REGULAR_ID -> PIPE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2550:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("pipe"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "pipe_key", "input.LT(1).getText().equalsIgnoreCase(\"pipe\")");
			}
			REGULAR_ID556=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_pipe_key16286); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID556);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2550:70: -> PIPE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PIPE_VK, REGULAR_ID556));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "pipe_key"


	public static class recursive_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "recursive_key"
	// PLSQLKeys.g:2553:1: recursive_key :{...}? REGULAR_ID -> RECURSIVE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.recursive_key_return recursive_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.recursive_key_return retval = new PLSQLParser_PLSQLKeys.recursive_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID557=null;

		Object REGULAR_ID557_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2554:5: ({...}? REGULAR_ID -> RECURSIVE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2554:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("recursive"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "recursive_key", "input.LT(1).getText().equalsIgnoreCase(\"recursive\")");
			}
			REGULAR_ID557=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_recursive_key16312); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID557);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2554:75: -> RECURSIVE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RECURSIVE_VK, REGULAR_ID557));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "recursive_key"


	public static class primary_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "primary_key"
	// PLSQLKeys.g:2557:1: primary_key :{...}? REGULAR_ID -> PRIMARY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.primary_key_return primary_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.primary_key_return retval = new PLSQLParser_PLSQLKeys.primary_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID558=null;

		Object REGULAR_ID558_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2558:5: ({...}? REGULAR_ID -> PRIMARY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2558:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("primary"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "primary_key", "input.LT(1).getText().equalsIgnoreCase(\"primary\")");
			}
			REGULAR_ID558=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_primary_key16338); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID558);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2558:73: -> PRIMARY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(PRIMARY_VK, REGULAR_ID558));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "primary_key"


	public static class key_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "key_key"
	// PLSQLKeys.g:2561:1: key_key :{...}? REGULAR_ID -> KEY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.key_key_return key_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.key_key_return retval = new PLSQLParser_PLSQLKeys.key_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID559=null;

		Object REGULAR_ID559_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2562:5: ({...}? REGULAR_ID -> KEY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2562:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("key"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "key_key", "input.LT(1).getText().equalsIgnoreCase(\"key\")");
			}
			REGULAR_ID559=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_key_key16364); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID559);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2562:69: -> KEY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(KEY_VK, REGULAR_ID559));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "key_key"


	public static class references_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "references_key"
	// PLSQLKeys.g:2565:1: references_key :{...}? REGULAR_ID -> REFERENCES_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.references_key_return references_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.references_key_return retval = new PLSQLParser_PLSQLKeys.references_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID560=null;

		Object REGULAR_ID560_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2566:5: ({...}? REGULAR_ID -> REFERENCES_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2566:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("references"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "references_key", "input.LT(1).getText().equalsIgnoreCase(\"references\")");
			}
			REGULAR_ID560=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_references_key16390); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID560);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2566:76: -> REFERENCES_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(REFERENCES_VK, REGULAR_ID560));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "references_key"


	public static class deferrable_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "deferrable_key"
	// PLSQLKeys.g:2569:1: deferrable_key :{...}? REGULAR_ID -> DEFERRABLE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.deferrable_key_return deferrable_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.deferrable_key_return retval = new PLSQLParser_PLSQLKeys.deferrable_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID561=null;

		Object REGULAR_ID561_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2570:5: ({...}? REGULAR_ID -> DEFERRABLE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2570:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("deferrable"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "deferrable_key", "input.LT(1).getText().equalsIgnoreCase(\"deferrable\")");
			}
			REGULAR_ID561=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_deferrable_key16416); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID561);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2570:76: -> DEFERRABLE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(DEFERRABLE_VK, REGULAR_ID561));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "deferrable_key"


	public static class initially_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "initially_key"
	// PLSQLKeys.g:2573:1: initially_key :{...}? REGULAR_ID -> INITIALLY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.initially_key_return initially_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.initially_key_return retval = new PLSQLParser_PLSQLKeys.initially_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID562=null;

		Object REGULAR_ID562_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2574:5: ({...}? REGULAR_ID -> INITIALLY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2574:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("initially"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "initially_key", "input.LT(1).getText().equalsIgnoreCase(\"initially\")");
			}
			REGULAR_ID562=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_initially_key16442); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID562);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2574:75: -> INITIALLY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(INITIALLY_VK, REGULAR_ID562));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "initially_key"


	public static class rely_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "rely_key"
	// PLSQLKeys.g:2577:1: rely_key :{...}? REGULAR_ID -> RELY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.rely_key_return rely_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.rely_key_return retval = new PLSQLParser_PLSQLKeys.rely_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID563=null;

		Object REGULAR_ID563_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2578:5: ({...}? REGULAR_ID -> RELY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2578:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("rely"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "rely_key", "input.LT(1).getText().equalsIgnoreCase(\"rely\")");
			}
			REGULAR_ID563=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_rely_key16468); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID563);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2578:70: -> RELY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(RELY_VK, REGULAR_ID563));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "rely_key"


	public static class norely_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "norely_key"
	// PLSQLKeys.g:2581:1: norely_key :{...}? REGULAR_ID -> NORELY_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.norely_key_return norely_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.norely_key_return retval = new PLSQLParser_PLSQLKeys.norely_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID564=null;

		Object REGULAR_ID564_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2582:5: ({...}? REGULAR_ID -> NORELY_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2582:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("norely"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "norely_key", "input.LT(1).getText().equalsIgnoreCase(\"norely\")");
			}
			REGULAR_ID564=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_norely_key16494); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID564);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2582:72: -> NORELY_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NORELY_VK, REGULAR_ID564));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "norely_key"


	public static class novalidate_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "novalidate_key"
	// PLSQLKeys.g:2585:1: novalidate_key :{...}? REGULAR_ID -> NOVALIDATE_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.novalidate_key_return novalidate_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.novalidate_key_return retval = new PLSQLParser_PLSQLKeys.novalidate_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID565=null;

		Object REGULAR_ID565_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2586:5: ({...}? REGULAR_ID -> NOVALIDATE_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2586:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("novalidate"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "novalidate_key", "input.LT(1).getText().equalsIgnoreCase(\"novalidate\")");
			}
			REGULAR_ID565=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_novalidate_key16520); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID565);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2586:76: -> NOVALIDATE_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(NOVALIDATE_VK, REGULAR_ID565));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "novalidate_key"


	public static class foreign_key_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "foreign_key"
	// PLSQLKeys.g:2589:1: foreign_key :{...}? REGULAR_ID -> FOREIGN_VK[$REGULAR_ID] ;
	public final PLSQLParser_PLSQLKeys.foreign_key_return foreign_key() throws RecognitionException {
		PLSQLParser_PLSQLKeys.foreign_key_return retval = new PLSQLParser_PLSQLKeys.foreign_key_return();
		retval.start = input.LT(1);

		Object root_0 = null;

		Token REGULAR_ID566=null;

		Object REGULAR_ID566_tree=null;
		RewriteRuleTokenStream stream_REGULAR_ID=new RewriteRuleTokenStream(adaptor,"token REGULAR_ID");

		try {
			// PLSQLKeys.g:2590:5: ({...}? REGULAR_ID -> FOREIGN_VK[$REGULAR_ID] )
			// PLSQLKeys.g:2590:9: {...}? REGULAR_ID
			{
			if ( !((input.LT(1).getText().equalsIgnoreCase("foreign"))) ) {
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "foreign_key", "input.LT(1).getText().equalsIgnoreCase(\"foreign\")");
			}
			REGULAR_ID566=(Token)match(input,REGULAR_ID,FOLLOW_REGULAR_ID_in_foreign_key16546); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_REGULAR_ID.add(REGULAR_ID566);

			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 2590:73: -> FOREIGN_VK[$REGULAR_ID]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(FOREIGN_VK, REGULAR_ID566));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
		}
		finally {
			// do for sure before leaving
		}
		return retval;
	}
	// $ANTLR end "foreign_key"

	// Delegated rules



	public static final BitSet FOLLOW_SQL92_RESERVED_CREATE_in_create_key2413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_replace_key2440 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_package_key2468 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_body_key2495 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key2520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_exit_key2537 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key2562 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key2582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_serveroutput_key2604 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_off_key2626 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_constant_key2653 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_subtype_key2680 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key2700 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nextval_key2723 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_GOTO_in_goto_key2743 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_execute_key2765 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_immediate_key2793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_return_key2820 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key2845 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_function_key2868 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_pragma_key2890 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_exception_init_key2917 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_type_key2945 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_record_key2973 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_indexed_key2995 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_INDEX_in_index_key3015 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_notfound_key3038 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_notfound_key3040 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_found_key3068 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_found_key3070 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_isopen_key3098 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_isopen_key3100 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_rowcount_key3128 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_rowcount_key3130 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_rowtype_key3158 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_rowtype_key3160 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PERCENT_in_percent_type_key3189 = new BitSet(new long[]{0x0000000000000000L,0x0000000010000000L});
	public static final BitSet FOLLOW_REGULAR_ID_in_percent_type_key3191 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_out_key3219 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_inout_key3246 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_extend_key3274 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_raise_key3296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_while_key3323 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_loop_key3345 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_commit_key3373 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_work_key3395 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_IF_in_if_key3420 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key3440 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_authid_key3463 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_definer_key3490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_external_key3517 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_language_key3544 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_java_key3571 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_name_key3599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_deterministic_key3627 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_parallel_enable_key3655 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_result_cache_key3683 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_pipelined_key3711 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_aggregate_key3738 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ALTER_in_alter_key3763 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_compile_key3785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_debug_key3813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_reuse_key3840 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_settings_key3867 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_specification_key3889 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DROP_in_drop_key3914 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_trigger_key3937 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_force_key3960 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_validate_key3987 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ref_key4015 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_array_key4043 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_varray_key4066 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_pls_integer_key4089 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_serially_reusable_key4117 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_autonomous_transaction_key4145 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_inline_key4173 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_restrict_references_key4201 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_exceptions_key4229 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_save_key4258 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_forall_key4281 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_continue_key4309 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_indices_key4337 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_VALUES_in_values_key4357 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_CASE_in_case_key4377 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_bulk_key4400 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_collect_key4428 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_committed_key4455 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_use_key4483 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_level_key4505 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_isolation_key4528 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_serializable_key4555 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_segment_key4582 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_write_key4605 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_wait_key4633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_corrupt_xid_all_key4661 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_corrupt_xid_key4689 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_batch_key4717 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_session_key4745 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_role_key4768 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_constraint_key4791 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_constraints_key4819 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_call_key4842 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_explain_key4870 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_merge_key4893 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_plan_key4921 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_system_key4944 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_subpartition_key4967 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_partition_key4995 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_matched_key5023 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_reject_key5046 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_log_key5074 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_unlimited_key5102 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_limit_key5130 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_errors_key5158 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key5181 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_urowid_key5209 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key5237 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_min_normal_key5260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_max_normal_key5283 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_positiven_key5306 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timezone_abbr_key5334 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key5362 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key5385 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_key5408 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_bfile_key5436 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_infinity_key5464 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timezone_region_key5487 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key5515 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_naturaln_key5543 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_simple_integer_key5571 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key5599 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_byte_key5622 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_infinity_key5650 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_key5673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_range_key5701 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nclob_key5729 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_clob_key5757 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key5785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key5813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rowid_key5841 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_nan_key5869 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key5892 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_min_normal_key5920 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_signtype_key5943 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_blob_key5971 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nvarchar2_key5999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_double_max_normal_key6027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_float_nan_key6050 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_string_key6073 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_c_key6101 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_library_key6129 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_context_key6157 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_parameters_key6185 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_agent_key6213 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cluster_key6241 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_hash_key6269 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_relies_on_key6297 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_returning_key6325 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_statement_id_key6352 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_deferred_key6375 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_advise_key6403 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_resumable_key6426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timeout_key6449 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_parallel_key6472 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ddl_key6495 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_query_key6523 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dml_key6546 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_guard_key6569 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nothing_key6592 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_enable_key6615 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_database_key6643 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_disable_key6671 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_link_key6699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key6719 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_none_key6742 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_before_key6770 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_referencing_key6799 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_logon_key6827 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_after_key6855 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_schema_key6883 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_GRANT_in_grant_key6908 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_truncate_key6931 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_startup_key6959 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_statistics_key6987 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_noaudit_key7015 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_suspend_key7043 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_audit_key7071 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_disassociate_key7099 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_shutdown_key7128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_compound_key7156 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_servererror_key7184 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_parent_key7212 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_follows_key7240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nested_key7268 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_old_key7296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_statement_key7324 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_db_role_change_key7347 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_each_key7375 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_logoff_key7398 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_analyze_key7426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_instead_key7454 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_associate_key7482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_new_key7510 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key7535 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rename_key7558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_customdatum_key7587 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_oradata_key7615 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_constructor_key7643 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sqldata_key7671 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_member_key7699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_self_key7727 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_object_key7755 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_variable_key7783 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_instantiable_key7806 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_final_key7834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_static_key7862 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_oid_key7890 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_result_key7913 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_under_key7936 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_map_key7964 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_overriding_key7992 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_add_key8020 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_modify_key8048 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_including_key8076 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_substitutable_key8104 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_attribute_key8127 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cascade_key8150 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_data_key8179 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_invalidate_key8202 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_element_key8230 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_first_key8253 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_CHECK_in_check_key8278 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_OPTION_in_option_key8298 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nocycle_key8321 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_locked_key8349 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_block_key8372 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xml_key8400 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_pivot_key8428 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key8453 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sequential_key8476 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_single_key8504 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_skip_key8532 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key8566 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_updated_key8589 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_increment_key8617 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_exclude_key8645 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_reference_key8673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sets_key8701 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_until_key8724 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_seed_key8752 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_maxvalue_key8780 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_siblings_key8808 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cube_key8836 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nulls_key8864 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dimension_key8892 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_scn_key8920 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_snapshot_key8948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_decrement_key8971 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_unpivot_key8999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_keep_key9027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_measures_key9055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rows_key9083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sample_key9111 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_upsert_key9139 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_versions_key9167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rules_key9195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_iterate_key9223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_minvalue_key9251 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rollup_key9279 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nav_key9307 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_automatic_key9335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_last_key9363 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_main_key9391 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_grouping_key9414 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_include_key9442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ignore_key9470 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_respect_key9498 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key9522 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_submultiset_key9545 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_at_key9573 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_a_key9601 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_empty_key9624 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_likec_key9647 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nan_key9675 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_infinite_key9698 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_like2_key9721 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_like4_key9749 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_present_key9777 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dbtimezone_key9800 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sessiontimezone_key9828 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nchar_cs_key9856 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_decompose_key9884 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_following_key9912 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_first_value_key9940 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_preceding_key9968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_within_key9996 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_canonical_key10024 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_compatibility_key10052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_over_key10080 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_multiset_key10108 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key10128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_last_value_key10151 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_CURRENT_in_current_key10176 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_unbounded_key10199 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dense_rank_key10227 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cost_key10255 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_char_cs_key10283 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_auto_key10311 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_treat_key10339 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_content_key10367 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlparse_key10395 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlelement_key10423 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_entityescaping_key10451 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_standalone_key10479 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_wellformed_key10507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlexists_key10535 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_version_key10563 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlcast_key10591 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_yes_key10619 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_no_key10647 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_evalname_key10675 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlpi_key10703 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlcolattval_key10731 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_document_key10759 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlforest_key10787 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_passing_key10815 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_columns_key10843 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_indent_key10872 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_hide_key10900 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlagg_key10928 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_path_key10956 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlnamespaces_key10979 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_SIZE_in_size_key11004 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_noschemacheck_key11027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_noentityescaping_key11055 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlquery_key11083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmltable_key11111 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlroot_key11139 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_schemacheck_key11167 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlattributes_key11195 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_encoding_key11223 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_show_key11251 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_xmlserialize_key11279 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ordinality_key11307 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_defaults_key11335 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sqlerror_key11362 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_oserror_key11390 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_success_key11417 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_warning_key11444 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_failure_key11471 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_INSERT_in_insert_key11496 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ORDER_in_order_key11516 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key11536 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_row_key11558 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_raw_key11586 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_power_key11613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key11633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key11653 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_HAVING_in_having_key11673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ANY_in_any_key11693 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_WITH_in_with_key11713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_transaction_key11736 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rawtohex_key11758 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_number_key11781 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nocopy_key11809 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_TO_in_to_key11834 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_abs_key11856 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rollback_key11879 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_SHARE_in_share_key11904 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_greatest_key11926 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_vsize_key11948 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key11968 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_varchar2_key11991 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rowidtochar_key12018 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_open_key12041 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_comment_key12069 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sqrt_key12096 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_instr_key12118 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key12138 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_lpad_key12160 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_boolean_key12183 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rpad_key12210 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_savepoint_key12233 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_decode_key12260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_reverse_key12282 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_least_key12309 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nvl_key12331 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_variance_key12353 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_START_in_start_key12373 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DESC_in_desc_key12393 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_concat_key12415 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dump_key12437 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_soundex_key12459 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_positive_key12482 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_UNION_in_union_key12507 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ascii_key12529 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key12549 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ASC_in_asc_key12569 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_hextoraw_key12591 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_to_date_key12613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_floor_key12635 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sign_key12657 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_UPDATE_in_update_key12677 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_trunc_key12699 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rtrim_key12721 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_close_key12744 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_to_char_key12771 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ltrim_key12793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_RESERVED_MODE_in_mode_key12813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_uid_key12835 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_chr_key12857 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key12882 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_chartorowid_key12904 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_mlslabel_key12927 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_userenv_key12954 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_stddev_key12976 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_length_key12998 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key13018 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_GROUP_in_group_key13038 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sysdate_key13060 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_binary_integer_key13083 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_to_number_key13110 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_substr_key13132 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_ceil_key13154 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_initcap_key13176 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_round_key13198 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_long_key13221 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_read_key13249 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_only_key13276 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_set_key13304 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nullif_key13331 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_coalesce_key13353 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_count_key13375 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_avg_key13401 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_max_key13422 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_min_key13443 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sum_key13464 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_unknown_key13486 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_escape_key13508 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_some_key13530 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_match_key13557 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cast_key13579 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_full_key13602 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_partial_key13629 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_character_key13652 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_except_key13679 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_char_key13697 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_varying_key13725 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_varchar_key13748 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_national_key13775 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nchar_key13797 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_bit_key13823 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_float_key13850 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_real_key13877 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_double_key13905 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_precision_key13932 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_interval_key13960 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_time_key13982 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_zone_key14005 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timestamp_key14027 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DATE_in_date_key14052 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_numeric_key14075 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_decimal_key14103 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_dec_key14130 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_integer_key14158 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_int_key14185 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_smallint_key14213 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_corresponding_key14240 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cross_key14263 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_join_key14291 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_left_key14314 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_right_key14342 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_inner_key14370 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_natural_key14398 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_outer_key14426 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key14446 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_indicator_key14468 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_user_key14490 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_current_user_key14512 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_session_user_key14539 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_system_user_key14561 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_value_key14583 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_substring_key14611 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_upper_key14633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_lower_key14655 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_convert_key14677 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_translate_key14704 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_trim_key14731 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_leading_key14758 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_trailing_key14785 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_both_key14812 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_collate_key14839 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_position_key14861 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_extract_key14883 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_second_key14910 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timezone_hour_key14937 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_timezone_minute_key14964 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_char_length_key14991 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_octet_length_key15013 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_character_length_key15035 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_bit_length_key15057 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_local_key15079 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_current_timestamp_key15106 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_current_date_key15128 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_current_time_key15150 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_module_key15172 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_global_key15194 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_year_key15217 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_month_key15244 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_day_key15272 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_hour_key15294 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_minute_key15321 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_whenever_key15348 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_IS_in_is_key15373 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ELSE_in_else_key15393 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_TABLE_in_table_key15413 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_THE_in_the_key15433 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_THEN_in_then_key15453 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_END_in_end_key15473 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ALL_in_all_key15493 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_ON_in_on_key15513 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_OR_in_or_key15533 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_AND_in_and_key15553 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_NOT_in_not_key15573 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_TRUE_in_true_key15593 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_FALSE_in_false_key15613 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key15633 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key15653 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_INTO_in_into_key15673 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_BY_in_by_key15693 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_AS_in_as_key15713 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_IN_in_in_key15733 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_OF_in_of_key15753 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_NULL_in_null_key15773 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_FOR_in_for_key15793 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_SELECT_in_select_key15813 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_WHEN_in_when_key15833 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_DELETE_in_delete_key15853 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key15873 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_LIKE_in_like_key15893 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_FROM_in_from_key15913 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_WHERE_in_where_key15933 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SQL92_RESERVED_VIEW_in_view_key15952 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_sequence_key15973 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_noorder_key15999 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cycle_key16025 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_cache_key16051 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nocache_key16077 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nomaxvalue_key16103 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_nominvalue_key16129 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_search_key16155 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_depth_key16181 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_breadth_key16207 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_mod_key16234 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_div_key16260 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_pipe_key16286 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_recursive_key16312 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_primary_key16338 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_key_key16364 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_references_key16390 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_deferrable_key16416 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_initially_key16442 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_rely_key16468 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_norely_key16494 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_novalidate_key16520 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_REGULAR_ID_in_foreign_key16546 = new BitSet(new long[]{0x0000000000000002L});
}
